= V4 Outline MultiLine NoSorting TabWidth=30

H="Project outline"
The Burden of Care for Adults with Dementia: Impact on Care Quality and Family Outcomes

10/9/17

This is a project to set up the structure for Amy's R01 and get initial findings while we wait for the HRS and claims data through 2016 and the MDS and Medicaid MAX files.  Right now we have HRS interviews through 2014 and Rand family and CMS data through 2012.  Because we're looking at the last five years of life, the full sample will be those who die 2005-2012.  

Initial dataset creation:

index_date: death date from Karen's death date file
n1, n2, n3, and exit interviews
-OOP spending (have all the code from Kathleen)
-dementia probability
-unpaid caregiving hours (values at state average for hired cgs)
-NH admission
-wealth (Rand)
-cohabitation with adult kids (Rand)
-financial support from adult kids (Rand)
-demographics
-SR illnesses
-location of death

Annual Medicare claims from five years pre-death

Burdensome transitions last 90 days

H="set libraries"
libname clean 'E:\data\hrs_cleaned'; 
libname medi 'E:\data\CMS_DUA_24548_2012';
libname dmouth 'E:\data\Dartmouth_misc';

/*rand data path*/
libname rand 'E:\data\hrs_public_2012\rand2012\main';

libname proj_int 'E:\data\burden_dementia\int_data';
libname proj_fin 'E:\data\burden_dementia\final_data';
libname proj_ref 'E:\data\burden_dementia\ref_data';



H="get index date"
/*pull the date of death, assign as index date*/

data proj_int.index(keep=id bid_hrs_21 index_date index_month index_year);
set clean.death_date_2012;
index_date=death_all;
index_month=death_month;
index_year=death_year;
if bid_hrs_21~='';
run;



H="get ffs before"
/*determine Spouse ffs medicare before R's death using the 
claims denominator files

Several sets of variables created, looking back 6m, 12m, 18m, 24m from R's death

Also pulls in spouse date of death where available in the claims s_claims_dod*/

/*sort claims denominator file*/

proc sort data=medi.dn_2000_2012 out=dn  nodupkey;
by bid_hrs_21 year;
run;

proc sort data=proj_int.index out=index1 nodupkey;
by bid_hrs_21 index_year;
run;

/*get dn just for interview year*/

proc sql; 
create table dn_index_year as select
a.*,b.buyin12,b.year,b.hmoind12
from index1 a inner join
dn b
on trim(left(a.bid_hrs_21))=trim(left(b.bid_hrs_21)) 
and a.index_year=b.year;
quit;


proc sql;
select count(distinct bid_hrs_21) from dn_index_year;
quit;



data all_insurance_0;
set dn_index_year;
if length(trim(left(buyin12)))=12 and index_month>0 then do;
buyin_iy=substr(trim(left(buyin12)),1,index_month);
hmo_iy=substr(trim(left(HMOIND12)),1,index_month);
end;
else do;
buyin_iy=trim(left(buyin12));
hmo_iy=trim(left(HMOIND12));
end;
format index_date date9.;
run;
proc means n;
var index_month;
run;


%macro insyrs(numyrs=);
%do i=1 %to &numyrs.;

%let l=%eval(&i.-1);


proc sql;
create table dn_index_year_&i.bef1 as select
a.*,b.year as index_year_&i.bef,
b.year, b.buyin12,b.HMOIND12
from index1 a inner join
dn b
on trim(left(a.bid_hrs_21))=trim(left(b.bid_hrs_21))
and &l.<a.index_year-b.year<=&i. order by bid_hrs_21,year;
quit;

data dn_index_year_&i.bef(keep=buyin_&i.bef hmo_&i.bef bid_hrs_21 index_year);
set dn_index_year_&i.bef1;
buyin_&i.bef=buyin12;
hmo_&i.bef=hmoind12;
run;


proc sql;
create table all_insurance_&i. as select * from
all_insurance_&l. a
left join
dn_index_year_&i.bef b
on a.bid_hrs_21=b.bid_hrs_21 and a.index_year=b.index_year;
quit;

%end;



/*merge death year and year before death buy-in and hmo variables
note--I haven't figured out how to make this generalized to any given year (10/9/17)
*/
data all_insurance;
set all_insurance_&numyrs.;

buyin_&numyrs.y=trimn(left(buyin_&numyrs.bef))||trimn(left(buyin_4bef))||trimn(left(buyin_3bef))||trimn(left(buyin_2bef))||trimn(left(buyin_1bef))||trimn(left(buyin_iy));
hmo_&numyrs.y=trimn(left(hmo_&numyrs.bef))||trimn(left(hmo_4bef))||trimn(left(hmo_3bef))||trimn(left(hmo_2bef))||trimn(left(hmo_1bef))||trimn(left(hmo_iy));

buyin_&numyrs.y_r=reverse(trim(buyin_&numyrs.y));
hmo_&numyrs.y_r=reverse(trim(hmo_&numyrs.y));



/*create length of continous a&b and non-hmo coverage vars*/
if indexc(buyin_&numyrs.y_r,"0","1","2","A","B")=0 then part_ab_n_mos=length(buyin_&numyrs.y_r)-1;
if indexc(buyin_&numyrs.y_r,"0","1","2","A","B") then part_ab_n_mos=indexc(buyin_&numyrs.y_r,"0","1","2","A","B")-1;
if indexc(hmo_&numyrs.y_r,"1","2","4","A","B","C")=0 then non_hmo_d_n_mos=length(hmo_&numyrs.y_r)-1;
if indexc(hmo_&numyrs.y_r,"1","2","4","A","B","C") then non_hmo_d_n_mos=indexc(hmo_&numyrs.y_r,"1","2","4","A","B","C")-1;
if part_ab_n_mos<=non_hmo_d_n_mos then cont_ffs_n_mos=part_ab_n_mos;
if non_hmo_d_n_mos<part_ab_n_mos then cont_ffs_n_mos=non_hmo_d_n_mos;
run;
%mend;

%insyrs(numyrs=5);


data proj_int.ffs_before;
set all_insurance;
run;


H="get claims before"
proc sort data=proj_int.index out=index1 nodupkey;
by bid_hrs_21 id index_date;
run;




/**************************************************************************/
/* ************** S Claims Before R's Death  ******************************/
/**************************************************************************/
/*macro to get claims before death
saves datasets for each claim type / time window to the spo_mc_i directory*/
%macro claimspre(days_start=,days_bef_index=,source=,suf=);

/*claims fully within x time of death date*/
proc sql;
create table &source._meet_1 as select a.*,b.index_date,b.id 
from medi.&source._2000_2012 a inner join
index1 b
on trim(left(a.bid_hrs_21))=trim(left(b.bid_hrs_21))
and &days_start<=b.index_date-a.admit_date<=&days_bef_index ;
quit;

/*claims that start earlier than x time but span into x time before death*/
proc sql;
create table &source._meet_2 as select a.*,b.index_date,b.id 
from medi.&source._2000_2012 a inner join
index1 b
on trim(left(a.bid_hrs_21))=trim(left(b.bid_hrs_21))
and b.index_date-a.admit_date>&days_bef_index and b.index_date-a.disch_date<=&days_bef_index;
quit;

data proj_int.&source._meet_&suf.(compress=yes);
set &source._meet_1 &source._meet_2;
run;
%mend;

/*6m before death*/
*%claims(days_start=0,days_bef_index=183,source=hh,suf=6m); /*home health*/
*%claims(days_start=0,days_bef_index=183,source=hs,suf=6m); /*hospice*/
*%claims(days_start=0,days_bef_index=183,source=mp,suf=6m); /*medpar*/
*%claims(days_start=0,days_bef_index=183,source=dm,suf=6m); /*dme*/
*%claims(days_start=0,days_bef_index=183,source=op,suf=6m); /*outpatient*/
*%claims(days_start=0,days_bef_index=183,source=pb,suf=6m); /*carrier*/
/*12m before death*/
%macro bef(time=);
%claimspre(days_start=0,days_bef_index=365*&time.,source=hh,suf=%eval(12*&time.)m); /*home health*/
%claimspre(days_start=0,days_bef_index=365*&time.,source=hs,suf=%eval(12*&time.)m); /*hospice*/
%claimspre(days_start=0,days_bef_index=365*&time.,source=mp,suf=%eval(12*&time.)m); /*medpar*/
%claimspre(days_start=0,days_bef_index=365*&time.,source=dm,suf=%eval(12*&time.)m); /*dme*/
%claimspre(days_start=0,days_bef_index=365*&time.,source=op,suf=%eval(12*&time.)m); /*outpatient*/
%claimspre(days_start=0,days_bef_index=365*&time.,source=pb,suf=%eval(12*&time.)m); /*carrier*/
%mend;



/**************************************************************************/
/* ************** S Claims After R's Death   ******************************/
/**************************************************************************/
/*macro to get claims after death
saves datasets for each claim type / time window to the spo_mc_i directory*/
%macro claimspost(days_start=,days_aft_index=,source=,suf=);

/*claims fully within x time of death date*/
proc sql;
create table &source._meet_1 as select a.*,b.index_date,b.id 
from medi.&source._2000_2012 a inner join
index1 b
on trim(left(a.bid_hrs_21))=trim(left(b.bid_hrs_21))
and &days_start<=a.admit_date - b.index_date<=&days_aft_index ;
quit;

/*claims that start earlier than R's DOD but span after R's death*/
proc sql;
create table &source._meet_2 as select a.*,b.index_date,b.id 
from medi.&source._2000_2012 a inner join
index1 b
on trim(left(a.bid_hrs_21))=trim(left(b.bid_hrs_21))
and a.admit_date<b.index_date
and &days_start<=a.disch_date - b.index_date;
quit;

data proj_int.&source._meet_&suf.(compress=yes);
set &source._meet_1 &source._meet_2;
format disch_date date9.;
format admit_date date9.;
run;
%mend;

%macro aft(time=);
%claimspost(days_start=0,days_aft_index=365*&time.,source=hh,suf=p%eval(12*&time.)m); /*home health*/
%claimspost(days_start=0,days_aft_index=365*&time.,source=hs,suf=p%eval(12*&time.)m); /*hospice*/
%claimspost(days_start=0,days_aft_index=365*&time.,source=mp,suf=p%eval(12*&time.)m); /*medpar*/
%claimspost(days_start=0,days_aft_index=365*&time.,source=dm,suf=p%eval(12*&time.)m); /*dme*/
%claimspost(days_start=0,days_aft_index=365*&time.,source=op,suf=p%eval(12*&time.)m); /*outpatient*/
%claimspost(days_start=0,days_aft_index=365*&time.,source=pb,suf=p%eval(12*&time.)m); /*carrier*/
%mend;


/**************************************************************************/
/* ********************* S Diagnosis Lists   ******************************/
/**************************************************************************/

%macro dx_time_range(range1=, range2=, suf=);
/*pulls just dx codes from carrier claims*/
data pb_last_&range2._dx(keep=bid_hrs_21 id diag index_date);
set proj_int.pb_meet_&suf.(keep=bid_hrs_21 id PDGNS_CD DGNSCD01-DGNSCD12 index_date);
array dx PDGNS_CD DGNSCD01-DGNSCD12;
do over dx;
diag=dx ;
output;
end;
run;
proc sort data=pb_last_&range2._dx out=pb_last_&range2._dx2 nodupkey;
by bid_hrs_21 id index_date diag;
run;

/*outpatient claims*/
data op_last_&range2._dx(keep=bid_hrs_21 id diag index_date);
set proj_int.op_meet_&suf.(keep=bid_hrs_21 id PDGNS_CD DGNSCD01-DGNSCD25  index_date);
array dx PDGNS_CD DGNSCD01-DGNSCD25 ;
do over dx;
diag=dx ;
output;
end;
run;
proc sort data=op_last_&range2._dx out=op_last_&range2._dx2 nodupkey;
by bid_hrs_21 id index_date diag;
run;

/*medpar claims*/
data mp_last_&range2._dx(keep=bid_hrs_21 id diag index_date);
set proj_int.mp_meet_&suf.(keep=bid_hrs_21 id AD_DGNS DGNS_CD01-DGNS_CD25 index_date );
array dx D_DGNS DGNS_CD01-DGNS_CD25 ;
do over dx;
diag=dx ;
output;
end;
run;
proc sort data=mp_last_&range2._dx out=mp_last_&range2._dx2 nodupkey;
by bid_hrs_21 id index_date diag;
run;

/*dme claims*/
data dm_last_&range2._dx(keep=bid_hrs_21 id diag index_date);
set proj_int.dm_meet_&suf.(keep=bid_hrs_21 id PDGNS_CD DGNSCD01-DGNSCD12 index_date);
array dx PDGNS_CD DGNSCD01-DGNSCD12 ;
do over dx;
diag=dx ;
output;
end;
run;
proc sort data=dm_last_&range2._dx out=dm_last_&range2._dx2 nodupkey;
by bid_hrs_21 id index_date diag;
run;

/*home health agency*/
data hh_last_&range2._dx(keep=bid_hrs_21 id diag index_date);
set proj_int.hh_meet_&suf.(keep=bid_hrs_21 id PDGNS_CD DGNSCD01-DGNSCD25 index_date);
array dx PDGNS_CD DGNSCD01-DGNSCD25 ;
do over dx;
diag=dx ;
output;
end;
run;
proc sort data=hh_last_&range2._dx out=hh_last_&range2._dx2 nodupkey;
by bid_hrs_21 id index_date diag;
run;

/*hospice*/
data hs_last_&range2._dx(keep=bid_hrs_21 id diag index_date);
set proj_int.hs_meet_&suf.(keep=bid_hrs_21 id PDGNS_CD DGNSCD01-DGNSCD25 index_date);
array dx PDGNS_CD DGNSCD01-DGNSCD25 ;
do over dx;
diag=dx ;
output;
end;
run;
proc sort data=hs_last_&range2._dx out=hs_last_&range2._dx2 nodupkey;
by bid_hrs_21 id index_date diag;
run;

/*set diag variable length = 7 chars since that's the max length from the mc claims
Need to do this because length varies across the different mc claim types*/
data hs_last_&range2._dx3;
length diag $7;
set hs_last_&range2._dx2;
run;
data hh_last_&range2._dx3;
length diag $7;
set hh_last_&range2._dx2;
run;
data mp_last_&range2._dx3;
length diag $7;
set mp_last_&range2._dx2;
run;
data dm_last_&range2._dx3;
length diag $7;
set dm_last_&range2._dx2;
run;
data op_last_&range2._dx3;
length diag $7;
set op_last_&range2._dx2;
run;
data pb_last_&range2._dx3;
length diag $7;
set pb_last_&range2._dx2;
run;

data dx_all_last_&range2.;
set hs_last_&range2._dx3
hh_last_&range2._dx3
mp_last_&range2._dx3
dm_last_&range2._dx3
op_last_&range2._dx3
pb_last_&range2._dx3;
run;

proc sort data=dx_all_last_&range2.(where=(diag~="")) out=proj_int.dx_&range1._&range2 nodupkey;
by bid_hrs_21 id index_date diag;
run;

%mend;

/****************************************************************/
/*medpar claims, time periods before R's death*******************/
/****************************************************************/
/*macro for medpar claims, splits into costs for snf and ip claims
for time periods before r's death*/
%macro mp(source=,equ=,name=);
data proj_int.&source._meet_&name.;
set proj_int.mp_meet_&name.;
if (trim(left(SSLSSNF)))&equ.="N";
run;
%mend;

%macro mpsplit(time=);
%mp(source=ip,equ=~,name=%eval(12*&i.)m);
%mp(source=snf,equ=,name=%eval(12*&i.)m);
%mp(source=ip,equ=~,name=p%eval(12*&i.)m);
%mp(source=snf,equ=,name=p%eval(12*&i.)m);
%mend;



/*run macros*/

%macro runall(years=);
%do i=1 %to &years.;
%bef(time=&i.);
%aft(time=&i.);
%mpsplit(time=&i.);
%end;
%mend;

%runall(years=5);


/*run macro to create data files proj_int.dx_0d_n6m proj_int.dx_0d_n12m and proj_int.dx_0d_n24m */
*%dx_time_range(range1=0d, range2=n6m, suf=6m);
%dx_time_range(range1=0d, range2=n12m, suf=12m);
*%dx_time_range(range1=0d, range2=n24m, suf=24m);

/*run for dx lists after R's death*/
*%dx_time_range(range1=0d, range2=p6m, suf=p6m);
*%dx_time_range(range1=0d, range2=p12m, suf=p12m);
*%dx_time_range(range1=0d, range2=p24m, suf=p24m);



/*get spouse medicare costs by claim type and total, adjusted for inflation
to 2012$, monthly, 24m before and after R's death

begins with claims lists from "Get S MC claims lists..." section

final dataset is spo_mc_i.hrs_elix_cc_pay*/




H="MC Spending"
/*get spouse medicare costs by claim type and total, adjusted for inflation
to 2012$, monthly, 60m before and after R's death

begins with claims lists from "Get S MC claims lists..." section

final dataset is proj_int.hrs_elix_cc_pay*/



%macro mp_index_dt(source=);
*get claims that overlap with date of death;

data &source._meet_admit;
set proj_int.&source._meet_60m;
if index_date=admit_date and admit_date~=disch_date;
admit_on_index_date=1;
run;


data &source._meet_both;
set proj_int.&source._meet_60m;
if index_date=disch_date and admit_date=disch_date;
admit_on_index_date=1;
disch_on_index_date=1;
run;




data &source._cost;
set &source._meet_admit &source._meet_both;
array list pmt_amt passthru;
do over list;
if list=. then list=0;
end;

if year(admit_date)>=2012 then rate=1;
if year(admit_date)=2011 then rate=1.03902;
if year(admit_date)=2010 then rate=1.07086;
if year(admit_date)=2009 then rate=1.10835;
if year(admit_date)=2008 then rate=1.1439;
if year(admit_date)=2007 then rate=1.1923;
if year(admit_date)=2006 then rate=1.25586;
if year(admit_date)=2005 then rate=1.30783;
if year(admit_date)=2004 then rate=1.37027;
if year(admit_date)=2003 then rate=1.43908;
if year(admit_date)=2002 then rate=1.50337;
if year(admit_date)=2001 then rate=1.57963;
if year(admit_date)=2000 then rate=1.65519;
if year(admit_date)<=1999 then rate=1.72641;


&source._paid_by_mc=rate*(pmt_amt+passthru);
&source._paid_by_mc_index_dt=(1/(disch_date-admit_date+1))*&source._paid_by_mc;
run;

proc sql;
create table &source._pay as select distinct bid_hrs_21,index_date,
sum(&source._paid_by_mc_index_dt) as &source._paid_by_mc_index_dt,
sum(admit_on_index_date) as &source._admit_dod, sum(disch_on_index_date) as &source._disch_dod
from &source._cost group by bid_hrs_21,index_date;
quit;


proc sort data=&source._pay;
by bid_hrs_21 index_date;
run;

%mend;
%mp_index_dt(source=ip);
%mp_index_dt(source=snf);


%macro claims_index_dt(source=);
*get claims that start with date of death;

data &source._meet_admit;
set proj_int.&source._meet_60m;
if index_date=admit_date; 
run;



data &source._cost;
set &source._meet_admit;
array list pmt_amt passthru;
do over list;
if list=. then list=0;
end;

if year(admit_date)>=2012 then rate=1;
if year(admit_date)=2011 then rate=1.03902;
if year(admit_date)=2010 then rate=1.07086;
if year(admit_date)=2009 then rate=1.10835;
if year(admit_date)=2008 then rate=1.1439;
if year(admit_date)=2007 then rate=1.1923;
if year(admit_date)=2006 then rate=1.25586;
if year(admit_date)=2005 then rate=1.30783;
if year(admit_date)=2004 then rate=1.37027;
if year(admit_date)=2003 then rate=1.43908;
if year(admit_date)=2002 then rate=1.50337;
if year(admit_date)=2001 then rate=1.57963;
if year(admit_date)=2000 then rate=1.65519;
if year(admit_date)<=1999 then rate=1.72641;


&source._paid_by_mc_index_dt=rate*(pmt_amt);
run;

proc sql;
create table &source._pay as select distinct bid_hrs_21,index_date,
sum(&source._paid_by_mc_index_dt) as &source._paid_by_mc_index_dt
from &source._cost group by bid_hrs_21,index_date;
quit;

proc sort data=&source._pay;
by bid_hrs_21 index_date;
run;

%mend;

%claims_index_dt(source=op);
%claims_index_dt(source=pb);
%claims_index_dt(source=hh);
%claims_index_dt(source=hs);
%claims_index_dt(source=dm);


data mc_costs_doda;
merge ip_pay snf_pay op_pay pb_pay hh_pay hs_pay dm_pay ;
bid_hrs_21=bid_hrs_21;
by bid_hrs_21 index_date;
run;


data mc_costs_dod;
set mc_costs_doda;
tot_paid_by_mc_index_dt=ip_paid_by_mc_index_dt+snf_paid_by_mc_index_dt+op_paid_by_mc_index_dt +
pb_paid_by_mc_index_dt+hs_paid_by_mc_index_dt+dm_paid_by_mc_index_dt;
run;


%macro mp_claims(days_start=,days_bef_index=,source=,name=);

*first get claims lists for the specific claims type, snf or ip;
data &source._meet;
set proj_int.&source._meet_60m;
win_start_dt=index_date-&days_bef_index;
win_stop_dt=index_date-&days_start;
format admit_date disch_date win_start_dt win_stop_dt date9.;
run;

/*identify claims where entire claim is within the x months prior to death*/
data &source._meet_1;
set &source._meet;
if win_start_dt<=admit_date<win_stop_dt and
	win_start_dt<=disch_date<win_stop_dt;
run;

/*identify claims where start before window but end during window*/
data &source._meet_2;
set &source._meet;
if win_start_dt>admit_date and
	win_start_dt<=disch_date<win_stop_dt;
run;

/*identify fraction of claims to be attributed to period before death
by just using the fraction of time that was included in the time window*/
data &source._meet_3;
set &source._meet_2;
pct_xm=(disch_date-win_start_dt)/(disch_date-admit_date+1);
array list pmt_amt passthru;
do over list;
if list=. then list=0;
/*scale the partial claims by the time within the x month period*/
list=list*pct_xm;
end;

run;

/*claims where start within window but end after R's death*/
data &source._meet_4;
set &source._meet;
if win_start_dt<=admit_date<win_stop_dt and
	disch_date>=win_stop_dt;
run;

/*again fraction to attribute to window*/
data &source._meet_5;
set &source._meet_4;
pct_xm=(win_stop_dt-admit_date+1)/(disch_date-admit_date+1);
array list pmt_amt passthru;
do over list;
if list=. then list=0;
/*scale the partial claims by the time within the x month period*/
list=list*pct_xm;
end;
run;

/*claims where start before and end after window*/
data &source._meet_6;
set &source._meet;
if win_start_dt>admit_date and
	disch_date>=win_stop_dt;
run;

/*again fraction to attribute to window*/
data &source._meet_7;
set &source._meet_6;
pct_xm=(win_stop_dt-win_start_dt)/(disch_date-admit_date+1);
array list pmt_amt passthru;
do over list;
if list=. then list=0;
/*scale the partial claims by the time within the x month period*/
list=list*pct_xm;
end;
run;

/*merge claims into single dataset, adjust for inflation
Uses CPI for Medical Services from BLS website, accessed 5/4/2015*/
data &source._cost;
set &source._meet_1 &source._meet_3 &source._meet_5 &source._meet_7;
array list pmt_amt passthru;
do over list;
if list=. then list=0;
end;

if year(admit_date)>=2012 then rate=1;
if year(admit_date)=2011 then rate=1.03902;
if year(admit_date)=2010 then rate=1.07086;
if year(admit_date)=2009 then rate=1.10835;
if year(admit_date)=2008 then rate=1.1439;
if year(admit_date)=2007 then rate=1.1923;
if year(admit_date)=2006 then rate=1.25586;
if year(admit_date)=2005 then rate=1.30783;
if year(admit_date)=2004 then rate=1.37027;
if year(admit_date)=2003 then rate=1.43908;
if year(admit_date)=2002 then rate=1.50337;
if year(admit_date)=2001 then rate=1.57963;
if year(admit_date)=2000 then rate=1.65519;
if year(admit_date)<=1999 then rate=1.72641;


&source._paid_by_mc=rate*(pmt_amt+passthru);
run;

*calculates total of mc charges for the claim type by hrs bid;
proc sql;
create table &source._pay as select distinct bid_hrs_21,index_date,
sum(&source._paid_by_mc) as &source._paid_by_mc 
from &source._cost group by bid_hrs_21,index_date;
quit;

/*merge into a full bid list of those s's with ffs mc 6m or more*/
proc sql;
create table &source._&name. as select 
a.bid_hrs_21,a.index_date,coalesce(b.&source._paid_by_mc,0) as &source._paid_by_mc_&name.
from proj_int.index a
left join
 &source._pay b
 on trim(left(a.bid_hrs_21))=trim(left(b.bid_hrs_21)) and a.index_date=b.index_date;
 quit;

proc sort data=&source._&name.; by bid_hrs_21 index_date; run;

%mend;



%macro claims(days_start=,days_bef_index=,source=,name=);

*first get claims lists for the specific claims type, not snf or ip;
data &source._meet;
set proj_int.&source._meet_60m;
win_start_dt=index_date-&days_bef_index;
win_stop_dt=index_date-&days_start;
format admit_date disch_date win_start_dt win_stop_dt date9.;
run;

/*identify claims where start of claim is within the x months prior to death*/
data proj_int.&source._meet&name.;
set &source._meet;
if win_start_dt<=admit_date<win_stop_dt;
run;


/*adjust for inflation
Uses CPI for Medical Services from BLS website, accessed 5/4/2015*/
data &source._cost;
set proj_int.&source._meet&name.;
array list pmt_amt passthru;
do over list;
if list=. then list=0;
end;

if year(admit_date)>=2012 then rate=1;
if year(admit_date)=2011 then rate=1.03902;
if year(admit_date)=2010 then rate=1.07086;
if year(admit_date)=2009 then rate=1.10835;
if year(admit_date)=2008 then rate=1.1439;
if year(admit_date)=2007 then rate=1.1923;
if year(admit_date)=2006 then rate=1.25586;
if year(admit_date)=2005 then rate=1.30783;
if year(admit_date)=2004 then rate=1.37027;
if year(admit_date)=2003 then rate=1.43908;
if year(admit_date)=2002 then rate=1.50337;
if year(admit_date)=2001 then rate=1.57963;
if year(admit_date)=2000 then rate=1.65519;
if year(admit_date)<=1999 then rate=1.72641;


&source._paid_by_mc=rate*(pmt_amt);
run;

*calculates total of mc charges for the claim type by hrs bid;
proc sql;
create table &source._pay as select distinct bid_hrs_21,index_date,
sum(&source._paid_by_mc) as &source._paid_by_mc 
from &source._cost group by bid_hrs_21,index_date;
quit;

/*merge into a full bid list of those s's with ffs at death*/
proc sql;
create table &source._&name. as select 
a.bid_hrs_21,a.index_date,coalesce(b.&source._paid_by_mc,0) as &source._paid_by_mc_&name.
from proj_int.index a
left join
 &source._pay b
 on trim(left(a.bid_hrs_21))=trim(left(b.bid_hrs_21)) and a.index_date=b.index_date;
 quit;

proc sort data=&source._&name.; by bid_hrs_21 index_date; run;

%mend;




/****************************************************************/
/*all claims, time periods after R's death********************/
/****************************************************************/
%macro mp_claims_p(days_start=,days_aft_index=,source=,name=);

*first get claims lists for the specific claims type, snf or ip;
data &source._meet;
set proj_int.&source._meet_p60m;
win_end_dt=index_date+&days_aft_index;
win_start_dt=index_date+&days_start;
format admit_date disch_date win_end_dt win_start_dt date9.;
run;

/*identify claims where entire claim is within the x months after death*/
data &source._meet_1;
set &source._meet;
if win_start_dt<admit_date<=win_end_dt and
	win_start_dt<disch_date<=win_end_dt;
run;

/*identify claims where start before window but end during window*/
data &source._meet_2;
set &source._meet;
if win_start_dt>=admit_date and
	win_start_dt<disch_date<=win_end_dt;
run;

/*identify fraction of claims to be attributed to period after death
by just using the fraction of time that was included in the time window*/
data &source._meet_3;
set &source._meet_2;
pct_xm=(disch_date-win_start_dt)/(disch_date-admit_date+1);
array list pmt_amt passthru;
do over list;
if list=. then list=0;
/*scale the partial claims by the time within the x month period*/
list=list*pct_xm;
end;
run;

/*claims where start within window but end after window*/
data &source._meet_4;
set &source._meet;
if win_start_dt<admit_date<=win_end_dt and
	disch_date>win_end_dt ;
run;

/*again fraction to attribute to window*/
data &source._meet_5;
set &source._meet_4;
pct_xm=(win_end_dt-admit_date+1)/(disch_date-admit_date+1);
array list pmt_amt passthru;
do over list;
if list=. then list=0;
/*scale the partial claims by the time within the x month period*/
list=list*pct_xm;
end;
run;

/*claims where start before window but end after window*/
data &source._meet_6;
set &source._meet;
if win_start_dt>=admit_date and
	disch_date>win_end_dt ;
run;

/*again fraction to attribute to window*/
data &source._meet_7;
set &source._meet_6;
pct_xm=(win_end_dt -win_start_dt)/(disch_date-admit_date+1);
array list pmt_amt passthru;
do over list;
if list=. then list=0;
/*scale the partial claims by the time within the x month period*/
list=list*pct_xm;
end;
run;
/*merge claims into single dataset, adjust for inflation*/
data &source._cost;
set &source._meet_1 &source._meet_3 &source._meet_5 &source._meet_7;
array list pmt_amt passthru;
do over list;
if list=. then list=0;
end;

if year(admit_date)>=2012 then rate=1;
if year(admit_date)=2011 then rate=1.03902;
if year(admit_date)=2010 then rate=1.07086;
if year(admit_date)=2009 then rate=1.10835;
if year(admit_date)=2008 then rate=1.1439;
if year(admit_date)=2007 then rate=1.1923;
if year(admit_date)=2006 then rate=1.25586;
if year(admit_date)=2005 then rate=1.30783;
if year(admit_date)=2004 then rate=1.37027;
if year(admit_date)=2003 then rate=1.43908;
if year(admit_date)=2002 then rate=1.50337;
if year(admit_date)=2001 then rate=1.57963;
if year(admit_date)=2000 then rate=1.65519;
if year(admit_date)<=1999 then rate=1.72641;

&source._paid_by_mc=rate*(pmt_amt+passthru);
run;

*calculates total of mc charges for the claim type by hrs bid;
proc sql;
create table &source._pay as select distinct bid_hrs_21,index_date,
sum(&source._paid_by_mc) as &source._paid_by_mc 
from &source._cost group by bid_hrs_21,index_date;
quit;

/*merge into a full bid list of those s's with ffs mc at death*/
proc sql;
create table &source._&name. as select 
a.bid_hrs_21,a.index_date,coalesce(b.&source._paid_by_mc,0) as &source._paid_by_mc_&name.
from proj_int.index a
left join
 &source._pay b
 on trim(left(a.bid_hrs_21))=trim(left(b.bid_hrs_21)) and a.index_date=b.index_date;
 quit;

proc sort data=&source._&name.; by bid_hrs_21 index_date; run;

%mend;




/****************************************************************/
/*all claims, time periods after R's death********************/
/****************************************************************/
%macro claims_p(days_start=,days_aft_index=,source=,name=);

*first get claims lists for the specific claims type, snf or ip;
data &source._meet;
set proj_int.&source._meet_p60m;
win_end_dt=index_date+&days_aft_index;
win_start_dt=index_date+&days_start;
format admit_date disch_date win_end_dt win_start_dt date9.;
run;

/*identify claims where entire claim is within the x months after death*/
data proj_int.&source._meet&name.;
set &source._meet;
if win_start_dt<admit_date<=win_end_dt;
run;


/*adjust for inflation*/
data &source._cost;
set proj_int.&source._meet&name.;
array list pmt_amt;
do over list;
if list=. then list=0;
end;

if year(admit_date)>=2012 then rate=1;
if year(admit_date)=2011 then rate=1.03902;
if year(admit_date)=2010 then rate=1.07086;
if year(admit_date)=2009 then rate=1.10835;
if year(admit_date)=2008 then rate=1.1439;
if year(admit_date)=2007 then rate=1.1923;
if year(admit_date)=2006 then rate=1.25586;
if year(admit_date)=2005 then rate=1.30783;
if year(admit_date)=2004 then rate=1.37027;
if year(admit_date)=2003 then rate=1.43908;
if year(admit_date)=2002 then rate=1.50337;
if year(admit_date)=2001 then rate=1.57963;
if year(admit_date)=2000 then rate=1.65519;
if year(admit_date)<=1999 then rate=1.72641;

&source._paid_by_mc=rate*(pmt_amt);
run;

*calculates total of mc charges for the claim type by hrs bid;
proc sql;
create table &source._pay as select distinct bid_hrs_21,index_date,
sum(&source._paid_by_mc) as &source._paid_by_mc 
from &source._cost group by bid_hrs_21,index_date;
quit;

/*merge into a full bid list of those s's with ffs mc at death*/
proc sql;
create table &source._&name. as select 
a.bid_hrs_21,a.index_date,coalesce(b.&source._paid_by_mc,0) as &source._paid_by_mc_&name.
from proj_int.index a
left join
 &source._pay b
 on trim(left(a.bid_hrs_21))=trim(left(b.bid_hrs_21)) and a.index_date=b.index_date;
 quit;

proc sort data=&source._&name.; by bid_hrs_21 index_date; run;

%mend;

%macro days_nesting();

%do i=1 %to 5 ;


%mp_claims(days_start=floor((&i.-1)*365),days_bef_index=floor(&i.*365), source=snf,  name=%eval(12*&i.)m);
%mp_claims(days_start=floor((&i.-1)*365),days_bef_index=floor(&i.*365), source=ip,  name=%eval(12*&i.)m);
%claims(days_start=floor((&i.-1)*365),days_bef_index=floor(&i.*365), source=pb,  name=%eval(12*&i.)m);
%claims(days_start=floor((&i.-1)*365),days_bef_index=floor(&i.*365), source=op,  name=%eval(12*&i.)m);
%claims(days_start=floor((&i.-1)*365),days_bef_index=floor(&i.*365), source=hh,  name=%eval(12*&i.)m);
%claims(days_start=floor((&i.-1)*365),days_bef_index=floor(&i.*365), source=hs,  name=%eval(12*&i.)m);
%claims(days_start=floor((&i.-1)*365),days_bef_index=floor(&i.*365), source=dm,  name=%eval(12*&i.)m);

%mp_claims_p(days_start=floor((&i.-1)*365),days_aft_index=floor(&i.*365), source=snf,  name=p%eval(12*&i.)m);
%mp_claims_p(days_start=floor((&i.-1)*365),days_aft_index=floor(&i.*365), source=ip,  name=p%eval(12*&i.)m);
%claims_p(days_start=floor((&i.-1)*365),days_aft_index=floor(&i.*365), source=op,  name=p%eval(12*&i.)m);
%claims_p(days_start=floor((&i.-1)*365),days_aft_index=floor(&i.*365), source=pb,  name=p%eval(12*&i.)m);
%claims_p(days_start=floor((&i.-1)*365),days_aft_index=floor(&i.*365), source=hh,  name=p%eval(12*&i.)m);
%claims_p(days_start=floor((&i.-1)*365),days_aft_index=floor(&i.*365), source=hs,  name=p%eval(12*&i.)m);
%claims_p(days_start=floor((&i.-1)*365),days_aft_index=floor(&i.*365), source=dm,  name=p%eval(12*&i.)m);


%end;
%mend;

%days_nesting();




%macro merge(l=,source=,time=,p=);
data &source._&time._12m;
set &source._&p.12m;
run;

%do i=24 %to 60 %by 12;
%let l = %eval(&i.-12) ;

data &source._&time._&i.m;
merge &source._&time._&l.m &source._&p.&i.m;
run;
%end;

data &source._&time.;
set &source._&time._60m;
run;

proc sort data=&source._&time.;
by bid_hrs_21 index_date;
run;
%mend;

%merge(source=ip,time=bef,p=);
%merge(source=ip,time=aft,p=p);
%merge(source=snf,time=bef,p=);
%merge(source=snf,time=aft,p=p);
%merge(source=op,time=bef,p=);
%merge(source=op,time=aft,p=p);
%merge(source=pb,time=bef,p=);
%merge(source=pb,time=aft,p=p);
%merge(source=hh,time=bef,p=);
%merge(source=hh,time=aft,p=p);
%merge(source=hs,time=bef,p=);
%merge(source=hs,time=aft,p=p);
%merge(source=dm,time=bef,p=);
%merge(source=dm,time=aft,p=p);

/*now merge into single dataset of MC costs and get totals for each time window*/
data mc_costs_all;
merge ip_bef snf_bef op_bef pb_bef hh_bef hs_bef dm_bef 
ip_aft snf_aft op_aft pb_aft hh_aft hs_aft dm_aft;
by bid_hrs_21 index_date;
run;

%macro total();

data mc_costs_all2;
set mc_costs_all;
%do i=12 %to 60 %by 12;
tot_paid_by_mc_&i.m=ip_paid_by_mc_&i.m + snf_paid_by_mc_&i.m + op_paid_by_mc_&i.m + 
pb_paid_by_mc_&i.m + hh_paid_by_mc_&i.m + hs_paid_by_mc_&i.m + dm_paid_by_mc_&i.m;
tot_paid_by_mc_p&i.m=ip_paid_by_mc_p&i.m + snf_paid_by_mc_p&i.m + op_paid_by_mc_p&i.m + 
pb_paid_by_mc_p&i.m + hh_paid_by_mc_p&i.m + hs_paid_by_mc_p&i.m + dm_paid_by_mc_p&i.m;
%end;
run;

proc sort data=mc_costs_all2;
by bid_hrs_21 index_date;
run;

%mend;

%total();

data mc_costs_all3;
merge mc_costs_all2 mc_costs_dod;
by  bid_hrs_21 index_date;
run;

/*save permanent dataset*/
data proj_int.mc_costs_yearly;
set mc_costs_all3;
run;



H="combine with interviews into one dataset"
data index;
set proj_int.index;
run;



proc sql; 
create table tomerge as select * from
proj_int.index a left join
proj_int.ffs_before b 
on a.bid_hrs_21=b.bid_hrs_21 and a.index_year=b.index_year
left join 
proj_int.mc_costs_yearly c
on a.bid_hrs_21=c.bid_hrs_21 and a.index_date=c.index_date;
quit;

proc sql;
create table proj_int.decedent_dataset as select * from
proj_int.index a 
left join
tomerge b 
on a.id=b.id and a.index_year=b.index_year;
quit;

proc export data=proj_int.decedent_dataset outfile="E:\data\burden_dementia\int_data\decedent_dataset.dta" replace; run;

H="sample table"
clear all
set more off
capture log close

local datapath "E:\data\burden_dementia\int_data"
local logpath "E:\data\burden_dementia\logs"
local ooppath "E:\data\burden_dementia\oopdata"

cd `datapath'

use "E:\data\hrs_cleaned\core_00_to_14.dta", clear
sort id core_year
by id: keep if _n==_N & core_year>=2000
tempfile core
save `core'

use "E:\data\hrs_cleaned\core_00_to_14.dta", clear
sort id core_year
gsort id -core_year
by id: gen n=_n
keep if n<5
rename adl_independent_core adl_independent
keep id adl_independent core_year c_ivw_date networth_adj2012 n
reshape wide adl_independent core_year c_ivw_date networth_adj2012, i(id) j(n)
tempfile core2
save `core2'

use "E:\data\serious_ill\int_data\core_age_1.dta", clear
sort id core_year
gsort id -core_year
by id: gen n=_n
keep if n<5
keep id core_year n nw*
reshape wide nw* core_year, i(id) j(n)
tempfile nw
save `nw'

use "E:\data\hrs_public_2012\dementia\pdem_withvarnames_ebl.dta", clear
sort id core_year 
by id: egen firstdem=min(cond(inrange(pdem,0.5,1),core_year,.))
by id: keep if _n==_N
tempfile dem
save `dem'

use "E:\data\hrs_cleaned\restr_tracker_v2014.dta", clear
drop id
gen id=hhid+pn
tempfile track
save `track'

use `ooppath'\oopme_final.dta if year>=2000, clear
rename *, l
gen id=hhid+pn
gsort id -year
by id: gen n=_n
keep if n<5
by id: gen lastyear=year[1]
keep id lastyear total_oop n year
reshape wide total_oop year, i(id) j(n)
tempfile oop
save `oop'

use "E:\data\hrs_oop_2010\received_data\2012\helper_hours_2012.dta", clear
gen id=hhid+pn 
rename year core_year
tempfile help
save `help'

use decedent_dataset.dta if inrange(index_year,2001,2012), clear
drop *bef

local vars female married_or_ medicaid champus medigap nhres hospice ///
e_ivw* *year loc_hosp adl_independent iadl_independent reschil_d livealone

merge 1:1 id using "E:\data\hrs_cleaned\exit_02_to_14_dt.dta", ///
nogen keep(match) keepusing(`vars')
merge 1:1 id using `track', nogen keep(match)
merge 1:m id using `core', nogen keep(match)
merge 1:1 id using `dem', nogen keep(match)
merge 1:1 id using `oop', nogen keep(match)
merge 1:1 id core_year using ///
"E:\data\hrs_public_2014\rand2014\family\family_r_clean_98_12.dta", ///
nogen keep(match)
merge 1:1 id core_year using `help', nogen keep(match master)
merge 1:1 id using `core2', nogen keep(match)

replace n_hp=0 if missing(n_hp)
replace hlphrs=0 if missing(hlphrs)
gen ind_hp=n_hp>0
label var ind_hp "Indicator any helper reported"

gen prob_dem=pdem>=.5 if !missing(pdem)
label var prob_dem "Prob dementia >.5"

gen ffs_yrs=floor(cont_ffs_n_mos/12)
foreach x in 12 24 36 48 60 {
rename tot_paid_by_mc_`x'm tot_paid_by_mc_`=`x'/12'yr
}
forvalues i=1/5 {
replace tot_paid_by_mc_`i'=. if ffs_yrs<`i'
}

label var adl_independent_core "Independent for ADLs (Final core interview)"
label var iadl_independent_core "Independent for IADLs (Final core interview)"
label var adl_independent "Independent for ADLs (Exit)"
label var iadl_independent "Independent for IADLs (Exit)"


drop nw*
merge 1:1 id core_year using "E:\data\serious_ill\int_data\core_age_1.dta", ///
nogen keep(match master)
merge 1:1 id using `nw', nogen keep(match master)
replace birth_date=mdy(1,birthd,birthy) if missing(birth_date)
replace death_date=index_date
gen age_at_death=floor((death_date-birth_date)/365.25)

replace hseduc=degree>0

local cvars1 age_at_death
local ivars1 female black white hisp_eth other_na_api_race married_or_part_v2 ///
livealone reschil_d hseduc nw_lowest nw_midlow nw_midhigh nw_highest ///
medicaid champus medigap srh_pf adl_independent adl_independent_core ///
iadl_independent iadl_independent_core ind_hp 
local cvars2 n_hp hlphrs 
local ivars2 prob_dem nhres hospice loc_hosp //northeast midwest south west 
local famvars2 resd_kid_ind help_adls_kid_adult help_iadls_kid_adult ///
transf_from_kid_adult_ind
local spendvars2 tot_paid_by_mc_1yr tot_paid_by_mc_2yr tot_paid_by_mc_3yr ///
tot_paid_by_mc_4yr tot_paid_by_mc_5yr total_oop1 total_oop2 total_oop3 ///
total_oop4 


foreach x of local famvars {
	replace `x'=0 if missing(`x')
}

local rn : word count `cvars1' `cvars2' `ivars1' `ivars2' `famvars2' `spendvars2' n

mat tab=J(`rn',4,.)
mat stars=J(`rn',4,0)
local r=1
local c=1


foreach group in "0,1" 0 1 {
	forvalues time=1/2 {
		foreach x in `cvars`time'' {
			sum `x' if inlist(prob_dem,`group')
			mat tab[`r',`c']=r(mean)
			if "`group'"=="1" {
				ttest `x', by(prob_dem)
				mat tab[`r',4]=r(p)
				mat stars[`r',4]=(r(p)<.05)+(r(p)<.01)
}
			local r=`r'+1
}
		foreach x in `ivars`time'' `famvars`time'' {
			sum `x' if inlist(prob_dem,`group')
			mat tab[`r',`c']=r(mean)*100
			if "`group'"=="1" {
				tab `x' prob_dem, chi2
				mat tab[`r',4]=r(p)
				mat stars[`r',4]=(r(p)<.05)+(r(p)<.01)
}
			local r=`r'+1
}
		foreach x in `spendvars`time'' {
			sum `x' if inlist(prob_dem,`group')
			mat tab[`r',`c']=r(mean)
			if "`group'"=="1" {
				ttest `x', by(prob_dem)
				mat tab[`r',4]=r(p)
				mat stars[`r',4]=(r(p)<.05)+(r(p)<.01)
}
			local r=`r'+1
}
}
	sum prob_dem if inlist(prob_dem,`group')
	mat tab[`r',`c']=r(N)
	local r=1
	local c=`c'+1
}

mat rownames tab=`cvars1' `ivars1' `cvars2'  `ivars2' `famvars2' `spendvars2' N

frmttable using "`logpath'/summary_stats.rtf", statmat(tab) annotate(stars) asymbol(*,**) varlabels ///
ctitles("" "Full sample" "Probable dementia <.5" "Probable dementia >.5") replace

save burden_dementia_set.dta, replace


H="sample table using newer data"
/******************
things from the exit, need to figure this out
-death date, adls/iadls, location of death, hospice medicaid/gap/va, value estate
	
things that are t:
-MC expenditures
-i

things that are in waves, need to be converted to annual:
-fixed characteristics
    -gender, birth date, death date, race, education
-mutable
	-age (computed at each year, from birth date above, rather than filled)
	-net worth, financial wealth, adl/iadls, srh, medicaid, champus, medigap, married or partnered
	-nursing home resident
	-dementia
	-region
	-family vars-resident children, transfers, help from kids 
	-out of pocket spending
	-number of helpers, helper hours, any helpers, imputed social costs

******************/
clear all
set more off
capture log close

local datapath "E:\data\burden_dementia\int_data"
local fdpath "E:\data\burden_dementia\final_data"
local logpath "E:\data\burden_dementia\logs"
local ooppath "E:\data\burden_dementia\oopdata"

cd `datapath'

/*first pull an index file from the decedent dataset*/
use id index_date index_year cont_ffs_n_mos using decedent_dataset.dta if inrange(index_year,2001,2012), clear
gen ffs_yrs=floor(cont_ffs_n_mos/12)
keep if ffs_y==5
tempfile index
save `index'


/*2nd, connect decedent dataset to exit*/
local vars female married_or_ medicaid champus medigap nhres hospice ///
e_ivw* *year loc_hosp adl_independent iadl_independent reschil_d livealone ///
comor_c_hrs 

use id `vars' using "E:\data\hrs_cleaned\exit_02_to_14_dt.dta" if !missing(e_ivw_date)
foreach x in married_o medicaid champus medigap nhres hospice loc_hosp ///
adl_independent iadl_independent reschil_d livealone {
rename `x' `x'_x
}
tempfile exit1
save `exit1'

merge 1:1 id using `index', nogen keep(match)
//set time=0 so it can be appended to the core
gen t2=0
drop if e_ivw_date<index_date
tempfile exit
save `exit'

/*3rd, save tracker, oop, dementia, rand family, and helpers*/


use "E:\data\hrs_public_2014\dementia\pdem_withvarnames_00_14.dta", clear
gsort id -core_year 
replace pdem=prob_hurd if !missing(prob_hurd)
by id: egen firstdem=min(cond(inrange(pdem,0.5,1),core_year,.))
by id: keep if _n<5
tempfile dem
save `dem'

use "E:\data\hrs_cleaned\restr_tracker_v2014.dta", clear
drop id
gen id=hhid+pn
tempfile track
save `track'


use `ooppath'\oopme_final.dta if year>=2000, clear
rename *, l
gen id=hhid+pn
/*gsort id -year
by id: gen n=_n
keep if n<5
by id: gen lastyear=year[1]
keep id lastyear total_oop n year
rename year core_year
*reshape wide total_oop year, i(id) j(n)*/
tempfile oop
save `oop'


use "E:\data\hrs_oop_2010\received_data\2012\helper_hours_2012.dta", clear
gen id=hhid+pn 
//cap number of hours at 720 (24 hrs for 30 days) for spouses and other informal
foreach x in s u {
replace hlphrs_`x'=720 if hlphrs_`x'>720
}
replace hlphrs_i=hlphrs_s+hlphrs_u
tempfile help
save `help'


/*5th, connect decedent dataset to core
	1) merge 1:m to restrict to decedents
	2) flag those that have two+ cores within 5 years
	3) keep all within 5 years and the one before for baseline
	4) merge by core year with dementia prob, rand fam, helpers, oop datasets
	5) reset so that it's in annual long format
*/

use `index', clear
merge 1:m id using "E:\data\hrs_cleaned\core_00_to_14.dta", nogen ///
keep(match master)
sort id core_year
replace wgthh=. if wgthh==0
carryforward wgthh, replace
gsort id -core_year
carryforward wgthh, replace
by id: gen n=_n
gen time=(index_date-c_ivw_date)/365.25
gen t2=ceil(time)
by id: egen yes=min(time)
gen y1=inrange(yes,0,5)
gen inn=n if time<=5
gen outn=n if time>5
by id: egen y2=max(inn)
//get the first interview outside the window
by id: egen y3=min(outn)

/*keep all ivws within 5 years and a baseline for those who have at least one 
ivw w/in 5 years*/
keep if y1 & (inrange(time,0.00001,5) | y3==n)

/*drop baselines if >8 years out*/
drop if time>8

//locals to keep relevant vars
local corevars networth_adj2012 finwealth_adj2012 medicaid champus medigap srh_pf adl_independent_core ///
iadl_independent_core nhres reschil_d wgthh comor_c smoke_ever smoke_curr
local helpvars n_hp hlphrs_i n_i hlphrs_u hlphrs_s
local famvars resd_kid_ind help_adls_kid_adult help_iadls_kid_adult ///
transf_from_kid_adult_ind
local oopvars total_oop
local trackvars birth_date hisp_eth white black other_na_api cause_death degree
local demvars pdem ldem firstdem prob_hurd
keep id `corevars' core_year c_ivw_* index_date t2 time

append using `exit'

//keep only those with an exit
sort id t2
by id: egen min=min(t2)
keep if min==0
drop min

//keep only those with at least one core
by id: gen n=_n
by id: gen obs=_N
by id: drop if _N==1

//gen year to merge with oop & helper
gen year=core_year
replace year=exit_year if missing(year)

merge 1:1 id year using `oop', gen(oopmerge) keep(match master)  ///
keepusing(`oopvars')
merge 1:1 id year using `help', gen(helpmerge) keep(match master) ///
keepusing(`helpvars')
merge 1:1 id core_year using `dem', gen(demmerge) keep(match master) ///
keepusing(`demvars')
merge m:1 id core_year using ///
"E:\data\hrs_public_2014\rand2014\family\family_r_clean_98_12.dta", ///
gen(randfammerge) keep(match master) keepusing(`famvars')
merge m:1 id using `track', nogen keep(match) keepusing(`trackvars')

//hs+ (including ged)
gen hseduc=degree>0
label var hseduc "HS Degree+ (including GED)"

replace t2=6 if t2>6
gsort id -year
by id: replace pdem=pdem[_n+1] if t2==0
gen no=0
by id: replace no=1 if year>year[_n+1]+2 & _n!=_N
by id: replace no=1 if _n==_N & t2<4
by id: egen anyno=max(no)
drop if anyno==1 | obs==3
/*
foreach x of varlist * {
	if !inlist("`x'","id","t2") local allvars `allvars' `x'
}

reshape wide `allvars', i(id) j(t2)
*/

foreach x in `helpvars' {
	replace `x'=0 if missing(`x')
}
drop year
gen yearfromdeath=t2
tempfile t1
save `t1'

keep id t2 time *oop c_ivw_date n hlphrs_*
replace time=0 if t2==0
sort id t2 
by id: gen timetonext=time[_n+1]-time
by id: replace timetonext=5-time if missing(timetonext) & time<3
by id: replace timetonext=2 if missing(timetonext) & time>=3
replace timetonext=0 if t2==6
gen wave_oop=total_oop
gen og=wave_oop
//convert total oop to annual measure
replace total_oop=total_oop/timetonext
by id: gen timefromlast=time-time[_n-1]
by id: gen yearnext=t2[_n+1]
by id: gen lastoop=total_oop[_n-1]
by id: replace lastoop=lastoop[_n-1] if missing(lastoop)
replace total_oop=0 if t2==6
/*helper hours--get previous and do the same as oop, but avg between two
from OOP code--use 4 months if previous wave there was no help, otherwise use 4 
months at current and rest between*/

foreach x in _u _s {
by id: gen last`x'=hlphrs`x'[_n-1]
by id: gen next`x'=hlphrs`x'[_n+1]
replace next`x'=0 if missing(next`x')
replace last`x'=hlphrs`x' if missing(last`x')
replace last`x'=0 if missing(last`x')
gen avg`x'=(hlphrs`x'+next`x')/2
}
gen hlphrs_ann=(avg_u+avg_s)*12
by id: gen lasthelp=hlphrs_ann[_n-1]
replace lasthelp=hlphrs_ann if t2==0
by id: gen nexthelp=hlphrs_ann[_n+1]
replace hlphrs_ann=0 if missing(nexthelp)
replace nexthelp=hlphrs_ann if missing(nexthelp)
reshape wide og time total_oop c_ivw_date hlphrs_ann hlphrs_i hlphrs_u hlphrs_s last_u last_s next_u next_s ///
avg_u avg_s lasthelp nexthelp timetonext timefromlast yearnext lastoop wave_oop n, i(id) j(t2)
reshape long time og total_oop c_ivw_date hlphrs_ann hlphrs_i hlphrs_u hlphrs_s last_u last_s next_u next_s ///
avg_u avg_s l lasthelp nexthelp timetonext timefromlast yearnext lastoop wave_oop n, i(id) j(year)

sort id year
*by id: carryforward total_oop, gen(annual_oop)
by id: carryforward time, gen(antime)
by id: replace lastoop=total_oop[_n-1] if missing(lastoop)
by id: replace lastoop=lastoop[_n-1] if missing(lastoop)
by id: carryforward timetonext timefromlast lasthelp hlphrs_ann, replace
gsort id -year
by id: carryforward nexthelp, replace
sort id year
gen pct1=(year-time) if year<6
gen pct2=1-(year-time) if year<6
by id: replace pct2=1 if missing(time) & year<6


gen annual_oop=pct2*lastoop if inrange(year,1,5)
replace annual_oop=annual_oop+pct1*total_oop if !missing(pct1)
/*for annual helper hours 
-4 months at current
-if any at previous, 4 months at current and 8 months at avg current and former*/
gen annual_hlphrs=hlphrs_ann*2/3 + hlphrs_i*12/3
replace annual_hlphrs=hlphrs_ann if missing(annual_hlphrs) 
replace annual_hlphrs=. if inlist(year,0,6)
/*gen annual_hlphrs=hlphrs_ann/3+(hlphrs_ann+nexthelp)/3
replace annual_hlphrs=(lasthelp+nexthelp)/2 if missing(n)
gen annual_hlphrs=(nexthelp) if inrange(year,1,5) & missing(n)
replace annual_hlphrs=pct2*lasthelp if  missing(annual_h) & inrange(year,1,5)
replace annual_hlphrs=annual_h+pct1*hlphrs_a if !missing(pct1)*/
replace wave_oop=wave_oop*timetonext/(time[_n+1]-time) if time[_n+1]>5 & ///
!missing(time[_n+1])
replace wave_oop=wave_oop*(5-time)/2 if missing(time[_n+1]) & time>=3
replace wave_oop=0 if time>5

by id: egen all=total(wave)
by id: egen a2=total(annual_oop)
sum all a2
sum all a2 if year==0
keep id all a2 year annual_* hlphrs*

rename (year ) (yearfromdeath )
tempfile t2
save `t2'

use decedent_dataset.dta if inrange(index_year,2001,2012), clear
drop *bef

gen ffs_yrs=floor(cont_ffs_n_mos/12)
foreach x in 12 24 36 48 60 {
rename tot_paid_by_mc_`x'm tot_paid_by_mc`=`x'/12'
}

forvalues i=1/5 {
replace tot_paid_by_mc`i'=. if ffs_yrs<`i'
}

reshape long tot_paid_by_mc, i(id) j(yearfromdeath)
keep id tot* yearfr
tempfile t3
save `t3'
/*
merge 1:1 id yearfromdeath using `t2', gen(oopme2) keep(match using)
merge 1:1 id yearfromdeath using `t1', gen(fullmerge)
*/
use `t1', clear
merge 1:1 id yearfromdeath using `t2', gen(oopme2) keep(match using)
merge 1:1 id yearfromdeath using `t3', gen(mcmerge) keep(match master)
sort id yearf

by id: replace ffs_y=ffs_y[_n+1] if missing(ffs_y)
by id: replace pdem=pdem[_n+1] if n==1 & missing(pdem)
gen likely_dem=inrange(pdem,.5,1) if !missing(pdem)
by id: egen pdem_gt50_n1=max(cond(n==2,likely_dem,.))
drop if missing(pdem_g) 
gen age_at_death=floor((index_dat-birth_date)/365.25)
drop if age_<70
label var age_ "Age at death"
foreach x of varlist `helpvars' {
replace `x'=0 if missing(`x')
}
gen ind_hp=n_hp>0
label var ind_hp "any helpers"
gen comorb_modsev=comor_c>=2 if !missing(comor_c)
label var comorb_modsev "4+ SR conditions"
label var likely_dem "Probable demntia (Pr>.5)"
label var time "Time from ivw to death, years"
foreach x in pdem likely_dem medicaid adl_independent_core iadl_independent_core ///
smoke_curr comorb_modsev time ind_hp `helpvars' networth_adj2012 finwealth_adj2012 {
gen `x'_ba=`x' if n==obs
by id: egen `x'_b=max(`x'_ba)
drop `x'_ba
local lab : var label `x'
label var `x'_b "`lab' at baseline"
}
replace networth_adj2012_b=1 if networth_adj2012_b<=0
//discounting--why?
forvalues i=1/5 {
	foreach x in tot_paid_by_mc annual_oop annual_hlp {
		replace `x'=`x'/1.03^`=`i'-1' if year==`i'
}
}
by id: egen tottot=total(tot_paid_by_mc)
by id: egen alloop=total(annual_oop)
by id: egen allhelp=total(annual_hlp)
replace allhelp=allhelp*20
label var allhelp "Imputed informal help over 5 years (at $20/hr)"
label var tottot "Total paid by MC over 5 years"
label var alloop "Total paid OOP over 5 years"
gen time_x=(e_ivw_date-index_date)/365.25
label var time_x "Time from death to exit, years"
gen baseline_out=time_b>=5
label var baseline_out "% with a baseline outside the 5 year window"

replace likely_dem=pdem_g if year==0



gen oopsofar=0
forvalues i=5(-1)1 {
by id: replace oopsofar=annual_oop+oopsofar[_n+1] if year==`i'
}
replace oopsofar=alloop if year==0
gen oop_gt_nw=oopsofar>=networth_adj2012_b
gen nw_remaining=100*(networth_adj2012_b-oopsofar)/networth_adj2012_b
replace nw_r=0 if nw_r<0
replace nw_r=0 if networth_adj2012_b<0
//table
local cvars1 time_x time_b 
local ivars1 baseline_out
local cvars2 age_at_death
local cvars3 n_i n_i_b pdem pdem_b
local ivars2 white black hisp_eth other_na_api_race female married_o_x hseduc medicaid_x medicaid_b ///
medigap_x champus_x ind_hp ind_hp_b 
local ivars3 likely_dem likely_dem_b ///
adl_independent_x adl_independent_core_b iadl_independent_x ///
iadl_independent_core_b smoke_curr_b comorb_modsev comorb_modsev_b
local coutcomes3 tottot alloop allhelp
local rn : word count `cvars1' `cvars2' `ivars1' `ivars2' `cvars3' `ivars3' `coutcomes3' 1

mat tab=J(`rn',4,.)
local r=1
local c=1
gsort id -year
by id: carryforward wgthh, replace
sort id year
preserve

keep if n==1
foreach group in "0,1" 0 1 {
	sum likely_dem if inlist(likely_dem,`group')
	local denom=r(N)
	foreach round in 1 2 3 {
		foreach x of local cvars`round' {
			sum `x' if inlist(likely_dem,`group') [aw=wgthh]
			if !inrange(r(N),1,10) mat tab[`r',`c']=r(mean)
			if "`group'"=="0,1" & !inrange(`denom'-r(N),1,10) mat tab[`r',`c'+3]=`denom'-r(N)
			local r=`r'+1
}
		foreach x of local ivars`round' {
			sum `x' if inlist(likely_dem,`group') [aw=wgthh]
			if !inrange(r(mean)*r(N),1,10) mat tab[`r',`c']=r(mean)*100
			if "`group'"=="0,1" & !inrange(`denom'-r(N),1,10) mat tab[`r',`c'+3]=`denom'-r(N)
			local r=`r'+1
}
		foreach x of local coutcomes`round' {
			sum `x' if inlist(likely_dem,`group') [aw=wgthh]
			if !inrange(r(N),1,10) mat tab[`r',`c']=r(mean)
			if "`group'"=="0,1" & !inrange(`denom'-r(N),1,10) mat tab[`r',`c'+3]=`denom'-r(N)
			local r=`r'+1
}


}	
	mat tab[`r',`c']=`denom'
	local r=1
	local c=`c'+1
}
mat rownames tab=`cvars1' `ivars1'  `cvars2' `ivars2' `cvars3' `ivars3' `coutcomes3' N

frmttable using "E:\data\burden_dementia\logs\table_baseline_death.rtf", replace ///
statmat(tab) title("Sample Characteristics by dementia status at n1 ivw") ///
ctitles("" "Full Sample" "No dementia" "Dementia" "N missing") sdec(2,2,2,0) ///
varlabels note("Decedents 2006-2012 with 60m continuous FFS pre-death, an exit and all core ivws" ///
"Household weights applied")

restore
preserve

egen totalpaid=rowtotal(tot_paid_by_mc total_oop annual_hlp)
collapse tot_paid_by_mc total_oop annual_hlp pdem likely_dem totalpaid networth_adj2012_b ///
oopsofar oop_gt_nw nw_remaining [pw=wgthh], by(pdem_gt50_n1 year)
replace year=-year+6

label define year 0 "Baseline" 6 "Death"
label values year year

twoway (line pdem year if pdem_g==1) (line pdem year if pdem_g==0) ///
(line likely_dem year if pdem_g==1) (line likely_dem year if pdem_g==0) if year<6, ///
xlabel(0.1 "Baseline" 1 2 3 4  5 "Death") xtitle("")
graph save "E:\data\burden_dementia\logs\dementia_prob_over_time", replace
graph export "E:\data\burden_dementia\logs\dementia_prob_over_time.pdf", replace

twoway (line nw_remaining yearfromdeath if pdem_g==1)(line nw_remaining yearfromdeath if pdem_g==0) ///
(line oop_gt yearfromdeath if pdem_g==1 , yaxis(2)) (line oop_gt yearfromdeath if pdem_g==0, yaxis(2)) ///
if year<6, xlabel(0.1 "Baseline" 1 2 3 4  5 "Death") xtitle("") ///
legend(label(1 "% NW remaining, demented") label(2 "% remaining, nondemented") ///
label(3 "% OOP>NW, demented") label(4 "% OOP>NW, nondemented"))
graph save "E:\data\burden_dementia\logs\networth_oop_over_time", replace
graph export "E:\data\burden_dementia\logs\networth_oop_over_time.pdf", replace
restore
//save "`fdpath'/burden_dementia_sample_long.dta", replace


H="long form table and graphs"
/******************
things from the exit, need to figure this out
-death date, adls/iadls, location of death, hospice medicaid/gap/va, value estate
	
things that are t:
-MC expenditures
-i

things that are in waves, need to be converted to annual:
-fixed characteristics
    -gender, birth date, death date, race, education
-mutable
	-age (computed at each year, from birth date above, rather than filled)
	-net worth, financial wealth, adl/iadls, srh, medicaid, champus, medigap, married or partnered
	-nursing home resident
	-dementia
	-region
	-family vars-resident children, transfers, help from kids 
	-out of pocket spending
	-number of helpers, helper hours, any helpers, imputed social costs

******************/
clear all
set more off
capture log close

local datapath "E:\data\burden_dementia\int_data"
local fdpath "E:\data\burden_dementia\final_data"
local logpath "E:\data\burden_dementia\logs"
local ooppath "E:\data\burden_dementia\oopdata"

cd `datapath'

/*first pull an index file from the decedent dataset*/
use id index_date index_year cont_ffs_n_mos using decedent_dataset.dta if inrange(index_year,2001,2012), clear
gen ffs_yrs=floor(cont_ffs_n_mos/12)
keep if ffs_y==5
tempfile index
save `index'


/*2nd, connect decedent dataset to exit*/
local vars female married_or_ medicaid champus medigap nhres hospice ///
e_ivw* *year loc_hosp adl_independent iadl_independent reschil_d livealone ///
comor_c_hrs 

use id `vars' using "E:\data\hrs_cleaned\exit_02_to_14_dt.dta" if !missing(e_ivw_date)
foreach x in married_o medicaid champus medigap nhres hospice loc_hosp ///
adl_independent iadl_independent reschil_d livealone {
rename `x' `x'_x
}
tempfile exit1
save `exit1'

merge 1:1 id using `index', nogen keep(match)
//set time=0 so it can be appended to the core
gen t2=0
drop if e_ivw_date<index_date
tempfile exit
save `exit'

/*3rd, save tracker, oop, dementia, rand family, and helpers*/


use "E:\data\hrs_public_2012\dementia\pdem_withvarnames_ebl.dta", clear
gsort id -core_year 
replace pdem=prob_hurd if !missing(prob_hurd)
by id: egen firstdem=min(cond(inrange(pdem,0.5,1),core_year,.))
by id: keep if _n<5
tempfile dem
save `dem'

use "E:\data\hrs_cleaned\restr_tracker_v2014.dta", clear
drop id
gen id=hhid+pn
tempfile track
save `track'


use `ooppath'\oopme_final.dta if year>=2000, clear
rename *, l
gen id=hhid+pn
/*gsort id -year
by id: gen n=_n
keep if n<5
by id: gen lastyear=year[1]
keep id lastyear total_oop n year
rename year core_year
*reshape wide total_oop year, i(id) j(n)*/
tempfile oop
save `oop'


use "E:\data\hrs_oop_2010\received_data\2012\helper_hours_2012.dta", clear
gen id=hhid+pn 
//cap number of hours at 720 (24 hrs for 30 days) for spouses and other informal
foreach x in s u {
replace hlphrs_`x'=720 if hlphrs_`x'>720
}
replace hlphrs_i=hlphrs_s+hlphrs_u
tempfile help
save `help'


/*5th, connect decedent dataset to core
	1) merge 1:m to restrict to decedents
	2) flag those that have two+ cores within 5 years
	3) keep all within 5 years and the one before for baseline
	4) merge by core year with dementia prob, rand fam, helpers, oop datasets
	5) reset so that it's in annual long format
*/

use `index', clear
merge 1:m id using "E:\data\hrs_cleaned\core_00_to_14.dta", nogen ///
keep(match master)
sort id core_year
replace wgthh=. if wgthh==0
carryforward wgthh, replace
gsort id -core_year
carryforward wgthh, replace
by id: gen n=_n
gen time=(index_date-c_ivw_date)/365.25
gen t2=ceil(time)
by id: egen yes=min(time)
gen y1=inrange(yes,0,5)
gen inn=n if time<=5
gen outn=n if time>5
by id: egen y2=max(inn)
//get the first interview outside the window
by id: egen y3=min(outn)

/*keep all ivws within 5 years and a baseline for those who have at least one 
ivw w/in 5 years*/
keep if y1 & (inrange(time,0.00001,5) | y3==n)

/*drop baselines if >8 years out*/
drop if time>8

//locals to keep relevant vars
local corevars networth_adj2012 finwealth_adj2012 medicaid champus medigap srh_pf adl_independent_core ///
iadl_independent_core nhres reschil_d wgthh comor_c smoke_ever smoke_curr
local helpvars n_hp hlphrs_i n_i hlphrs_u hlphrs_s
local famvars resd_kid_ind help_adls_kid_adult help_iadls_kid_adult ///
transf_from_kid_adult_ind
local oopvars total_oop
local trackvars birth_date hisp_eth white black other_na_api cause_death degree
local demvars pdem ldem firstdem prob_hurd
keep id `corevars' core_year c_ivw_* index_date t2 time

append using `exit'

//keep only those with an exit
sort id t2
by id: egen min=min(t2)
keep if min==0
drop min

//keep only those with at least one core
by id: gen n=_n
by id: gen obs=_N
by id: drop if _N==1

//gen year to merge with oop & helper
gen year=core_year
replace year=exit_year if missing(year)

merge 1:1 id year using `oop', gen(oopmerge) keep(match master)  ///
keepusing(`oopvars')
merge 1:1 id year using `help', gen(helpmerge) keep(match master) ///
keepusing(`helpvars')
merge 1:1 id core_year using `dem', gen(demmerge) keep(match master) ///
keepusing(`demvars')
merge m:1 id core_year using ///
"E:\data\hrs_public_2014\rand2014\family\family_r_clean_98_12.dta", ///
gen(randfammerge) keep(match master) keepusing(`famvars')
merge m:1 id using `track', nogen keep(match) keepusing(`trackvars')

//hs+ (including ged)
gen hseduc=degree>0
label var hseduc "HS Degree+ (including GED)"

replace t2=6 if t2>6
gsort id -year
by id: replace pdem=pdem[_n+1] if t2==0
gen no=0
by id: replace no=1 if year>year[_n+1]+2 & _n!=_N
by id: replace no=1 if _n==_N & t2<4
by id: egen anyno=max(no)
drop if anyno==1 | obs==3
/*
foreach x of varlist * {
	if !inlist("`x'","id","t2") local allvars `allvars' `x'
}

reshape wide `allvars', i(id) j(t2)
*/

foreach x in `helpvars' {
	replace `x'=0 if missing(`x')
}
drop year
gen yearfromdeath=t2
tempfile t1
save `t1'

keep id t2 time *oop c_ivw_date n hlphrs_*
replace time=0 if t2==0
sort id t2 
by id: gen timetonext=time[_n+1]-time
by id: replace timetonext=5-time if missing(timetonext) & time<3
by id: replace timetonext=2 if missing(timetonext) & time>=3
replace timetonext=0 if t2==6
gen wave_oop=total_oop
gen og=wave_oop
//convert total oop to annual measure
replace total_oop=total_oop/timetonext
by id: gen timefromlast=time-time[_n-1]
by id: gen yearnext=t2[_n+1]
by id: gen lastoop=total_oop[_n-1]
by id: replace lastoop=lastoop[_n-1] if missing(lastoop)
replace total_oop=0 if t2==6
/*helper hours--get previous and do the same as oop, but avg between two
from OOP code--use 4 months if previous wave there was no help, otherwise use 4 
months at current and rest between*/

foreach x in _u _s {
by id: gen last`x'=hlphrs`x'[_n-1]
by id: gen next`x'=hlphrs`x'[_n+1]
replace next`x'=0 if missing(next`x')
replace last`x'=hlphrs`x' if missing(last`x')
replace last`x'=0 if missing(last`x')
gen avg`x'=(hlphrs`x'+next`x')/2
}
gen hlphrs_ann=(avg_u+avg_s)*12
by id: gen lasthelp=hlphrs_ann[_n-1]
replace lasthelp=hlphrs_ann if t2==0
by id: gen nexthelp=hlphrs_ann[_n+1]
replace hlphrs_ann=0 if missing(nexthelp)
replace nexthelp=hlphrs_ann if missing(nexthelp)
reshape wide og time total_oop c_ivw_date hlphrs_ann hlphrs_i hlphrs_u hlphrs_s last_u last_s next_u next_s ///
avg_u avg_s lasthelp nexthelp timetonext timefromlast yearnext lastoop wave_oop n, i(id) j(t2)
reshape long time og total_oop c_ivw_date hlphrs_ann hlphrs_i hlphrs_u hlphrs_s last_u last_s next_u next_s ///
avg_u avg_s l lasthelp nexthelp timetonext timefromlast yearnext lastoop wave_oop n, i(id) j(year)

sort id year
*by id: carryforward total_oop, gen(annual_oop)
by id: carryforward time, gen(antime)
by id: replace lastoop=total_oop[_n-1] if missing(lastoop)
by id: replace lastoop=lastoop[_n-1] if missing(lastoop)
by id: carryforward timetonext timefromlast lasthelp hlphrs_ann, replace
gsort id -year
by id: carryforward nexthelp, replace
sort id year
gen pct1=(year-time) if year<6
gen pct2=1-(year-time) if year<6
by id: replace pct2=1 if missing(time) & year<6


gen annual_oop=pct2*lastoop if inrange(year,1,5)
replace annual_oop=annual_oop+pct1*total_oop if !missing(pct1)
/*for annual helper hours 
-4 months at current
-if any at previous, 4 months at current and 8 months at avg current and former*/
gen annual_hlphrs=hlphrs_ann*2/3 + hlphrs_i*12/3
replace annual_hlphrs=hlphrs_ann if missing(annual_hlphrs) 
replace annual_hlphrs=. if inlist(year,0,6)
/*gen annual_hlphrs=hlphrs_ann/3+(hlphrs_ann+nexthelp)/3
replace annual_hlphrs=(lasthelp+nexthelp)/2 if missing(n)
gen annual_hlphrs=(nexthelp) if inrange(year,1,5) & missing(n)
replace annual_hlphrs=pct2*lasthelp if  missing(annual_h) & inrange(year,1,5)
replace annual_hlphrs=annual_h+pct1*hlphrs_a if !missing(pct1)*/
replace wave_oop=wave_oop*timetonext/(time[_n+1]-time) if time[_n+1]>5 & ///
!missing(time[_n+1])
replace wave_oop=wave_oop*(5-time)/2 if missing(time[_n+1]) & time>=3
replace wave_oop=0 if time>5

by id: egen all=total(wave)
by id: egen a2=total(annual_oop)
sum all a2
sum all a2 if year==0
keep id all a2 year annual_* hlphrs*

rename (year ) (yearfromdeath )
tempfile t2
save `t2'

use decedent_dataset.dta if inrange(index_year,2001,2012), clear
drop *bef

gen ffs_yrs=floor(cont_ffs_n_mos/12)
foreach x in 12 24 36 48 60 {
rename tot_paid_by_mc_`x'm tot_paid_by_mc`=`x'/12'
}

forvalues i=1/5 {
replace tot_paid_by_mc`i'=. if ffs_yrs<`i'
}

reshape long tot_paid_by_mc, i(id) j(yearfromdeath)
keep id tot* yearfr
tempfile t3
save `t3'
/*
merge 1:1 id yearfromdeath using `t2', gen(oopme2) keep(match using)
merge 1:1 id yearfromdeath using `t1', gen(fullmerge)
*/
use `t1', clear
merge 1:1 id yearfromdeath using `t2', gen(oopme2) keep(match using)
merge 1:1 id yearfromdeath using `t3', gen(mcmerge) keep(match master)
sort id yearf

by id: replace ffs_y=ffs_y[_n+1] if missing(ffs_y)
by id: replace pdem=pdem[_n+1] if n==1 & missing(pdem)
gen likely_dem=inrange(pdem,.5,1) if !missing(pdem)
by id: egen pdem_gt50_n1=max(cond(n==2,likely_dem,.))
drop if missing(pdem_g) 
gen age_at_death=floor((index_dat-birth_date)/365.25)
drop if age_<70
label var age_ "Age at death"
foreach x of varlist `helpvars' {
replace `x'=0 if missing(`x')
}
gen ind_hp=n_hp>0
label var ind_hp "any helpers"
gen comorb_modsev=comor_c>=2 if !missing(comor_c)
label var comorb_modsev "4+ SR conditions"
label var likely_dem "Probable demntia (Pr>.5)"
label var time "Time from ivw to death, years"
foreach x in pdem likely_dem medicaid adl_independent_core iadl_independent_core ///
smoke_curr comorb_modsev time ind_hp `helpvars' networth_adj2012 finwealth_adj2012 {
gen `x'_ba=`x' if n==obs
by id: egen `x'_b=max(`x'_ba)
drop `x'_ba
local lab : var label `x'
label var `x'_b "`lab' at baseline"
}
replace networth_adj2012_b=1 if networth_adj2012_b<=0
//discounting--why?
forvalues i=1/5 {
	foreach x in tot_paid_by_mc annual_oop annual_hlp {
		replace `x'=`x'/1.03^`=`i'-1' if year==`i'
}
}
by id: egen tottot=total(tot_paid_by_mc)
by id: egen alloop=total(annual_oop)
by id: egen allhelp=total(annual_hlp)
replace allhelp=allhelp*20
label var allhelp "Imputed informal help over 5 years (at $20/hr)"
label var tottot "Total paid by MC over 5 years"
label var alloop "Total paid OOP over 5 years"
gen time_x=(e_ivw_date-index_date)/365.25
label var time_x "Time from death to exit, years"
gen baseline_out=time_b>=5
label var baseline_out "% with a baseline outside the 5 year window"

replace likely_dem=pdem_g if year==0



gen oopsofar=0
forvalues i=5(-1)1 {
by id: replace oopsofar=annual_oop+oopsofar[_n+1] if year==`i'
}
replace oopsofar=alloop if year==0
gen oop_gt_nw=oopsofar>=networth_adj2012_b
gen nw_remaining=100*(networth_adj2012_b-oopsofar)/networth_adj2012_b
replace nw_r=0 if nw_r<0
replace nw_r=0 if networth_adj2012_b<0
//table
local cvars1 time_x time_b 
local ivars1 baseline_out
local cvars2 age_at_death
local cvars3 n_i n_i_b pdem pdem_b
local ivars2 white black hisp_eth other_na_api_race female married_o_x hseduc medicaid_x medicaid_b ///
medigap_x champus_x ind_hp ind_hp_b 
local ivars3 likely_dem likely_dem_b ///
adl_independent_x adl_independent_core_b iadl_independent_x ///
iadl_independent_core_b smoke_curr_b comorb_modsev comorb_modsev_b
local coutcomes3 tottot alloop allhelp
local rn : word count `cvars1' `cvars2' `ivars1' `ivars2' `cvars3' `ivars3' `coutcomes3' 1

mat tab=J(`rn',4,.)
local r=1
local c=1
gsort id -year
by id: carryforward wgthh, replace
sort id year
preserve

keep if n==1
foreach group in "0,1" 0 1 {
	sum likely_dem if inlist(likely_dem,`group')
	local denom=r(N)
	foreach round in 1 2 3 {
		foreach x of local cvars`round' {
			sum `x' if inlist(likely_dem,`group') [aw=wgthh]
			if !inrange(r(N),1,10) mat tab[`r',`c']=r(mean)
			if "`group'"=="0,1" & !inrange(`denom'-r(N),1,10) mat tab[`r',`c'+3]=`denom'-r(N)
			local r=`r'+1
}
		foreach x of local ivars`round' {
			sum `x' if inlist(likely_dem,`group') [aw=wgthh]
			if !inrange(r(mean)*r(N),1,10) mat tab[`r',`c']=r(mean)*100
			if "`group'"=="0,1" & !inrange(`denom'-r(N),1,10) mat tab[`r',`c'+3]=`denom'-r(N)
			local r=`r'+1
}
		foreach x of local coutcomes`round' {
			sum `x' if inlist(likely_dem,`group') [aw=wgthh]
			if !inrange(r(N),1,10) mat tab[`r',`c']=r(mean)
			if "`group'"=="0,1" & !inrange(`denom'-r(N),1,10) mat tab[`r',`c'+3]=`denom'-r(N)
			local r=`r'+1
}


}	
	mat tab[`r',`c']=`denom'
	local r=1
	local c=`c'+1
}
mat rownames tab=`cvars1' `ivars1'  `cvars2' `ivars2' `cvars3' `ivars3' `coutcomes3' N

frmttable using "E:\data\burden_dementia\logs\table_baseline_death.rtf", replace ///
statmat(tab) title("Sample Characteristics by dementia status at n1 ivw") ///
ctitles("" "Full Sample" "No dementia" "Dementia" "N missing") sdec(2,2,2,0) ///
varlabels note("Decedents 2006-2012 with 60m continuous FFS pre-death, an exit and all core ivws" ///
"Household weights applied")

restore
preserve

egen totalpaid=rowtotal(tot_paid_by_mc total_oop annual_hlp)
collapse tot_paid_by_mc total_oop annual_hlp pdem likely_dem totalpaid networth_adj2012_b ///
oopsofar oop_gt_nw nw_remaining [pw=wgthh], by(pdem_gt50_n1 year)
replace year=-year+6

label define year 0 "Baseline" 6 "Death"
label values year year

twoway (line pdem year if pdem_g==1) (line pdem year if pdem_g==0) ///
(line likely_dem year if pdem_g==1) (line likely_dem year if pdem_g==0) if year<6, ///
xlabel(0.1 "Baseline" 1 2 3 4  5 "Death") xtitle("")
graph save "E:\data\burden_dementia\logs\dementia_prob_over_time", replace
graph export "E:\data\burden_dementia\logs\dementia_prob_over_time.pdf", replace

twoway (line nw_remaining yearfromdeath if pdem_g==1)(line nw_remaining yearfromdeath if pdem_g==0) ///
(line oop_gt yearfromdeath if pdem_g==1 , yaxis(2)) (line oop_gt yearfromdeath if pdem_g==0, yaxis(2)) ///
if year<6, xlabel(0.1 "Baseline" 1 2 3 4  5 "Death") xtitle("") ///
legend(label(1 "% NW remaining, demented") label(2 "% remaining, nondemented") ///
label(3 "% OOP>NW, demented") label(4 "% OOP>NW, nondemented"))
graph save "E:\data\burden_dementia\logs\networth_oop_over_time", replace
graph export "E:\data\burden_dementia\logs\networth_oop_over_time.pdf", replace
restore
save "`fdpath'/burden_dementia_sample_long.dta", replace


H="quick sample estimate for incident dementia"
use "E:\data\hrs_cleaned\core_00_to_14.dta", clear
merge 1:1 id core_year using E:\data\hrs_public_2014\dementia\pdem_withvarnames_00_14, ///
keep(match) nogen
merge 1:1 id core_year using "E:\data\serious_ill\int_data\core_ids_1yr_criteria_5.dta", ///
keep(match master) nogen

gen a70=age_at>=70
drop if missing(pdem)
gen dem=inrange(pdem,0.5,1)
by id, sort: egen firstdem=min(cond(dem==1),core_year,.)
by id: egen firstobs=min(core_year)
keep if a70==1 & core_year>=2000
replace criteria_smi=0 if smi_count==1 & smi_dem==1
drop if firstdem>core_year
by id: egen develops_smi=max(criteria_smi)
keep if firstdem==core_year
log using "E:\data\burden_dementia\logs\incident_dem.txt", text replace
tab firstdem 
tab firstdem if firstdem>firstobs
tab firstdem if !missing(death_date)
gen ffs12=part_ab_12m==1 & hmo_d_12m==0 
tab firstdem if ffs12
tab firstdem if criteria_smi==1 & ffs12
tab firstdem if develops_smi==1 & !criteria_smi
keep if firstdem>firstobs
tab firstdem if ffs12
tab firstdem if criteria_smi==1 & ffs12
tab firstdem if develops_smi==1 & !criteria_smi
log close


H="H1c: nw<oop earlier for vulnerable subgroups"
/*H1C: Vulnerable subgroups (African Americans, Hispanics, those w/o a HS diploma,
unmarried) of older adults with ADRD are more likely to exhaust household wealth 
earlier (e.g. prior to the last year of life) compared to non-vulnerable adults 
w/ ADRD and all older adults w/o ADRD*/


clear all
set more off
capture log close

local datapath "E:\data\burden_dementia\int_data"
local fdpath "E:\data\burden_dementia\final_data"
local logpath "E:\data\burden_dementia\logs"
local ooppath "E:\data\burden_dementia\oopdata"

cd `logpath'

use "`fdpath'/burden_dementia_sample_long.dta", replace
by id: egen ex=min(year)
drop if ex!=0
drop ex

gen ind_ndd=pdem_gt50_n1==1
gen ind_nd=pdem_gt50_n1==0
label var ind_ndd "Non-disadvantaged with dementia"
label var ind_nd "Non-dementia"
gen ind_nhs=!hseduc
label var ind_nhs "No HS degree"
by id: gen ind_unm=married_o_x==0 if year==0
label var ind_unm "Not married at death"
sort id year
by id: carryforward ind_nhs ind_unm, replace
foreach x in black hisp_eth ind_nhs ind_unm {
	replace ind_ndd=0 if `x'==1
	gen ind_`x'd=pdem_gt50_n1==1 & `x'==1
}

label var ind_black "Dementia & Black"
label var ind_hisp_eth "Dementia & Hispanic"
label var ind_ind_nhs "Dementia & no HS diploma"
label var ind_ind_unm "Dementia & unmarried at death"

local group ind_nd ind_ndd ind_black ind_hisp_eth ind_ind_nhs ind_ind_unm
sum `group'
tab1 `group'
local cn : word count `group'

mat tab=J(8,`cn'*3,.)
mat stars=J(8,`cn'*3,0)
local r=1
local c=1

foreach x of local group {
	sum networth_adj2012_b if year==0 & `x'==1
	mat tab[`r',`c']=r(mean)
	if `c'>1 {
		ttest networth_adj2012_b if year==0 & (ind_nd==1 | `x'==1), by(`x')
		mat tab[`r',`c'+1]=r(p)
		mat stars[`r',`c'+1]=(r(p)<.05)+(r(p)<.01)
}
	if `c'!=4 {
		ttest networth_adj2012_b if year==0 & (ind_ndd==1 | `x'==1), by(`x')
		mat tab[`r',`c'+2]=r(p)
		mat stars[`r',`c'+2]=(r(p)<.05)+(r(p)<.01)
}	
local c=`c'+3
}
local r=`r'+1
local c=1
forvalues i=6(-1)0 {
	foreach x of local group {
		di "`x'"
		sum oop_gt_nw if year==`i' & `x'==1
		mat tab[`r',`c']=r(mean)*100
		di "`r'"
		di "`c'"
		if `c'>1 {
			tab oop_gt_nw `x' if year==`i' & (ind_nd==1 | `x'==1), chi2
			mat tab[`r',`c'+1]=r(p)
			mat stars[`r',`c'+1]=(r(p)<.05)+(r(p)<.01)
}
		if `c'!=4 {
			tab oop_gt_nw `x' if year==`i' & (ind_ndd==1 | `x'==1), chi2
			mat tab[`r',`c'+2]=r(p)
			mat stars[`r',`c'+2]=(r(p)<.05)+(r(p)<.01)
}			
	local c=`c'+3
}
	local r=`r'+1
	local c=1
}

frmttable, statmat(tab) sdec(2) title("OOP and NW by Vulnerable subgroups") ///
ctitles("" "no dementia" "non-vulnerable" "black" "hisp" "no hs degree" "unmarried") ///
rtitles("Mean NW at baseline (2012$)"\"P-relative to No dementia"\ ///
"P-relative to white, married HS grad"\ ///
"OOP>NW at death"\""\""\"Year 5"\""\""\"Year 4"\""\""\"Year 3"\""\""\"Year 2"\ ///
""\""\"Year 1"\""\""\"Year 0"\""\"") substat(2) annotate(stars) asymbol(*,**)


H="H1a: nw<oop in first 4yrs and public exp. last year"


H="***************"


H="Merge Medicaid files and extract total cost"
libname raw 'E:\data\CMS_DUA_51675_2014\Received_20180307';
libname merged 'E:\data\CMS_DUA_51675_2014\Medicaid_merged';


/* Macro to pull raw individual years */

%macro import(source=);

%do i = 1999 %to 2012;

data max_&source._&i.;
set raw.hrs_max_&source._&i.;
type_of_claim1 = put(type_of_claim, $4.);
Com_based_LTC_flag1 = put(Com_based_LTC_flag, $4.);
run;

data max_&source._&i. (drop= type_of_claim Com_based_LTC_flag);
set max_&source._&i.;
run;


data max_&source._&i.;
set max_&source._&i. (rename=(type_of_claim1 = type_of_claim Com_based_LTC_flag1 = Com_based_LTC_flag));
run;

%end;



%mend import;


/* Macro to merge years into single file */

%macro merge(source=);

data merged.hrs_max_&source._99_12;
set max_&source._1999 max_&source._2000 max_&source._2001 max_&source._2002 max_&source._2003 max_&source._2004
max_&source._2005 max_&source._2006 max_&source._2007 max_&source._2008 max_&source._2009 max_&source._2010
max_&source._2011 max_&source._2012;
run;

%mend merge;


%import(source=ip);
%import(source=ot);
%import(source=lt);
%import(source=rx);

%merge(source=ip);
%merge(source=ot);
%merge(source=lt);
%merge(source=rx);

%macro importps(source=);

%do i = 1999 %to 2012;

data max_&source._&i.;
set raw.hrs_max_&source._&i.;
Restricted_benefits_mo_01a = strip(put(Restricted_benefits_mo_01, 8.));
Restricted_benefits_mo_02a = strip(put(Restricted_benefits_mo_02, 8.));
Restricted_benefits_mo_03a = strip(put(Restricted_benefits_mo_03, 8.));
Restricted_benefits_mo_04a = strip(put(Restricted_benefits_mo_04, 8.));
Restricted_benefits_mo_05a = strip(put(Restricted_benefits_mo_05, 8.));
Restricted_benefits_mo_06a = strip(put(Restricted_benefits_mo_06, 8.));
Restricted_benefits_mo_07a = strip(put(Restricted_benefits_mo_07, 8.));
Restricted_benefits_mo_08a = strip(put(Restricted_benefits_mo_08, 8.));
Restricted_benefits_mo_09a = strip(put(Restricted_benefits_mo_09, 8.));
Restricted_benefits_mo_10a = strip(put(Restricted_benefits_mo_10, 8.));
Restricted_benefits_mo_11a = strip(put(Restricted_benefits_mo_11, 8.));
Restricted_benefits_mo_12a = strip(put(Restricted_benefits_mo_12, 8.));
Eligible_months1 = strip(put(Eligible_months, 8.));
Private_insurance_months1 = strip(put(Private_insurance_months, 8.));
run;


data max_&source._&i. (drop= Restricted_benefits_mo_01 Restricted_benefits_mo_02 Restricted_benefits_mo_03 Restricted_benefits_mo_04 Restricted_benefits_mo_05 Restricted_benefits_mo_06
Restricted_benefits_mo_07 Restricted_benefits_mo_08 Restricted_benefits_mo_09 Restricted_benefits_mo_10 Restricted_benefits_mo_11 Restricted_benefits_mo_12 Eligible_months Private_insurance_months);
set max_&source._&i.;
run;

%end;



%mend importps;


%importps(source=ps);
%merge(source=ps);


/* Calculate annual totals */

proc contents data=merged.hrs_max_asf_1999_2012 short; run;




proc export data=merged.hrs_max_asf_1999_2012 outfile="E:\data\CMS_DUA_51675_2014\Medicaid_merged\asf.dta" dbms=stata replace; run;


data annual_sum;
set merged.hrs_max_asf_1999_2012;
tot_paid_by_mdcd = sum(mdcd_ffs_amt, mdcd_hmo_amt, mdcd_hmo_amt_hcbs, mdcd_php_amt, mdcd_php_amt_hcbs, mdcd_pccm_amt, mdcd_pccm_amt_hcbs, mdcd_ip_amt, mdcd_ip_amt_hcbs, 
mdcd_mhs_amt, mdcd_mhs_amt_hcbs, mdcd_ipf_amt, mdcd_ipf_amt_hcbs, mdcd_icf_amt, mdcd_icf_amt_hcbs, mdcd_nf_amt, mdcd_nf_amt_hcbs, mdcd_phys_amt, mdcd_phys_amt_hcbs, 
mdcd_dn_amt, mdcd_dn_amt_hcbs, mdcd_opr_amt, mdcd_opr_amt_hcbs, mdcd_oph_amt, mdcd_oph_amt_hcbs, mdcd_clin_amt, mdcd_clin_amt_hcbs, mdcd_hh_amt, mdcd_hh_amt_hcbs,
mdcd_lx_amt, mdcd_lx_amt_hcbs, mdcd_rx_amt, mdcd_rx_amt_hcbs, mdcd_os_amt, mdcd_os_amt_hcbs, mdcd_st_amt, mdcd_st_amt_hcbs, mdcd_ab_amt, mdcd_ab_amt_hcbs, mdcd_ts_amt,
mdcd_ts_amt_hcbs, mdcd_pcs_amt, mdcd_pcs_amt_hcbs, mdcd_tc_amt, mdcd_tc_amt_hcbs, mdcd_rs_amt, mdcd_rs_amt_hcbs, mdcd_sh_amt, mdcd_sh_amt_hcbs, mdcd_hs_amt, mdcd_hs_amt_hcbs, 
mdcd_nms_amt, mdcd_nms_amt_hcbs, mdcd_nps_amt, mdcd_nps_amt_hcbs, mdcd_pdn_amt, mdcd_pdn_amt_hcbs, mdcd_rnhc_amt, mdcd_rnhc_amt_hcbs, mdcd_dmes_amt, mdcd_dmes_amt_hcbs,
mdcd_rc_amt, mdcd_rc_amt_hcbs, mdcd_ps_amt, mdcd_ps_amt_hcbs, mdcd_adc_amt, mdcd_adc_amt_hcbs, mdcd_us_amt, mdcd_us_amt_hcbs);
run;




libname merged 'E:\data\CMS_DUA_51675_2014\Medicaid_merged';

proc import datafile="E:\data\burden_dementia\int_data\medicaid_link.dta" out=R01 dbms=stata replace; run;


data r01;
set r01;
index_year = year(index_date);
index_month = month(index_date);
format index_date date9.;
run;

data month_sum (keep = bid_hrs_23 year month tot_paid);
set merged.Hrs_max_msf_1999_2012;
tot_paid = sum(mdcd_ffs_amt, mdcd_hmo_amt, mdcd_hmo_amt_hcbs, mdcd_php_amt, mdcd_php_amt_hcbs, mdcd_pccm_amt, mdcd_pccm_amt_hcbs, mdcd_ip_amt, mdcd_ip_amt_hcbs, 
mdcd_mhs_amt, mdcd_mhs_amt_hcbs, mdcd_ipf_amt, mdcd_ipf_amt_hcbs, mdcd_icf_amt, mdcd_icf_amt_hcbs, mdcd_nf_amt, mdcd_nf_amt_hcbs, mdcd_phys_amt, mdcd_phys_amt_hcbs, 
mdcd_dn_amt, mdcd_dn_amt_hcbs, mdcd_opr_amt, mdcd_opr_amt_hcbs, mdcd_oph_amt, mdcd_oph_amt_hcbs, mdcd_clin_amt, mdcd_clin_amt_hcbs, mdcd_hh_amt, mdcd_hh_amt_hcbs,
mdcd_lx_amt, mdcd_lx_amt_hcbs, mdcd_rx_amt, mdcd_rx_amt_hcbs, mdcd_os_amt, mdcd_os_amt_hcbs, mdcd_st_amt, mdcd_st_amt_hcbs, mdcd_ab_amt, mdcd_ab_amt_hcbs, mdcd_ts_amt,
mdcd_ts_amt_hcbs, mdcd_pcs_amt, mdcd_pcs_amt_hcbs, mdcd_tc_amt, mdcd_tc_amt_hcbs, mdcd_rs_amt, mdcd_rs_amt_hcbs, mdcd_sh_amt, mdcd_sh_amt_hcbs, mdcd_hs_amt, mdcd_hs_amt_hcbs, 
mdcd_nms_amt, mdcd_nms_amt_hcbs, mdcd_nps_amt, mdcd_nps_amt_hcbs, mdcd_pdn_amt, mdcd_pdn_amt_hcbs, mdcd_rnhc_amt, mdcd_rnhc_amt_hcbs, mdcd_dmes_amt, mdcd_dmes_amt_hcbs,
mdcd_rc_amt, mdcd_rc_amt_hcbs, mdcd_ps_amt, mdcd_ps_amt_hcbs, mdcd_adc_amt, mdcd_adc_amt_hcbs, mdcd_us_amt, mdcd_us_amt_hcbs);
run;

proc sort data=month_sum; by bid_hrs_23 year; run;
proc transpose data=month_sum out=month_sum_wide; by bid_hrs_23 year; id month; run;

proc sql;
create table r01_month as select a.*, b.*
from r01 a
left join month_sum_wide b
on a.bid_hrs_23=b.bid_hrs_23;
quit;






H="Pull costs and days from monthly summary file"
libname merged 'E:\data\CMS_DUA_51675_2014\Medicaid_merged';

proc import datafile="E:\data\burden_dementia\int_data\medicaid_link.dta" out=R01 dbms=stata replace; run;


data r01;
set r01;
index_year = year(index_date);
index_month = month(index_date);
format index_date date9.;
run;

data month_sum (keep = bid_hrs_23 year month tot_paid);
set merged.Hrs_max_msf_1999_2012;
tot_paid = sum(mdcd_ffs_amt, mdcd_hmo_amt, mdcd_php_amt, mdcd_pccm_amt); /* total paid by MC, FFS + Managed Care */
run;

proc sort data=month_sum; by bid_hrs_23 year; run;
proc transpose data=month_sum out=month_sum_wide; by bid_hrs_23 year; id month; run;

proc sql;
create table r01_month as select a.*, b.*
from r01 a
left join month_sum_wide b
on a.bid_hrs_23=b.bid_hrs_23;
quit;

/*** Get HH + SNF days & cost *****/

data month_breakdown (keep = bid_hrs_23 year month mdcd_ffs_amt mdcd_hmo_amt mdcd_php_amt mdcd_pccm_amt mdcd_nf_days_all mdcd_nf_days_hcbs_all mdcd_nf_amt mdcd_nf_amt_hcbs mdcd_hh_amt mdcd_hh_amt_hcbs mdcd_hh_days_all mdcd_hh_days_hcbs_all);
set merged.hrs_max_msf_1999_2012;
run;

data month_breakdown (drop = mdcd_ffs_amt mdcd_hmo_amt mdcd_php_amt mdcd_pccm_amt mdcd_nf_days_all mdcd_nf_days_hcbs_all mdcd_nf_amt mdcd_nf_amt_hcbs mdcd_hh_amt mdcd_hh_amt_hcbs mdcd_hh_days_all mdcd_hh_days_hcbs_all);
set month_breakdown;
tot_paid_maid = sum(mdcd_ffs_amt, mdcd_hmo_amt, mdcd_php_amt, mdcd_pccm_amt);
nf_days_maid = sum(mdcd_nf_days_all);
nf_cost_maid = sum(mdcd_nf_amt);
hh_days_maid = sum(mdcd_hh_days_all);
hh_cost_maid = sum(mdcd_hh_amt);
run;

proc sort data=month_breakdown; by bid_hrs_23 year; run;
proc transpose data=month_breakdown out=month_breakdown_wide; by bid_hrs_23 year; id month; run;

proc freq data= month_breakdown; tables tot_paid_maid nf_days_maid nf_cost_maid hh_days_maid hh_cost_maid; run;


proc sql;
create table r01_b as select a.*, b.*
from r01 a
left join month_breakdown_wide b
on a.bid_hrs_23=b.bid_hrs_23;
quit;




proc export data=r01_b outfile="E:\data\burden_dementia\int_data\medicaid_cost_hh_snf.dta" dbms=stata replace; run;


H="Calculate annual Medicaid cost for years prior to death"
use "E:\data\burden_dementia\int_data\medicaid_cost_raw.dta", clear



/* Flag year markers, n1=[0,-12], n2=[-12,-24], n3=[-24,-36], etc. */

gen n1_flag = 0
replace n1_flag = 1 if (index_year==year) | (year==index_year-1)

gen n2_flag = 0
replace n2_flag = 1 if (year==index_year-1) | (year==index_year-2)

gen n3_flag = 0
replace n3_flag = 1 if (year==index_year-2) | (year==index_year-3)

gen n4_flag = 0
replace n4_flag = 1 if (year==index_year-3) | (year==index_year-4)

gen n5_flag = 0
replace n5_flag = 1 if (year==index_year-4) | (year==index_year-5)

gen index_day = day(index_date)

/* inflation adjustment */

gen rate = .

replace rate=1 if year==2012
replace rate=1.03902 if year==2011
replace rate=1.07086 if year==2010
replace rate=1.10835 if year==2009
replace rate=1.1439 if year==2008
replace rate=1.1923 if year==2007
replace rate=1.25586 if year==2006
replace rate=1.30783 if year==2005
replace rate=1.37027 if year==2004
replace rate=1.43908 if year==2003
replace rate=1.50337 if year==2002
replace rate=1.57963 if year==2001
replace rate=1.65519 if year==2000
replace rate=1.72641 if year<=1999

forvalues p = 1/12 {

replace _`p' = _`p'*rate
}

*levelsof bid_hrs_23, local(bid_check)

*foreach x of local bid_check { 

forvalues t=1/12 {

preserve
keep if index_month==`t'

forvalues i=1/5 {

gen sum_n`i'_cyr= 0 if n`i'_flag==1 /*sum months before index month in current year*/

local j = index_month
local k = 1


	while `k' <= `j' { // while current month less than or equal index, add to past value
		while `k' < `j' {
			replace sum_n`i'_cyr = sum_n`i'_cyr + _`k' if sum_n`i'_cyr!=.
			local ++k
		}
	    replace sum_n`i'_cyr = sum_n`i'_cyr + (_`k')*(index_day/30.4) if sum_n`i'_cyr!=. // if current month = index, then prorate it
		local ++k
}

gen sum_n`i'_b4yr = 0 if n`i'_flag==1

local r = index_month
local s = 12
	while `s' >=`r' { // count backwards to get months before index in previous year
		while `s' > `r' {
		replace sum_n`i'_b4yr = sum_n`i'_b4yr + _`s' if sum_n`i'_b4yr!=.
		local --s
	}
	
	replace sum_n`i'_b4yr = sum_n`i'_b4yr + (_`s')*(1-(index_day/30.4)) if sum_n`i'_b4yr!=.
	local --s
	}
	


}
keep if n1_flag | n2_flag | n3_flag | n4_flag | n5_flag


gsort +id +year


forvalues i=1/5 {

gen tot_paid_maid_n`i' = sum_n`i'_cyr + sum_n`i'_b4yr[_n-1]
}

keep id index_date bid_hrs_23 index_year year n*_flag tot_paid_maid_n* 
save mc_costs_`t'.dta, replace

restore

}


H="Calculate SNF/HH Medicaid cost+days "
use "E:\data\burden_dementia\int_data\medicaid_cost_hh_snf.dta", clear


/* inflation adjustment */

gen rate = .

replace rate=1 if year==2012
replace rate=1.03902 if year==2011
replace rate=1.07086 if year==2010
replace rate=1.10835 if year==2009
replace rate=1.1439 if year==2008
replace rate=1.1923 if year==2007
replace rate=1.25586 if year==2006
replace rate=1.30783 if year==2005
replace rate=1.37027 if year==2004
replace rate=1.43908 if year==2003
replace rate=1.50337 if year==2002
replace rate=1.57963 if year==2001
replace rate=1.65519 if year==2000
replace rate=1.72641 if year<=1999

gen cost = 0
replace cost = 1 if (_name_=="hh_cost_maid" | _name_=="nf_cost_maid" | _name_=="tot_paid_maid")

forvalues p = 1/12 {

replace _`p' = _`p'*rate if cost==1
}


/*Flag year markers, n1=[0,-12], n2=[-12,-24], n3=[-24,-36], etc. */

gen n1_flag = 0
replace n1_flag = 1 if (index_year==year) | (year==index_year-1)

gen n2_flag = 0
replace n2_flag = 1 if (year==index_year-1) | (year==index_year-2)

gen n3_flag = 0
replace n3_flag = 1 if (year==index_year-2) | (year==index_year-3)

gen n4_flag = 0
replace n4_flag = 1 if (year==index_year-3) | (year==index_year-4)

gen n5_flag = 0
replace n5_flag = 1 if (year==index_year-4) | (year==index_year-5)

gen index_day = day(index_date)



save "E:\data\burden_dementia\int_data\medicaid_cost_inflation.dta", replace

cd "E:\data\burden_dementia\int_data"

levelsof _name_, local(namevars)
return list

foreach x of local namevars {
use "E:\data\burden_dementia\int_data\medicaid_cost_inflation.dta", clear
keep if _name_=="`x'"



forvalues t=1/12 {
preserve
keep if index_month==`t'

forvalues i=1/5 {

gen sum_n`i'_cyr= 0 if n`i'_flag==1 /*sum months before index month in current year*/

local j = index_month
local k = 1


	while `k' <= `j' { // while current month less than or equal index, add to past value
		while `k' < `j' {
			replace sum_n`i'_cyr = sum_n`i'_cyr + _`k' if sum_n`i'_cyr!=.
			local ++k
		}
	    replace sum_n`i'_cyr = sum_n`i'_cyr + (_`k')*(index_day/30.4) if sum_n`i'_cyr!=. // if current month = index, then prorate it
		local ++k
}

gen sum_n`i'_b4yr = 0 if n`i'_flag==1

local r = index_month
local s = 12
	while `s' >=`r' { // count backwards to get months before index in previous year
		while `s' > `r' {
		replace sum_n`i'_b4yr = sum_n`i'_b4yr + _`s' if sum_n`i'_b4yr!=.
		local --s
	}
	
	replace sum_n`i'_b4yr = sum_n`i'_b4yr + (_`s')*(1-(index_day/30.4)) if sum_n`i'_b4yr!=.
	local --s
	}
	


}
keep if n1_flag | n2_flag | n3_flag | n4_flag | n5_flag


gsort +id +year


forvalues i=1/5 {

gen tot_`x'_n`i' = sum_n`i'_cyr + sum_n`i'_b4yr[_n-1]
}

*keep id index_date bid_hrs_23 index_year year n*_flag tot_`x'_n* 
sort id year
by id: carryforward tot_*, replace
by id: keep if _n==_N
keep id index_date bid_hrs_23 tot_`x'_n* 
save mc_`x'_`t'.dta, replace

restore

}

}

foreach x of local namevars {

	use mc_`x'_1.dta, clear
	
	forvalues i = 2/12 {
		
		append using mc_`x'_`i'.dta
		save tot_`x'.dta, replace
		}
		}

foreach x of local namevars {

use tot_paid_maid.dta, clear
cap drop _m 
merge 1:1 id using "E:\data\burden_dementia\int_data\tot_`x'.dta", keepus(tot_`x'_n1 tot_`x'_n2 tot_`x'_n3 tot_`x'_n4 tot_`x'_n5)
save tot_paid_maid.dta, replace
}

label var tot_paid_maid_n1 "Total Medicaid Spending N1"
label var tot_paid_maid_n2 "Total Medicaid Spending N2"
label var tot_paid_maid_n3 "Total Medicaid Spending N3"
label var tot_paid_maid_n4 "Total Medicaid Spending N4"
label var tot_paid_maid_n5 "Total Medicaid Spending N5"

label var tot_hh_cost_maid_n1 "Total HH (FFS) Medicaid Spending N1"
label var tot_hh_cost_maid_n2 "Total HH (FFS) Medicaid Spending N2"
label var tot_hh_cost_maid_n3 "Total HH (FFS) Medicaid Spending N3"
label var tot_hh_cost_maid_n4 "Total HH (FFS) Medicaid Spending N4"
label var tot_hh_cost_maid_n5 "Total HH (FFS) Medicaid Spending N5"

label var tot_hh_days_maid_n1 "Total HH Medicaid Days N1"
label var tot_hh_days_maid_n2 "Total HH Medicaid Days N2"
label var tot_hh_days_maid_n3 "Total HH Medicaid Days N3"
label var tot_hh_days_maid_n4 "Total HH Medicaid Days N4"
label var tot_hh_days_maid_n5 "Total HH Medicaid Days N5"

label var tot_hh_ffs_days_maid_n1 "Total HH (FFS) Medicaid Days N1"
label var tot_hh_ffs_days_maid_n2 "Total HH (FFS) Medicaid Days N2"
label var tot_hh_ffs_days_maid_n3 "Total HH (FFS) Medicaid Days N3"
label var tot_hh_ffs_days_maid_n4 "Total HH (FFS) Medicaid Days N4"
label var tot_hh_ffs_days_maid_n5 "Total HH (FFS) Medicaid Days N5"

label var tot_nf_cost_maid_n1 "Total SNF (FFS) Medicaid Spending N1"
label var tot_nf_cost_maid_n2 "Total SNF (FFS) Medicaid Spending N2"
label var tot_nf_cost_maid_n3 "Total SNF (FFS) Medicaid Spending N3"
label var tot_nf_cost_maid_n4 "Total SNF (FFS) Medicaid Spending N4"
label var tot_nf_cost_maid_n5 "Total SNF (FFS) Medicaid Spending N5"

label var tot_nf_days_maid_n1 "Total SNF Medicaid Days N1"
label var tot_nf_days_maid_n2 "Total SNF Medicaid Days N2"
label var tot_nf_days_maid_n3 "Total SNF Medicaid Days N3"
label var tot_nf_days_maid_n4 "Total SNF Medicaid Days N4"
label var tot_nf_days_maid_n5 "Total SNF Medicaid Days N5"

label var tot_nf_ffs_days_maid_n1 "Total SNF (FFS) Medicaid Days N1"
label var tot_nf_ffs_days_maid_n2 "Total SNF (FFS) Medicaid Days N2"
label var tot_nf_ffs_days_maid_n3 "Total SNF (FFS) Medicaid Days N3"
label var tot_nf_ffs_days_maid_n4 "Total SNF (FFS) Medicaid Days N4"
label var tot_nf_ffs_days_maid_n5 "Total SNF (FFS) Medicaid Days N5"

cd "E:\projects\burden_dementia\archive logs"

forvalues i = 1/5 {

twoway scatter tot_nf_cost_maid_n`i' tot_nf_ffs_days_maid_n`i'
graph export SNF_n`i'.pdf, as(pdf)

twoway scatter tot_hh_cost_maid_n`i' tot_hh_ffs_days_maid_n`i'
graph export HH_n`i'.pdf, as(pdf)
}


local cost tot_paid_maid_n1 tot_paid_maid_n2 tot_paid_maid_n3 tot_paid_maid_n4 tot_paid_maid_n5 tot_hh_cost_maid_n1 tot_hh_cost_maid_n2 tot_hh_cost_maid_n3 tot_hh_cost_maid_n4 tot_hh_cost_maid_n5 tot_nf_cost_maid_n1 tot_nf_cost_maid_n2 tot_nf_cost_maid_n3 tot_nf_cost_maid_n4 tot_nf_cost_maid_n5
local days tot_hh_days_maid_n1 tot_hh_days_maid_n2 tot_hh_days_maid_n3 tot_hh_days_maid_n4 tot_hh_days_maid_n5 tot_nf_days_maid_n1 tot_nf_days_maid_n2 tot_nf_days_maid_n3 tot_nf_days_maid_n4 tot_nf_days_maid_n5 tot_hh_ffs_days_maid_n1 tot_hh_ffs_days_maid_n2 tot_hh_ffs_days_maid_n3 tot_hh_ffs_days_maid_n4 tot_hh_ffs_days_maid_n5 tot_nf_ffs_days_maid_n1 tot_nf_ffs_days_maid_n2 tot_nf_ffs_days_maid_n3 tot_nf_ffs_days_maid_n4 tot_nf_ffs_days_maid_n5
local full `cost' `days'

local rd: word count `full' 1

di `rd'

mat tab1= J(`rd',9,.)
local r = 1

foreach x of local full {

sum `x'
mat tab1[`r',1] = r(mean)
sum `x' if `x'>0, d
mat tab1[`r',2]= r(mean)
mat tab1[`r',3] = r(min)
mat tab1[`r',4]= r(p25)
mat tab1[`r',5] = r(p50)
mat tab1[`r',6]= r(p75)
mat tab1[`r',7] = r(p99)
mat tab1[`r',8] = r(max)

cap drop zero
gen zero = .
replace zero = 1 if `x'==0
sum zero, d
mat tab1[`r',9]= r(N)
local ++r

}

sum `x'
mat tab1[`r',9] = 618
mat list tab1

mat rownames tab1 = `full' N

frmttable using "E:\projects\burden_dementia\archive logs\MAX_summary.doc", replace statmat(tab1) landscape a4 ///
varlabels title("MAX Summary Statistics For R01") ctitles("Variables" "Ave." "Ave (non-zero)" "Minimum" "25th percentile" "Median" "75th percentile" "99th percentile" "Maximum" "# of zero's") sdec(2) ///
note("Costs have been pro-rated and inflation adjusted to 2012 dollars. The Percentiles exclude zeros")



H="Creating Medicaid files for 1-5 years prior to index"
libname clean 'E:\data\hrs_cleaned'; 
libname medi 'E:\data\CMS_DUA_51675_2014\Medicaid_merged';
libname dmouth 'E:\data\Dartmouth_misc';

/*rand data path*/
libname rand 'E:\data\hrs_public_2012\rand2012\main';

libname proj_int 'E:\data\burden_dementia\int_data';
libname proj_fin 'E:\data\burden_dementia\final_data';
libname proj_ref 'E:\data\burden_dementia\ref_data';



data hrs_max_1;
set proj_int.hrs_max_ip_meet_60m;
diff=index_date-bdos;
run;

data hrs_max_2;
set proj_int.hrs_max_lt_meet_60m;
diff=index_date-bdos;
run;

data hrs_max_3;
set proj_int.hrs_max_ot_meet_60m;
diff=index_date-bdos;
run;

data hrs_max_4;
set proj_int.hrs_max_rx_meet_60m;
diff=index_date-pfd;
bdos=pfd;
run;

%macro plus;
%do i=1 %to 4;

data a1yr&i.;
set hrs_max_&i.;
	where diff>0 and diff<365;
run;

data a2yr&i.;
set hrs_max_&i.;
	where diff>365 and diff<730;
run;

data a3yr&i.;
set hrs_max_&i.;
	where diff>730 and diff<1095;
run;

data a4yr&i.;
set hrs_max_&i.;
	where diff>1095 and diff<1460;
run;

data a5yr&i.;
set hrs_max_&i.;
	where diff>1460 and diff<1825;
run;



proc sort data= a1yr&i.; 
by bid_hrs_23 bdos;
run;

proc sort data= a2yr&i.; 
by bid_hrs_23 bdos;
run;

proc sort data= a3yr&i.; 
by bid_hrs_23 bdos;
run;

proc sort data= a4yr&i.; 
by bid_hrs_23 bdos;
run;

proc sort data= a5yr&i.; 
by bid_hrs_23 bdos;
run;


/*Creating a flag for the first observation and last observation in that year prior to index*/

data a1yr&i.;
set a1yr&i.; 
by bid_hrs_23;
	 first= first.bid_hrs_23;
	 last= last.bid_hrs_23;
run;

data a2yr&i.;
set a2yr&i.; 
by bid_hrs_23;
	 first= first.bid_hrs_23;
	 last= last.bid_hrs_23;
run;

data a3yr&i.;
set a3yr&i.; 
by bid_hrs_23;
	 first= first.bid_hrs_23;
	 last= last.bid_hrs_23;
run;

data a4yr&i.;
set a4yr&i.; 
by bid_hrs_23;
	 first= first.bid_hrs_23;
	 last= last.bid_hrs_23;
run;

data a5yr&i.;
set a5yr&i.; 
by bid_hrs_23;
	 first= first.bid_hrs_23;
	 last= last.bid_hrs_23;
run;


/* keeping the first and last observation in that year prior to index*/

data only_a1yr&i.;
set a1yr&i.;
	where first=1 or last=1;
run;

data only_a2yr&i.;
set a2yr&i.;
	where first=1 or last=1;
run;

data only_a3yr&i.;
set a3yr&i.;
	where first=1 or last=1;
run;

data only_a4yr&i.;
set a4yr&i.;
	where first=1 or last=1;
run;

data only_a5yr&i.;
set a5yr&i.;
	where first=1 or last=1;
run;

%end;

%mend;
%plus();





%macro plus;
%do i=1 %to 5;

data proj_int.ip_yrbk&i.; 
set only_a&i.yr1;
run;

data proj_int.lt_yrbk&i.; 
set only_a&i.yr2;
run;

data proj_int.ot_yrbk&i.; 
set only_a&i.yr3;
run;

data proj_int.rx_yrbk&i.; 
set only_a&i.yr4;
run;

%end;

%mend;
%plus();



H="Informal Caregiving Costs"
clear all
capture log close

//burden dementia data has the number of hours prorated. 
use "E:\data\burden_dementia\final_data\burden_dementia_sample_long.dta" , replace
 
sort id index_date
by id: carryforward index_date, replace

//formatting days to be in terms of index year instead of calendar year. 
format index_date %td
gen year_index= year(index_date)
gen day_index=day(index_date)
gen mon_index=month(index_date)
gen year_bef=year_index-yearfromdeath
gen date_bef=mdy(mon_index, day_index, year_bef) 
format date_bef %td

gen year_bef1=year_bef-1

gen beg_day=31
gen beg_mon=12
gen beg_date=mdy(beg_mon, beg_day, year_bef1) 
format beg_date %td

//getting the proportion of days in each calendar year, they were indexed for. 

gen leap_year=1 if inlist(year_bef, 2000,2004,2008,2012) 
gen leap_year1=1 if inlist(year_bef1, 1999,2003,2007,2011) 
gen leap_mon=1 if inlist(mon_index, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12)
gen leap_mon1=1 if inlist(mon_index, 1, 2)

gen leap=1 if leap_mon==1 & leap_year==1

gen leap1=1 if leap_mon1==1 & leap_year1==1

gen days= date_bef-beg_date
gen proportion=days/365 //if inlist(year_bef, 1998,1999,2001,2002,2003,2005,2006,2007,2009,2010,2011,2013,2014,2015) 
replace proportion=days/366 if /*inlist(year_bef, 2000,2004,2008,2012) &*/ leap==1

gen date_1_bef=mdy(mon_index, day_index, year_bef1)
format date_1_bef %td

gen days1=beg_date-date_1_bef
capture drop proportion1
gen proportion1=days1/365 //if inlist(year_bef1, 1998,1999,2001,2002,2003,2005,2006,2007,2009,2010,2011,2013,2014,2015) 
replace proportion1=days1/366 if /*inlist(year_bef1, 2000,2004,2008,2012) &*/ leap1==1

rename year_bef year

drop if index_date==.

tempfile index
save "`index'"

// merging together with the state information for each person
use "E:\data\hrs_cleaned\restricted_tracker_v2012.dta", replace

keep hhid pn stateusps*

gen stateusps97=""
gen stateusps99=""

forvalues i= 1(2)11{
gen stateusps`i'=""
}

forvalues i=0(2)8{
rename stateusps0`i' stateusps`i'
}
reshape long stateusps, i(hhid pn) j(year)

forvalues i=0/99{
qui replace year=200`i' if year==`i' & year<=9
qui replace year=20`i' if year==`i' & inrange(year, 10,12)
qui replace year=19`i' if year==`i' & year>=90
}

gen id= hhid+pn
sort id year
drop if id==""
by id: carryforward stateusps, replace

gsort id -year
by id: carryforward stateusps, replace

tempfile state
save "`state'"


use "`index'", replace

merge 1:1 id year using "`state'"
keep if _merge==3
drop hhid pn _merge

tempfile full
save "`full'"

//merging with the Genworth/Metlife hourly home health aide cost. 
import excel "E:\data\Cost Care Survey (Genworth-Metlife)\HHA_hourly_genworth.xlsx", sheet("Sheet1") firstrow clear

rename A year
rename B stateusps
rename HomeHealthAideServicesHourly state_hha
rename MedianHourlyRate hr_rate

drop if year==.
destring hr_rate, replace


tempfile rate
save "`rate'"

use "`full'", replace
merge m:1 year stateusps using "`rate'"
//Don't have full data on home health aide hourly rates. 
drop if id==""

//creating total cost of informal care within the index year( which spans between calendar years).
capture drop a
gen a=proportion*hlphrs_i*hr_rate

rename year year1
rename year_bef1 year
rename _merge merge1
rename hr_rate hr_rate1

merge m:1 year stateusps using "`rate'"

capture drop b
gen b= proportion1*hlphrs_i*hr_rate

// C represents the total cost of informal caregiving prorated to a year prior to the index. 
capture drop c
gen c=a+b

///need to fix names of vars
rename year year_bef1
label var year_bef1 "Year prior to index"
rename year1 year
label var year "Year of index"

rename c total

mat sum =J(6,7,.)
local r=1
foreach x in total hlphrs_i{
local c=1
forvalues i=0/6{
sum `x' if yearfromdeath==`i'
mat sum[`r',`c']=r(mean)
mat sum[`r'+1,`c']=r(min)
mat sum[`r'+2,`c']=r(max)
local c=`c'+1
}
local r=`r'+3
}



matrix colnames sum= "0" "1" "2" "3" "4" "5" "6"
/*"1999" "2000" "2001" "2002" "2003" "2004" "2005" "2006" "2007" ///
"2008" "2009" "2010" "2011" "2012" */

matrix rownames sum= "Mean Cost" "Min Cost" "Max Cost" "Mean Hours" "Min Hours" "Max Hours"

mat list sum 


frmttable using "E:\data\burden_dementia\logs\cost_hours.doc", statmat(sum) replace ///
title(Cost and Hours by Year from Death) sdec(2) note("Each column is a year from death")


H="xxxxxpractice snf medpar contact days hrsxxxx"
/*Finding Nursing home days*/


use "E:\data\CMS_DUA_51675_2014\Merged\Stata\mp_1998_2012.dta", clear
keep bid_hrs_21 sslssnf *date



keep if sslssnf=="N"
gen duration=disch_date - admit_date +1
expand duration
bysort bid_hrs_21 admit_date: gen date=admit_date +_n-1
format date %td

gen medpar_day=1


merge m:1 bid_hrs_21 using "E:\data\cms_DUA_24548_2012\cmsxref2012.dta", nogen
tempfile a
duplicates tag hhid pn date, gen(tag)

duplicates drop hhid pn date, force
save "`a'"

use "E:\data\CMS_DUA_51675_2014\Medicaid_merged\hrs_max_lt_99_12.dta", clear
keep nursing_facility_days beginning_date_of_service ending_date_of_service ///
bid_hrs_23 

capture drop if nursing_facility_days<=0

tostring beginning_date_of_service, replace
tostring ending_date_of_service, replace
gen beg_date=date(beginning_date_of_service,"YMD")
gen end_date=date(ending_date_of_service,"YMD")
format beg_date %d
format end_date %d

duplicates drop bid_hrs_23 beg_date end_date, force
sort bid_hrs_23 beg_date end_date
by bid_hrs_23 beg_date: gen a=1 if beg_date==beg_date[_n+1]
drop if a==1

gen duration=end_date - beg_date +1
sort bid_hrs_23 beg_date
expand duration
sort bid_hrs_23 beg_date
bysort bid_hrs_23 beg_date: gen date=beg_date +_n-1
format date %td
duplicates tag bid_hrs_23 date, gen(tag)
sort bid_hrs_23 date beg_date end_date
duplicates drop bid_hrs_23 date, force

gen ltc_day=1

merge m:1 bid_hrs_23 using "E:\data\CMS_DUA_51675_2014\Medicaid_merged\MedicaidXref2012_old.dta", nogen 
duplicates report hhid pn date

//duplicates tag hhid pn date, gen(tag)


merge 1:1 hhid pn date using "`a'", force
capture drop day
egen day= rowtotal(medpar_day ltc_day)

gen both=1 if day==2
replace day=1 if day==2

saveold "E:\data\test\mp_ltc_contact_days.dta", version(12)


/*SAS SECTION

libname mpltc 'E:\data\test\';

proc import out=work.day
		datafile  = "E:\data\test\mp_ltc_contact_days.dta" replace;
run;


proc import out=work.hrs
datafile='E:\data\test\oopme_final_xref_core_2014.dta'
dbms=DTA replace;
run;


proc sort data=hrs out=hrs nodupkey;
by hhidpn c_ivw_date;
run;

data hrs1;
set hrs;
by hhidpn;
c_ivw_date_pre=lag(c_ivw_date);
if first.hhidpn then do;
	c_ivw_date_pre=c_ivw_date-731;
end;
format c_ivw_date_pre yymmddn8.;
bet_days=c_ivw_date-c_ivw_date_pre;
run;

data hrs1;
set hrs1;
keep c_ivw_date c_ivw_date_pre nh_nights bet_days hhid hhidpn pn c_ivw_year;
run;

proc sql;
create table hrs_day as select * from
day a inner join 
hrs1 b
on a.hhidpn=b.hhidpn and b.c_ivw_date>=a.date>b.c_ivw_date_pre;
run;

proc export data=hrs_day outfile="E:\data\test\hrs_day.dta" replace; run;

*/





////////////////HRS
 
use "E:\data\test\hrs_day.dta", clear

gen too_big=1 if nh_nights>bet_days & nh_nights!=.

replace nh_nights=bet_days if too_big==1

bys hhidpn c_ivw_year: egen mm_days=total(day)
bys hhidpn c_ivw_year: egen medpar_tot=total(medpar_day)
bys hhidpn c_ivw_year: egen ltc_tot=total(ltc_day)

bys hhidpn c_ivw_year: keep if _n==1


capture drop diff
gen diff=nh_nights-mm_days

sum diff,d






H="xxxattempt to bring days into R01xxx"
/*First, get index dates (death or ivw and previous ivw or 5 year cutoff*/

use id index_date cont_ffs_n bid using "E:\data\burden_dementia\int_data\decedent_dataset.dta", clear
merge 1:1 id using "E:\data\CMS_DUA_51675_2014\Medicaid_merged\MedicaidXref2012_old.dta", nogen ///
keepusing(bid_hrs_23)
gen ffs_yrs=floor(cont_ffs_n_mos/12)
keep if ffs_y>=5 & !missing(ffs_y)
tempfile index
save `index'


use "E:\data\hrs_cleaned\exit_02_to_14_dt.dta" if !missing(e_ivw_date)

merge 1:1 id using `index', nogen keep(match)
//set time=0 so it can be appended to the core
gen t2=0
drop if e_ivw_date<index_date
gen exit=1
rename e_ivw_date ivw_date
rename exit_year year
keep id index_date year exit ivw_date medigap medicaid nhres bid*
tempfile exit
save `exit'


use "E:\data\burden_dementia\oopdata\oopme_final_2014.dta", clear
rename *, l
gen id=hhid+pn
keep id year nh_nights nh_oop

tempfile oop
save `oop'


use `index', clear
merge 1:m id using "E:\data\hrs_cleaned\core_00_to_14.dta", nogen ///
keep(match) keepusing(c_ivw_date core_year medigap champus medicaid)
rename core_year year
rename c_ivw_date ivw_date
tempfile core
save `core' 

use `exit', clear
append using `core'
sort id year
by id: gen ivw_date_n1=ivw_date[_n-1]
replace ivw_date=index_date if exit==1
gen timetodeath=index_date-ivw_date
by id: egen mintime=min(timeto)
drop if mintime<0
keep if timeto<=5*365.25
keep id bid* ivw_date ivw_date_n1 index_date timeto year
merge 1:1 id year using `oop', gen(oopm) keep(match master) keepusing(nh_nights)
/*drop one who died on previous ivw date*/
sort id ivw_date 
duplicates drop id ivw_date, force
tempfile dates
save `dates'


use "E:\data\CMS_DUA_51675_2014\Merged\Stata\mp_1998_2012.dta" if ssls=="N", clear
keep bid_hrs_21 admit_date disch_date
duplicates drop
tempfile snf
save `snf'

use "E:\data\CMS_DUA_51675_2014\Medicaid_merged\hrs_max_lt_99_12.dta", clear
keep nursing_facility_days beginning_date_of_service ending_date_of_service ///
bid_hrs_23 

drop if nursing_facility_days<=0
tostring *date*, replace
gen admit_date=date(beg,"YMD")
gen disch_date=date(end,"YMD")

keep admit disch bid
tempfile ltc
save `ltc'

/*now get individual days*/

local i=1
foreach type in snf ltc {
	use `dates', clear
	joinby bid_hrs_2`i' using ``type''
	replace ivw_date_n1=index_date-floor(5*365.25) ///
	 if ivw_date_n1<index_date-floor(5*365.25) | missing(ivw_date_n1)
	keep if inrange(admit_date,ivw_date_n1+1,ivw_date) | ///
	inrange(disch_date,ivw_date_n1,ivw_date) | (admit_date<=ivw_date_n1 & disch_date>ivw_date)
	replace admit_date=ivw_date_n1+1 if admit_date<=ivw_date_n1
	replace disch_date=ivw_date if disch_date>ivw_date
	gen duration=disch_date - admit_date +1
	expand duration
	sort bid_hrs_2`i' admit_date disch_date
	by bid_hrs_2`i' admit_date: gen n=_n
	gen date=admit_date +(n-1)
	format date %td
	gen `type'_day=1
	keep id ivw_date date `type'_day
	duplicates drop
	tempfile `type'days
	save ``type'days'
	local i=3
}

use `snfdays', clear
append using `ltcdays'
merge m:1 id ivw_date using `dates'
replace snf_day=0 if missing(snf_day)
replace ltc_day=0 if missing(ltc_day)
by id ivw_date date, sort: egen ind_snf_day=max(snf_day)
by id ivw_date date: egen ind_ltc_day=max(ltc_day)
drop snf_day ltc_day
duplicates drop



H="XXXXXXXXXXXXXXXXXX"
use id death_date using "E:\data\burden_dementia\final_data\R01_final.dta", replace
format %td death_date
duplicates drop 

merge 1:1 id using "E:\data\hrs_cleaned\exit_02_to_14_dt.dta", keep(match master) ///
keepusing(nh_nights exit_year ltc_ins nhres)  gen(xm)
rename nh_ nh_nights_x
rename ltc_ins ltc_ins_x
rename nhres nhres_x

duplicates report 

merge 1:m id using "E:\data\hrs_cleaned\core_00_to_12.dta", keep(match master) gen(cm)
sort id core_year

by id: keep if _n==_N

gen ivw_time=death_date-c_ivw_date
drop if ivw_time<0
replace nh_nights_x=ivw_time if nh_nights_x>ivw_time
//>=730

rename hhidpn hh
rename id hhidpn

merge 1:1 hhid pn core_year using "E:\data\hrs_cleaned\working\core_98_14_clean_final.dta", keepusing(ltc_ins) keep(master matched)

gen year= exit_year
gen HHID=hhid
gen PN=pn
merge 1:1 HHID PN year using "E:\data\burden_dementia\oopdata\oopme_final_2014.dta" , keepusing(NH_OOP) keep(master matched) nogen

merge 1:m hhidpn using "E:\data\test\mp_ltc_contact_days.dta", gen(p)


//replace nh_nights_x=730 if nh_nights_x==770

drop if p==2

keep if inrange(date, c_ivw_date, death_date) | day==0
sort hhidpn

gen range=1 if death_date>=date & date>c_ivw_date & date!=.

codebook hhidpn

bys hhidpn core_year: egen mm_days=total(day) if range==1,m
bys hhidpn core_year: egen medpar_tot=total(medpar_day) if range==1,m
bys hhidpn core_year: egen ltc_tot=total(ltc_day) if range==1,m

bys hhidpn core_year: keep if _n==1

//replace nh_nights_x=. if nh_nights_x==0
//replace mm_days=. if mm_days==0

merge 1:1 hhidpn using "E:\data\CMS_DUA_51675_2014\Medicare Xref2015\CMSxref20151\stata\xref2015medicare.dta", nogen keep(master matched) force
rename BID_HRS_22 bid_hrs_22
capture drop year
gen year=exit_year

rename medicaid sr_medicaid

drop if bid_hrs_22==""

tempfile a
save "`a'"

use "E:\data\CMS_DUA_51675_2014\Merged\Stata\basf_1998_2015.dta", replace
gen year=year(start_dt)
gen medicaid=0
replace medicaid=1 if buyin_mo>=1 & buyin_mo!=.

sort bid_hrs_22 year
gen medicaid_p=0
by bid_hrs_22: replace medicaid_p=1 if medicaid==1 | medicaid[_n-1]==1 
//by bid_hrs_22: replace medicaid_p=2 if medicaid==1 & medicaid[_n-1]==1 

label var medicaid "Medicaid from Medicare claims"
label var medicaid_p "Medicaid from claims previous year"

sort bid_hrs_22 year
by bid_hrs_22: keep if _n==_N 


tempfile b
save "`b'"

use "`a'", replace

merge 1:1 bid_hrs_22 using "`b'", nogen keep(master match) keepusing(medicaid medicaid_p)


capture drop diff
gen diff=nh_nights_x-mm_days

replace ltc_ins_x=. if ltc_ins_x==8

gen mcaid=0
replace mcaid=1 if ltc_tot>=1 & ltc_tot!=.
label var mcaid "Medicaid from Medicaid Claims"

//nh_nights_x is not missing for any observations
//ltc_ins_x can be missing
//

gen nh_nights_f=0
replace nh_nights_f=1 if nh_nights_x!=0
gen mm_days_f=0 
replace mm_days_f=1 if mm_days!=.
gen both_f=0
replace both=1 if nh_nights_f==1 & mm_days_f==1


gen nh_oop=NH_OOP if NH_OOP!=0 & NH_OOP!=.
gen nh_oop_f=0 
replace nh_oop_f=1 if nh_oop!=0 & nh_oop!=.


sum nh_nights_x if nh_oop_f==1
sum mm_days if nh_oop_f==1

sum nh_oop if ltc_ins_x==0



label var mm_days "Claim Nights"
label var nh_nights_x "NH Nights from exit" 
label var diff "Difference"
label var ltc_ins_x "LTC insurance at exit"
la def lt 0 "No LTC Ins." 1 "LTC Ins."
la val ltc_ins_x lt
la def nhres_x 0 "Not NHRES" 1 "NHRES"
la val nhres_x nhres_x



sum diff,d
sum diff if ltc_ins_x==0 & nhres_x==0,d
local a=`r(N)'
sum diff if ltc_ins_x==1 & nhres_x==0,d 
local b=`r(N)'
sum diff if ltc_ins_x==0 & nhres_x==1,d 
local c=`r(N)'
sum diff if ltc_ins_x==1 & nhres_x==1,d 
local d=`r(N)'


count if !missing(nh_nights_x) & !missing(mm_days) & !missing(ltc_ins_x)
local N=`r(N)'

graph bar (mean) diff diff if nh_nights_x!=. & mm_days!=., over(ltc_ins_x) over(nhres_x) note("`N' Non-missing/non-zero HRS Nursing Home Nights & Medicare/Medicaid Nights" ///
"`a' Not a NHRES and No SR LTC Ins." "`b' Not a NHRES with SR LTC Ins." ///
"`c' NHRES and No SR LTC Ins." "`d' NHRES and SR LTC Ins.") ///
blabel(bar) ytitle(mean `:variable label diff') title("Diff. between SR HRS and Medicaid/Medicare Nights" " by LTC Ins. and NHRES from death to last core ivw.")

//graph save "E:\projects\burden_dementia\archive logs\20181217\difference", replace
//graph export "E:\projects\burden_dementia\archive logs\20181217\difference.pdf", replace

graph bar (mean) nh_nights_x mm_days if nh_nights_x!=. & mm_days!=., over(ltc_ins_x) over(nhres_x) blabel(bar) ///
note("SR HRS and Medicare/Medicare NH Nights by LTC Ins.") ytitle(Mean # of Nights) ///
title("Mean Nights by LTC Ins. for SR HRS and Claims" "by LTC Ins. and NHRES") legend(label(2 "Claim Nights") label(1 "SR NH Nights from exit" ))

//graph save "E:\projects\burden_dementia\archive logs\20181217\mean_nights", replace
//graph export "E:\projects\burden_dementia\archive logs\20181217\mean_nights.pdf", replace

graph bar (count) nh_nights_f mm_days_f both_f, over(ltc_ins_x) over(nhres_x) blabel(bar) ///
title("Count of having NH Nights in SR HRS, Claims, & Both" "by LTC Ins. and NHRES") ytitle(# of people) ///
legend(label(1 "SR NH Nights from exit") ///
label(2 "Claim Nights") label(3 "Both"))

//graph save "E:\projects\burden_dementia\archive logs\20181217\count", replace
//graph export "E:\projects\burden_dementia\archive logs\20181217\count.pdf", replace

tab ltc_ins_x medicaid_p


tab nh_oop_f nhres_x
tab nh_oop_f ltc_ins_x

tab nh_oop_f nh_nights_f,m
sum NH_OOP if nhres_x==1 & nh_oop_f==1, d

pctile nh_oop_q= NH_OOP, n(4)


// need to first find state var
//then make sure genworth data is showing nh rates costs
//then merge in to the exit year--will need to change variable
//then convert sr oop nh to nights 
// then find the unattributed section


tempfile a 
save "`a'"

use "E:\data\hrs_restricted_2014\hrsxgeo1_3.dta", replace 

rename stateusps0* stateusps*
rename zipcode0* zipcode*

reshape long zipcode stateusps, i(id) j(year)

forvalues i=90/99{
replace year=19`i' if year==`i'
}

forvalues i=0/9{
replace year=200`i' if year==`i'
}

forvalues i=10/16{
replace year=20`i' if year==`i'
}

sort id year

//assumption
by id: carryforward stateusps, gen(state)

rename id hhidpn 
rename year exit_year

merge 1:1 hhid exit_year using "`a'", nogen keep(using match)

tempfile b
save "`b'"

import excel "E:\data\burden_dementia\ref_data\Cost Care Survey (Genworth-Metlife)\HHA_hourly_genworth.xlsx" ///
, sheet("Sheet5") firstrow case(lower) clear

drop if year==.
rename mediandailyratenursinghomed nh_daily
rename year exit_year 
merge 1:m exit_year state using "`b'", nogen keep(using matched)

destring nh_daily, replace
gen nh_oop_nights=NH_OOP/nh_daily
gen nh_oop_big_flag=1 if nh_oop_nights>ivw_time

replace nh_oop_nights=ivw_time if nh_oop_nights>ivw_time
replace nh_oop_nights=round(nh_oop_nights)


replace mm_days=0 if mm_days==.
replace nh_nights_x=0 if nh_nights_x==.

gen unatt=nh_nights_x-nh_oop_nights-mm_days
/*
//just to see comparing nh_nights_x with ivw_time
gen comp=ivw_time-nh_oop_nights-mm_days

sum unatt if sr_medicaid==0, d
// N-3023 Mean-78 Med-0
sum unatt if sr_medicaid==1, d
//N-830 Mean- 70 Med-0
sum unatt if medicaid==0, d
// N-3019 Mean-77 Med-0
sum unatt if medicaid==1, d
// N-919 Mean-78 Med-0

tab medicaid sr_medicaid, m

tab ltc_ins_x sr_medicaid, m

tab ltc_ins_x medicaid,m

sum unatt if ltc_ins_x==0,d
//3424 mean-75
sum unatt if ltc_ins_x==1,d
//363 mean-104

sum unatt if sr_medicaid==0 & ltc_ins_x==0, d
// N-2583 Mean-74 Med-0
sum unatt if sr_medicaid==1 & ltc_ins_x==0, d
//N-766 Mean- 75 Med-0
sum unatt if medicaid==0 & ltc_ins_x==0, d
// N-2567 Mean-72 Med-0
sum unatt if medicaid==1 & ltc_ins_x==0, d
// N-854 Mean-83 Med-0
*/
//frequency of people who have reported nh_days and then how many people have unatt nights

gen mcaid_final=0
replace mcaid_final=1 if medicaid==1 | mcaid==1

sum nh_nights_f, d

sum mm_days_f, d

la def nh_nights_f 0 "No NH Nights" 1 "Yes NH Nights"
la val nh_nights_f nh_nights_f

la def mm_days_f 0 "No Claims" 1 "Yes Claims"
la val mm_days_f mm_days_f
la def medicaid 0 "No Medicaid" 1 "Yes Medicaid"
la val medicaid medicaid
la def mcaid_final 0 "No Medicaid" 1 "Yes Medicaid"
la val mcaid_final mcaid_final
la def ltc_ins_x 0 "No LTC Ins." 1 "Yes LTC Ins. "
la val ltc_ins_x ltc_ins_x
la def nh_oop_f 0 "No NH OOP" 1 "Yes NH OOP"
la val nh_oop_f nh_oop_f
la def sr_medicaid 0 "No SR Medicaid" 1 "Yes SR Medicaid"
la val sr_medicaid sr_medicaid

count if !missing(nh_nights_f)
local N `r(N)'
graph bar, over(nh_nights_f) blabel(bar) title(Reported NH Nights (N =`N'))
graph save "E:\data\burden_dementia\logs\nh_nights_flag", replace
graph export "E:\data\burden_dementia\logs\nh_nights_flag.pdf", replace

count if !missing(mm_days_f)
local N `r(N)'
graph bar, over(mm_days_f) blabel(bar)  title(Reported Medicare/Medicaid Nights (N =`N'))
graph save "E:\data\burden_dementia\logs\mm_days_flag", replace
graph export "E:\data\burden_dementia\logs\mm_days_flag.pdf", replace

count if !missing(mm_days_f) & !missing(nh_nights_f)
local N `r(N)'
catplot mm_days_f nh_nights_f ,percent recast(bar) title("SR NH Nights flag vs Medicare/Medicaid Nights flag" "(N =`N')") blabel(total)
graph save "E:\data\burden_dementia\logs\mm_days_nh_nights", replace
graph export "E:\data\burden_dementia\logs\mm_days_nh_nights.pdf", replace

count if !missing(nh_nights_f) & !missing(mcaid_final) 
local N `r(N)'
catplot mcaid_final nh_nights_f, percent recast(bar) title("SR NH Nights flag vs Medicaid flag (from claims)" "(N =`N')") blabel(bar)
graph save "E:\data\burden_dementia\logs\nh_nights_medicaid", replace
graph export "E:\data\burden_dementia\logs\nh_nights_medicaid.pdf", replace

count if !missing(nh_nights_f) & !missing(ltc_ins_x) 
local N `r(N)'
catplot ltc_ins_x nh_nights_f ,percent recast(bar) title("SR NH Nights flag vs LTC Insurance flag" "(N =`N')") blabel(bar)
graph save "E:\data\burden_dementia\logs\nh_nights_ltc", replace
graph export "E:\data\burden_dementia\logs\nh_nights_ltc.pdf", replace

count if !missing(nh_nights_f) & !missing(nh_oop_f) 
local N `r(N)'
catplot nh_oop_f nh_nights_f ,percent recast(bar) title("SR NH Nights flag vs NH OOP" "(N =`N')") blabel(bar)
graph save "E:\data\burden_dementia\logs\nh_nights_nh_oop", replace
graph export "E:\data\burden_dementia\logs\nh_nights_nh_oop.pdf", replace

count if !missing(unatt)
local N `r(N)'
graph bar (mean) unatt, blabel(bar) title("Unattributed Nights" "(N =`N')") blabel(bar) ytitle("Mean of Unattributed Nights")
graph save "E:\data\burden_dementia\logs\unatt", replace
graph export "E:\data\burden_dementia\logs\unatt.pdf", replace

count if !missing(unatt) & !missing(mcaid_final)
local N `r(N)'
count if mcaid_final==0
local a `r(N)'
count if mcaid_final==1
local b `r(N)'
graph bar (mean) unatt, over(mcaid_final) blabel(bar) title("Unattributed Nights vs Medicaid flag (from claims)" "(N =`N')") blabel(bar) ytitle("Mean of Unattributed Nights") ///
note("`a' No Medicaid" "`b' Yes Medicaid")
graph save "E:\data\burden_dementia\logs\unatt_medicaid", replace
graph export "E:\data\burden_dementia\logs\unatt_medicaid.pdf", replace

count if !missing(unatt) & !missing(sr_medicaid)
local N `r(N)'
graph bar (mean) unatt, over(sr_medicaid) blabel(bar) title("Unattributed Nights vs Medcaid flag (SR)" "(N =`N')") blabel(bar) ytitle("Mean of Unattributed Nights")
graph save "E:\data\burden_dementia\logs\unatt_sr_medicaid", replace
graph export "E:\data\burden_dementia\logs\unatt_sr_medicaid.pdf", replace

count if !missing(unatt) & !missing(ltc_ins_x)
local N `r(N)' 
count if ltc_ins_x==0
local a `r(N)'
count if ltc_ins_x==1
local b `r(N)'
graph bar (mean) unatt, over(ltc_ins_x) blabel(bar) title("Unattributed Nights vs LTC Ins. flag" "(N =`N')") blabel(bar) ytitle("Mean of Unattributed Nights") ///
note("`a' No LTC Insurance" "`b' Yes LTC Insurance")
graph save "E:\data\burden_dementia\logs\unatt_ltc", replace
graph export "E:\data\burden_dementia\logs\unatt_ltc.pdf", replace

count if !missing(unatt) & !missing(nh_oop_f)
local N `r(N)'
count if nh_oop_f==0
local a `r(N)'
count if nh_oop_f==1
local b `r(N)'
graph bar (mean) unatt, over(nh_oop_f) blabel(bar) title("Unattributed Nights vs NH OOP flag" "(N =`N')") blabel(bar) ytitle("Mean of Unattributed Nights") ///
note("`a' No NH OOP" "`b' Yes NH OOP")
graph save "E:\data\burden_dementia\logs\unatt_nh_oop", replace
graph export "E:\data\burden_dementia\logs\unatt_nh_oop.pdf", replace

gen unatt_b=0 if unatt==0
replace unatt_b=-1 if unatt<0
replace unatt_b=1 if unatt>0
label def unatt_b -1 "<0 Unattributed" 0 "=0 Unattributed" 1 ">0 Unattributed"
la val unatt_b unatt_b

label var nh_nights_f "SR NH Nights Flag"
count if !missing(unatt) & !missing(nh_oop_f)
local N `r(N)'
catplot nh_nights_f, over(unatt_b) blabel(bar) title("Unattributed Nights vs NH Nights" "(N =`N')") percent 
graph save "E:\data\burden_dementia\logs\unatt_nh", replace
graph export "E:\data\burden_dementia\logs\unatt_nh.pdf", replace


catplot nh_nights_f , over(mm_days_f) over(unatt_b) recast(bar) percent
tab nh_nights_f mm_days_f if unatt==0
tab nh_nights_f mm_days_f if unatt>0
tab nh_nights_f mm_days_f if unatt<0

gen cat=0 if nh_nights_f==0 & unatt_b==-1
replace cat=1 if nh_nights_f==0 & unatt_b==0
replace cat=2 if nh_nights_f==0 & unatt_b==1
replace cat=3 if nh_nights_f==1 & unatt_b==-1
replace cat=4 if nh_nights_f==1 & unatt_b==0
replace cat=5 if nh_nights_f==1 & unatt_b==1

graph bar, over(cat)
graph bar unatt, over(cat) 

count if !missing(unatt) & !missing(ltc_ins_x) & ! missing(nhres_x)
local N `r(N)'
count if nhres_x==0 & ltc_ins_x==0
local a `r(N)'
count if nhres_x==1 & ltc_ins_x==0
local b `r(N)'
count if nhres_x==0 & ltc_ins_x==1
local c `r(N)'
count if nhres_x==1 & ltc_ins_x==1
local d `r(N)'
graph bar (mean) unatt, over(nhres_x) over(ltc_ins_x) blabel(bar) ///
title("Unattributed Nights by LTC and NHRES" "(N=`N')") ///
note("`a' No NHRES & No LTC Ins." "`b' NHRES & No LTC Ins." "`c' No NHRES & LTC Ins." ///
"`d' NHRES & LTC Ins.")
/*
saveold "E:\data\test\samp.dta", version(12) replace


"E:\data\hrs_cleaned\working\core_98_14_clean_final.dta"

"E:\data\test\mp_ltc_contact_days.dta"

"E:\data\CMS_DUA_51675_2014\Merged\Stata\basf_1998_2015.dta"


H="X"
use id death_date using "E:\data\burden_dementia\final_data\R01_final.dta", replace
format %td death_date
duplicates drop 
/*
merge 1:1 id using "E:\data\hrs_cleaned\exit_02_to_14_dt.dta", keep(match master) ///
keepusing(nh_nights exit_year ltc_ins nhres)  gen(xm)
rename nh_ nh_nights_x
rename ltc_ins ltc_ins_x
rename nhres nhres_x

duplicates report 

*/
duplicates drop id, force
merge 1:m id using "E:\data\hrs_cleaned\core_00_to_14.dta", keep(match master) gen(cm)
sort id core_year

gen c_ivw_date_1=.
bys id: replace c_ivw_date_1=c_ivw_date if _n==_N-1
format %td c_ivw_date_1
bys id: carryforward c_ivw_date_1, replace

by id: keep if _n==_N

replace nh_nights=730 if nh_nights==770

gen ivw_time=c_ivw_date-c_ivw_date_1
drop if ivw_time<0
replace nh_nights=ivw_time if nh_nights>ivw_time
//>=730

rename hhidpn hh
rename id hhidpn

merge 1:1 hhid pn core_year using "E:\data\hrs_cleaned\working\core_98_14_clean_final.dta", keepusing(ltc_ins) keep(master matched)

gen year= core_year
gen HHID=hhid
gen PN=pn
merge 1:1 HHID PN year using "E:\data\burden_dementia\oopdata\oopme_final_2016.dta" , keepusing(NH_OOP long_term_care private_medigap) keep(master matched) nogen

merge 1:m hhidpn using "E:\data\test\mp_ltc_contact_days.dta", gen(p)


drop if p==2

keep if inrange(date, c_ivw_date_1, c_ivw_date) | day==0
sort hhidpn

gen range=1 if c_ivw_date>=date & date>c_ivw_date_1 & date!=.

codebook hhidpn

bys hhidpn core_year: egen mm_days=total(day) if range==1,m
bys hhidpn core_year: egen medpar_tot=total(medpar_day) if range==1,m
bys hhidpn core_year: egen ltc_tot=total(ltc_day) if range==1,m

bys hhidpn core_year: keep if _n==1

//replace nh_nights_x=. if nh_nights_x==0
//replace mm_days=. if mm_days==0

merge 1:1 hhidpn using "E:\data\CMS_DUA_51675_2014\Medicare Xref2015\CMSxref20151\stata\xref2015medicare.dta", nogen keep(master matched) force
rename BID_HRS_22 bid_hrs_22
capture drop year
gen year=core_year

rename medicaid sr_medicaid

drop if bid_hrs_22==""

tempfile a
save "`a'"

use "E:\data\CMS_DUA_51675_2014\Merged\Stata\basf_1998_2015.dta", replace
gen year=year(start_dt)
gen medicaid=0
replace medicaid=1 if buyin_mo>=1 & buyin_mo!=.

sort bid_hrs_22 year
gen medicaid_p=0
by bid_hrs_22: replace medicaid_p=1 if medicaid==1 | medicaid[_n-1]==1 
//by bid_hrs_22: replace medicaid_p=2 if medicaid==1 & medicaid[_n-1]==1 

label var medicaid "Medicaid from Medicare claims"
label var medicaid_p "Medicaid from claims previous year"

sort bid_hrs_22 year
by bid_hrs_22: keep if _n==_N 


tempfile b
save "`b'"

use "`a'", replace

merge 1:1 bid_hrs_22 using "`b'", nogen keep(master match) keepusing(medicaid medicaid_p)


capture drop diff
gen diff=nh_nights-mm_days

replace ltc_ins=. if ltc_ins==8

gen mcaid=0
replace mcaid=1 if ltc_tot>=1 & ltc_tot!=.
label var mcaid "Medicaid from Medicaid Claims"

//nh_nights_x is not missing for any observations
//ltc_ins_x can be missing
//

gen nh_nights_f=0
replace nh_nights_f=1 if nh_nights!=0
gen mm_days_f=0 
replace mm_days_f=1 if mm_days!=.
gen both_f=0
replace both=1 if nh_nights_f==1 & mm_days_f==1


gen nh_oop=NH_OOP if NH_OOP!=0 & NH_OOP!=.
gen nh_oop_f=0 
replace nh_oop_f=1 if nh_oop!=0 & nh_oop!=.


sum nh_nights if nh_oop_f==1
sum mm_days if nh_oop_f==1

sum nh_oop if ltc_ins==0



label var mm_days "Claim Nights"
label var nh_nights "NH Nights from core" 
label var diff "Difference"
label var ltc_ins "LTC insurance at core"
la def lt 0 "No LTC Ins." 1 "LTC Ins."
la val ltc_ins lt
la def nhres 0 "Not NHRES" 1 "NHRES"
la val nhres nhres


/*
sum diff,d
sum diff if ltc_ins_x==0 & nhres_x==0,d
local a=`r(N)'
sum diff if ltc_ins_x==1 & nhres_x==0,d 
local b=`r(N)'
sum diff if ltc_ins_x==0 & nhres_x==1,d 
local c=`r(N)'
sum diff if ltc_ins_x==1 & nhres_x==1,d 
local d=`r(N)'


count if !missing(nh_nights_x) & !missing(mm_days) & !missing(ltc_ins_x)
local N=`r(N)'

graph bar (mean) diff diff if nh_nights_x!=. & mm_days!=., over(ltc_ins_x) over(nhres_x) note("`N' Non-missing/non-zero HRS Nursing Home Nights & Medicare/Medicaid Nights" ///
"`a' Not a NHRES and No SR LTC Ins." "`b' Not a NHRES with SR LTC Ins." ///
"`c' NHRES and No SR LTC Ins." "`d' NHRES and SR LTC Ins.") ///
blabel(bar) ytitle(mean `:variable label diff') title("Diff. between SR HRS and Medicaid/Medicare Nights" " by LTC Ins. and NHRES from death to last core ivw.")

//graph save "E:\projects\burden_dementia\archive logs\20181217\difference", replace
//graph export "E:\projects\burden_dementia\archive logs\20181217\difference.pdf", replace

graph bar (mean) nh_nights_x mm_days if nh_nights_x!=. & mm_days!=., over(ltc_ins_x) over(nhres_x) blabel(bar) ///
note("SR HRS and Medicare/Medicare NH Nights by LTC Ins.") ytitle(Mean # of Nights) ///
title("Mean Nights by LTC Ins. for SR HRS and Claims" "by LTC Ins. and NHRES") legend(label(2 "Claim Nights") label(1 "SR NH Nights from exit" ))

//graph save "E:\projects\burden_dementia\archive logs\20181217\mean_nights", replace
//graph export "E:\projects\burden_dementia\archive logs\20181217\mean_nights.pdf", replace

graph bar (count) nh_nights_f mm_days_f both_f, over(ltc_ins_x) over(nhres_x) blabel(bar) ///
title("Count of having NH Nights in SR HRS, Claims, & Both" "by LTC Ins. and NHRES") ytitle(# of people) ///
legend(label(1 "SR NH Nights from exit") ///
label(2 "Claim Nights") label(3 "Both"))

//graph save "E:\projects\burden_dementia\archive logs\20181217\count", replace
//graph export "E:\projects\burden_dementia\archive logs\20181217\count.pdf", replace

tab ltc_ins_x medicaid_p


tab nh_oop_f nhres_x
tab nh_oop_f ltc_ins_x

tab nh_oop_f nh_nights_f,m
sum NH_OOP if nhres_x==1 & nh_oop_f==1, d

pctile nh_oop_q= NH_OOP, n(4)

*/

// need to first find state var
//then make sure genworth data is showing nh rates costs
//then merge in to the exit year--will need to change variable
//then convert sr oop nh to nights 
// then find the unattributed section


tempfile a 
save "`a'"

use "E:\data\hrs_restricted_2014\hrsxgeo1_3.dta", replace 

rename stateusps0* stateusps*
rename zipcode0* zipcode*

reshape long zipcode stateusps, i(id) j(year)

forvalues i=90/99{
replace year=19`i' if year==`i'
}

forvalues i=0/9{
replace year=200`i' if year==`i'
}

forvalues i=10/16{
replace year=20`i' if year==`i'
}

sort id year

//assumption
by id: carryforward stateusps, gen(state)

rename id hhidpn 
rename year core_year

merge 1:1 hhid core using "`a'", nogen keep(using match)

tempfile b
save "`b'"

import excel "E:\data\burden_dementia\ref_data\Cost Care Survey (Genworth-Metlife)\HHA_hourly_genworth.xlsx" ///
, sheet("Sheet5") firstrow case(lower) clear

drop if year==.
rename mediandailyratenursinghomed nh_daily
rename year core_year 
merge 1:m core_year state using "`b'", nogen keep(using matched)

destring nh_daily, replace
gen nh_oop_nights=NH_OOP/nh_daily
gen ltc_nights=long_term_care/nh_daily
gen medigap_nights=private_medigap/nh_daily

gen ltc_flag=1 if long_term_care>=1 & long_term_care!=.
gen medigap_flag=1 if private_medigap>=1 & private_medigap!=.

gen nh_oop_big_flag=1 if nh_oop_nights>ivw_time

replace nh_oop_nights=ivw_time if nh_oop_nights>ivw_time
replace nh_oop_nights=round(nh_oop_nights)
replace ltc_nights=round(ltc_nights)
replace medigap_nights=round(medigap_nights)

replace mm_days=0 if mm_days==.
replace nh_nights=0 if nh_nights==.

gen unatt=nh_nights-nh_oop_nights-mm_days
gen unatt_1=nh_nights-nh_oop_nights-mm_days-ltc_nights
gen unatt_2=nh_nights-nh_oop_nights-mm_days-ltc_nights-medigap_nights

sum unatt, d
sum unatt_1, d
sum unatt_2, d


gen mcaid_final=0
replace mcaid_final=1 if medicaid==1 | mcaid==1

sum nh_nights_f, d

sum mm_days_f, d

la def nh_nights_f 0 "No NH Nights" 1 "Yes NH Nights"
la val nh_nights_f nh_nights_f

la def mm_days_f 0 "No Claims" 1 "Yes Claims"
la val mm_days_f mm_days_f
la def medicaid 0 "No Medicaid" 1 "Yes Medicaid"
la val medicaid medicaid
la def mcaid_final 0 "No Medicaid" 1 "Yes Medicaid"
la val mcaid_final mcaid_final
la def ltc_ins 0 "No LTC Ins." 1 "Yes LTC Ins. "
la val ltc_ins ltc_ins_x
la def nh_oop_f 0 "No NH OOP" 1 "Yes NH OOP"
la val nh_oop_f nh_oop_f
la def sr_medicaid 0 "No SR Medicaid" 1 "Yes SR Medicaid"
la val sr_medicaid sr_medicaid


gen unatt_c=unatt*nh_daily

sum unatt, d
sum unatt_1, d
sum unatt_2, d