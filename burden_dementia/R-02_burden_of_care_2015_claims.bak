= V4 Outline MultiLine NoSorting TabWidth=30

H="Project outline"
The Burden of Care for Adults with Dementia: Impact on Care Quality and Family Outcomes


10/9/17

This is a project to set up the structure for Amy's R01 and get initial findings while we wait for the HRS and claims data through 2016 and the MDS and Medicaid MAX files.  Right now we have HRS interviews through 2014 and Rand family and CMS data through 2012.  Because we're looking at the last five years of life, the full sample will be those who die 2005-2012.  

Initial dataset creation:

index_date: death date from Karen's death date file
n1, n2, n3, and exit interviews
-OOP spending (have all the code from Kathleen)
-dementia probability
-unpaid caregiving hours (values at state average for hired cgs)
-NH admission
-wealth (Rand)
-cohabitation with adult kids (Rand)
-financial support from adult kids (Rand)
-demographics
-SR illnesses
-location of death

Annual Medicare claims from five years pre-death

Burdensome transitions last 90 days

H="set libraries"
libname clean 'E:\data\hrs_cleaned'; 
libname medi 'E:\data\CMS_DUA_51675_2014\Merged\SAS';
libname dmouth 'E:\data\Dartmouth_misc';

/*rand data path*/
libname rand 'E:\data\hrs_public_2012\rand2012\main';

libname proj_int 'E:\data\burden_dementia\int_data';
libname proj_fin 'E:\data\burden_dementia\final_data';
libname proj_ref 'E:\data\burden_dementia\ref_data';



H="get index date"
/*pull the date of death, assign as index date*/

/*
proc import datafile="E:\data\hrs_cleaned\death_date_2014.dta" out=death_date_2014 dbms=stata replace; run;

data index;
set death_date_2014;
index_date=death_all;
index_month=month(death_all);
index_year=year(death_all);
if bid_hrs_21~='';
run;

data proj_int.index (keep = id bid_hrs_21 index_date index_month index_year);
set index;
run;


*/

data proj_int.index(keep=id bid_hrs_22 index_date index_month index_year);
set clean.death_date_2015;
index_date=death_all;
index_month=death_month;
index_year=death_year;
if bid_hrs_22~='';
run;


proc export data=proj_int.index outfile="E:\data\burden_dementia\int_data\index_dates.dta" dbms=stata replace; run;

H="get ffs before"
/*determine Spouse ffs medicare before R's death using the 
claims denominator files

Several sets of variables created, looking back 6m, 12m, 18m, 24m from R's death

Also pulls in spouse date of death where available in the claims s_claims_dod*/

/*sort claims denominator file*/

proc sort data=medi.bqsf_1998_2015 out=dn  nodupkey;
by bid_hrs_22 start_dt;
run;

proc sort data=proj_int.index out=index1 nodupkey;
by bid_hrs_22 index_year;
run;

/*get dn just for interview year*/

proc sql; 
create table dn_index_quarter as select
a.*,b.ab_mo_cnt,b.start_dt,b.end_dt,b.hmo_mo
from index1 a inner join
dn b
on trim(left(a.bid_hrs_22))=trim(left(b.bid_hrs_22)) 
and b.start_dt<=a.index_date<=b.end_dt;
quit;



data all_insurance_0 (rename=(hmo_mo=hmo0 ab_mo_cnt=ab0));
set dn_index_quarter;
ffs0=ab_mo_cnt>=1 & hmo_mo=0;
set dn_index_quarter;
format index_date date9.;
run;

data all_insurance_0b;
set all_insurance_0;
ab_mos0=ab0;
if ffs0=1 then ffs_mos0=ab_mos0;
if ffs0=0 then ffs_mos0=0;
run;



%macro insyrs(numyrs=);
%let y=%eval(&numyrs.*4);
%do i=1 %to &y.;

%let l=%eval(&i.-1);
proc sql; 
create table dn&i. as select
a.*,b.ab_mo_cnt,b.start_dt,b.end_dt,b.hmo_mo
from index1 a inner join
dn b
on trim(left(a.bid_hrs_22))=trim(left(b.bid_hrs_22)) 
and b.start_dt<=a.index_date-(&i.*(365.25/4))<=end_dt;
quit;

data all_insurance_&i.(rename=(hmo_mo=hmo&i. ab_mo_cnt=ab&i.)); 
set dn&i.;
ffs&i.=ab_mo_cnt>=1 & hmo_mo=0;
format index_date date9.;
run;

proc sql;
create table all_insurance_&i.2 as select * from
all_insurance_&l.b a
left join
all_insurance_&i. b
on a.bid_hrs_22=b.bid_hrs_22;
quit;

data all_insurance_&i.b (drop=ab_mos&l. ffs_mos&l.);
set all_insurance_&i.2;
ab_mos&i.=ab_mos&l.+ab&i.;
if ffs&i.=. then ffs&i.=0;
if ffs&l.=0 then ffs&i.=0;
if ffs&i.=1 then ffs_mos&i.=ab&i.+ffs_mos&l.;
if ffs&i.=0 then ffs_mos&i.=ffs_mos&l.;
run;

%end;

data all_insurance;
set all_insurance_&y.b;
cont_ffs_n_mos=ffs_mos&y.;
%mend;




%insyrs(numyrs=7);


data proj_int.ffs_before;
set all_insurance;
run;

proc export data=proj_int.ffs_before outfile="E:\data\burden_dementia\int_data\ffs_before.dta" replace; run;

H="get claims before"
proc sort data=proj_int.index out=index1 nodupkey;
by bid_hrs_22 id index_date;
run;




/**************************************************************************/
/* ************** Claims Before Death  ******************************/
/**************************************************************************/
/*macro to get claims before death
saves datasets for each claim type / time window to the spo_mc_i directory*/
%macro claimspre(days_start=,days_bef_index=,source=,suf=);

/*claims fully within x time of death date*/
proc sql;
create table &source._meet_1 as select a.*,b.index_date,b.id 
from medi.&source._1998_2015 a inner join
index1 b
on trim(left(a.bid_hrs_22))=trim(left(b.bid_hrs_22))
and &days_start<=b.index_date-a.admit_date<=&days_bef_index ;
quit;

/*claims that start earlier than x time but span into x time before death*/
proc sql;
create table &source._meet_2 as select a.*,b.index_date,b.id 
from medi.&source._1998_2015 a inner join
index1 b
on trim(left(a.bid_hrs_22))=trim(left(b.bid_hrs_22))
and b.index_date-a.admit_date>&days_bef_index and b.index_date-a.disch_date<=&days_bef_index;
quit;

data proj_int.&source._meet_&suf.(compress=yes);
set &source._meet_1 &source._meet_2;
run;
%mend;

/*6m before death*/
*%claims(days_start=0,days_bef_index=183,source=hh,suf=6m); /*home health*/
*%claims(days_start=0,days_bef_index=183,source=hs,suf=6m); /*hospice*/
*%claims(days_start=0,days_bef_index=183,source=mp,suf=6m); /*medpar*/
*%claims(days_start=0,days_bef_index=183,source=dm,suf=6m); /*dme*/
*%claims(days_start=0,days_bef_index=183,source=op,suf=6m); /*outpatient*/
*%claims(days_start=0,days_bef_index=183,source=pb,suf=6m); /*carrier*/
/*12m before death*/
%macro bef(time=);
%claimspre(days_start=0,days_bef_index=365*&time.,source=hh,suf=%eval(12*&time.)m); /*home health*/
%claimspre(days_start=0,days_bef_index=365*&time.,source=hs,suf=%eval(12*&time.)m); /*hospice*/
%claimspre(days_start=0,days_bef_index=365*&time.,source=mp,suf=%eval(12*&time.)m); /*medpar*/
%claimspre(days_start=0,days_bef_index=365*&time.,source=dm,suf=%eval(12*&time.)m); /*dme*/
%claimspre(days_start=0,days_bef_index=365*&time.,source=op,suf=%eval(12*&time.)m); /*outpatient*/
%claimspre(days_start=0,days_bef_index=365*&time.,source=pb,suf=%eval(12*&time.)m); /*carrier*/
%mend;



/**************************************************************************/
/* ************** S Claims After R's Death   ******************************/
/**************************************************************************/
/*macro to get claims after death
saves datasets for each claim type / time window to the spo_mc_i directory*/
%macro claimspost(days_start=,days_aft_index=,source=,suf=);

/*claims fully within x time of death date*/
proc sql;
create table &source._meet_1 as select a.*,b.index_date,b.id 
from medi.&source._1998_2015 a inner join
index1 b
on trim(left(a.bid_hrs_22))=trim(left(b.bid_hrs_22))
and &days_start<=a.admit_date - b.index_date<=&days_aft_index ;
quit;

/*claims that start earlier than R's DOD but span after R's death*/
proc sql;
create table &source._meet_2 as select a.*,b.index_date,b.id 
from medi.&source._1998_2015 a inner join
index1 b
on trim(left(a.bid_hrs_22))=trim(left(b.bid_hrs_22))
and a.admit_date<b.index_date
and &days_start<=a.disch_date - b.index_date;
quit;

data proj_int.&source._meet_&suf.(compress=yes);
set &source._meet_1 &source._meet_2;
format disch_date date9.;
format admit_date date9.;
run;
%mend;

%macro aft(time=);
%claimspost(days_start=0,days_aft_index=365*&time.,source=hh,suf=p%eval(12*&time.)m); /*home health*/
%claimspost(days_start=0,days_aft_index=365*&time.,source=hs,suf=p%eval(12*&time.)m); /*hospice*/
%claimspost(days_start=0,days_aft_index=365*&time.,source=mp,suf=p%eval(12*&time.)m); /*medpar*/
%claimspost(days_start=0,days_aft_index=365*&time.,source=dm,suf=p%eval(12*&time.)m); /*dme*/
%claimspost(days_start=0,days_aft_index=365*&time.,source=op,suf=p%eval(12*&time.)m); /*outpatient*/
%claimspost(days_start=0,days_aft_index=365*&time.,source=pb,suf=p%eval(12*&time.)m); /*carrier*/
%mend;


/**************************************************************************/
/* ********************* S Diagnosis Lists   ******************************/
/**************************************************************************/

%macro dx_time_range(range1=, range2=, suf=);
/*pulls just dx codes from carrier claims*/
data pb_last_&range2._dx(keep=bid_hrs_22 id diag index_date);
set proj_int.pb_meet_&suf.(keep=bid_hrs_22 id PDGNS_CD DGNSCD01-DGNSCD12 index_date);
array dx PDGNS_CD DGNSCD01-DGNSCD12;
do over dx;
diag=dx ;
output;
end;
run;
proc sort data=pb_last_&range2._dx out=pb_last_&range2._dx2 nodupkey;
by bid_hrs_22 id index_date diag;
run;

/*outpatient claims*/
data op_last_&range2._dx(keep=bid_hrs_22 id diag index_date);
set proj_int.op_meet_&suf.(keep=bid_hrs_22 id PDGNS_CD DGNSCD01-DGNSCD25  index_date);
array dx PDGNS_CD DGNSCD01-DGNSCD25 ;
do over dx;
diag=dx ;
output;
end;
run;
proc sort data=op_last_&range2._dx out=op_last_&range2._dx2 nodupkey;
by bid_hrs_22 id index_date diag;
run;

/*medpar claims*/
data mp_last_&range2._dx(keep=bid_hrs_22 id diag index_date);
set proj_int.mp_meet_&suf.(keep=bid_hrs_22 id AD_DGNS DGNS_CD01-DGNS_CD25 index_date );
array dx D_DGNS DGNS_CD01-DGNS_CD25 ;
do over dx;
diag=dx ;
output;
end;
run;
proc sort data=mp_last_&range2._dx out=mp_last_&range2._dx2 nodupkey;
by bid_hrs_22 id index_date diag;
run;

/*dme claims*/
data dm_last_&range2._dx(keep=bid_hrs_22 id diag index_date);
set proj_int.dm_meet_&suf.(keep=bid_hrs_22 id PDGNS_CD DGNSCD01-DGNSCD12 index_date);
array dx PDGNS_CD DGNSCD01-DGNSCD12 ;
do over dx;
diag=dx ;
output;
end;
run;
proc sort data=dm_last_&range2._dx out=dm_last_&range2._dx2 nodupkey;
by bid_hrs_22 id index_date diag;
run;

/*home health agency*/
data hh_last_&range2._dx(keep=bid_hrs_22 id diag index_date);
set proj_int.hh_meet_&suf.(keep=bid_hrs_22 id PDGNS_CD DGNSCD01-DGNSCD25 index_date);
array dx PDGNS_CD DGNSCD01-DGNSCD25 ;
do over dx;
diag=dx ;
output;
end;
run;
proc sort data=hh_last_&range2._dx out=hh_last_&range2._dx2 nodupkey;
by bid_hrs_22 id index_date diag;
run;

/*hospice*/
data hs_last_&range2._dx(keep=bid_hrs_22 id diag index_date);
set proj_int.hs_meet_&suf.(keep=bid_hrs_22 id PDGNS_CD DGNSCD01-DGNSCD25 index_date);
array dx PDGNS_CD DGNSCD01-DGNSCD25 ;
do over dx;
diag=dx ;
output;
end;
run;
proc sort data=hs_last_&range2._dx out=hs_last_&range2._dx2 nodupkey;
by bid_hrs_22 id index_date diag;
run;

/*set diag variable length = 7 chars since that's the max length from the mc claims
Need to do this because length varies across the different mc claim types*/
data hs_last_&range2._dx3;
length diag $7;
set hs_last_&range2._dx2;
run;
data hh_last_&range2._dx3;
length diag $7;
set hh_last_&range2._dx2;
run;
data mp_last_&range2._dx3;
length diag $7;
set mp_last_&range2._dx2;
run;
data dm_last_&range2._dx3;
length diag $7;
set dm_last_&range2._dx2;
run;
data op_last_&range2._dx3;
length diag $7;
set op_last_&range2._dx2;
run;
data pb_last_&range2._dx3;
length diag $7;
set pb_last_&range2._dx2;
run;

data dx_all_last_&range2.;
set hs_last_&range2._dx3
hh_last_&range2._dx3
mp_last_&range2._dx3
dm_last_&range2._dx3
op_last_&range2._dx3
pb_last_&range2._dx3;
run;

proc sort data=dx_all_last_&range2.(where=(diag~="")) out=proj_int.dx_&range1._&range2 nodupkey;
by bid_hrs_22 id index_date diag;
run;

%mend;

/****************************************************************/
/*medpar claims, time periods before R's death*******************/
/****************************************************************/
/*macro for medpar claims, splits into costs for snf and ip claims
for time periods before r's death*/
%macro mp(source=,equ=,name=);
data proj_int.&source._meet_&name.;
set proj_int.mp_meet_&name.;
if (trim(left(SSLSSNF)))&equ.="N";
run;
%mend;

%macro mpsplit(time=);
%mp(source=ip,equ=~,name=%eval(12*&i.)m);
%mp(source=snf,equ=,name=%eval(12*&i.)m);
%mp(source=ip,equ=~,name=p%eval(12*&i.)m);
%mp(source=snf,equ=,name=p%eval(12*&i.)m);
%mend;



/*run macros*/

%macro runall(years=);
%do i=1 %to &years.;
%bef(time=&i.);
%aft(time=&i.);
%mpsplit(time=&i.);
%end;
%mend;

%runall(years=7);


/*run macro to create data files proj_int.dx_0d_n6m proj_int.dx_0d_n12m and proj_int.dx_0d_n24m */
*%dx_time_range(range1=0d, range2=n6m, suf=6m);
%dx_time_range(range1=0d, range2=n12m, suf=12m);
*%dx_time_range(range1=0d, range2=n24m, suf=24m);

/*run for dx lists after R's death*/
*%dx_time_range(range1=0d, range2=p6m, suf=p6m);
*%dx_time_range(range1=0d, range2=p12m, suf=p12m);
*%dx_time_range(range1=0d, range2=p24m, suf=p24m);



/*get spouse medicare costs by claim type and total, adjusted for inflation
to 2012$, monthly, 24m before and after R's death

begins with claims lists from "Get S MC claims lists..." section

final dataset is spo_mc_i.hrs_elix_cc_pay*/




H="MC Spending"

%macro mp_index_dt(source=);
*get claims that overlap with date of death;

data &source._meet_admit;
set proj_int.&source._meet_60m;
if index_date=admit_date and admit_date~=disch_date;
admit_on_index_date=1;
run;


data &source._meet_both;
set proj_int.&source._meet_60m;
if index_date=disch_date and admit_date=disch_date;
admit_on_index_date=1;
disch_on_index_date=1;
run;




data &source._cost;
set &source._meet_admit &source._meet_both;
array list pmt_amt passthru;
do over list;
if list=. then list=0;
end;

if year(admit_date)=2016 then rate=1;
if year(admit_date)=2015 then rate=1.01262;
if year(admit_date)=2014 then rate=1.01382;
if year(admit_date)=2013 then rate=1.03026;
if year(admit_date)=2012 then rate=1.04535;
if year(admit_date)=2011 then rate=1.06699;
if year(admit_date)=2010 then rate=1.10067;
if year(admit_date)=2009 then rate=1.11872;
if year(admit_date)=2008 then rate=1.11474;
if year(admit_date)=2007 then rate=1.15754;
if year(admit_date)=2006 then rate=1.19051;
if year(admit_date)=2005 then rate=1.22891;
if year(admit_date)=2004 then rate=1.27055;
if year(admit_date)=2003 then rate=1.30439;
if year(admit_date)=2002 then rate=1.33411;
if year(admit_date)=2001 then rate=1.35521;
if year(admit_date)=2000 then rate=1.39377;
if year(admit_date)=1999 then rate=1.44062;
if year(admit_date)=1998 then rate=1.47244;


&source._paid_by_mc=rate*(pmt_amt+passthru);
&source._paid_by_mc_index_dt=(1/(disch_date-admit_date+1))*&source._paid_by_mc;
run;

proc sql;
create table &source._pay as select distinct bid_hrs_21,index_date,
sum(&source._paid_by_mc_index_dt) as &source._paid_by_mc_index_dt,
sum(admit_on_index_date) as &source._admit_dod, sum(disch_on_index_date) as &source._disch_dod
from &source._cost group by bid_hrs_21,index_date;
quit;


proc sort data=&source._pay;
by bid_hrs_21 index_date;
run;

%mend;
%mp_index_dt(source=ip);
%mp_index_dt(source=snf);


%macro claims_index_dt(source=);
*get claims that start with date of death;

data &source._meet_admit;
set proj_int.&source._meet_60m;
if index_date=admit_date; 
run;



data &source._cost;
set &source._meet_admit;
array list pmt_amt passthru;
do over list;
if list=. then list=0;
end;

if year(admit_date)=2014 then rate=1;
if year(admit_date)=2013 then rate=1.01622;
if year(admit_date)=2012 then rate=1.03111;
if year(admit_date)=2011 then rate=1.05245;
if year(admit_date)=2010 then rate=1.08567;
if year(admit_date)=2009 then rate=1.10347;
if year(admit_date)=2008 then rate=1.09955;
if year(admit_date)=2007 then rate=1.14177;
if year(admit_date)=2006 then rate=1.17429;
if year(admit_date)=2005 then rate=1.21217;
if year(admit_date)=2004 then rate=1.25323;
if year(admit_date)=2003 then rate=1.28661;
if year(admit_date)=2002 then rate=1.31593;
if year(admit_date)=2001 then rate=1.33674;
if year(admit_date)=2000 then rate=1.37477;
if year(admit_date)=1999 then rate=1.42098;
if year(admit_date)=1998 then rate=1.45237



&source._paid_by_mc_index_dt=rate*(pmt_amt);
run;

proc sql;
create table &source._pay as select distinct bid_hrs_21,index_date,
sum(&source._paid_by_mc_index_dt) as &source._paid_by_mc_index_dt
from &source._cost group by bid_hrs_21,index_date;
quit;

proc sort data=&source._pay;
by bid_hrs_21 index_date;
run;

%mend;

%claims_index_dt(source=op);
%claims_index_dt(source=pb);
%claims_index_dt(source=hh);
%claims_index_dt(source=hs);
%claims_index_dt(source=dm);


data mc_costs_doda;
merge ip_pay snf_pay op_pay pb_pay hh_pay hs_pay dm_pay ;
bid_hrs_21=bid_hrs_21;
by bid_hrs_21 index_date;
run;


data mc_costs_dod;
set mc_costs_doda;
tot_paid_by_mc_index_dt=ip_paid_by_mc_index_dt+snf_paid_by_mc_index_dt+op_paid_by_mc_index_dt +
pb_paid_by_mc_index_dt+hs_paid_by_mc_index_dt+dm_paid_by_mc_index_dt;
run;


%macro mp_claims(days_start=,days_bef_index=,source=,name=);

*first get claims lists for the specific claims type, snf or ip;
data &source._meet;
set proj_int.&source._meet_60m;
win_start_dt=index_date-&days_bef_index;
win_stop_dt=index_date-&days_start;
format admit_date disch_date win_start_dt win_stop_dt date9.;
run;

/*identify claims where entire claim is within the x months prior to death*/
data &source._meet_1;
set &source._meet;
if win_start_dt<=admit_date<win_stop_dt and
	win_start_dt<=disch_date<win_stop_dt;
run;

/*identify claims where start before window but end during window*/
data &source._meet_2;
set &source._meet;
if win_start_dt>admit_date and
	win_start_dt<=disch_date<win_stop_dt;
run;

/*identify fraction of claims to be attributed to period before death
by just using the fraction of time that was included in the time window*/
data &source._meet_3;
set &source._meet_2;
pct_xm=(disch_date-win_start_dt)/(disch_date-admit_date+1);
array list pmt_amt passthru;
do over list;
if list=. then list=0;
/*scale the partial claims by the time within the x month period*/
list=list*pct_xm;
end;

run;

/*claims where start within window but end after R's death*/
data &source._meet_4;
set &source._meet;
if win_start_dt<=admit_date<win_stop_dt and
	disch_date>=win_stop_dt;
run;

/*again fraction to attribute to window*/
data &source._meet_5;
set &source._meet_4;
pct_xm=(win_stop_dt-admit_date+1)/(disch_date-admit_date+1);
array list pmt_amt passthru;
do over list;
if list=. then list=0;
/*scale the partial claims by the time within the x month period*/
list=list*pct_xm;
end;
run;

/*claims where start before and end after window*/
data &source._meet_6;
set &source._meet;
if win_start_dt>admit_date and
	disch_date>=win_stop_dt;
run;

/*again fraction to attribute to window*/
data &source._meet_7;
set &source._meet_6;
pct_xm=(win_stop_dt-win_start_dt)/(disch_date-admit_date+1);
array list pmt_amt passthru;
do over list;
if list=. then list=0;
/*scale the partial claims by the time within the x month period*/
list=list*pct_xm;
end;
run;

/*merge claims into single dataset, adjust for inflation
xxxxxUses CPI for Medical Services from BLS website, accessed 5/4/2015
Uses CPI from BLS website, accessed 11/28/2018*/
data &source._cost;
set &source._meet_1 &source._meet_3 &source._meet_5 &source._meet_7;
array list pmt_amt passthru;
do over list;
if list=. then list=0;
end;

if year(admit_date)=2014 then rate=1;
if year(admit_date)=2013 then rate=1.01622;
if year(admit_date)=2012 then rate=1.03111;
if year(admit_date)=2011 then rate=1.05245;
if year(admit_date)=2010 then rate=1.08567;
if year(admit_date)=2009 then rate=1.10347;
if year(admit_date)=2008 then rate=1.09955;
if year(admit_date)=2007 then rate=1.14177;
if year(admit_date)=2006 then rate=1.17429;
if year(admit_date)=2005 then rate=1.21217;
if year(admit_date)=2004 then rate=1.25323;
if year(admit_date)=2003 then rate=1.28661;
if year(admit_date)=2002 then rate=1.31593;
if year(admit_date)=2001 then rate=1.33674;
if year(admit_date)=2000 then rate=1.37477;
if year(admit_date)=1999 then rate=1.42098;
if year(admit_date)=1998 then rate=1.45237


&source._paid_by_mc=rate*(pmt_amt+passthru);
run;

*calculates total of mc charges for the claim type by hrs bid;
proc sql;
create table &source._pay as select distinct bid_hrs_21,index_date,
sum(&source._paid_by_mc) as &source._paid_by_mc 
from &source._cost group by bid_hrs_21,index_date;
quit;

/*merge into a full bid list of those s's with ffs mc 6m or more*/
proc sql;
create table &source._&name. as select 
a.bid_hrs_21,a.index_date,coalesce(b.&source._paid_by_mc,0) as &source._paid_by_mc_&name.
from proj_int.index a
left join
 &source._pay b
 on trim(left(a.bid_hrs_21))=trim(left(b.bid_hrs_21)) and a.index_date=b.index_date;
 quit;

proc sort data=&source._&name.; by bid_hrs_21 index_date; run;

%mend;



%macro claims(days_start=,days_bef_index=,source=,name=);

*first get claims lists for the specific claims type, not snf or ip;
data &source._meet;
set proj_int.&source._meet_60m;
win_start_dt=index_date-&days_bef_index;
win_stop_dt=index_date-&days_start;
format admit_date disch_date win_start_dt win_stop_dt date9.;
run;

/*identify claims where start of claim is within the x months prior to death*/
data proj_int.&source._meet&name.;
set &source._meet;
if win_start_dt<=admit_date<win_stop_dt;
run;


/*adjust for inflation
xxxxxUses CPI for Medical Services from BLS website, accessed 5/4/2015
Uses CPI from BLS website, accessed 11/28/2018*/
data &source._cost;
set proj_int.&source._meet&name.;
array list pmt_amt passthru;
do over list;
if list=. then list=0;
end;

if year(admit_date)=2016 then rate=1;
if year(admit_date)=2015 then rate=1.01262;
if year(admit_date)=2014 then rate=1.01382;
if year(admit_date)=2013 then rate=1.03026;
if year(admit_date)=2012 then rate=1.04535;
if year(admit_date)=2011 then rate=1.06699;
if year(admit_date)=2010 then rate=1.10067;
if year(admit_date)=2009 then rate=1.11872;
if year(admit_date)=2008 then rate=1.11474;
if year(admit_date)=2007 then rate=1.15754;
if year(admit_date)=2006 then rate=1.19051;
if year(admit_date)=2005 then rate=1.22891;
if year(admit_date)=2004 then rate=1.27055;
if year(admit_date)=2003 then rate=1.30439;
if year(admit_date)=2002 then rate=1.33411;
if year(admit_date)=2001 then rate=1.35521;
if year(admit_date)=2000 then rate=1.39377;
if year(admit_date)=1999 then rate=1.44062;
if year(admit_date)=1998 then rate=1.47244;



&source._paid_by_mc=rate*(pmt_amt);
run;

*calculates total of mc charges for the claim type by hrs bid;
proc sql;
create table &source._pay as select distinct bid_hrs_21,index_date,
sum(&source._paid_by_mc) as &source._paid_by_mc 
from &source._cost group by bid_hrs_21,index_date;
quit;

/*merge into a full bid list of those s's with ffs at death*/
proc sql;
create table &source._&name. as select 
a.bid_hrs_21,a.index_date,coalesce(b.&source._paid_by_mc,0) as &source._paid_by_mc_&name.
from proj_int.index a
left join
 &source._pay b
 on trim(left(a.bid_hrs_21))=trim(left(b.bid_hrs_21)) and a.index_date=b.index_date;
 quit;

proc sort data=&source._&name.; by bid_hrs_21 index_date; run;

%mend;




/****************************************************************/
/*all claims, time periods after R's death********************/
/****************************************************************/
%macro mp_claims_p(days_start=,days_aft_index=,source=,name=);

*first get claims lists for the specific claims type, snf or ip;
data &source._meet;
set proj_int.&source._meet_p60m;
win_end_dt=index_date+&days_aft_index;
win_start_dt=index_date+&days_start;
format admit_date disch_date win_end_dt win_start_dt date9.;
run;

/*identify claims where entire claim is within the x months after death*/
data &source._meet_1;
set &source._meet;
if win_start_dt<admit_date<=win_end_dt and
	win_start_dt<disch_date<=win_end_dt;
run;

/*identify claims where start before window but end during window*/
data &source._meet_2;
set &source._meet;
if win_start_dt>=admit_date and
	win_start_dt<disch_date<=win_end_dt;
run;

/*identify fraction of claims to be attributed to period after death
by just using the fraction of time that was included in the time window*/
data &source._meet_3;
set &source._meet_2;
pct_xm=(disch_date-win_start_dt)/(disch_date-admit_date+1);
array list pmt_amt passthru;
do over list;
if list=. then list=0;
/*scale the partial claims by the time within the x month period*/
list=list*pct_xm;
end;
run;

/*claims where start within window but end after window*/
data &source._meet_4;
set &source._meet;
if win_start_dt<admit_date<=win_end_dt and
	disch_date>win_end_dt ;
run;

/*again fraction to attribute to window*/
data &source._meet_5;
set &source._meet_4;
pct_xm=(win_end_dt-admit_date+1)/(disch_date-admit_date+1);
array list pmt_amt passthru;
do over list;
if list=. then list=0;
/*scale the partial claims by the time within the x month period*/
list=list*pct_xm;
end;
run;

/*claims where start before window but end after window*/
data &source._meet_6;
set &source._meet;
if win_start_dt>=admit_date and
	disch_date>win_end_dt ;
run;

/*again fraction to attribute to window*/
data &source._meet_7;
set &source._meet_6;
pct_xm=(win_end_dt -win_start_dt)/(disch_date-admit_date+1);
array list pmt_amt passthru;
do over list;
if list=. then list=0;
/*scale the partial claims by the time within the x month period*/
list=list*pct_xm;
end;
run;
/*merge claims into single dataset, adjust for inflation*/
data &source._cost;
set &source._meet_1 &source._meet_3 &source._meet_5 &source._meet_7;
array list pmt_amt passthru;
do over list;
if list=. then list=0;
end;

if year(admit_date)=2016 then rate=1;
if year(admit_date)=2015 then rate=1.01262;
if year(admit_date)=2014 then rate=1.01382;
if year(admit_date)=2013 then rate=1.03026;
if year(admit_date)=2012 then rate=1.04535;
if year(admit_date)=2011 then rate=1.06699;
if year(admit_date)=2010 then rate=1.10067;
if year(admit_date)=2009 then rate=1.11872;
if year(admit_date)=2008 then rate=1.11474;
if year(admit_date)=2007 then rate=1.15754;
if year(admit_date)=2006 then rate=1.19051;
if year(admit_date)=2005 then rate=1.22891;
if year(admit_date)=2004 then rate=1.27055;
if year(admit_date)=2003 then rate=1.30439;
if year(admit_date)=2002 then rate=1.33411;
if year(admit_date)=2001 then rate=1.35521;
if year(admit_date)=2000 then rate=1.39377;
if year(admit_date)=1999 then rate=1.44062;
if year(admit_date)=1998 then rate=1.47244;

&source._paid_by_mc=rate*(pmt_amt+passthru);
run;

*calculates total of mc charges for the claim type by hrs bid;
proc sql;
create table &source._pay as select distinct bid_hrs_21,index_date,
sum(&source._paid_by_mc) as &source._paid_by_mc 
from &source._cost group by bid_hrs_21,index_date;
quit;

/*merge into a full bid list of those s's with ffs mc at death*/
proc sql;
create table &source._&name. as select 
a.bid_hrs_21,a.index_date,coalesce(b.&source._paid_by_mc,0) as &source._paid_by_mc_&name.
from proj_int.index a
left join
 &source._pay b
 on trim(left(a.bid_hrs_21))=trim(left(b.bid_hrs_21)) and a.index_date=b.index_date;
 quit;

proc sort data=&source._&name.; by bid_hrs_21 index_date; run;

%mend;




/****************************************************************/
/*all claims, time periods after R's death********************/
/****************************************************************/
%macro claims_p(days_start=,days_aft_index=,source=,name=);

*first get claims lists for the specific claims type, snf or ip;
data &source._meet;
set proj_int.&source._meet_p60m;
win_end_dt=index_date+&days_aft_index;
win_start_dt=index_date+&days_start;
format admit_date disch_date win_end_dt win_start_dt date9.;
run;

/*identify claims where entire claim is within the x months after death*/
data proj_int.&source._meet&name.;
set &source._meet;
if win_start_dt<admit_date<=win_end_dt;
run;


/*adjust for inflation*/
data &source._cost;
set proj_int.&source._meet&name.;
array list pmt_amt;
do over list;
if list=. then list=0;
end;

if year(admit_date)=2016 then rate=1;
if year(admit_date)=2015 then rate=1.01262;
if year(admit_date)=2014 then rate=1.01382;
if year(admit_date)=2013 then rate=1.03026;
if year(admit_date)=2012 then rate=1.04535;
if year(admit_date)=2011 then rate=1.06699;
if year(admit_date)=2010 then rate=1.10067;
if year(admit_date)=2009 then rate=1.11872;
if year(admit_date)=2008 then rate=1.11474;
if year(admit_date)=2007 then rate=1.15754;
if year(admit_date)=2006 then rate=1.19051;
if year(admit_date)=2005 then rate=1.22891;
if year(admit_date)=2004 then rate=1.27055;
if year(admit_date)=2003 then rate=1.30439;
if year(admit_date)=2002 then rate=1.33411;
if year(admit_date)=2001 then rate=1.35521;
if year(admit_date)=2000 then rate=1.39377;
if year(admit_date)=1999 then rate=1.44062;
if year(admit_date)=1998 then rate=1.47244;

&source._paid_by_mc=rate*(pmt_amt);
run;

*calculates total of mc charges for the claim type by hrs bid;
proc sql;
create table &source._pay as select distinct bid_hrs_21,index_date,
sum(&source._paid_by_mc) as &source._paid_by_mc 
from &source._cost group by bid_hrs_21,index_date;
quit;

/*merge into a full bid list of those s's with ffs mc at death*/
proc sql;
create table &source._&name. as select 
a.bid_hrs_21,a.index_date,coalesce(b.&source._paid_by_mc,0) as &source._paid_by_mc_&name.
from proj_int.index a
left join
 &source._pay b
 on trim(left(a.bid_hrs_21))=trim(left(b.bid_hrs_21)) and a.index_date=b.index_date;
 quit;

proc sort data=&source._&name.; by bid_hrs_21 index_date; run;

%mend;

%macro days_nesting();

%do i=1 %to 5 ;


%mp_claims(days_start=floor((&i.-1)*365),days_bef_index=floor(&i.*365), source=snf,  name=%eval(12*&i.)m);
%mp_claims(days_start=floor((&i.-1)*365),days_bef_index=floor(&i.*365), source=ip,  name=%eval(12*&i.)m);
%claims(days_start=floor((&i.-1)*365),days_bef_index=floor(&i.*365), source=pb,  name=%eval(12*&i.)m);
%claims(days_start=floor((&i.-1)*365),days_bef_index=floor(&i.*365), source=op,  name=%eval(12*&i.)m);
%claims(days_start=floor((&i.-1)*365),days_bef_index=floor(&i.*365), source=hh,  name=%eval(12*&i.)m);
%claims(days_start=floor((&i.-1)*365),days_bef_index=floor(&i.*365), source=hs,  name=%eval(12*&i.)m);
%claims(days_start=floor((&i.-1)*365),days_bef_index=floor(&i.*365), source=dm,  name=%eval(12*&i.)m);

%mp_claims_p(days_start=floor((&i.-1)*365),days_aft_index=floor(&i.*365), source=snf,  name=p%eval(12*&i.)m);
%mp_claims_p(days_start=floor((&i.-1)*365),days_aft_index=floor(&i.*365), source=ip,  name=p%eval(12*&i.)m);
%claims_p(days_start=floor((&i.-1)*365),days_aft_index=floor(&i.*365), source=op,  name=p%eval(12*&i.)m);
%claims_p(days_start=floor((&i.-1)*365),days_aft_index=floor(&i.*365), source=pb,  name=p%eval(12*&i.)m);
%claims_p(days_start=floor((&i.-1)*365),days_aft_index=floor(&i.*365), source=hh,  name=p%eval(12*&i.)m);
%claims_p(days_start=floor((&i.-1)*365),days_aft_index=floor(&i.*365), source=hs,  name=p%eval(12*&i.)m);
%claims_p(days_start=floor((&i.-1)*365),days_aft_index=floor(&i.*365), source=dm,  name=p%eval(12*&i.)m);


%end;
%mend;

%days_nesting();




%macro merge(l=,source=,time=,p=);
data &source._&time._12m;
set &source._&p.12m;
run;

%do i=24 %to 60 %by 12;
%let l = %eval(&i.-12) ;

data &source._&time._&i.m;
merge &source._&time._&l.m &source._&p.&i.m;
run;
%end;

data &source._&time.;
set &source._&time._60m;
run;

proc sort data=&source._&time.;
by bid_hrs_21 index_date;
run;
%mend;

%merge(source=ip,time=bef,p=);
%merge(source=ip,time=aft,p=p);
%merge(source=snf,time=bef,p=);
%merge(source=snf,time=aft,p=p);
%merge(source=op,time=bef,p=);
%merge(source=op,time=aft,p=p);
%merge(source=pb,time=bef,p=);
%merge(source=pb,time=aft,p=p);
%merge(source=hh,time=bef,p=);
%merge(source=hh,time=aft,p=p);
%merge(source=hs,time=bef,p=);
%merge(source=hs,time=aft,p=p);
%merge(source=dm,time=bef,p=);
%merge(source=dm,time=aft,p=p);

/*now merge into single dataset of MC costs and get totals for each time window*/
data mc_costs_all;
merge ip_bef snf_bef op_bef pb_bef hh_bef hs_bef dm_bef 
ip_aft snf_aft op_aft pb_aft hh_aft hs_aft dm_aft;
by bid_hrs_21 index_date;
run;

%macro total();

data mc_costs_all2;
set mc_costs_all;
%do i=12 %to 60 %by 12;
tot_paid_by_mc_&i.m=ip_paid_by_mc_&i.m + snf_paid_by_mc_&i.m + op_paid_by_mc_&i.m + 
pb_paid_by_mc_&i.m + hh_paid_by_mc_&i.m + hs_paid_by_mc_&i.m + dm_paid_by_mc_&i.m;
tot_paid_by_mc_p&i.m=ip_paid_by_mc_p&i.m + snf_paid_by_mc_p&i.m + op_paid_by_mc_p&i.m + 
pb_paid_by_mc_p&i.m + hh_paid_by_mc_p&i.m + hs_paid_by_mc_p&i.m + dm_paid_by_mc_p&i.m;
%end;
run;

proc sort data=mc_costs_all2;
by bid_hrs_21 index_date;
run;

%mend;

%total();

data mc_costs_all3;
merge mc_costs_all2 mc_costs_dod;
by  bid_hrs_21 index_date;
run;

/*save permanent dataset*/
data proj_int.mc_costs_yearly;
set mc_costs_all3;
run;



H="combine with interviews into one dataset"
data index;
set proj_int.index;
run;



proc sql; 
create table tomerge as select * from
proj_int.index a left join
proj_int.ffs_before b 
on a.bid_hrs_22=b.bid_hrs_22 and a.index_year=b.index_year
left join 
proj_int.mc_costs_yearly c
on a.bid_hrs_22=c.bid_hrs_22 and a.index_date=c.index_date;
quit;

proc sql;
create table proj_int.decedent_dataset as select * from
proj_int.index a 
left join
tomerge b 
on a.id=b.id and a.index_year=b.index_year;
quit;

proc export data=proj_int.decedent_dataset outfile="E:\data\burden_dementia\int_data\decedent_dataset.dta" replace; run;

H="Model Medicaid spending"
set more off
capture log close
version 15
clear all


local medipath "E:\data\CMS_DUA_51675_2014\Merged\Stata"
local logpath "E:\data\burden_dementia\logs"
local datapath "E:\data\burden_dementia\int_data"
local hrspath "E:\data\hrs_cleaned"
local restrpath "E:\data\hrs_restricted_2014\Ref Docs"
cd `medipath'


//pull in medicaid generosity
import excel "E:\data\hrs_restricted_2014\Ref Docs\Medicaid generosity.xlsx", ///
sheet("Sheet1") firstrow case(lower) clear
rename location stateusps
tempfile generosity
save `generosity'

//pull HRS ivw dates--going to assign the following core/exit to the year
use `hrspath'\core_00_to_14

append using `hrspath'\exit_02_to_16_dt
gen ivw_date=c_ivw_date
replace ivw_date=e_ivw_date if missing(ivw_date)
replace ivw_date=td(01jan2016) if missing(ivw_date)
gen ivw_year=year(ivw_date)

tempfile hrs
save `hrs'

keep id ivw_*
reshape wide ivw_date, i(id) j(ivw_year)
tempfile hrswide
save `hrswide'

//get state and demo for re model

use "E:\data\hrs_cleaned\restr_tracker_v2014.dta", clear
gen stateusps16=stateusps14
keep hhid pn stateus* birth_date hisp_eth white black other_na degree
rename stateusps0* stateusps200*
rename stateusps1* stateusps201*
rename stateusps9* stateusps199*
reshape long stateusps, i(hhid pn) j(year)
drop if year<1998
expand 2, gen(dup)
replace year=year+1 if dup
gen id=hhid+pn
sort id year
by id: carryforward state, replace
gsort id -year
by id: carryforward state, replace
drop dup


drop if missing(id)
tempfile track
save `track'

//pull Medicaid
use hrs_max_asf_1999_2012, clear
merge m:1 bid using Medicaid2016Xref, keepusing(hhid pn) nogen
gen id=hhid+pn
gen rate=1 if year==2016
quietly replace rate=1.01262 if year==2015
quietly replace rate=1.01382 if year==2014
quietly replace rate=1.03026 if year==2013
quietly replace rate=1.04535 if year==2012
quietly replace rate=1.06699 if year==2011
quietly replace rate=1.10067 if year==2010
quietly replace rate=1.11872 if year==2009
quietly replace rate=1.11474 if year==2008
quietly replace rate=1.15754 if year==2007
quietly replace rate=1.19051 if year==2006
quietly replace rate=1.22891 if year==2005
quietly replace rate=1.27055 if year==2004
quietly replace rate=1.30439 if year==2003
quietly replace rate=1.33411 if year==2002
quietly replace rate=1.35521 if year==2001
quietly replace rate=1.39377 if year==2000
quietly replace rate=1.44062 if year==1999
quietly replace rate=1.47244 if year==1998

by bid, sort: egen ly=max(year)
drop if ly<2004
foreach x in ffs hmo php pccm {
	gen `x'exp=mdcd_`x'_amt*rate
	label var `x'exp "Annual `x' Medicaid Expenditures (2016$)
}
egen mcaidexp=rowtotal(*exp)
label var mcaidexp "Total Annual Medicaid Expenditures (2016$)
keep id bid *exp year
tempfile mcaid
save `mcaid'





//pull annual expenditures for medicare
use hhid pn BID_HRS_22 using xref2015medicare, clear
rename *, l
tempfile xwalk
save `xwalk'

use bid start_dt ab_mo_cnt hmo_mo buyin_mo using basf_1998_2015 if buyin_mo>=1 & ab_mo_cnt>=1 & hmo_mo==0, clear
gen year=year(start_dt)
drop start_dt
by bid, sort: egen ly=max(year)
drop if ly<2004
merge m:1 bid using `xwalk', keep(match) nogen
drop ly
tempfile mbsf
save `mbsf'

foreach x in dm hh hs ip snf op pb {
	di "`x'"
	use bid_hrs_22 pmt_amt admit_date using `x'_1998_2015
	gen year=year(admit_date)
	merge m:1 bid year using `mbsf', keep(match)
	gen rate=1 if year==2016
	quietly replace rate=1.01262 if year==2015
	quietly replace rate=1.01382 if year==2014
	quietly replace rate=1.03026 if year==2013
	quietly replace rate=1.04535 if year==2012
	quietly replace rate=1.06699 if year==2011
	quietly replace rate=1.10067 if year==2010
	quietly replace rate=1.11872 if year==2009
	quietly replace rate=1.11474 if year==2008
	quietly replace rate=1.15754 if year==2007
	quietly replace rate=1.19051 if year==2006
	quietly replace rate=1.22891 if year==2005
	quietly replace rate=1.27055 if year==2004
	quietly replace rate=1.30439 if year==2003
	quietly replace rate=1.33411 if year==2002
	quietly replace rate=1.35521 if year==2001
	quietly replace rate=1.39377 if year==2000
	quietly replace rate=1.44062 if year==1999
	quietly replace rate=1.47244 if year==1998
	replace pmt_amt=pmt_amt*rate
	by bid year, sort: egen `x'exp=total(pmt_amt)
	label var `x'exp "Annual `x' expenditures (2016$)"
	keep bid year `x'exp
	duplicates drop
	tempfile `x'
	save ``x''
}

use `mbsf'
foreach x in dm hh hs ip snf op pb {
	merge 1:1 bid year using ``x'', gen(`x'm) 
}
gen id=hhid+pn

merge 1:1 id year using `mcaid', keep(match master) gen(mcmcm)

order id bid* year *exp*

merge m:1 id using `hrswide', keep(match) gen(hrsm)

//find the closest ivw during or after the year

gen ivw_date2001=.
gen ivw_date=ivw_date2016
forvalues i=2015(-1)1998 {
replace ivw_date=ivw_date`i' if year<=`i' & !missing(ivw_date`i')
drop ivw_date`i'
}

drop if missing(ivw_date)

merge m:1 id ivw_date using `hrs', nogen keep(match master)


gen ivw_type=0
replace ivw_type=1 if !missing(exit_year)
label define ivw_type 0 "Core" 1 "Exit"
label values ivw_type ivw_type

merge 1:1 id year using `track', gen(trackm) keep(match master)

//generate variables for use in model

//# months w/ MC but no Medicaid
gen m_no_mcaid=ab_mo-buyin_mo
replace m_no_mcaid=0 if m_no_mcaid<0

//state will be panel variable
encode stateusps, gen(state)
xtset state 

//demovars
rename other_na other_race

gen ind_hs_educ=degree>=2 if !inlist(degree,9,.)
label var ind_hs_educ "Education: HS+ (excl. GED)"

gen age=year-year(birth_date)
label var age "Age on Dec. 31st"
gen age2=age^2

replace nhres=0 if missing(nhres)
replace adl_independent=adl_independent_core if missing(adl_independent)
replace adl_independent=0 if missing(adl_independent)
replace medicaid=0 if missing(medicaid)

//total mc expenditures
egen mcexp=rowtotal(*exp)
label var mcexp "Total Annual Medicare Expenditures (2016$)"
	

	
//merge in medicaid generosity
merge m:1 stateusps using `generosity', keep(match master) gen(gm)
	
local modelvars nhres age age2 black hisp_eth other_race ind_hs_educ ///
ab_mo m_no_mcaid adl_independent married medicaid 


foreach x of local modelvars {
	replace `x'=0 if missing(`x')
}


reg mcaidexp mcexp `modelvars'  generous
estimates store est0

//drop other race & education & mcaid generosity
	
local modelvars nhres age age2 black hisp_eth ///
ab_mo m_no_mcaid adl_independent married medicaid 

reg mcaidexp mcexp `modelvars'  
estimates store est1

lrtest est1 est0

//still drop hispanics
local modelvars nhres married age age2 black ///
ab_mo m_no_mcaid adl_independent medicaid ivw_type year

reg mcaidexp mcexp `modelvars'  
estimates store est2
lrtest est2 est0

local xn : word count `modelvars' 

local mn=1
forvalues i=1/`xn' {
	di `i'
	local v : word `i' of `modelvars' 
	local mvincl`i' `mvincl`=`i'-1'' `v'
	foreach x of local modelvars {
		di "`x'"
		if "`x'"!="`v'" local mvexcl`i' `mvexcl`i'' `x'
}

	foreach y in incl excl {
		qui reg mcaidexp mcexp `mv`y'`i'' i.state
		estimates store est`v'`y'`i'
		local ests`v'`y' `ests`v'`y'' est`v'`y'`i'
		lrtest est0 est`v'`y'`i'
}
}

preserve

gen proxy=proxy_core
replace proxy=proxy_exit if missing(proxy)

xtreg mcaidexp mcexp `modelvars' , fe
predict pfe
capture log close
local logpath E:\data\burden_dementia\logs
log using "`logpath'\predicted_annual_medicaid_costs`c(current_date)'", replace

set seed 12345
gen norm=rnormal()
sort norm
gen testsamp=_n<=_N/2
tab testsamp
tab testsamp if !missing(mcaidexp)

local modelvars nhres married c.age##c.age black ///
ab_mo m_no_mcaid adl_independent medicaid ivw_type proxy year
reg mcaidexp mcexp `modelvars' if testsamp==1
predict pols 
xtreg mcaidexp mcexp `modelvars' if testsamp==1, re
predict pre

twopm mcaidexp mcexp `modelvars' if testsamp==1, firstpart(logit) secondpart(regress)
predict ptwopart
estimates store est1
twopm mcaidexp mcexp `modelvars' i.state  , firstpart(logit) secondpart(regress)
predict ptptwithstates
estimates store est2

log close 
log using "`logpath'\predicted_annual_medicaid_costs_quick_compare`c(current_date)'", replace

foreach x in  re two tpt {
	di "In sample"
	reg mcaidexp p`x' if testsamp
	di "Out of sample"
	reg mcaidexp p`x' if !testsamp
	
}

log close

xtreg mcaidexp mcexp `modelvars' , re

predict pmcaid
replace mcaidexp=pmcaid if missing(mcaidexp)
gen ind_mcaid_imputed=missing(mcaidexp) & !missing(pmcaid)

save E:\data\burden_dementia\int_data\\predicted_annual_medicaid_costs.dta, replace

translate "`logpath'\predicted_annual_medicaid_costs`c(current_date)'.smcl" ///
"`logpath'\predicted_annual_medicaid_costs`c(current_date)'.pdf", replace
translate "E:\data\burden_dementia\logs\predicted_annual_medicaid_costs_quick_compare `c(current_date)'.smcl" ///
"E:\data\burden_dementia\logs\predicted_annual_medicaid_costs_quick_compare `c(current_date)'.pdf", replace

H="Pull Medicaid costs and days"
libname merged 'E:\data\CMS_DUA_51675_2014\Medicaid_merged';

proc import datafile="E:\data\burden_dementia\int_data\decedent_dataset.dta" out=R01 (keep = id index_month index_year index_date) dbms=stata replace; run;

proc import datafile="E:\data\CMS_DUA_51675_2014\Medicaid_merged\MedicaidXref2012_old.dta" out=maid_xwalk (keep = hhidpn bid_hrs_23) dbms=stata replace; run;

proc sql;
create table r01_merged as select a.*, b.bid_hrs_23
from R01 a
inner join maid_xwalk b
on a.id = b.hhidpn; 
quit;


data r01;
set r01_merged;
format index_date date9.;
run;


/*** Get HH + SNF days & cost + Total Maid cost *****/

data month_breakdown (keep = bid_hrs_23 year month mdcd_ffs_amt mdcd_hmo_amt mdcd_php_amt mdcd_pccm_amt mdcd_nf_days_all mdcd_nf_days_hcbs_all mdcd_nf_amt mdcd_nf_amt_hcbs mdcd_hh_amt mdcd_hh_amt_hcbs mdcd_hh_days_all mdcd_hh_days_hcbs_all mdcd_hh_days_ffs mdcd_nf_days_ffs);
set merged.hrs_max_msf_1999_2012;
run;

data month_breakdown (drop = mdcd_ffs_amt mdcd_hmo_amt mdcd_php_amt mdcd_pccm_amt mdcd_nf_days_all mdcd_nf_days_hcbs_all mdcd_nf_amt mdcd_nf_amt_hcbs mdcd_hh_amt mdcd_hh_amt_hcbs mdcd_hh_days_all mdcd_hh_days_hcbs_all);
set month_breakdown;
paid_maid = sum(mdcd_ffs_amt, mdcd_hmo_amt, mdcd_php_amt, mdcd_pccm_amt); /*total paid medicaid */
nf_days_maid = sum(mdcd_nf_days_all);
nf_ffs_days_maid = sum(mdcd_nf_days_ffs);
nf_cost_maid = sum(mdcd_nf_amt);
hh_days_maid = sum(mdcd_hh_days_all);
hh_ffs_days_maid = sum(mdcd_hh_days_ffs);
hh_cost_maid = sum(mdcd_hh_amt);
run;

proc sort data=month_breakdown; by bid_hrs_23 year; run;
proc transpose data=month_breakdown out=month_breakdown_wide; by bid_hrs_23 year; id month; run;


proc sql;
create table r01_b as select a.*, b.*
from r01 a
left join month_breakdown_wide b
on a.bid_hrs_23=b.bid_hrs_23;
quit;



proc export data=r01_b outfile="E:\data\burden_dementia\int_data\medicaid_cost_hh_snf.dta" dbms=stata replace; run;


H="Calculate SNF/HH Medicaid cost+days "
use "E:\data\burden_dementia\int_data\predicted_annual_medicaid_costs.dta", clear

forvalues i=1/12 {
	gen _`i'=mcaidexp/12
}

gen _name_="paid_maid"

keep id year _* ind_mcaid_imp

tempfile pmcaid
save `pmcaid'

use  "E:\data\burden_dementia\int_data\medicaid_cost_hh_snf.dta", clear

*drop if index_year>2012 | index_year<=2005

/* inflation adjustment */



gen rate = .

replace rate = 1 if year==2016
replace rate=1.01262 if year==2015
replace rate=1.01382 if year==2014
replace rate=1.03026 if year==2013
replace rate=1.04535 if year==2012
replace rate=1.06699 if year==2011
replace rate=1.10067 if year==2010
replace rate=1.11872 if year==2009
replace rate=1.11474 if year==2008
replace rate=1.15754 if year==2007
replace rate=1.19051 if year==2006
replace rate=1.22891 if year==2005
replace rate=1.27055 if year==2004
replace rate=1.30439 if year==2003
replace rate=1.33411 if year==2002
replace rate=1.35521 if year==2001
replace rate=1.39377 if year==2000
replace rate=1.44062 if year==1999
replace rate=1.47244 if year==1998

gen cost = 0
replace cost = 1 if (_name_=="hh_cost_maid" | _name_=="nf_cost_maid" | _name_=="paid_maid")

forvalues p = 1/12 {

replace _`p' = _`p'*rate if cost==1
}

merge m:1 id year using `pmcaid', gen(pmcaidm)

/*Flag year markers, n1=[0,-12], n2=[-12,-24], n3=[-24,-36], etc. */



forvalues i=1/7 {
gen n`i'_flag = 0
replace n`i'_flag = 1 if (year==index_year-`=`i'-1') | (year==index_year-`i')
}


gen index_day = day(index_date)



save "E:\data\burden_dementia\int_data\medicaid_cost_inflation.dta", replace

cd "E:\data\burden_dementia\int_data"

levelsof _name_, local(namevars)
return list

foreach x of local namevars {
use "E:\data\burden_dementia\int_data\medicaid_cost_inflation.dta", clear
keep if _name_=="`x'"



forvalues t=1/12 {
preserve
keep if index_month==`t'

forvalues i=1/7 {

gen sum_n`i'_cyr= 0 if n`i'_flag==1 /*sum months before index month in current year*/

local j = index_month
local k = 1


	while `k' <= `j' { // while current month less than or equal index, add to past value
		while `k' < `j' {
			replace sum_n`i'_cyr = sum_n`i'_cyr + _`k' if sum_n`i'_cyr!=.
			local ++k
		}
	    replace sum_n`i'_cyr = sum_n`i'_cyr + (_`k')*(index_day/30.4) if sum_n`i'_cyr!=. // if current month = index, then prorate it
		local ++k
}

gen sum_n`i'_b4yr = 0 if n`i'_flag==1

local r = index_month
local s = 12
	while `s' >=`r' { // count backwards to get months before index in previous year
		while `s' > `r' {
		replace sum_n`i'_b4yr = sum_n`i'_b4yr + _`s' if sum_n`i'_b4yr!=.
		local --s
	}
	
	replace sum_n`i'_b4yr = sum_n`i'_b4yr + (_`s')*(1-(index_day/30.4)) if sum_n`i'_b4yr!=.
	local --s
	}
	


}
keep if n1_flag | n2_flag | n3_flag | n4_flag | n5_flag | n6_flag | n7_flag


gsort +id +year


forvalues i=1/7 {

gen tot_`x'_n`i' = sum_n`i'_cyr + sum_n`i'_b4yr[_n-1]
}

*keep id index_date bid_hrs_23 index_year year n*_flag tot_`x'_n* 
sort id year
by id: carryforward tot_*, replace
by id: keep if _n==_N
keep id index_date bid_hrs_23 tot_`x'_n* 
save mc_`x'_`t'.dta, replace

restore

}

}

foreach x of local namevars {

	use mc_`x'_1.dta, clear
	
	forvalues i = 2/12 {
		
		append using mc_`x'_`i'.dta
		save tot_`x'.dta, replace
		}
		}

foreach x of local namevars {

use tot_paid_maid.dta, clear
cap drop _m 
merge 1:1 id using "E:\data\burden_dementia\int_data\tot_`x'.dta", keepus(tot_`x'_n1 tot_`x'_n2 tot_`x'_n3 tot_`x'_n4 tot_`x'_n5 tot_`x'_n6 tot_`x'_n7)
save tot_paid_maid.dta, replace
}


label var tot_paid_maid_n1 "Total Medicaid Spending N1"
label var tot_paid_maid_n2 "Total Medicaid Spending N2"
label var tot_paid_maid_n3 "Total Medicaid Spending N3"
label var tot_paid_maid_n4 "Total Medicaid Spending N4"
label var tot_paid_maid_n5 "Total Medicaid Spending N5"
label var tot_paid_maid_n6 "Total Medicaid Spending N6"
label var tot_paid_maid_n7 "Total Medicaid Spending N7"

label var tot_hh_cost_maid_n1 "Total HH (FFS) Medicaid Spending N1"
label var tot_hh_cost_maid_n2 "Total HH (FFS) Medicaid Spending N2"
label var tot_hh_cost_maid_n3 "Total HH (FFS) Medicaid Spending N3"
label var tot_hh_cost_maid_n4 "Total HH (FFS) Medicaid Spending N4"
label var tot_hh_cost_maid_n5 "Total HH (FFS) Medicaid Spending N5"
label var tot_hh_cost_maid_n6 "Total HH (FFS) Medicaid Spending N6"
label var tot_hh_cost_maid_n7 "Total HH (FFS) Medicaid Spending N7"

label var tot_hh_days_maid_n1 "Total HH Medicaid Days N1"
label var tot_hh_days_maid_n2 "Total HH Medicaid Days N2"
label var tot_hh_days_maid_n3 "Total HH Medicaid Days N3"
label var tot_hh_days_maid_n4 "Total HH Medicaid Days N4"
label var tot_hh_days_maid_n5 "Total HH Medicaid Days N5"
label var tot_hh_days_maid_n6 "Total HH Medicaid Days N6"
label var tot_hh_days_maid_n7 "Total HH Medicaid Days N7"

label var tot_hh_ffs_days_maid_n1 "Total HH (FFS) Medicaid Days N1"
label var tot_hh_ffs_days_maid_n2 "Total HH (FFS) Medicaid Days N2"
label var tot_hh_ffs_days_maid_n3 "Total HH (FFS) Medicaid Days N3"
label var tot_hh_ffs_days_maid_n4 "Total HH (FFS) Medicaid Days N4"
label var tot_hh_ffs_days_maid_n5 "Total HH (FFS) Medicaid Days N5"
label var tot_hh_ffs_days_maid_n6 "Total HH (FFS) Medicaid Days N6"
label var tot_hh_ffs_days_maid_n7 "Total HH (FFS) Medicaid Days N7"

label var tot_nf_cost_maid_n1 "Total SNF (FFS) Medicaid Spending N1"
label var tot_nf_cost_maid_n2 "Total SNF (FFS) Medicaid Spending N2"
label var tot_nf_cost_maid_n3 "Total SNF (FFS) Medicaid Spending N3"
label var tot_nf_cost_maid_n4 "Total SNF (FFS) Medicaid Spending N4"
label var tot_nf_cost_maid_n5 "Total SNF (FFS) Medicaid Spending N5"
label var tot_nf_cost_maid_n6 "Total SNF (FFS) Medicaid Spending N6"
label var tot_nf_cost_maid_n7 "Total SNF (FFS) Medicaid Spending N7"

label var tot_nf_days_maid_n1 "Total SNF Medicaid Days N1"
label var tot_nf_days_maid_n2 "Total SNF Medicaid Days N2"
label var tot_nf_days_maid_n3 "Total SNF Medicaid Days N3"
label var tot_nf_days_maid_n4 "Total SNF Medicaid Days N4"
label var tot_nf_days_maid_n5 "Total SNF Medicaid Days N5"
label var tot_nf_days_maid_n6 "Total SNF Medicaid Days N6"
label var tot_nf_days_maid_n7 "Total SNF Medicaid Days N7"

label var tot_nf_ffs_days_maid_n1 "Total SNF (FFS) Medicaid Days N1"
label var tot_nf_ffs_days_maid_n2 "Total SNF (FFS) Medicaid Days N2"
label var tot_nf_ffs_days_maid_n3 "Total SNF (FFS) Medicaid Days N3"
label var tot_nf_ffs_days_maid_n4 "Total SNF (FFS) Medicaid Days N4"
label var tot_nf_ffs_days_maid_n5 "Total SNF (FFS) Medicaid Days N5"
label var tot_nf_ffs_days_maid_n6 "Total SNF (FFS) Medicaid Days N6"
label var tot_nf_ffs_days_maid_n7 "Total SNF (FFS) Medicaid Days N7"


cd "E:\projects\burden_dementia\archive logs"
/*
forvalues i = 1/5 {

qui twoway scatter tot_nf_cost_maid_n`i' tot_nf_ffs_days_maid_n`i'
graph export SNF_n`i'.pdf, as(pdf) replace 

qui twoway scatter tot_hh_cost_maid_n`i' tot_hh_ffs_days_maid_n`i'
graph export HH_n`i'.pdf, as(pdf) replace
}
*/

*preserve
*keep if year(index_date)>=2005 & year(index_date)<=2012

local cost tot_paid_maid_n1 tot_paid_maid_n2 tot_paid_maid_n3 tot_paid_maid_n4 tot_paid_maid_n5 tot_paid_maid_n6 tot_paid_maid_n7 tot_hh_cost_maid_n1 tot_hh_cost_maid_n2 tot_hh_cost_maid_n3 tot_hh_cost_maid_n4 tot_hh_cost_maid_n5 tot_hh_cost_maid_n6 tot_hh_cost_maid_n7 tot_nf_cost_maid_n1 tot_nf_cost_maid_n2 tot_nf_cost_maid_n3 tot_nf_cost_maid_n4 tot_nf_cost_maid_n5 tot_nf_cost_maid_n6 tot_nf_cost_maid_n7
local days tot_hh_days_maid_n1 tot_hh_days_maid_n2 tot_hh_days_maid_n3 tot_hh_days_maid_n4 tot_hh_days_maid_n5 tot_hh_days_maid_n6 tot_hh_days_maid_n7 tot_nf_days_maid_n1 tot_nf_days_maid_n2 tot_nf_days_maid_n3 tot_nf_days_maid_n4 tot_nf_days_maid_n5 tot_nf_days_maid_n6 tot_nf_days_maid_n7 tot_hh_ffs_days_maid_n1 tot_hh_ffs_days_maid_n2 tot_hh_ffs_days_maid_n3 tot_hh_ffs_days_maid_n4 tot_hh_ffs_days_maid_n5 ///
tot_hh_ffs_days_maid_n6 tot_hh_ffs_days_maid_n7 tot_nf_ffs_days_maid_n1 tot_nf_ffs_days_maid_n2 tot_nf_ffs_days_maid_n3 tot_nf_ffs_days_maid_n4 tot_nf_ffs_days_maid_n5 tot_nf_ffs_days_maid_n6 tot_nf_ffs_days_maid_n7
local full `cost' `days'

local rd: word count `full' 1

di `rd'

mat tab1= J(`rd',9,.)
local r = 1

foreach x of local full {

sum `x'
mat tab1[`r',1] = r(mean)
sum `x' if `x'>0, d
mat tab1[`r',2]= r(mean)
mat tab1[`r',3] = r(min)
mat tab1[`r',4]= r(p25)
mat tab1[`r',5] = r(p50)
mat tab1[`r',6]= r(p75)
mat tab1[`r',7] = r(p99)
mat tab1[`r',8] = r(max)

cap drop zero
gen zero = .
replace zero = 1 if `x'==0
sum zero, d
mat tab1[`r',9]= r(N)
local ++r

}

sum `x'
mat tab1[`r',9] = 1422
mat list tab1

mat rownames tab1 = `full' N


frmttable using "E:\projects\burden_dementia\archive logs\MAX_summary.doc", replace statmat(tab1) landscape a4 ///
varlabels title("MAX Summary Statistics For R01 Sample (includes all deceased, regardless of age or dementia)") ctitles("Variables" "Ave." "Ave (non-zero)" "Minimum" "25th percentile" "Median" "75th percentile" "99th percentile" "Maximum" "# of zero's") sdec(2) ///
note("Costs have been pro-rated and inflation adjusted to 2012 dollars. The Percentiles exclude zeros")





H="Cleaning/Merging/Data aggregation"
clear all
capture log close

global datapath "E:\data\burden_dementia\int_data"
local logpath "E:\data\burden_dementia\logs"
global ooppath "E:\data\burden_dementia\oopdata"
global output "E:\projects\burden_dementia\archive logs"

*log using `logpath'\R01_aggregate.txt, text replace

* Constructs aggregate dataset and variables for R01 before people are dropped
* search "to be dropped" to find sample exclusion variables

/****************** START WITH EXIT **********************/

use "E:\data\hrs_cleaned\exit_02_to_16_dt.dta", clear

foreach x of varlist * {

rename `x' `x'_exit
}

rename id_exit id
gen nflag = 0
cap drop _m
gen year = exit_year_exit
save $datapath\exit.dta, replace // all exit interviews 2002-14

/**************** MERGE TRACKER WITH DECEDENT DATASET ***********/

cd $datapath

use decedent_dataset.dta if inrange(index_year,2004,2015), clear
cap drop _m
format %td index_date
merge m:1 id using tracker.dta 
keep if _m==3

replace birth_date=mdy(6,birthd,birthy) if missing(birth_date)
cap drop death_date
gen death_date = index_date
gen age_at_death=floor((death_date-birth_date)/365.25)

cap drop _m
merge 1:1 id using exit.dta
gen age_lt_72 = 1 if age_at_death<72
gen age_lt_70 = 1 if age_at_death<70
label var age_lt_72 "Age <72 at death, to be dropped"
label var age_lt_70 "Age <70 at death, to be dropped"

gen no_exit=1 if _m==1
label var no_exit "Decedents with no exit ivw 2002-16, to be dropped"
drop if _m==2
cap drop _m
save r01_a.dta, replace

/*************** MERGE WITH CORE INTERVIEW **************/

use r01_a.dta, clear
keep id index_date index_year exit_year_exit e_ivw_date_exit
tempfile id 
save `id' //decedents with exit 

use "E:\data\hrs_cleaned\core_00_to_14.dta", clear
merge m:1 id using "`id'", keepus(index_date index_year exit_year_exit e_ivw_date_exit)
levelsof id if _m==2, local(nocore)
global nocore1 "`nocore'"
keep if _m==3
cap drop _m
gsort id -core_year
by id: gen obs=_n
keep if obs<=5 // keeping last 5 core interviews (N1 - N4 + Baseline)

* I'm creating a single ivw date variable that has both the core ivw date and exit ivw date
gen ivw_date = c_ivw_date

* data is sorted in descending order by core year. I am carrying the date & year //
* of the previous (chronologically) interview into the current row
*by id: gen next_ivw_date_old = ivw_date[_n+1]
by id: gen next_ivw_year = core_year[_n+1]

by id: gen diff = core_year - core_year[_n-1] // -4 or higher denotes a gap year

bysort id: egen gap = min(diff) // using min because diff is negative
replace gap = abs(gap) // max number of years between consecutive core
levelsof id if gap>4, local(misscore)

gen miss_core = .
label var miss_core "Missing consecutive core ivw, to be dropped"
foreach x of local misscore {

replace miss_core = 1 if id=="`x'"
}

drop obs gap diff
gen year = core_year // combines exit_year & core_year into a single variable

* Merge with dementia dataset

merge 1:1 id core_year using "E:\data\hrs_public_2014\dementia\pdem_withvarnames_00_14.dta", keepus(pdem)
drop if _m==2

gen dementia = 0
replace dementia = 1 if pdem>=.5 & pdem!=.
cap drop _m

tempfile core
save `core'

use r01_a.dta, clear
append using "`core'" // appending to exit/tracker 
gen no_core = .
label var no_core "No core ivw 2000-14, to be dropped"
foreach x of global nocore1 {

replace no_core = 1 if id=="`x'"

}

* Data is currently in long form, with one row for exit and a row for each core

save r01_b.dta, replace

/****** Imputing core for people with a 4 year gap between ivws *******/

use r01_b.dta, clear

levelsof id if no_exit==1, local(noexit)

foreach x of local noexit {

replace no_exit = 1 if id=="`x'"
}

/*
preserve
keep if no_exit==1
save noexit.dta, replace
restore
drop if no_exit==1
*/


gen year_ci = core_year 
replace year_ci = index_year if nflag==0
label var year_ci "core_year(if nflag>0) or index_year(if nflag=0)"
gsort id -year_ci // year = combined core_year & index_year
by id: gen obs=_n

cap drop nflag 
gen nflag = obs - 1
label var nflag "Interview type, 0 = exit, 1 = N1, etc."

gen dem_cohort = 0
label var dem_cohort "Probable Dementia at N1"
levelsof id if dementia==1 & nflag==1, local(demlist)

foreach x of local demlist {
replace dem_cohort = 1 if id=="`x'"
}

gen core_4yr = index_year - c_ivw_year if obs==2

/* 

* Final R01 dataset requires everyone to have a core ivw within 4 (calendar) years of death
* But their exit ivw may be further away. The date of exit is irrelevant for ivw spacing
* so will use their date of death instead

Funky stuff: People who have a core ivw after they have died
keep if core_4yr < 0
c_ivw_date > index_date */

preserve
keep if c_ivw_date > index_date & c_ivw_date!=. // people with core dates after ivw
keep id index_date c_ivw_date core_year proxy_core no_exit female birth_date bid_hrs_22
save check_id_xwalk.dta, replace
restore

levelsof id if (core_4yr>4 & core_4yr!=.) | core_4yr<0, local(nocore4yr)

gen nocore4yr = .
label var nocore4yr "No Core ivw within 4 years of death, to be dropped"

gen death_b4_core = .
label var death_b4_core "Has NDI/Bene DOD before Core Ivw" 


levelsof id if c_ivw_date > index_date & c_ivw_date!=., local(diedb4core)

foreach x of local diedb4core {

replace death_b4_core = 1 if id=="`x'"
}

foreach x of local nocore4yr {
replace nocore4yr = 1 if id=="`x'"
}

gsort id -year
by id: gen diff = year_ci - year_ci[_n-1] // -4 or higher denotes a gap year

replace diff = -4 if diff<=-3 & obs==2 & nocore4yr==. & no_exit==. // imputing an interview between N1 & death if N1>=3yrs prior to death
expand 2 if diff==-4, gen(imputed) 
replace year = year + 2 if imputed==1 // imputed core interview
label var imputed "imputed core interview"

drop if year > index_year & imputed==1 // dropping imputed cores after death
drop if (index_year - c_ivw_year)<=2 & imputed==1 // dropping imputed cores if person died inbetween core and exit
drop if exit_year_exit==year & imputed==1 // dropping core interviews imputed in exit years
*keep if (index_year - c_ivw_year)==2 & imputed==1
drop obs nflag

gsort id -year
by id: gen nflag = _n
replace nflag = nflag - 1

*replace year = year_ci if nflag>0
label var year "core_year(if nflag>0), exit_year(if nflag=0), includes imputed cores"


levelsof id if miss_core==1, local(misscore)
foreach x of local misscore {

replace miss_core = 1 if id=="`x'"
}

*drop if no_exit==1 & nflag==0 & imputed==1

save r01_c.dta, replace

/**************** GET OOP DATA ********************/

use r01_c.dta, clear

keep if nflag==0 & no_exit==.
keep id index_date index_year exit_year_exit year
tempfile index
save `index'

use $ooppath\oopme_final_2016.dta, clear
rename *, l
gen id=hhid+pn

merge m:1 id using "`index'", keepus(index_year index_date)
keep if _m==3 // only keep oop data for people in cohort
drop if total_oop==.

* Imputing the missing interviews (gap years) for OOP and then append to original dataset
preserve
tempfile oop_mer
save `oop_mer' // original dataset, no imputed cores
restore 

gsort id -year
by id: gen obs=_n
keep if obs<=6 // (N1 - N4 + baseline + extra ivw)
by id: gen diff = year - year[_n-1] // -4 or higher denotes a gap year
replace diff = -4 if diff<=-4 & obs==2 // recoding people with >4 gap between exit and N1 to be 4yrs

expand 2 if diff==-4, gen(ooptag) //created imputed interview
replace year = year + 2 if ooptag==1
gsort id -year
cap drop obs
by id: gen obs=_n

by id: gen total_imp_a = total_oop[_n+1] if ooptag==1
by id: gen total_imp_b = (total_oop[_n+1] + total_oop[_n-1])/2 if ooptag==1

label var ooptag "imputed oop"
keep if ooptag==1 // keep only imputed cores and then append to original dataset
tempfile imputed
save `imputed'

use "`oop_mer'", clear

append using "`imputed'"
cap drop _m 
preserve
drop if iwtype==1 // dropping exit so it can be merged separately (see below)

tempfile oop
save `oop'
restore 

keep if iwtype==1

gen nflag = 0

foreach x of varlist total* {

rename `x' `x'_exit
}
rename year exit_year_exit

tempfile oop_exit
save `oop_exit'

cd $datapath 

use r01_c.dta, clear
cap drop _m
merge 1:1 id year using "`oop'", keepus(total* ooptag)
drop if _m==2
cap drop _m

merge 1:1 id nflag using "`oop_exit'", keepus(total* ooptag)

drop if _m==2
cap drop _m


save r01_d.dta, replace

/************ Get Helper data ***********/

/* Helper hours imputation follows the same logic as the OOP, but structure is
slighty different. Everyone has OOP data for their core ivw, so missing oop = missing core.
But not everyone has helper data for their core, so missing helper != missing core */

use r01_d.dta, clear

*dropping the people missing consecutive cores before merging with helper data

keep if miss_core==. & no_exit==. // keep only people not missing consecutive cores and have an exit
keep id index_date index_year exit_year_exit year imputed nflag
tempfile index
save `index'


use "E:\data\hrs_cleaned\helper_hours_2016.dta" , clear
*gen id=hhid+pn 
*rename year core_year
//cap number of hours at 720 (24 hrs for 30 days) for spouses and other informal
/*
foreach x in s u {
replace hlphrs_`x'=720 if hlphrs_`x'>720
replace hlphrs_`x' = 0 if hlphrs_`x'==.
}
*/

*replace hlphrs_i= 720 if hlphrs_i>=720 & hlphrs_i!=.

merge m:1 id year using "`index'"
drop if _m==1


* Imputing 0 helper hours for interviews with no helper data 
replace ivw_type = 2 if exit_year_exit==year //_m==2
foreach x in i u s k {
replace hlphrs_`x' = 0 if _m==2
}
*cap drop _m

gsort id -year
by id: gen obs=_n
* Imputations, Method A (Carry forward) and Method B (Ave prior and later ivws to fill gap)

foreach x in i u s k {

*by id: gen hlphrs_`x'_a = hlphrs_`x'[_n+1] if imputed==1
by id: gen hlphrs_`x'_b = (hlphrs_`x'[_n+1] + hlphrs_`x'[_n-1])/2 if imputed==1 // if there is no _n+1 then this returns missing

}

preserve
drop if ivw_type==2
tempfile help
save `help'
restore 

keep if ivw_type==2

foreach x of varlist hlphrs_* {

rename `x' `x'_exit
}

tempfile hlp_exit 
save `hlp_exit'

use r01_d.dta, clear
cap drop _m
merge 1:1 id nflag using "`help'", keepus(hlphrs_*)
drop if _m==2

cap drop _m

merge 1:1 id nflag using "`hlp_exit'", keepus(hlphrs_*) update

drop if _m==2
cap drop _m

save r01_e.dta, replace

/****** Imputing Interview dates for imputed core interviews ******/

use r01_e.dta, clear

*gen core_b4_death = 0
*replace core_b4_death = 1 if nflag==1

gsort id nflag
cap drop ivw_date
gen ivw_date = c_ivw_date
replace ivw_date = index_date if nflag==0
by id: gen old_ivw_date = ivw_date[_n-1] 

gen new_ivw_days = old_ivw_date - c_ivw_date
replace new_ivw_days = new_ivw_days/2
replace new_ivw_days = 730 if imputed==1 & new_ivw_days>730 & nflag==1 ////// capping interview gap to 2yrs.. possible gap in coverage?

replace new_ivw_days = ceil(new_ivw_days)
replace ivw_date = c_ivw_date + new_ivw_days if imputed==1 //c_ivw is date for core prior to gap
replace c_ivw_year = year(ivw_date)
replace c_ivw_month = month(ivw_date)
replace c_ivw_date = ivw_date if imputed==1

format %td ivw_date old_ivw_date

replace c_ivw_year=9999 if (miss_core==1 | no_exit==1) & c_ivw_year==. // need to create a value since cannot merge with missing values
/*
preserve
keep if miss_core==1 | no_exit==1
tempfile tempdrop
save `tempdrop'

restore
drop if miss_core==1 | no_exit==1
*/
* Get years before the interview to multiply by Genworth hourly rate  
gen c_ivw_year_n0 = c_ivw_year
replace c_ivw_year_n0 = index_year if nflag==0
gen c_ivw_year_n1 = c_ivw_year_n0 - 1
label var c_ivw_year_n1 "calendar year prior to ivw date"
gen c_ivw_year_n2 = c_ivw_year_n0 - 2
label var c_ivw_year_n2 "calendar year 2 yrs prior to ivw date"

save r01_f.dta, replace

/************** Get State information *************/

use r01_f.dta, clear
keep id

duplicates drop id, force
tempfile id
save `id'

// creating CPI-U 
clear
set obs 21
gen obs = _n
gen year = .
gen cpi_rate = .

forvalues i=1/21 {

replace year = 2017 - `i' if obs==`i'

}

replace cpi_rate = 1 if year==2016
replace cpi_rate=1.01262 if year==2015
replace cpi_rate=1.01382 if year==2014
replace cpi_rate=1.03026 if year==2013
replace cpi_rate=1.04535 if year==2012
replace cpi_rate=1.06699 if year==2011
replace cpi_rate=1.10067 if year==2010
replace cpi_rate=1.11872 if year==2009
replace cpi_rate=1.11474 if year==2008
replace cpi_rate=1.15754 if year==2007
replace cpi_rate=1.19051 if year==2006
replace cpi_rate=1.22891 if year==2005
replace cpi_rate=1.27055 if year==2004
replace cpi_rate=1.30439 if year==2003
replace cpi_rate=1.33411 if year==2002
replace cpi_rate=1.35521 if year==2001
replace cpi_rate=1.39377 if year==2000
replace cpi_rate=1.44062 if year==1999
replace cpi_rate=1.47244 if year<=1998

rename year c_ivw_year
label var cpi_rate "Inflation adjustment factor"
tempfile cpi
save `cpi'

// pull tracker
use "E:\data\hrs_cleaned\restr_tracker_v2014.dta", clear
drop id
gen id=hhid+pn

merge 1:1 id using "`id'"
keep if _m==3

keep hhid pn stateusps* zipcode*

gen stateusps16 = stateusps14
gen zipcode16 = zipcode14

foreach x of varlist stateusps* {

replace `x' = "" if `x'=="ZZ"

}

gen stateusps97=""
gen stateusps99=""

forvalues i= 1(2)15{
gen stateusps`i'=""
gen zipcode`i' = ""
}

forvalues i=0(2)8{
rename stateusps0`i' stateusps`i'
rename zipcode0`i' zipcode`i'
}
reshape long stateusps zipcode, i(hhid pn) j(c_ivw_year)

forvalues i=0/99{
qui replace c_ivw_year=200`i' if c_ivw_year==`i' & c_ivw_year<=9
qui replace c_ivw_year=20`i' if c_ivw_year==`i' & inrange(c_ivw_year, 10,16)
qui replace c_ivw_year=19`i' if c_ivw_year==`i' & c_ivw_year>=90
}

gen id= hhid+pn
sort id c_ivw_year
drop if id==""
by id: carryforward stateusps, replace

gsort id -c_ivw_year
by id: carryforward stateusps, replace

merge m:1 c_ivw_year using "`cpi'", keepus(cpi_rate)
cap drop _m

tempfile state
save "`state'"

rename c_ivw_year c_ivw_year_n1
rename stateusps stateusps_n1
rename cpi_rate cpi_rate_n1
tempfile state_n1
save `state_n1'

rename c_ivw_year_n1 c_ivw_year_n2
rename stateusps_n1 stateusps_n2 
rename cpi_rate_n1 cpi_rate_n2
tempfile state_n2
save `state_n2'

use R01_f.dta, clear
merge m:1 id c_ivw_year using "`state'"
drop if _m==2
cap drop _m
merge m:1 id c_ivw_year_n1 using "`state_n1'"
drop if _m==2
cap drop _m
merge m:1 id c_ivw_year_n2 using "`state_n2'"
drop if _m==2
cap drop _m

save R01_g.dta, replace

//merging with the Genworth/Metlife hourly home health aide cost. 
import excel "E:\data\burden_dementia\ref_data\Cost Care Survey (Genworth-Metlife)\HHA_hourly_genworth.xlsx", sheet("Sheet1") firstrow clear

rename A c_ivw_year
rename B stateusps
rename HomeHealthAideServicesHourly state_hha
rename MedianHourlyRate hr_rate

drop if c_ivw_year==.
destring hr_rate, replace

expand 2 if c_ivw_year==1998, gen(duptag)

replace c_ivw_year = c_ivw_year - 1 if duptag==1
cap drop duptag

expand 2 if c_ivw_year==1997, gen(duptag)

replace c_ivw_year = c_ivw_year - 1 if duptag==1
drop duptag

rename c_ivw_year c_ivw_year_n0

tempfile rate
save "`rate'" // hourly rate for calendar c_ivw_year of i

rename c_ivw_year_n0 c_ivw_year_n1
rename stateusps stateusps_n1
rename state_hha state_hha_n1
rename hr_rate hr_rate_n1

tempfile rate_n1
save "`rate_n1'"

rename c_ivw_year_n1 c_ivw_year_n2
rename stateusps_n1 stateusps_n2
rename state_hha_n1 state_hha_n2
rename hr_rate_n1 hr_rate_n2

tempfile rate_n2
save "`rate_n2'"

use R01_g.dta, clear
cap drop _m
merge m:1 c_ivw_year_n0 stateusps using "`rate'"
drop if _m==2
cap drop _m
merge m:1 c_ivw_year_n1 stateusps_n1 using "`rate_n1'"
drop if _m==2
cap drop _m
merge m:1 c_ivw_year_n2 stateusps_n2 using "`rate_n2'"
drop if _m==2
cap drop _m

save R01_h.dta, replace

/********** Final Calculations For Sample Derivation *********/

use R01_h.dta, clear

gsort id nflag

by id: gen next_ivw_date = ivw_date[_n+1] // bringing forward date from prior core away from death

format %td next_ivw_date

gen n1_2_death = index_date - c_ivw_date if nflag==1
replace n1_2_death = n1_2_death * 0.0329
replace n1_2_death = ceil(n1_2_death)
replace n1_2_death = 24 if n1_2_death>=24 & n1_2_death!=.
replace n1_2_death = 1 if n1_2_death<=0

gen core_b4_death = 0
replace core_b4_death = 1 if nflag==1

gsort id -core_b4_death

gen n1_ivw_date = c_ivw_date if nflag==1

by id: carryforward n1_2_death n1_ivw_date, replace



gen ivw_time = ivw_date - next_ivw_date
replace ivw_time = ivw_time * 0.0329
label var ivw_time "Months between previous ivw & current ivw"

gen n1_2_ivw = n1_ivw_date - ivw_date
replace n1_2_ivw = n1_2_ivw * 0.0329
label var n1_2_ivw "Months between current ivw & N1 interview"



gen last_core = 1 if ivw_time==. & nflag>0
label var last_core "Last observable core, ivw_time imputed at 24 months"
replace ivw_time = 24 if ivw_time==. & nflag>0

sum ivw_time if nflag>0
/*Average time between core ivws is 24 months. So if we subtract ivw date from death, 
only need it to be >=60 since interview data extends ~24 months back */

gen months_obs = n1_2_ivw + ivw_time + n1_2_death
replace months_obs = ceil(months_obs) // round up to keep integers. Makes subsequent math easier
label var months_obs "# of months person is observed in sample"

gen hrs_gte_84m = 0
replace hrs_gte_84m = 1 if months_obs>=83.5 & months_obs!=.
label var hrs_gte_84m ">=84 months of HRS ivw data"

gen hrs_gte_60m = 0
replace hrs_gte_60m = 1 if months_obs>=60 & months_obs!=.

levelsof id if hrs_gte_60m, local(moredata)
foreach x of local moredata {
replace hrs_gte_60m = 1 if id=="`x'"
}

gen hrs_lt_60m = .
replace hrs_lt_60m = 1 if hrs_gte_60m==0
label var hrs_lt_60m "<60m of HRS ivw data, to be dropped"



levelsof id if hrs_gte_84m, local(havedata)
foreach x of local havedata {
replace hrs_gte_84m = 1 if id=="`x'"
}

gen hrs_lt_84m = .
replace hrs_lt_84m = 1 if hrs_gte_84m==0
label var hrs_lt_84m "<84 months of HRS ivw data, to be dropped"

gen ffs_84m = 0
replace ffs_84m = 1 if cont_ffs_n_mos>=84 & cont_ffs_n_mos!=. & nflag==0
label var ffs_84m "84 months of continuous FFS prior to death"


gen ffs_60m = 0
replace ffs_60m = 1 if cont_ffs_n_mos>=60 & cont_ffs_n_mos!=. & nflag==0
label var ffs_84m "60 months of continuous FFS prior to death"


gen has_imputed = imputed
label var has_imputed "Has an imputed core ivw"

local samplevars age_lt_72 age_lt_70 no_exit miss_core no_core nocore4yr hrs_lt_84m hrs_lt_60m has_imputed death_b4_core ffs_84m ffs_60m 

foreach x of local samplevars {

levelsof id if `x'==1, local(samp)

foreach y of local samp {

replace `x'=1 if id=="`y'"
replace `x'=0 if `x'!=1

}
} 

save R01_i.dta, replace


H="Sample derivation"
clear all
capture log close

global datapath "E:\data\burden_dementia\int_data"
local logpath "E:\data\burden_dementia\logs"
global ooppath "E:\data\burden_dementia\oopdata"
global output "E:\projects\burden_dementia\archive logs"

log using `logpath'\sample_derivation.txt, text replace
cd $datapath

use R01_i.dta, clear


local deri age_lt_72 no_exit miss_core no_core nocore4yr hrs_lt_84m death_b4_core

gen final = 1
label var final "Sample Size, includes decedents w/imputed core"

foreach x of local deri {
replace final = 0 if `x'==1
}

gen final_ffs = 0
replace final_ffs = 1 if final==1 & ffs_84m==1
label var final_ffs "84m FFS Sample Size, includes decedents w/imputed core"

gen final_noimp = 0
replace final_noimp = 1 if final==1 & has_imputed==0
label var final_noimp "Sample Size, excludes decedents with imputed core"

gen final_noimp_ffs = 0
replace final_noimp_ffs = 1 if final_noimp==1 & ffs_84m==1
label var final_noimp_ffs "84m FFS Sample Size, excludes decedents with imputed core"

preserve
keep if nflag==0

gen all = 1
label var all "All HRS respondents Deceased 2004-2015"

local full all age_lt_72 no_exit miss_core no_core nocore4yr death_b4_core hrs_lt_84m final final_noimp final_ffs final_noimp_ffs

local rd: word count `full'

mat tab1 = J(`rd',3,.)

local r = 1

foreach x of local full {

sum `x'
mat tab1[`r',1] = r(sum)

sum `x' if dem_cohort==1
mat tab1[`r',2] = r(sum)

sum `x' if dem_cohort==0
mat tab1[`r',3] = r(sum)

local ++r
}

mat rownames tab1 = `full'


frmttable using "E:\projects\burden_dementia\archive logs\Sample_Derivation.doc", replace statmat(tab1) ///
varlabels title("Sample Derivation for R01 (Deceased 2004-2015, Age 72+)") ctitles("Reason for Exclusion" "All" "Dementia" "Non-Dementia") sdec(0) ///
annotate(stars) asymbol(*,**)note("Death Date was determined by NDI, Medicare MBSF or HRS Exit in that order. Reasons for exclusion are NOT mutally exclusive.")


/**** */


local full1 age_lt_72 no_exit miss_core no_core nocore4yr hrs_lt_84m death_b4_core
local full2 final final_noimp final_ffs final_noimp_ffs

local rd: word count 1 `full1' `full2'

mat tab1 = J(`rd',3,.)

sum all
mat tab1[1,1] = r(sum)

sum all if dem_cohort==1
mat tab1[1,2] = r(sum)

sum all if dem_cohort==0
mat tab1[1,3] = r(sum)


local r = 2

foreach x of local full1 {

sum `x'
mat tab1[`r',1] = r(sum)

sum `x' if dem_cohort==1
mat tab1[`r',2] = r(sum)

sum `x' if dem_cohort==0
mat tab1[`r',3] = r(sum)

drop if `x'==1
local ++r
}

foreach x of local full2 {

sum `x'
mat tab1[`r',1] = r(sum)

sum `x' if dem_cohort==1
mat tab1[`r',2] = r(sum)

sum `x' if dem_cohort==0
mat tab1[`r',3] = r(sum)

local ++r
}




mat rownames tab1 = all `full1' `full2'


frmttable using "E:\projects\burden_dementia\archive logs\Sample_Derivation.doc", addtable statmat(tab1) ///
varlabels title("Sample Derivation for R01 (Deceased 2004-2015, Age 72+)") ctitles("Reason for Exclusion" "All" "Dementia" "Non-Dementia") sdec(0) ///
annotate(stars) asymbol(*,**)note("Death Date was determined by NDI, Medicare MBSF or HRS Exit in that order. Reasons for exclusion are ARE mutally exclusive.")

cap log close


restore
keep if final==1
save R01_j.dta, replace




H="Annual Calculations"

/**************** calculations *********************/
clear all
capture log close

global datapath "E:\data\burden_dementia\int_data"
local logpath "E:\data\burden_dementia\logs"
global ooppath "E:\data\burden_dementia\oopdata"
global output "E:\projects\burden_dementia\archive logs"


log using `logpath'\R01_annual_calculations.txt, text replace

cd $datapath

use R01_j.dta, clear

/*
gen n1_2_death = index_date - c_ivw_date if nflag==1
replace n1_2_death = n1_2_death * 0.0329
replace n1_2_death = ceil(n1_2_death)
replace n1_2_death = 24 if n1_2_death>=24 & n1_2_death!=.
replace n1_2_death = 1 if n1_2_death<=0

gen core_b4_death = 0
replace core_b4_death = 1 if nflag==1

gsort id -core_b4_death

by id: carryforward n1_2_death, replace
*/
gen death_cat = .
replace death_cat = 1 if n1_2_death<12
replace death_cat = 2 if n1_2_death==12
replace death_cat = 3 if n1_2_death>12

cap drop mar_n0 mar_n1 mar_n2
cap drop mar

gen mar_n0 = . //months observed (aka "at risk") within a calendar year for helper hours cost imputation
gen mar_n1 = .
gen mar_n2 = .

replace mar_n0 = index_month if nflag==0
replace mar_n0 = n1_2_death if (n1_2_death-mar_n0 < 0) & nflag==0 // if they died the same year as their N1 ivw, then

replace mar_n1 = n1_2_death - mar_n0 if nflag==0
replace mar_n1 = 0 if mar_n1<0 & nflag==0
replace mar_n1 = 12 if (mar_n1>12 & mar_n1!=.) & nflag==0

replace mar_n2 = n1_2_death - mar_n0 -mar_n1 if nflag==0
replace mar_n2 = 0 if mar_n2<0


replace mar_n0 = c_ivw_month if nflag>0
replace mar_n1 = ivw_time - c_ivw_month if nflag>0
replace mar_n1 = 0 if mar_n1<0 & nflag>0
replace mar_n1 = 12 if (mar_n1>12 & mar_n1!=.) & nflag>0

replace mar_n2 = ivw_time - 12 - c_ivw_month if nflag>0
replace mar_n2 = 0 if mar_n2<0 & nflag>0
*replace mar_n2 = 12 if (mar_n2>12 & mar_n2!=.) & nflag>0

gen mar = mar_n0+mar_n1+mar_n2
corr mar n1_2_death if nflag==0
corr mar ivw_time if nflag>0 // checks to see if months at risk (mar) = months between ivw

gsort id +nflag

gen hlp_cost = hlphrs_i
replace hlp_cost = hlphrs_i_exit if nflag==0
replace hlp_cost = hlphrs_i_b if imputed==1

replace hlp_cost = 720 if hlp_cost>720 // capping hlphrs to 24 hours per day for each person

by id: gen hlp_cost_n = hlp_cost[_n+1]

/* Helper hours are currently 30 day estimates. Will create ~2 year totals using the
4 months at current ivw + remainder months*((current+previous)/2) */

gen hlp_cost_ivw = .
replace hlp_cost_ivw = n1_2_death*hlp_cost if n1_2_death<=4 & nflag==0
replace hlp_cost_ivw = (4*hlp_cost) + (n1_2_death-4)*((hlp_cost+hlp_cost_n)/2) if n1_2_death>4 & nflag==0
replace hlp_cost_ivw = (4*hlp_cost) + (ivw_time-4)*((hlp_cost+hlp_cost_n)/2) if nflag>0 & hlp_cost_n>0
replace hlp_cost_ivw = (4*hlp_cost) if nflag>0 & (hlp_cost_n==0 | hlp_cost_n==.)


egen hr_mean = mean(hr_rate)
egen hr_mean_n1 = mean(hr_rate_n1)
egen hr_mean_n2 = mean(hr_rate_n2)

replace hr_rate = hr_mean if hr_rate==.
replace hr_rate_n1 = hr_mean_n1 if hr_rate_n1==.
replace hr_rate_n2 = hr_mean_n2 if hr_rate_n2==.

foreach x of varlist hlp_cost_ivw  {

replace `x' = `x'/n1_2_death if nflag==0
replace `x' = `x'/ivw_time if nflag>0
replace `x' = (`x'*mar_n0*hr_rate) +  (`x'*mar_n1*hr_rate_n1) + (`x'*mar_n2*hr_rate_n2)

}


gen oop_cost = total_oop
replace oop_cost = total_imp_b if imputed==1
replace oop_cost = total_oop_exit if nflag==0

replace ivw_time = ceil(ivw_time)
replace ivw_time = 1 if ivw_time==0 & nflag==0

// Combining original OOP and imputed OOP into a single variable 


keep id death_cat nflag oop_cost hlp_cost_ivw n1_2_death c_ivw_year ivw_time

reshape wide oop_cost hlp_cost_ivw c_ivw_year ivw_time, i(id) j(nflag)


gen a = n1_2_death
gen b = ivw_time1
gen c = ivw_time2
gen d = ivw_time3
gen e = ivw_time4

*keep if death_cat<3

/* Year 1 cost imputation */


gen oop_y1 = ((a*oop_cost0)/ivw_time0) + (((12-a)*oop_cost1)/ivw_time1) if death_cat<=2
gen informal_y1 = ((a*hlp_cost_ivw0)/ivw_time0) + (((12-a)*hlp_cost_ivw1)/ivw_time1) if death_cat<=2

replace oop_y1 = ((12*oop_cost0)/ivw_time0) if death_cat==3
replace informal_y1 = ((12*hlp_cost_ivw0)/ivw_time0) if death_cat==3

replace b = b-(12-a) if death_cat<=2 // subtract the amount of months of N1 ivw that was used in Year 1
replace a = a - 12 if death_cat==3
replace a = 0 if death_cat<3

/* Year 2 cost */


gen oop_y2 = ((a*oop_cost0)/ivw_time0) +  (((12-a)*oop_cost1)/ivw_time1) if death_cat==3

gen informal_y2 = ((a*hlp_cost_ivw0)/ivw_time0) +  (((12-a)*hlp_cost_ivw1)/ivw_time1) if death_cat==3


replace b = b-(12-a) if death_cat==3

replace oop_y2 = ((b*oop_cost1)/ivw_time1) if b>=12 & death_cat<3
replace oop_y2 = ((b*oop_cost1)/ivw_time1) + (((12-b)*oop_cost2)/ivw_time2) if b<12 & death_cat<3


replace informal_y2 = ((b*hlp_cost_ivw1)/ivw_time1) if b>=12 & death_cat<3
replace informal_y2 = ((b*hlp_cost_ivw1)/ivw_time1) + (((12-b)*hlp_cost_ivw2)/ivw_time2) if b<12 & death_cat<3


replace c = c-(12-b) if b<12 & death_cat<2 // if b<12, part of the year came from N2 and needs to be subtracted
replace b = 0 if b<12 & death_cat<2 // recoding b to 0 to show that N1 interview will no longer contribute to cost
replace b = b-12 if b>=12 & death_cat<2 // if b>=12, used a full year of data from N1


/* Year 3 cost */

gen oop_y3 = ((b*oop_cost1)/ivw_time1) if b>=12
replace oop_y3 = ((b*oop_cost1)/ivw_time1) + (((12-b)*oop_cost2)/ivw_time2) if b<12


gen informal_y3 = ((b*hlp_cost_ivw1)/ivw_time1) if b>=12
replace informal_y3 = ((b*hlp_cost_ivw1)/ivw_time1) + (((12-b)*hlp_cost_ivw2)/ivw_time2) if b<12


replace c = c-(12-b) if b<12 // if b<12, part of the year came from N2 and needs to be subtracted
replace b = 0 if b<12 // recoding b to 0 to show that N1 interview will no longer contribute to cost
replace b = b-12 if b>=12 // if b>=12, used a full year of data from N1


/* Year 4 cost */

tab b
tab ivw_time1 /* not sure why so many people have >24 months attributed to 1 interview
there are weird cases e.g. 2010 core has a 2011 ivw date, so it ends up being ~ 3 years
between 2008 core and 2010. But expecting those to be in the minority */

*replace b = 12 if b>12 // need to remove and properly fix later

gen oop_y4 = ((b*oop_cost1)/ivw_time1) + (((12-b)*oop_cost2)/ivw_time2) if b>0 & b<=12 // if b = 12 the second term is zero
gen informal_y4 = ((b*hlp_cost_ivw1)/ivw_time1) + (((12-b)*hlp_cost_ivw2)/ivw_time2) if b>0 & b<=12 // if b = 12 the second term is zero

replace oop_y4 = ((b*oop_cost1)/ivw_time1) if b>=12
replace informal_y4 = ((b*hlp_cost_ivw1)/ivw_time1) if b>=12

gen tempflag = 1 if oop_y4!=.

replace c = c-(12-b) if b>0 & b<12 & tempflag==1 // if b<12, part of the year came from N2 and needs to be subtracted
replace b = 0 if b<12 & tempflag==1 // recoding b to 0 to show that N1 interview will no longer contribute to cost
replace b = b-12 if b>=12 & tempflag==1 // if b>=12, used a full year of data from N1

tab b


replace oop_y4 = ((c*oop_cost2)/ivw_time2) + (((12-c)*oop_cost3)/ivw_time3) if c<=12 & oop_y4==.
replace oop_y4 = ((c*oop_cost2)/ivw_time2) if c>12 & oop_y4==.

replace informal_y4 = ((c*hlp_cost_ivw2)/ivw_time2) + (((12-c)*hlp_cost_ivw3)/ivw_time3) if c<=12 & informal_y4==.
replace informal_y4 = ((c*hlp_cost_ivw2)/ivw_time2) if c>12 & informal_y4==.

replace d = d - (12-c) if c<12 & tempflag==.
replace c = 0 if c<12 & tempflag==.
replace c = c - 12 if c>=12 & tempflag==.

drop tempflag

/* Year 5 */

tab b

gen oop_y5 = ((b*oop_cost1)/ivw_time1) + (((12-b)*oop_cost2)/ivw_time2) if b>0 & b<=12
gen informal_y5 = ((b*hlp_cost_ivw1)/ivw_time1) + (((12-b)*hlp_cost_ivw2)/ivw_time2) if b>0 & b<=12 

replace oop_y5 = ((b*oop_cost1)/ivw_time1) if b>=12
replace informal_y5 = ((b*hlp_cost_ivw1)/ivw_time1) if b>=12

gen tempflag = 1 if oop_y5!=.

replace c = c-(12-b) if b>0 & b<12 & tempflag==1 // if b<12, part of the year came from N2 and needs to be subtracted
replace b = 0 if b<12 & tempflag==1 // recoding b to 0 to show that N1 interview will no longer contribute to cost
replace b = b-12 if b>=12 & tempflag==1 // if b>=12, used a full year of data from N1

replace oop_y5 = ((c*oop_cost2)/ivw_time2) + (((12-c)*oop_cost3)/ivw_time3) if c<=12 & oop_y5==.
replace oop_y5 = ((c*oop_cost2)/ivw_time2) if c>12 & oop_y5==.

replace informal_y5 = ((c*hlp_cost_ivw2)/ivw_time2) + (((12-c)*hlp_cost_ivw3)/ivw_time3) if c<=12 & informal_y5==.
replace informal_y5 = ((c*hlp_cost_ivw2)/ivw_time2) if c>12 & informal_y5==.

replace d = d - (12-c) if c<12 & tempflag==.
replace c = 0 if c<12 & tempflag==.
replace c = c - 12 if c>=12 & tempflag==.

drop tempflag

/* Year 6 */


gen oop_y6 = ((b*oop_cost1)/ivw_time1) + (((12-b)*oop_cost2)/ivw_time2) if b>0 & b<=12
gen informal_y6 = ((b*hlp_cost_ivw1)/ivw_time1) + (((12-b)*hlp_cost_ivw2)/ivw_time2) if b>0 & b<=12 

replace c = c-(12-b) if b>0 & b<12 & oop_y6!=. // if b<12, part of the year came from N2 and needs to be subtracted
replace b = 0 if b<12 & oop_y6!=. // recoding b to 0 to show that N1 interview will no longer contribute to cost
replace b = b-12 if b>=12 & oop_y6!=. // if b>=12, used a full year of data from N1

gen tempflag = 1 if c<=12 & oop_y6==.

replace oop_y6 = ((c*oop_cost2)/ivw_time2) + (((12-c)*oop_cost3)/ivw_time3) if c<=12 & oop_y6==.
replace informal_y6 = ((c*hlp_cost_ivw2)/ivw_time2) + (((12-c)*hlp_cost_ivw3)/ivw_time3) if c<=12 & informal_y6==.

replace d = d-(12-c) if c<12 & tempflag==1 // if b<12, part of the year came from N2 and needs to be subtracted
replace d = 0 if d<0 // temporary fix. 
replace c = 0 if c<12 & tempflag==1
replace c = c-12 if c>=12 & tempflag==1

gen tempflag1 = 1 if oop_y6==.

replace oop_y6 = ((d*oop_cost3)/ivw_time3) + (((12-d)*oop_cost4)/ivw_time4) if d<=12 & oop_y6==.
replace oop_y6 = ((d*oop_cost3)/ivw_time3) if d>12 & oop_y6==.

replace informal_y6 = ((d*hlp_cost_ivw3)/ivw_time3) + (((12-d)*hlp_cost_ivw4)/ivw_time4) if d<=12 & informal_y6==.
replace informal_y6 = ((d*hlp_cost_ivw3)/ivw_time3) if d>12 & informal_y6==.

replace e = e-(12-d) if d<12 & tempflag1==1
replace d = 0 if d<12 & tempflag1==1
replace d = d-12 if d>=12 & tempflag1==1

drop tempf*


/* Year 7 */

gen oop_y7 = ((c*oop_cost2)/ivw_time2) + (((12-c)*oop_cost3)/ivw_time3) if c>0 & c<=12 
replace oop_y7 = ((12*oop_cost2)/ivw_time2) if c>=12

replace oop_y7 = ((12*oop_cost3)/ivw_time3) if d>12 & oop_y7==.
replace oop_y7 = ((d*oop_cost3)/ivw_time3) + (((12-d)*oop_cost4)/ivw_time4) if d<=12 & oop_y7==.


gen informal_y7 = ((c*hlp_cost_ivw2)/ivw_time2) + (((12-c)*hlp_cost_ivw3)/ivw_time3) if c>0 & c<=12
replace informal_y7 = ((12*hlp_cost_ivw2)/ivw_time2) if c>12
replace informal_y7 = ((12*hlp_cost_ivw3)/ivw_time3) if d>12 & informal_y7==.
replace informal_y7 = ((d*hlp_cost_ivw3)/ivw_time3) + (((12-d)*hlp_cost_ivw4)/ivw_time4) if d<=12 & informal_y7==.




/* Visual check */

foreach x of varlist oop_y* informal_y* {

sum `x' 
}

save R01_annualized.dta, replace

log close



H="Final Sample & Table 1"
clear all
capture log close

global datapath "E:\data\burden_dementia\int_data"
global final "E:\data\burden_dementia\final_data"
local logpath "E:\data\burden_dementia\logs"
global ooppath "E:\data\burden_dementia\oopdata"
global output "E:\projects\burden_dementia\archive logs"

cd $datapath

use "E:\data\burden_dementia\int_data\predicted_annual_medicaid_costs.dta", clear

rename year index_year

tempfile predict
save `predict'


use R01_j.dta, clear

merge m:1 id using R01_annualized.dta, keepus(oop_y* informal_y*)
drop _m

merge m:1 id using tot_paid_maid.dta, keepus(tot_paid_m*)
drop if _m==2
cap drop _m

merge m:1 id index_year using `predict', keepus(buyin_mo generous)
drop if _m==2
cap drop _m



gen ffs_7yr = 0 
replace ffs_7yr = 1 if cont_ffs_n_mos>=84 & cont_ffs_n_mos!=.

gen ffs_6yr = 0 
replace ffs_6yr = 1 if cont_ffs_n_mos>=72 & cont_ffs_n_mos!=.

gen ffs_5yr = 0
replace ffs_5yr = 1 if cont_ffs_n_mos>=60 & cont_ffs_n_mos!=.

gen ffs_4yr = 0
replace ffs_4yr = 1 if cont_ffs_n_mos>=48 & cont_ffs_n_mos!=.

gen ffs_3yr = 0
replace ffs_3yr = 1 if cont_ffs_n_mos>=36 & cont_ffs_n_mos!=.

gen ffs_2yr = 0
replace ffs_2yr = 1 if cont_ffs_n_mos>=24 & cont_ffs_n_mos!=.

gen ffs_1yr = 0
replace ffs_1yr = 1 if cont_ffs_n_mos>=12 & cont_ffs_n_mos!=.


gen white = 0
replace white = 1 if race==1 & hisp_eth==0

gen black = 0
replace black = 1 if race==2 & hisp_eth==0

gen other = 0 
replace other = 1 if white==0 & black==0 & hisp_eth==0

label var white "Non-Hispanic White"
label var black "Non-Hispanic Black"
label var other "Non-Hispanic Other"

label var tot_paid_maid_n1 "Total Medicaid Spending Y1"
label var tot_paid_maid_n2 "Total Medicaid Spending Y2"
label var tot_paid_maid_n3 "Total Medicaid Spending Y3"
label var tot_paid_maid_n4 "Total Medicaid Spending Y4"
label var tot_paid_maid_n5 "Total Medicaid Spending Y5"
label var tot_paid_maid_n6 "Total Medicaid Spending Y6"
label var tot_paid_maid_n7 "Total Medicaid Spending Y7"

forvalues i = 1/7 {
rename tot_paid_maid_n`i' tot_paid_maid_y`i'
}

local y = 1
forvalues i = 12(12)84 {



rename tot_paid_by_mc_`i'm tot_paid_by_mc_y`y'

label var tot_paid_by_mc_y`y' "Total Medicare Spending Y`y'"

local ++y
}



save $final\R01_final.dta, replace

preserve 
keep if nflag==0

gen all = 1
gen no_impute= 2
replace no_impute  = 0 if has_imputed==1

local ivars female white black other hospice_exit nhres_exit married_exit reschil_d_exit resspouse_exit livealone_exit adl_independent_exit adl_severe_exit medicare_exit medicareb_exit medicaid_exit champus_exit ffs_7yr ffs_6yr ffs_5yr ffs_4yr ffs_3yr ffs_2yr ffs_1yr

local medcost age_at_death tot_paid_maid_y1 tot_paid_maid_y2 tot_paid_maid_y3 tot_paid_maid_y4 tot_paid_maid_y5 tot_paid_maid_y6 tot_paid_maid_y7 tot_paid_by_mc_y1 tot_paid_by_mc_y2 tot_paid_by_mc_y3 tot_paid_by_mc_y4 tot_paid_by_mc_y5 tot_paid_by_mc_y6 tot_paid_by_mc_y7 ///
oop_y1 oop_y2 oop_y3 oop_y4 oop_y5 oop_y6 oop_y7 informal_y1 informal_y2 informal_y3 informal_y4 informal_y5 informal_y6 informal_y7 


local rd: word count `ivars' `medcost' 1

mat tab1=J(`rd', 6,.)
mat stars=J(`rd',6,0)
local r = 1

foreach x of local ivars {

sum `x' if all==1

mat tab1[`r',1] = r(mean)*100

sum `x' if all==1 & dem_cohort==1
mat tab1[`r',2] = r(mean)*100

sum `x' if all==1 & dem_cohort==0
mat tab1[`r',3] = r(mean)*100

tab `x' dem_cohort if all==1, chi2
mat stars[`r',2] = (r(p)<.01) + (r(p)<0.05)


sum `x' if no_impute==2

mat tab1[`r',4] = r(mean)*100

sum `x' if no_impute==2 & dem_cohort==1
mat tab1[`r',5] = r(mean)*100

sum `x' if no_impute==2 & dem_cohort==0
mat tab1[`r',6] = r(mean)*100

tab `x' dem_cohort if no_impute==2, chi2
mat stars[`r',5] = (r(p)<.01) + (r(p)<0.05)


local ++r
}

foreach x of local medcost {

sum `x' if all==1 

mat tab1[`r',1] = r(mean)

sum `x' if all==1 & dem_cohort==1
mat tab1[`r',2] = r(mean)

sum `x' if all==1 & dem_cohort==0
mat tab1[`r',3] = r(mean) 

ttest `x' if all==1, by(dem_cohort)
mat stars[`r',2] = (r(p)<.01) + (r(p)<.05)


sum `x' if no_impute==2

mat tab1[`r',4] = r(mean)

sum `x' if no_impute==2 & dem_cohort==1
mat tab1[`r',5] = r(mean)

sum `x' if no_impute==2 & dem_cohort==0
mat tab1[`r',6] = r(mean) 

ttest `x' if no_impute==2, by(dem_cohort)
mat stars[`r',5] = (r(p)<.01) + (r(p)<.05)



local ++r
}


sum nflag if all==1
mat tab1[`r',1] = r(N)

sum nflag if all==1 & dem_cohort==1
mat tab1[`r',2] = r(N)

sum nflag if all==1 & dem_cohort==0
mat tab1[`r',3] = r(N)

sum nflag if no_impute==2
mat tab1[`r',4] = r(N)

sum nflag if no_impute==2 & dem_cohort==1
mat tab1[`r',5] = r(N)

sum nflag if no_impute==2 & dem_cohort==0
mat tab1[`r',6] = r(N)




mat rownames tab1 = `ivars' `medcost' N

frmttable using "E:\projects\burden_dementia\archive logs\R01_Table1.doc", replace statmat(tab1) ///
varlabels title("Summary Statistics For R01 Sample (Deceased 2004-2015, Age 72+ at Death)") ctitles("", "", "Full Sample", "", "Excludes Decedents", " w/Imputated Core", "" \"Variables", "All","Dementia","No Dementia", "All","Dementia","No Dementia"  ) sdec(2) ///
vlines(01001001) annotate(stars) asymbol(*,**)note("All costs have been inflation adjusted to 2016 dollars. <0.05*, p<0.01**")

/* FFS Only */


keep if ffs_7yr==1

local ivars female white black other hospice_exit nhres_exit married_exit reschil_d_exit resspouse_exit livealone_exit adl_independent_exit adl_severe_exit medicare_exit medicareb_exit medicaid_exit champus_exit ffs_7yr ffs_6yr ffs_5yr ffs_4yr ffs_3yr ffs_2yr ffs_1yr

local medcost age_at_death tot_paid_maid_y1 tot_paid_maid_y2 tot_paid_maid_y3 tot_paid_maid_y4 tot_paid_maid_y5 tot_paid_maid_y6 tot_paid_maid_y7 tot_paid_by_mc_y1 tot_paid_by_mc_y2 tot_paid_by_mc_y3 tot_paid_by_mc_y4 tot_paid_by_mc_y5 tot_paid_by_mc_y6 tot_paid_by_mc_y7 ///
oop_y1 oop_y2 oop_y3 oop_y4 oop_y5 oop_y6 oop_y7 informal_y1 informal_y2 informal_y3 informal_y4 informal_y5 informal_y6 informal_y7 


local rd: word count `ivars' `medcost' 1

mat tab1=J(`rd', 6,.)
mat stars=J(`rd',6,0)
local r = 1

foreach x of local ivars {

sum `x' if all==1

mat tab1[`r',1] = r(mean)*100

sum `x' if all==1 & dem_cohort==1
mat tab1[`r',2] = r(mean)*100

sum `x' if all==1 & dem_cohort==0
mat tab1[`r',3] = r(mean)*100

tab `x' dem_cohort if all==1, chi2
mat stars[`r',2] = (r(p)<.01) + (r(p)<0.05)


sum `x' if no_impute==2

mat tab1[`r',4] = r(mean)*100

sum `x' if no_impute==2 & dem_cohort==1
mat tab1[`r',5] = r(mean)*100

sum `x' if no_impute==2 & dem_cohort==0
mat tab1[`r',6] = r(mean)*100

tab `x' dem_cohort if no_impute==2, chi2
mat stars[`r',5] = (r(p)<.01) + (r(p)<0.05)


local ++r
}

foreach x of local medcost {

sum `x' if all==1 

mat tab1[`r',1] = r(mean)

sum `x' if all==1 & dem_cohort==1
mat tab1[`r',2] = r(mean)

sum `x' if all==1 & dem_cohort==0
mat tab1[`r',3] = r(mean) 

ttest `x' if all==1, by(dem_cohort)
mat stars[`r',2] = (r(p)<.01) + (r(p)<.05)


sum `x' if no_impute==2

mat tab1[`r',4] = r(mean)

sum `x' if no_impute==2 & dem_cohort==1
mat tab1[`r',5] = r(mean)

sum `x' if no_impute==2 & dem_cohort==0
mat tab1[`r',6] = r(mean) 

ttest `x' if no_impute==2, by(dem_cohort)
mat stars[`r',5] = (r(p)<.01) + (r(p)<.05)



local ++r
}


sum nflag if all==1
mat tab1[`r',1] = r(N)

sum nflag if all==1 & dem_cohort==1
mat tab1[`r',2] = r(N)

sum nflag if all==1 & dem_cohort==0
mat tab1[`r',3] = r(N)

sum nflag if no_impute==2
mat tab1[`r',4] = r(N)

sum nflag if no_impute==2 & dem_cohort==1
mat tab1[`r',5] = r(N)

sum nflag if no_impute==2 & dem_cohort==0
mat tab1[`r',6] = r(N)




mat rownames tab1 = `ivars' `medcost' N

frmttable using "E:\projects\burden_dementia\archive logs\R01_Table1.doc", addtable statmat(tab1) ///
varlabels title("Summary Statistics For R01 Sample (Deceased 2004-2015, Age 72+ at Deat, 7yrs Continuous FFS)") ctitles("", "", "Full Sample", "", "Excludes Decedents", " w/Imputated Core", "" \"Variables", "All","Dementia","No Dementia", "All","Dementia","No Dementia"  ) sdec(2) ///
vlines(01001001) annotate(stars) asymbol(*,**)note("All costs have been inflation adjusted to 2016 dollars. <0.05*, p<0.01**")


H="***************"


H="Merge Medicaid files and extract total cost"
libname raw 'E:\data\CMS_DUA_51675_2014\Received_20180307';
libname merged 'E:\data\CMS_DUA_51675_2014\Medicaid_merged';


/* Macro to pull raw individual years */

%macro import(source=);

%do i = 1999 %to 2012;

data max_&source._&i.;
set raw.hrs_max_&source._&i.;
type_of_claim1 = put(type_of_claim, $4.);
Com_based_LTC_flag1 = put(Com_based_LTC_flag, $4.);
run;

data max_&source._&i. (drop= type_of_claim Com_based_LTC_flag);
set max_&source._&i.;
run;


data max_&source._&i.;
set max_&source._&i. (rename=(type_of_claim1 = type_of_claim Com_based_LTC_flag1 = Com_based_LTC_flag));
run;

%end;



%mend import;


/* Macro to merge years into single file */

%macro merge(source=);

data merged.hrs_max_&source._99_12;
set max_&source._1999 max_&source._2000 max_&source._2001 max_&source._2002 max_&source._2003 max_&source._2004
max_&source._2005 max_&source._2006 max_&source._2007 max_&source._2008 max_&source._2009 max_&source._2010
max_&source._2011 max_&source._2012;
run;

%mend merge;


%import(source=ip);
%import(source=ot);
%import(source=lt);
%import(source=rx);

%merge(source=ip);
%merge(source=ot);
%merge(source=lt);
%merge(source=rx);

%macro importps(source=);

%do i = 1999 %to 2012;

data max_&source._&i.;
set raw.hrs_max_&source._&i.;
Restricted_benefits_mo_01a = strip(put(Restricted_benefits_mo_01, 8.));
Restricted_benefits_mo_02a = strip(put(Restricted_benefits_mo_02, 8.));
Restricted_benefits_mo_03a = strip(put(Restricted_benefits_mo_03, 8.));
Restricted_benefits_mo_04a = strip(put(Restricted_benefits_mo_04, 8.));
Restricted_benefits_mo_05a = strip(put(Restricted_benefits_mo_05, 8.));
Restricted_benefits_mo_06a = strip(put(Restricted_benefits_mo_06, 8.));
Restricted_benefits_mo_07a = strip(put(Restricted_benefits_mo_07, 8.));
Restricted_benefits_mo_08a = strip(put(Restricted_benefits_mo_08, 8.));
Restricted_benefits_mo_09a = strip(put(Restricted_benefits_mo_09, 8.));
Restricted_benefits_mo_10a = strip(put(Restricted_benefits_mo_10, 8.));
Restricted_benefits_mo_11a = strip(put(Restricted_benefits_mo_11, 8.));
Restricted_benefits_mo_12a = strip(put(Restricted_benefits_mo_12, 8.));
Eligible_months1 = strip(put(Eligible_months, 8.));
Private_insurance_months1 = strip(put(Private_insurance_months, 8.));
run;


data max_&source._&i. (drop= Restricted_benefits_mo_01 Restricted_benefits_mo_02 Restricted_benefits_mo_03 Restricted_benefits_mo_04 Restricted_benefits_mo_05 Restricted_benefits_mo_06
Restricted_benefits_mo_07 Restricted_benefits_mo_08 Restricted_benefits_mo_09 Restricted_benefits_mo_10 Restricted_benefits_mo_11 Restricted_benefits_mo_12 Eligible_months Private_insurance_months);
set max_&source._&i.;
run;

%end;



%mend importps;


%importps(source=ps);
%merge(source=ps);


H="Calculate annual Medicaid cost for years prior to death"
use "E:\data\burden_dementia\int_data\medicaid_cost_raw.dta", clear



/* Flag year markers, n1=[0,-12], n2=[-12,-24], n3=[-24,-36], etc. */

gen n1_flag = 0
replace n1_flag = 1 if (index_year==year) | (year==index_year-1)

gen n2_flag = 0
replace n2_flag = 1 if (year==index_year-1) | (year==index_year-2)

gen n3_flag = 0
replace n3_flag = 1 if (year==index_year-2) | (year==index_year-3)

gen n4_flag = 0
replace n4_flag = 1 if (year==index_year-3) | (year==index_year-4)

gen n5_flag = 0
replace n5_flag = 1 if (year==index_year-4) | (year==index_year-5)

gen index_day = day(index_date)

/* inflation adjustment */

gen rate = .

replace rate=1 if year==2014
replace rate=1.01622 if year==2013
replace rate=1.03111 if year==2012
replace rate=1.05245 if year==2011
replace rate=1.08567 if year==2010
replace rate=1.10347 if year==2009
replace rate=1.09955 if year==2008
replace rate=1.14177 if year==2007
replace rate=1.17429 if year==2006
replace rate=1.21217 if year==2005
replace rate=1.25323 if year==2004
replace rate=1.28661 if year==2003
replace rate=1.31593 if year==2002
replace rate=1.33674 if year==2001
replace rate=1.37477 if year==2000
replace rate=1.42098 if year==1999
replace rate=1.45237 if year==1998
forvalues p = 1/12 {

replace _`p' = _`p'*rate
}

*levelsof bid_hrs_23, local(bid_check)

*foreach x of local bid_check { 

forvalues t=1/12 {

preserve
keep if index_month==`t'

forvalues i=1/5 {

gen sum_n`i'_cyr= 0 if n`i'_flag==1 /*sum months before index month in current year*/

local j = index_month
local k = 1


	while `k' <= `j' { // while current month less than or equal index, add to past value
		while `k' < `j' {
			replace sum_n`i'_cyr = sum_n`i'_cyr + _`k' if sum_n`i'_cyr!=.
			local ++k
		}
	    replace sum_n`i'_cyr = sum_n`i'_cyr + (_`k')*(index_day/30.4) if sum_n`i'_cyr!=. // if current month = index, then prorate it
		local ++k
}

gen sum_n`i'_b4yr = 0 if n`i'_flag==1

local r = index_month
local s = 12
	while `s' >=`r' { // count backwards to get months before index in previous year
		while `s' > `r' {
		replace sum_n`i'_b4yr = sum_n`i'_b4yr + _`s' if sum_n`i'_b4yr!=.
		local --s
	}
	
	replace sum_n`i'_b4yr = sum_n`i'_b4yr + (_`s')*(1-(index_day/30.4)) if sum_n`i'_b4yr!=.
	local --s
	}
	


}
keep if n1_flag | n2_flag | n3_flag | n4_flag | n5_flag


gsort +id +year


forvalues i=1/5 {

gen tot_paid_maid_n`i' = sum_n`i'_cyr + sum_n`i'_b4yr[_n-1]
}

keep id index_date bid_hrs_23 index_year year n*_flag tot_paid_maid_n* 
save mc_costs_`t'.dta, replace

restore

}


H="Creating Medicaid files for 1-5 years prior to index"
libname clean 'E:\data\hrs_cleaned'; 
libname medi 'E:\data\CMS_DUA_51675_2014\Medicaid_merged';
libname dmouth 'E:\data\Dartmouth_misc';

/*rand data path*/
libname rand 'E:\data\hrs_public_2012\rand2012\main';

libname proj_int 'E:\data\burden_dementia\int_data';
libname proj_fin 'E:\data\burden_dementia\final_data';
libname proj_ref 'E:\data\burden_dementia\ref_data';



data hrs_max_1;
set proj_int.hrs_max_ip_meet_60m;
diff=index_date-bdos;
run;

data hrs_max_2;
set proj_int.hrs_max_lt_meet_60m;
diff=index_date-bdos;
run;

data hrs_max_3;
set proj_int.hrs_max_ot_meet_60m;
diff=index_date-bdos;
run;

data hrs_max_4;
set proj_int.hrs_max_rx_meet_60m;
diff=index_date-pfd;
bdos=pfd;
run;

%macro plus;
%do i=1 %to 4;

data a1yr&i.;
set hrs_max_&i.;
	where diff>0 and diff<365;
run;

data a2yr&i.;
set hrs_max_&i.;
	where diff>365 and diff<730;
run;

data a3yr&i.;
set hrs_max_&i.;
	where diff>730 and diff<1095;
run;

data a4yr&i.;
set hrs_max_&i.;
	where diff>1095 and diff<1460;
run;

data a5yr&i.;
set hrs_max_&i.;
	where diff>1460 and diff<1825;
run;



proc sort data= a1yr&i.; 
by bid_hrs_23 bdos;
run;

proc sort data= a2yr&i.; 
by bid_hrs_23 bdos;
run;

proc sort data= a3yr&i.; 
by bid_hrs_23 bdos;
run;

proc sort data= a4yr&i.; 
by bid_hrs_23 bdos;
run;

proc sort data= a5yr&i.; 
by bid_hrs_23 bdos;
run;


/*Creating a flag for the first observation and last observation in that year prior to index*/

data a1yr&i.;
set a1yr&i.; 
by bid_hrs_23;
	 first= first.bid_hrs_23;
	 last= last.bid_hrs_23;
run;

data a2yr&i.;
set a2yr&i.; 
by bid_hrs_23;
	 first= first.bid_hrs_23;
	 last= last.bid_hrs_23;
run;

data a3yr&i.;
set a3yr&i.; 
by bid_hrs_23;
	 first= first.bid_hrs_23;
	 last= last.bid_hrs_23;
run;

data a4yr&i.;
set a4yr&i.; 
by bid_hrs_23;
	 first= first.bid_hrs_23;
	 last= last.bid_hrs_23;
run;

data a5yr&i.;
set a5yr&i.; 
by bid_hrs_23;
	 first= first.bid_hrs_23;
	 last= last.bid_hrs_23;
run;


/* keeping the first and last observation in that year prior to index*/

data only_a1yr&i.;
set a1yr&i.;
	where first=1 or last=1;
run;

data only_a2yr&i.;
set a2yr&i.;
	where first=1 or last=1;
run;

data only_a3yr&i.;
set a3yr&i.;
	where first=1 or last=1;
run;

data only_a4yr&i.;
set a4yr&i.;
	where first=1 or last=1;
run;

data only_a5yr&i.;
set a5yr&i.;
	where first=1 or last=1;
run;

%end;

%mend;
%plus();





%macro plus;
%do i=1 %to 5;

data proj_int.ip_yrbk&i.; 
set only_a&i.yr1;
run;

data proj_int.lt_yrbk&i.; 
set only_a&i.yr2;
run;

data proj_int.ot_yrbk&i.; 
set only_a&i.yr3;
run;

data proj_int.rx_yrbk&i.; 
set only_a&i.yr4;
run;

%end;

%mend;
%plus();



H="Informal Caregiving Costs"
clear all
capture log close

//burden dementia data has the number of hours prorated. 
use "E:\data\burden_dementia\final_data\burden_dementia_sample_long.dta" , replace
 
sort id index_date
by id: carryforward index_date, replace

//formatting days to be in terms of index year instead of calendar year. 
format index_date %td
gen year_index= year(index_date)
gen day_index=day(index_date)
gen mon_index=month(index_date)
gen year_bef=year_index-yearfromdeath
gen date_bef=mdy(mon_index, day_index, year_bef) 
format date_bef %td

gen year_bef1=year_bef-1

gen beg_day=31
gen beg_mon=12
gen beg_date=mdy(beg_mon, beg_day, year_bef1) 
format beg_date %td

//getting the proportion of days in each calendar year, they were indexed for. 

gen leap_year=1 if inlist(year_bef, 2000,2004,2008,2012) 
gen leap_year1=1 if inlist(year_bef1, 1999,2003,2007,2011) 
gen leap_mon=1 if inlist(mon_index, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12)
gen leap_mon1=1 if inlist(mon_index, 1, 2)

gen leap=1 if leap_mon==1 & leap_year==1

gen leap1=1 if leap_mon1==1 & leap_year1==1

gen days= date_bef-beg_date
gen proportion=days/365 //if inlist(year_bef, 1998,1999,2001,2002,2003,2005,2006,2007,2009,2010,2011,2013,2014,2015) 
replace proportion=days/366 if /*inlist(year_bef, 2000,2004,2008,2012) &*/ leap==1

gen date_1_bef=mdy(mon_index, day_index, year_bef1)
format date_1_bef %td

gen days1=beg_date-date_1_bef
capture drop proportion1
gen proportion1=days1/365 //if inlist(year_bef1, 1998,1999,2001,2002,2003,2005,2006,2007,2009,2010,2011,2013,2014,2015) 
replace proportion1=days1/366 if /*inlist(year_bef1, 2000,2004,2008,2012) &*/ leap1==1

rename year_bef year

drop if index_date==.

tempfile index
save "`index'"

// merging together with the state information for each person
use "E:\data\hrs_cleaned\restricted_tracker_v2012.dta", replace

keep hhid pn stateusps*

gen stateusps97=""
gen stateusps99=""

forvalues i= 1(2)11{
gen stateusps`i'=""
}

forvalues i=0(2)8{
rename stateusps0`i' stateusps`i'
}
reshape long stateusps, i(hhid pn) j(year)

forvalues i=0/99{
qui replace year=200`i' if year==`i' & year<=9
qui replace year=20`i' if year==`i' & inrange(year, 10,12)
qui replace year=19`i' if year==`i' & year>=90
}

gen id= hhid+pn
sort id year
drop if id==""
by id: carryforward stateusps, replace

gsort id -year
by id: carryforward stateusps, replace

tempfile state
save "`state'"


use "`index'", replace

merge 1:1 id year using "`state'"
keep if _merge==3
drop hhid pn _merge

tempfile full
save "`full'"

//merging with the Genworth/Metlife hourly home health aide cost. 
import excel "E:\data\Cost Care Survey (Genworth-Metlife)\HHA_hourly_genworth.xlsx", sheet("Sheet1") firstrow clear

rename A year
rename B stateusps
rename HomeHealthAideServicesHourly state_hha
rename MedianHourlyRate hr_rate

drop if year==.
destring hr_rate, replace


tempfile rate
save "`rate'"

use "`full'", replace
merge m:1 year stateusps using "`rate'"
//Don't have full data on home health aide hourly rates. 
drop if id==""

//creating total cost of informal care within the index year( which spans between calendar years).
capture drop a
gen a=proportion*hlphrs_i*hr_rate

rename year year1
rename year_bef1 year
rename _merge merge1
rename hr_rate hr_rate1

merge m:1 year stateusps using "`rate'"

capture drop b
gen b= proportion1*hlphrs_i*hr_rate

// C represents the total cost of informal caregiving prorated to a year prior to the index. 
capture drop c
gen c=a+b

///need to fix names of vars
rename year year_bef1
label var year_bef1 "Year prior to index"
rename year1 year
label var year "Year of index"

rename c total

mat sum =J(6,7,.)
local r=1
foreach x in total hlphrs_i{
local c=1
forvalues i=0/6{
sum `x' if yearfromdeath==`i'
mat sum[`r',`c']=r(mean)
mat sum[`r'+1,`c']=r(min)
mat sum[`r'+2,`c']=r(max)
local c=`c'+1
}
local r=`r'+3
}



matrix colnames sum= "0" "1" "2" "3" "4" "5" "6"
/*"1999" "2000" "2001" "2002" "2003" "2004" "2005" "2006" "2007" ///
"2008" "2009" "2010" "2011" "2012" */

matrix rownames sum= "Mean Cost" "Min Cost" "Max Cost" "Mean Hours" "Min Hours" "Max Hours"

mat list sum 


frmttable using "E:\data\burden_dementia\logs\cost_hours.doc", statmat(sum) replace ///
title(Cost and Hours by Year from Death) sdec(2) note("Each column is a year from death")


H="*************"


H="graphs of spending over time"
clear all
set more off
capture log close

cd "E:\data\burden_dementia\logs"
use "E:\data\burden_dementia\final_data\R01_final.dta", clear
keep if ffs_5==1


	
keep if impute==1
drop tot_paid*p*

foreach x of varlist tot* oop* informal* {
	replace `x'=0 if missing(`x')
}


	forvalues i=12(12)60 {
		rename tot_paid_by_mc_`i'm tot_paid_by_mc`=`i'/12'
		rename tot_paid_maid_n`=`i'/12' tot_paid_by_mcaid`=`i'/12'
		rename oop_n`=`i'/12' tot_paid_oop`=`i'/12'
		rename informal_n`=`i'/12' tot_paid_informal`=`i'/12'
}

foreach x in by_mc by_mcaid oop informal{
	gen cum1_paid_`x'5=tot_paid_`x'5
	forvalues i=4(-1)1 {
		gen cum1_paid_`x'`i'=cum1_paid_`x'`=`i'+1'+tot_paid_`x'`i'
}
}

keep id tot_paid* cum1_* dem_cohort

reshape long tot_paid_by_mc tot_paid_by_mcaid tot_paid_oop cum1_paid_by_mc ///
cum1_paid_by_mcaid cum1_paid_oop tot_paid_informal cum1_paid_informal, i(id) j(year_bef_death)
replace tot_paid_by_mcaid=0 if missing(tot_paid_by_mcaid)

*preserve
replace year=-year+6
label define year 1 "5 yrs before death" 2 "4" 3 "3" 2 "4" 5 "year before death"
foreach x of varlist tot* cum* {
	*replace `x'=`x'/1.03^(year_bef-1)
}
label values year year

foreach x in tot cum1 {
	egen `x'_paid_by_all=rowtotal(`x'_paid_by_mc `x'_paid_by_mcaid `x'_paid_oop ///
	`x'_paid_informal)
}

foreach x in by_mc by_mcaid oop informal by_all {
	by dem_cohort year_bef_death, sort: egen annu_`x'=mean(tot_paid_`x')
	by dem_cohort year_bef_death, sort: egen cum_`x'=mean(cum1_paid_`x')
}

drop cum1*
preserve
drop id tot*
duplicates drop
format cum* %16.0g

foreach x of varlist annu* cum* {
	replace `x'=`x'/1000
}

label var dem_c "Dementia" 
label var year_bef "Years before death"
label var annu_by_mc "Annual Medicarenditures"
label var cum_by_mc "Cumulative Medicare "
label var annu_by_mca "Annual Medicaid "
label var cum_by_mca "Cumulative Medicaid "
label var annu_oop "Annual OOP"
label var cum_oop "Cumulative OOP"
label var annu_inf "Annual imputed inf. caregiving"
label var cum_inf "Cumulative imputed inf. caregiving "

format annu* cum* %9.2fc

log using spending_tables.txt, text replace
foreach x in by_mc by_mcaid oop inf by_all {
	list year_bef_death dem_cohort annu_`x' cum_`x', abbreviate(16)
}
log close


twoway (connected annu_by_mc year if dem_cohort==0) (connected annu_by_mc year if dem_cohort==1), ///
legend(label(1 "Non-dementia") label(2 "Probable dementia")) xlabel(1 "4-5" 2 "3-4" 3 "2-3" 4 "1-2" 5 "0-1")
graph save annu_mc_spending_over_time.gph, replace
graph export annu_mc_spending_over_time.pdf, replace
twoway (connected annu_by_mca year if dem_cohort==0) (connected annu_by_mca year if dem_cohort==1), ///
legend(label(1 "Non-dementia") label(2 "Probable dementia")) xlabel(1 "4-5" 2 "3-4" 3 "2-3" 4 "1-2" 5 "0-1")
graph save annu_mcaid_spending_over_time.gph, replace
graph export annu_mcaid_spending_over_time.pdf, replace
twoway (connected cum_by_mc year if dem_cohort==0) (connected cum_by_mc year if dem_cohort==1), ///
legend(label(1 "Non-dementia") label(2 "Probable dementia")) xlabel(1 "4-5" 2 "3-4" 3 "2-3" 4 "1-2" 5 "0-1")
graph save cum_mc_spending_over_time.gph, replace
graph export cum_mc_spending_over_time.pdf, replace
twoway (connected cum_by_mca year if dem_cohort==0) (connected cum_by_mca year if dem_cohort==1), ///
legend(label(1 "Non-dementia") label(2 "Probable dementia")) xlabel(1 "4-5" 2 "3-4" 3 "2-3" 4 "1-2" 5 "0-1")
graph save cum_mcaid_spending_over_time.gph, replace
graph export cum_mcaid_spending_over_time.pdf, replace

twoway (connected annu_oop year if dem_cohort==0) (connected annu_oop year if dem_cohort==1), ///
legend(label(1 "Non-dementia") label(2 "Probable dementia")) xlabel(1 "4-5" 2 "3-4" 3 "2-3" 4 "1-2" 5 "0-1")
graph save annu_oop_spending_over_time.gph, replace
graph export annu_oopid_spending_over_time.pdf, replace
twoway (connected cum_oop year if dem_cohort==0) (connected cum_oop year if dem_cohort==1), ///
legend(label(1 "Non-dementia") label(2 "Probable dementia")) xlabel(1 "4-5" 2 "3-4" 3 "2-3" 4 "1-2" 5 "0-1")
graph save cum_oop_spending_over_time.gph, replace
graph export cum_oop_spending_over_time.pdf, replace


twoway (connected annu_inf year if dem_cohort==0) (connected annu_inf year if dem_cohort==1), ///
legend(label(1 "Non-dementia") label(2 "Probable dementia")) xlabel(1 "4-5" 2 "3-4" 3 "2-3" 4 "1-2" 5 "0-1")
graph save annu_informal_spending_over_time.gph, replace
graph export annu_informal_spending_over_time.pdf, replace
twoway (connected cum_inf year if dem_cohort==0) (connected cum_inf year if dem_cohort==1), ///
legend(label(1 "Non-dementia") label(2 "Probable dementia")) xlabel(1 "4-5" 2 "3-4" 3 "2-3" 4 "1-2" 5 "0-1")
graph save cum_informal_spending_over_time.gph, replace
graph export cum_informal_spending_over_time.pdf, replace

twoway (connected annu_by_all year if dem_cohort==0) (connected annu_by_all year if dem_cohort==1), ///
legend(label(1 "Non-dementia") label(2 "Probable dementia")) xlabel(1 "4-5" 2 "3-4" 3 "2-3" 4 "1-2" 5 "0-1") 
graph save annu_all_spending_over_time.gph, replace
graph export annu_all_spending_over_time.pdf, replace
twoway (connected cum_by_all year if dem_cohort==0) (connected cum_by_all year if dem_cohort==1), ///
legend(label(1 "Non-dementia") label(2 "Probable dementia")) xlabel(1 "4-5" 2 "3-4" 3 "2-3" 4 "1-2" 5 "0-1")
graph save cum_all_spending_over_time.gph, replace
graph export cum_all_spending_over_time.pdf, replace


twoway (connected cum_by_mc year if dem_cohort==1) (connected cum_by_mca year if dem_cohort==1) (connected cum_oop year if dem_cohort==1) ///
(connected cum_inf year if dem_cohort==1), title("Dementia") ///
legend(label(1 "Medicare") label(2 "Medicaid") label(3 "OOP") label(4 "Informal")) ///
saving(cum_spending_diff_dem, replace) xlabel(1 "4-5" 2 "3-4" 3 "2-3" 4 "1-2" 5 "0-1") 


twoway (connected cum_by_mc year if dem_cohort==0) (connected cum_by_mca year if dem_cohort==0) (connected cum_oop year if dem_cohort==0) ///
(connected cum_inf year if dem_cohort==0), title("No Dementia") ///
legend(label(1 "Medicare") label(2 "Medicaid") label(3 "OOP") label(4 "Informal")) ///
saving(cum_spending_diff_no_dem, replace) xlabel(1 "4-5" 2 "3-4" 3 "2-3" 4 "1-2" 5 "0-1") 

graph combine cum_spending_diff_dem.gph cum_spending_diff_no_dem.gph, ycommon

graph combine annu_mc_spending_over_time.gph cum_mc_spending_over_time.gph, ycommon
graph combine annu_mcaid_spending_over_time.gph cum_mcaid_spending_over_time.gph, ycommon
graph combine annu_oop_spending_over_time.gph cum_oop_spending_over_time.gph, ycommon
graph combine annu_informal_spending_over_time.gph cum_informal_spending_over_time.gph, ycommon
graph combine annu_all_spending_over_time.gph cum_all_spending_over_time.gph, ycommon


H="experimental changes to informal calculations"
clear all
capture log close

local datapath "E:\data\burden_dementia\int_data"
local logpath "E:\data\burden_dementia\logs"
local ooppath "E:\data\burden_dementia\oopdata"

/****************** START WITH EXIT **********************/

use "E:\data\hrs_cleaned\exit_02_to_14_dt.dta", clear

foreach x of varlist * {

rename `x' `x'_exit
}

rename id_exit id

gen nflag = 0
cap drop _m
tempfile exit
gen year = exit_year_exit
save `exit' // all exit interviews 2002-14

/**************** MERGE TRACKER WITH DECEDENT DATASET ***********/

use "E:\data\hrs_cleaned\restr_tracker_v2014.dta", clear
drop id
gen id=hhid+pn
drop if id==""
keep id race hisp_eth birthmo birthday birthyr birth_date gender degree
tempfile track
save `track' // all restricted tracker

cd `datapath'

use decedent_dataset.dta if inrange(index_year,2004,2012), clear
drop year
cap drop _m
format %td index_date
merge m:1 id using "`track'"
keep if _m==3

replace birth_date=mdy(6,birthd,birthy) if missing(birth_date)
cap drop death_date
gen death_date = index_date
gen age_at_death=floor((death_date-birth_date)/365.25)

cap drop _m


/* Sample derivation Dataset 
tempfile sample
preserve
gen age_lt_70 = 0
replace age_lt_70 = 1 if age_at_death<70
label var age_lt_70 "Age at death <70"
save `sample'
restore 
*/

levelsof id if age_at_death<70, local(agedrop)

drop if age_at_death<70 /////////////// drop people <70 at death (800)

merge 1:1 id using "`exit'"

/* Sample derivation
preserve
gen no_exit = 1 if _m==1
keep if no_exit
keep id no_exit
tempfile noexit
save `noexit'

use "`sample'", clear
merge 1:1 id using "`noexit'", keepus(no_exit)
label var no_exit "No exit ivw 2002-2014"
cap drop _m
save `sample', replace
restore
************ */
levelsof id if _m==1, local(exitdrop) 
keep if _m==3 /////////// drop people with no exit (387)

cap drop _m

tempfile r01
save `r01'

keep id index_date index_year
tempfile id 
save `id' //decedents with exit 

/*************** MERGE WITH CORE INTERVIEW **************/

use "E:\data\hrs_cleaned\core_00_to_12.dta", clear

merge m:1 id using "`id'", keepus(index_date index_year)
levelsof id if _m==2, local(nocoredrop)
keep if _m==3 ///////////// 25 people no core interviews ever

cap drop _m

gsort id -core_year

by id: gen obs=_n

keep if obs<=4

gen ivw_date = c_ivw_date

by id: gen next_ivw_date = ivw_date[_n+1] // date prev ivw chronologically

by id: gen next_ivw_year = core_year[_n+1]

gen earliest = 0
replace earliest = 1 if next_ivw_year==.
label var earliest "flag for earliest observable core"


keep if obs<=3 // keep last 3 hrs interviews


by id: gen diff = core_year - core_year[_n-1] // -4 or higher denotes a gap year

bysort id: egen gap = min(diff)

replace gap = abs(gap) // max number of years between consecutive core
label var gap "max # of yrs between consecutive core ivw"
tab gap
preserve
keep if gap>4
keep id
duplicates drop 
levelsof id, local(misscore)
tempfile droplist
save `droplist' ///////// people with more than 4 year gap between cores

restore

drop obs gap diff
gen year = core_year

cap drop _m

/* merge with dementia dataset */

merge 1:1 id core_year using "E:\data\hrs_public_2012\dementia\pdem_withvarnames_ebl.dta", keepus(pdem)
drop if _m==2

gen dementia = 0
replace dementia = 1 if pdem>=.5 & pdem!=.
cap drop _m


tempfile core
save `core'

use "`r01'", clear
append using "`core'"

merge m:1 id using "`droplist'" //dropping people with >4 years between core

codebook id if _m==3
drop if _m==3
cap drop _m

codebook id

gsort id -year

by id: gen obs=_n

foreach x of local nocoredrop {

drop if obs==1 & id=="`x'" // dropping exit ivw for people with no core ever (2000-12)

}

gen nflag_ivw = obs - 1
label var nflag_ivw "Interview type, 0 = exit, 1 = N1, etc."

gen dem_cohort = 0

levelsof id if dementia==1 & nflag_ivw==1, local(demlist)

foreach x of local demlist {

replace dem_cohort = 1 if id=="`x'"

}




gen core_5yr = index_year - core_year if obs==2 
preserve 

keep if core_5yr>4 & obs==2
keep id
levelsof id, local(core4yr) 
tempfile core_2_far 
save `core_2_far' /////////////// no core ivw within 4yrs of death

restore

merge m:1 id using "`core_2_far'"
codebook id if _m==3
drop if _m==3 // dropping ppl with no core_ivw within 4 yrs
cap drop _m

gsort id -year


by id: gen diff = year - year[_n-1] // -4 or higher denotes a gap year

/*
gen ivw_date = c_ivw_date
replace ivw_date = e_ivw_date_exit if nflag_ivw==0

 by id: gen next_ivw_date = ivw_date[_n+1] */

gen ex2far = 0
replace ex2far = 1 if diff<-4 & obs==2

gen divide = 1
replace divide = 2 if diff<=-4  & ex2far==0

expand 2 if diff<=-4, gen(imputed) 

replace year = year + 2 if imputed==1 // imputed core interview

levelsof id if imputed==1, local(impu)

cap drop nflag

gsort id -year
by id: gen nflag = _n
replace nflag = nflag - 1

drop if nflag>3

cd "E:\data\burden_dementia\int_data"
save R01_int.dta, replace

use R01_int.dta, clear

keep if nflag_ivw==0
keep id index_date index_year exit_year_exit year
tempfile index
save `index'

/*
drop nflag obs

gsort id -year
by id: gen nflag==_n-1
*/

/**************** GET OOP DATA ********************/

local ooppath "E:\data\burden_dementia\oopdata"

use `ooppath'\oopme_final_2014.dta, clear
rename *, l
gen id=hhid+pn

merge m:1 id using "`index'", keepus(index_year index_date)
keep if _m==3 // only keep oop data for people in cohort

tab year if total_oop==.
drop if total_oop==.
preserve
*keep if iwtype==0 // keep non-imputed non-exit ivw
tempfile oop_mer
save `oop_mer' // original dataset, not imputed
restore 


gsort id -year

by id: gen obs=_n

keep if obs<=4

by id: gen diff = year - year[_n-1] // -4 or higher denotes a gap year


replace diff = -4 if diff<=-4 & obs==2 // recoding people with >4 gap between exit and N1 to be 4yrs


/*
bysort id: egen gap = min(diff)
keep if gap==-4 /* only keep people without consecutive missing interviews */
*/


expand 2 if diff==-4, gen(ooptag) //created imputed interview

replace year = year + 2 if ooptag==1

gsort id -year

cap drop obs
by id: gen obs=_n

by id: gen total_imp_a = total_oop[_n+1] if ooptag==1
by id: gen total_imp_b = (total_oop[_n+1] + total_oop[_n-1])/2 if ooptag==1

label var ooptag "imputed oop"

keep if ooptag==1

tempfile imputed
save `imputed'


use "`oop_mer'", clear

append using "`imputed'"
cap drop _m 
preserve
drop if iwtype==1

tempfile oop
save `oop'
restore 

keep if iwtype==1

gen nflag = 0

foreach x of varlist total* {

rename `x' `x'_exit
}
rename year exit_year_exit

tempfile oop_exit
save `oop_exit'

use R01_int.dta, clear
cap drop _m
merge 1:1 id year using "`oop'", keepus(total* ooptag)
*merge 1:1 id year using "`oop'", keepus(total* ooptag)
drop if _m==2
cap drop _m

merge 1:1 id nflag using "`oop_exit'", keepus(total* ooptag)

drop if _m==2
cap drop _m

save R01_int.dta, replace


use R01_int.dta, clear

keep if nflag_ivw==0
keep id index_date index_year exit_year_exit year
tempfile index
save `index'



/************ Get Helper data ***********/

use "E:\data\hrs_oop_2010\received_data\2012\helper_hours_2012.dta", clear
gen id=hhid+pn 
*rename year core_year
//cap number of hours at 720 (24 hrs for 30 days) for spouses and other informal
foreach x in s u {
replace hlphrs_`x'=720 if hlphrs_`x'>720
replace hlphrs_`x' = 0 if hlphrs_`x'==.
}
replace hlphrs_i=hlphrs_s+hlphrs_u
replace hlphrs_i= 720 if hlphrs_i>=720

merge m:1 id using "`index'", keepus(index_year index_date)
keep if _m==3 // only keep helper data for people in cohort
drop _m

tempfile hlp_mer

save `hlp_mer'

merge 1:1 id year using "`index'", keepus(id exit_year_exit year)

replace inx = 1 if _m==2
replace hlphrs_i = 0 if _m==2



gsort id -year

by id: gen obs=_n

tab inx if obs==2

by id: gen diff = year - year[_n-1] // -4 or higher denotes a gap year

replace diff = -4 if diff<=-4 & obs==2 // replacing obs where gap between exit and N1 was >4yrs, since we already kept people who had core in last years of life

expand 2 if diff==-4, gen(hlptag)



replace year = year + 2 if hlptag==1

replace hlptag=1 if _m==2

cap drop obs

gsort id -year

by id: gen obs=_n

by id: gen hlphrs_i_a = hlphrs_i[_n+1] if hlptag==1
by id: gen hlphrs_i_b = (hlphrs_i[_n+1] + hlphrs_i[_n-1])/2 if hlptag==1 // if there is no _n+1 then this returns missing





label var hlptag "imputed hlp hrs"

gen hlp_exit = 1 if hlptag==1 & _m==2
label var hlp_exit "hlp exit imputed"
replace hlptag = 0 if _m==2
preserve
keep if hlptag==1 

tempfile hlp
save `hlp'


use "`hlp_mer'", clear

append using "`hlp'"
cap drop _m

drop if inx==1


tempfile help
save `help'
restore 

keep if inx==1

gen nflag = 0

foreach x of varlist hlphrs_i* {

rename `x' `x'_exit
}

tempfile hlp_exit 
save `hlp_exit'


use R01_int.dta, clear
cap drop _m
merge 1:1 id year using "`help'", keepus(hlphrs_i* hlptag hlp_exit)
*merge 1:1 id year using "`help'", keepus(hlphrs_i* hlptag)
drop if _m==2

cap drop _m

merge 1:1 id nflag using "`hlp_exit'", keepus(hlphrs_i* hlptag hlp_exit) update

drop if _m==2
cap drop _m

foreach x of varlist hlphrs_i* {

replace `x' = 0 if (hlptag==1 & imputed==0)
replace `x' = 0 if `x'==.
}

gen year_n0 = year
replace year_n0 = index_year if nflag==0
gen year_n1 = year_n0 - 1
label var year_n1 "calendar year prior to ivw date"
gen year_n2 = year_n0 - 2
label var year_n2 "calendar year 2 yrs prior to ivw date"


save R01_int.dta, replace


use R01_int.dta, clear
keep id

duplicates drop id, force
tempfile id
save `id'

/************** Get State information *************/

use "E:\data\hrs_cleaned\restr_tracker_v2014.dta", clear
drop id
gen id=hhid+pn

merge 1:1 id using "`id'"
keep if _m==3

keep hhid pn stateusps* zipcode*

foreach x of varlist stateusps* {

replace `x' = "" if `x'=="ZZ"

}

gen stateusps97=""
gen stateusps99=""

forvalues i= 1(2)13{
gen stateusps`i'=""
gen zipcode`i' = ""
}

forvalues i=0(2)8{
rename stateusps0`i' stateusps`i'
rename zipcode0`i' zipcode`i'
}
reshape long stateusps zipcode, i(hhid pn) j(year)

forvalues i=0/99{
qui replace year=200`i' if year==`i' & year<=9
qui replace year=20`i' if year==`i' & inrange(year, 10,14)
qui replace year=19`i' if year==`i' & year>=90
}

gen id= hhid+pn
sort id year
drop if id==""
by id: carryforward stateusps, replace

gsort id -year
by id: carryforward stateusps, replace

/*
expand 2 if year==2012, gen(dupkey)

replace year = 2014 if dupkey==1


expand 2 if year==2014, gen(dup2)
replace year= 2013 if dup2==1
*/

tempfile state
save "`state'"

rename year year_n1
rename stateusps stateusps_n1
tempfile state_n1
save `state_n1'

rename year_n1 year_n2
rename stateusps_n1 stateusps_n2 
tempfile state_n2
save `state_n2'

use R01_int.dta, clear
merge 1:1 id year using "`state'"
keep if _m==3
cap drop _m
merge m:1 id year_n1 using "`state_n1'"
keep if _m==3
cap drop _m
merge m:1 id year_n2 using "`state_n2'"
keep if _m==3
cap drop _m


save R01_int.dta, replace

//merging with the Genworth/Metlife hourly home health aide cost. 
import excel "E:\data\burden_dementia\ref_data\Cost Care Survey (Genworth-Metlife)\HHA_hourly_genworth.xlsx", sheet("Sheet1") firstrow clear

rename A year
rename B stateusps
rename HomeHealthAideServicesHourly state_hha
rename MedianHourlyRate hr_rate

drop if year==.
destring hr_rate, replace

expand 2 if year==1998, gen(duptag)

replace year = year - 1 if duptag==1
cap drop duptag

expand 2 if year==1997, gen(duptag)

replace year = year - 1 if duptag==1
drop duptag

rename year year_n0

tempfile rate
save "`rate'"

rename year_n0 year_n1
rename stateusps stateusps_n1
rename state_hha state_hha_n1
rename hr_rate hr_rate_n1

tempfile rate_n1
save "`rate_n1'"

rename year_n1 year_n2
rename stateusps_n1 stateusps_n2
rename state_hha_n1 state_hha_n2
rename hr_rate_n1 hr_rate_n2

tempfile rate_n2
save "`rate_n2'"

use R01_int.dta, clear
cap drop _m
merge m:1 year_n0 stateusps using "`rate'"
keep if _m==3
cap drop _m
merge m:1 year_n1 stateusps_n1 using "`rate_n1'"
keep if _m==3
cap drop _m
merge m:1 year_n2 stateusps_n2 using "`rate_n2'"
keep if _m==3
cap drop _m

/**************** calculations *********************/

gen core_b4_death = 0
replace core_b4_death = 1 if nflag==1

gen n1_2_death = index_date - c_ivw_date if core_b4_death==1
replace n1_2_death = n1_2_death * 0.033
replace n1_2_death = ceil(n1_2_death)
replace n1_2_death = 24 if n1_2_death>=24 & n1_2_death!=.
replace n1_2_death = 1 if n1_2_death<=0


gen death_cat = .
replace death_cat = 1 if n1_2_death<12
replace death_cat = 2 if n1_2_death==12
replace death_cat = 3 if n1_2_death>12 & n1_2_death!=.

gsort id -core_b4_death

carryforward death_cat n1_2_death, replace

gen all = 1
bysort id: egen count = total(all)

codebook id if count==3
levelsof id if count==3 & death_cat==1, local(non3)

drop if count==3 & death_cat==1 /////////// dropping people with no N3 but death_cat ==1


cap drop ivw_time
gen ivw_time = ivw_date - next_ivw_date
*replace ivw_time = index_date - ivw_date if ex2far==1

replace ivw_time = ivw_time * 0.03
gen imp = core_year-next_ivw_year
replace ivw_time = 48 if imp>=6 & imp!=. // recode people with exit >2yrs from death  to cap it at 48m
replace ivw_time = 24 if earliest==1
replace imp = 1 if imp>=4 & imp!=.

replace ivw_time = ivw_time/2 if imp==1
replace ivw_time = ceil(ivw_time)

tab ivw_time
label var ivw_time "interview weight" 

cap drop mar_n0 mar_n1 mar_n2
cap drop mar

gen mar_n0 = . //months at risk
gen mar_n1 = .
gen mar_n2 = .

replace mar_n0 = index_month if nflag==0
*replace mar_n0 = n1_2_death if n1_2_death<12 & nflag==0
replace mar_n0 = n1_2_death if (n1_2_death-mar_n0 < 0) & nflag==0

replace mar_n1 = n1_2_death - mar_n0 if nflag==0
replace mar_n1 = 0 if mar_n1<0 & nflag==0
replace mar_n1 = 12 if (mar_n1>12 & mar_n1!=.) & nflag==0



replace mar_n2 = n1_2_death - mar_n0 -mar_n1 if nflag==0
replace mar_n2 = 0 if mar_n2<0
*replace mar_n2 = 12 if (mar_n2>12 & mar_n2!=.) & nflag==0



replace mar_n0 = c_ivw_month if nflag>0

replace mar_n1 = ivw_time - c_ivw_month if nflag>0
replace mar_n1 = 0 if mar_n1<0 & nflag>0
replace mar_n1 = 12 if (mar_n1>12 & mar_n1!=.) & nflag>0

replace mar_n2 = ivw_time - 12 - c_ivw_month if nflag>0
replace mar_n2 = 0 if mar_n2<0 & nflag>0
*replace mar_n2 = 12 if (mar_n2>12 & mar_n2!=.) & nflag>0

gen mar = mar_n0+mar_n1+mar_n2
corr mar n1_2_death if nflag==0
corr mar ivw_time if nflag>0 // checks to see if months at risk (mar) = months between ivw

gsort id +nflag

gen hlphrs_0 = hlphrs_i
replace hlphrs_0 = hlphrs_i_exit if nflag==0

gen hlphrs_a = hlphrs_i
replace hlphrs_a = hlphrs_i_a if imputed==1
replace hlphrs_a = hlphrs_i_exit if nflag==0

gen hlphrs_b = hlphrs_i
replace hlphrs_b = hlphrs_i_b if imputed==1
replace hlphrs_b = hlphrs_i_exit if nflag==0 



foreach x of varlist hlphrs_0 hlphrs_a hlphrs_b {

by id: gen `x'_n = `x'[_n+1]

replace `x'_n = 0 if `x'_n==. // stop gap, remove later 

} 


//start with nflag = 0

gen hlphrs_0_av = .
replace hlphrs_0_av = n1_2_death*hlphrs_0 if n1_2_death<=4 & nflag==0
replace hlphrs_0_av = (4*hlphrs_0) + (n1_2_death-4)*((hlphrs_0+hlphrs_0_n)/2) if n1_2_death>4 & nflag==0
replace hlphrs_0_av = (4*hlphrs_0) + (ivw_time-4)*((hlphrs_0+hlphrs_0_n)/2) if nflag>0

gen hlphrs_a_av = .
replace hlphrs_a_av = n1_2_death*hlphrs_a if n1_2_death<=4 & nflag==0
replace hlphrs_a_av = (4*hlphrs_a) + (n1_2_death-4)*((hlphrs_a+hlphrs_a_n)/2) if n1_2_death>4 & nflag==0
replace hlphrs_a_av = (4*hlphrs_a) + (ivw_time-4)*((hlphrs_a+hlphrs_a_n)/2) if nflag>0

gen hlphrs_b_av = .
replace hlphrs_b_av = n1_2_death*hlphrs_b if n1_2_death<=4 & nflag==0
replace hlphrs_b_av = (4*hlphrs_b) + (n1_2_death-4)*((hlphrs_b+hlphrs_b_n)/2) if n1_2_death>4 & nflag==0
replace hlphrs_b_av = (4*hlphrs_b) + (ivw_time-4)*((hlphrs_b+hlphrs_b_n)/2) if nflag>0







//st





foreach x of varlist *_av {

replace `x' = `x'/n1_2_death if nflag==0
replace `x' = `x'/ivw_time if nflag>0
replace `x' = (`x'*mar_n0*hr_rate) +  (`x'*mar_n1*hr_rate_n1) + (`x'*mar_n2*hr_rate_n2)

}

replace hlphrs_i = hlphrs_0_av if nflag>0
replace hlphrs_i_exit = hlphrs_0_av if nflag==0

replace hlphrs_i_a = hlphrs_a_av if nflag>0
replace hlphrs_i_a_exit = hlphrs_a_av if nflag==0

replace hlphrs_i_b = hlphrs_b_av if nflag>0
replace hlphrs_i_b_exit = hlphrs_b_av if nflag==0





gen has_imputed = 0
foreach x of local impu {

replace has_imputed=1 if id=="`x'"

}


save R01_int.dta, replace

/* Sample Derivation */

use decedent_dataset.dta if inrange(index_year,2004,2012), clear

gen age_lt_70 = 0
label var age_lt_70 "Dropped because age at death <70"
foreach x of local agedrop {

replace age_lt_70 = 1 if id=="`x'"

}

gen exdrop = 0
label var exdrop "Dropped because no Exit Ivw 2002-2014"
foreach x of local exitdrop {
replace exdrop = 1 if id=="`x'"
}

gen nocore = 0
label var nocore "Dropped because no Core Ivw 2000-2012"
foreach x of local nocoredrop {

replace nocore = 1 if id=="`x'"
}

gen misscore = 0
label var misscore "Dropped because missing consecutive cores"
foreach x of local misscore {

replace misscore = 1 if id=="`x'"
}

gen core4yr = 0
label var core4yr "Dropped because no Core within last 4 years of life"
foreach x of local core4yr {
replace core4yr = 1 if id=="`x'"
}

gen impu = 0
label var impu "Had a core imputed"
foreach x of local impu {
replace impu = 1 if id=="`x'"
}

gen non3 = 0
label var non3 "Dropped because Died <12m after N1 and missing N3"
foreach x of local non3 {

replace non3 = 1 if id=="`x'"

}

local deri age_lt_70 exdrop nocore misscore core4yr non3 

gen final = 1
label var final "Final Sample Size, includes decedents w/imputed core"

foreach x of local deri {

replace final = 0 if `x'==1

}

gen final_noimp = 0
replace final_noimp = 1 if final==1 & impu==0
label var final_noimp "Final Sample Size, excludes decedents with imputed core"

gen all = 1
label var all "All HRS respondents Deceased 2004-2012"

local full all age_lt_70 exdrop nocore misscore core4yr non3 final final_noimp

local rd: word count `full'

mat tab1 = J(`rd',1,.)

local r = 1

foreach x of local full {

sum `x'
mat tab1[`r',1] = r(sum)
local ++r
}

mat rownames tab1 = `full'


frmttable using "E:\projects\burden_dementia\archive logs\Sample_Derivation.doc", replace statmat(tab1) ///
varlabels title("Sample Derivation for R01 (Deceased 2004-2012, Age 70+)") ctitles("Reason for Exclusion" "N" ) sdec(0) ///
annotate(stars) asymbol(*,**)note("Death Date was determined by NDI, Medicare MBSF or HRS Exit in that order. //If NDI death date was after HRS Exit Interview and respondent had no subsequent data, then HRS death date was used.")




H="Experimental - checking discrepancies in DOD"
use check_id_xwalk.dta, clear

duplicates drop id, force


merge 1:1 id using "E:\data\hrs_cleaned\death_date_2015.dta", keep(match)

list index_date dod_ndi10 dod_basf15 dod_bene15 dod_exit14 c_ivw_date proxy_core no_exit death_exit

cap drop _m



cap drop bid_hrs_22
gen hhidpn = id
merge 1:1 hhidpn using "E:\data\CMS_DUA_51675_2014\Medicare Xref2015\CMSxref20151\stata\xref2015medicare.dta", keep(match)
drop _m
rename BID_HRS_22 bid_hrs_22

tempfile check
save `check'


use "E:\data\CMS_DUA_51675_2014\Merged\Stata\basf_1998_2015.dta", clear
duplicates drop bid_hrs_22, force
gen bene_female = 0
replace bene_female = 1 if sex=="2"
keep bid_hrs_22 bene_dob bene_female bene_dod

merge 1:1 bid_hrs_22 using "`check'", keep(match)

cap drop _m birth_date
merge 1:1 id using tracker.dta, keep(match)

format %td birth_date 

gen average = abs(birth_date - bene_dob)
replace average = average * 0.03
sum average // average discrepancy is 52 months


use tracker.dta, clear
gen hhidpn = id 
merge 1:1 hhidpn using "E:\data\CMS_DUA_51675_2014\Medicare Xref2015\CMSxref20151\stata\xref2015medicare.dta", keep(match)
drop _m
rename BID_HRS_22 bid_hrs_22 
merge 1:m bid_hrs_22 using "E:\data\CMS_DUA_51675_2014\Merged\Stata\basf_1998_2015.dta", keep(match) force
duplicates drop bid_hrs_22, force

gen average = abs(birth_date - bene_dob)
replace average = average * 0.03
sum average // average discrepancy is 52 months

/********** quick oop check***********/
use R01_i.dta, clear

merge m:1 id using R01_annualized_i.dta, keepus(oop_y* informal_y*)
drop _m

save R01_oopcosts_fullsample.dta, replace

merge m:1 id using oop_24m_60m, keepus(ind_60m_oop_yes total_oop_60m)
drop if _m==2

keep if nflag==1 & ffs_60m==1 & age_lt_70==0 index_year>=2005 & index_year<=2010
*keep if ffs_60m==1 & age_lt_70==0

gen oop_5yr = oop_y1 + oop_y2 + oop_y3 + oop_y4 + oop_y5

mean total_oop_60m , over(dem_cohort)

mean oop_5yr , over(dem_cohort)


mean total_oop_60m [aw=wgthh], over(dem_cohort)

mean oop_5yr [aw=wgthh], over(dem_cohort)


H="Experimental - Data aggreation"
clear all
capture log close

global datapath "E:\data\burden_dementia\int_data"
local logpath "E:\data\burden_dementia\logs"
global ooppath "E:\data\burden_dementia\oopdata"
global output "E:\projects\burden_dementia\archive logs"

*log using `logpath'\R01_aggregate.txt, text replace

* Constructs aggregate dataset and variables for R01 before people are dropped
* search "to be dropped" to find sample exclusion variables

/****************** START WITH EXIT **********************/

use "E:\data\hrs_cleaned\exit_02_to_16_dt.dta", clear

foreach x of varlist * {

rename `x' `x'_exit
}

rename id_exit id
gen nflag = 0
cap drop _m
gen year = exit_year_exit
save $datapath\exit.dta, replace // all exit interviews 2002-14

/**************** MERGE TRACKER WITH DECEDENT DATASET ***********/

cd $datapath

use decedent_dataset.dta if inrange(index_year,2004,2015), clear
cap drop _m
format %td index_date
merge m:1 id using tracker.dta 
keep if _m==3

replace birth_date=mdy(6,birthd,birthy) if missing(birth_date)
cap drop death_date
gen death_date = index_date
gen age_at_death=floor((death_date-birth_date)/365.25)

cap drop _m
merge 1:1 id using exit.dta
gen age_lt_72 = 1 if age_at_death<72
gen age_lt_70 = 1 if age_at_death<70
label var age_lt_72 "Age <72 at death, to be dropped"
label var age_lt_70 "Age <70 at death, to be dropped"

gen no_exit=1 if _m==1
label var no_exit "Decedents with no exit ivw 2002-16, to be dropped"
drop if _m==2
cap drop _m
save r01_a.dta, replace

/*************** MERGE WITH CORE INTERVIEW **************/

use r01_a.dta, clear
keep id index_date index_year exit_year_exit e_ivw_date_exit
tempfile id 
save `id' //decedents with exit 

use "E:\data\hrs_cleaned\core_00_to_14.dta", clear
merge m:1 id using "`id'", keepus(index_date index_year exit_year_exit e_ivw_date_exit)
levelsof id if _m==2, local(nocore)
global nocore1 "`nocore'"
keep if _m==3
cap drop _m
gsort id -core_year
by id: gen obs=_n
keep if obs<=5 // keeping last 5 core interviews (N1 - N4 + Baseline)

* I'm creating a single ivw date variable that has both the core ivw date and exit ivw date
gen ivw_date = c_ivw_date

* data is sorted in descending order by core year. I am carrying the date & year //
* of the previous (chronologically) interview into the current row
*by id: gen next_ivw_date_old = ivw_date[_n+1]
by id: gen next_ivw_year = core_year[_n+1]

by id: gen diff = core_year - core_year[_n-1] // -4 or higher denotes a gap year

bysort id: egen gap = min(diff) // using min because diff is negative
replace gap = abs(gap) // max number of years between consecutive core
levelsof id if gap>4, local(misscore)

gen miss_core = .
label var miss_core "Missing consecutive core ivw, to be dropped"
foreach x of local misscore {

replace miss_core = 1 if id=="`x'"
}

drop obs gap diff
gen year = core_year // combines exit_year & core_year into a single variable

* Merge with dementia dataset

merge 1:1 id core_year using "E:\data\hrs_public_2014\dementia\pdem_withvarnames_00_14.dta", keepus(pdem)
drop if _m==2

gsort id -core_year

by id: replace pdem = pdem[_n+1] if pdem==.

gen dementia = 0 if pdem!=.
replace dementia = 1 if pdem>=.5 & pdem!=.
cap drop _m

tempfile core
save `core'

use r01_a.dta, clear
append using "`core'" // appending to exit/tracker 
gen no_core = .
label var no_core "No core ivw 2000-14, to be dropped"
foreach x of global nocore1 {

replace no_core = 1 if id=="`x'"

}

* Data is currently in long form, with one row for exit and a row for each core

save r01_b.dta, replace

/****** Imputing core for people with a 4 year gap between ivws *******/

use r01_b.dta, clear

levelsof id if no_exit==1, local(noexit)

foreach x of local noexit {

replace no_exit = 1 if id=="`x'"
}

/*
preserve
keep if no_exit==1
save noexit.dta, replace
restore
drop if no_exit==1
*/


gen year_ci = core_year 
replace year_ci = index_year if nflag==0
label var year_ci "core_year(if nflag>0) or index_year(if nflag=0)"
gsort id -year_ci // year = combined core_year & index_year
by id: gen obs=_n

cap drop nflag 
gen nflag = obs - 1
label var nflag "Interview type, 0 = exit, 1 = N1, etc."

gen dem_cohort = 0 if dementia!=.
label var dem_cohort "Probable Dementia at N1"
levelsof id if dementia==1 & nflag==1, local(demlist)

foreach x of local demlist {
replace dem_cohort = 1 if id=="`x'"
}

gen core_4yr = index_year - c_ivw_year if obs==2

/* 

* Final R01 dataset requires everyone to have a core ivw within 4 (calendar) years of death
* But their exit ivw may be further away. The date of exit is irrelevant for ivw spacing
* so will use their date of death instead

Funky stuff: People who have a core ivw after they have died
keep if core_4yr < 0
c_ivw_date > index_date */

preserve
keep if c_ivw_date > index_date & c_ivw_date!=. // people with core dates after ivw
keep id index_date c_ivw_date core_year proxy_core no_exit female birth_date bid_hrs_22
save check_id_xwalk.dta, replace
restore

levelsof id if (core_4yr>4 & core_4yr!=.) | core_4yr<0, local(nocore4yr)

gen nocore4yr = .
label var nocore4yr "No Core ivw within 4 years of death, to be dropped"

gen death_b4_core = .
label var death_b4_core "Has NDI/Bene DOD before Core Ivw" 


levelsof id if c_ivw_date > index_date & c_ivw_date!=., local(diedb4core)

foreach x of local diedb4core {

replace death_b4_core = 1 if id=="`x'"
}

foreach x of local nocore4yr {
replace nocore4yr = 1 if id=="`x'"
}

gsort id -year
by id: gen diff = year_ci - year_ci[_n-1] // -4 or higher denotes a gap year

replace diff = -4 if diff<=-3 & obs==2 & nocore4yr==. & no_exit==. // imputing an interview between N1 & death if N1>=3yrs prior to death
expand 2 if diff==-4, gen(imputed) 
replace year = year + 2 if imputed==1 // imputed core interview
label var imputed "imputed core interview"

drop if year > index_year & imputed==1 // dropping imputed cores after death
drop if (index_year - c_ivw_year)<=2 & imputed==1 // dropping imputed cores if person died inbetween core and exit
drop if exit_year_exit==year & imputed==1 // dropping core interviews imputed in exit years
*keep if (index_year - c_ivw_year)==2 & imputed==1
drop obs nflag

gsort id -year
by id: gen nflag = _n
replace nflag = nflag - 1

*replace year = year_ci if nflag>0
label var year "core_year(if nflag>0), exit_year(if nflag=0), includes imputed cores"


levelsof id if miss_core==1, local(misscore)
foreach x of local misscore {

replace miss_core = 1 if id=="`x'"
}

*drop if no_exit==1 & nflag==0 & imputed==1

save r01_c.dta, replace

/**************** GET OOP DATA ********************/

use r01_c.dta, clear

keep if nflag==0 & no_exit==.
keep id index_date index_year exit_year_exit year
tempfile index
save `index'

use $ooppath\oopme_final_2016.dta, clear
rename *, l
gen id=hhid+pn

merge m:1 id using "`index'", keepus(index_year index_date)
keep if _m==3 // only keep oop data for people in cohort
drop if total_oop==.

* Imputing the missing interviews (gap years) for OOP and then append to original dataset
preserve
tempfile oop_mer
save `oop_mer' // original dataset, no imputed cores
restore 

gsort id -year
by id: gen obs=_n
keep if obs<=6 // (N1 - N4 + baseline + extra ivw)
by id: gen diff = year - year[_n-1] // -4 or higher denotes a gap year
replace diff = -4 if diff<=-4 & obs==2 // recoding people with >4 gap between exit and N1 to be 4yrs

expand 2 if diff==-4, gen(ooptag) //created imputed interview
replace year = year + 2 if ooptag==1
gsort id -year
cap drop obs
by id: gen obs=_n

by id: gen total_imp_a = total_oop[_n+1] if ooptag==1
by id: gen total_imp_b = (total_oop[_n+1] + total_oop[_n-1])/2 if ooptag==1

label var ooptag "imputed oop"
keep if ooptag==1 // keep only imputed cores and then append to original dataset
tempfile imputed
save `imputed'

use "`oop_mer'", clear

append using "`imputed'"
cap drop _m 
preserve
drop if iwtype==1 // dropping exit so it can be merged separately (see below)

tempfile oop
save `oop'
restore 

keep if iwtype==1

gen nflag = 0

foreach x of varlist total* {

rename `x' `x'_exit
}
rename year exit_year_exit

tempfile oop_exit
save `oop_exit'

cd $datapath 

use r01_c.dta, clear
cap drop _m
merge 1:1 id year using "`oop'", keepus(total* ooptag)
drop if _m==2
cap drop _m

merge 1:1 id nflag using "`oop_exit'", keepus(total* ooptag)

drop if _m==2
cap drop _m


save r01_d.dta, replace

/************ Get Helper data ***********/

/* Helper hours imputation follows the same logic as the OOP, but structure is
slighty different. Everyone has OOP data for their core ivw, so missing oop = missing core.
But not everyone has helper data for their core, so missing helper != missing core */

use r01_d.dta, clear

*dropping the people missing consecutive cores before merging with helper data

keep if miss_core==. & no_exit==. // keep only people not missing consecutive cores and have an exit
keep id index_date index_year exit_year_exit year imputed nflag
tempfile index
save `index'


use "E:\data\hrs_cleaned\helper_hours_2016.dta" , clear
*gen id=hhid+pn 
*rename year core_year
//cap number of hours at 720 (24 hrs for 30 days) for spouses and other informal
/*
foreach x in s u {
replace hlphrs_`x'=720 if hlphrs_`x'>720
replace hlphrs_`x' = 0 if hlphrs_`x'==.
}
*/

*replace hlphrs_i= 720 if hlphrs_i>=720 & hlphrs_i!=.

merge m:1 id year using "`index'"
drop if _m==1


* Imputing 0 helper hours for interviews with no helper data 
replace ivw_type = 2 if exit_year_exit==year //_m==2
foreach x in i u s k {
replace hlphrs_`x' = 0 if _m==2
}
*cap drop _m

gsort id -year
by id: gen obs=_n
* Imputations, Method A (Carry forward) and Method B (Ave prior and later ivws to fill gap)

foreach x in i u s k {

*by id: gen hlphrs_`x'_a = hlphrs_`x'[_n+1] if imputed==1
by id: gen hlphrs_`x'_b = (hlphrs_`x'[_n+1] + hlphrs_`x'[_n-1])/2 if imputed==1 // if there is no _n+1 then this returns missing

}

preserve
drop if ivw_type==2
tempfile help
save `help'
restore 

keep if ivw_type==2

foreach x of varlist hlphrs_* {

rename `x' `x'_exit
}

tempfile hlp_exit 
save `hlp_exit'

use r01_d.dta, clear
cap drop _m
merge 1:1 id nflag using "`help'", keepus(hlphrs_*)
drop if _m==2

cap drop _m

merge 1:1 id nflag using "`hlp_exit'", keepus(hlphrs_*) update

drop if _m==2
cap drop _m

save r01_e.dta, replace

/****** Imputing Interview dates for imputed core interviews ******/

use r01_e.dta, clear

*gen core_b4_death = 0
*replace core_b4_death = 1 if nflag==1

gsort id nflag
cap drop ivw_date
gen ivw_date = c_ivw_date
replace ivw_date = index_date if nflag==0
by id: gen old_ivw_date = ivw_date[_n-1] 

gen new_ivw_days = old_ivw_date - c_ivw_date
replace new_ivw_days = new_ivw_days/2
replace new_ivw_days = 730 if imputed==1 & new_ivw_days>730 & nflag==1 ////// capping interview gap to 2yrs.. possible gap in coverage?

replace new_ivw_days = ceil(new_ivw_days)
replace ivw_date = c_ivw_date + new_ivw_days if imputed==1 //c_ivw is date for core prior to gap
replace c_ivw_year = year(ivw_date)
replace c_ivw_month = month(ivw_date)
replace c_ivw_date = ivw_date if imputed==1

format %td ivw_date old_ivw_date

replace c_ivw_year=9999 if (miss_core==1 | no_exit==1) & c_ivw_year==. // need to create a value since cannot merge with missing values
/*
preserve
keep if miss_core==1 | no_exit==1
tempfile tempdrop
save `tempdrop'

restore
drop if miss_core==1 | no_exit==1
*/
* Get years before the interview to multiply by Genworth hourly rate  
gen c_ivw_year_n0 = c_ivw_year
replace c_ivw_year_n0 = index_year if nflag==0
gen c_ivw_year_n1 = c_ivw_year_n0 - 1
label var c_ivw_year_n1 "calendar year prior to ivw date"
gen c_ivw_year_n2 = c_ivw_year_n0 - 2
label var c_ivw_year_n2 "calendar year 2 yrs prior to ivw date"

save r01_f.dta, replace

/************** Get State information *************/

use r01_f.dta, clear
keep id

duplicates drop id, force
tempfile id
save `id'

// creating CPI-U 
clear
set obs 21
gen obs = _n
gen year = .
gen cpi_rate = .

forvalues i=1/21 {

replace year = 2017 - `i' if obs==`i'

}

replace cpi_rate = 1 if year==2016
replace cpi_rate=1.01262 if year==2015
replace cpi_rate=1.01382 if year==2014
replace cpi_rate=1.03026 if year==2013
replace cpi_rate=1.04535 if year==2012
replace cpi_rate=1.06699 if year==2011
replace cpi_rate=1.10067 if year==2010
replace cpi_rate=1.11872 if year==2009
replace cpi_rate=1.11474 if year==2008
replace cpi_rate=1.15754 if year==2007
replace cpi_rate=1.19051 if year==2006
replace cpi_rate=1.22891 if year==2005
replace cpi_rate=1.27055 if year==2004
replace cpi_rate=1.30439 if year==2003
replace cpi_rate=1.33411 if year==2002
replace cpi_rate=1.35521 if year==2001
replace cpi_rate=1.39377 if year==2000
replace cpi_rate=1.44062 if year==1999
replace cpi_rate=1.47244 if year<=1998

rename year c_ivw_year
label var cpi_rate "Inflation adjustment factor"
tempfile cpi
save `cpi'

// pull tracker
use "E:\data\hrs_cleaned\restr_tracker_v2014.dta", clear
drop id
gen id=hhid+pn

merge 1:1 id using "`id'"
keep if _m==3

keep hhid pn stateusps* zipcode*

gen stateusps16 = stateusps14
gen zipcode16 = zipcode14

foreach x of varlist stateusps* {

replace `x' = "" if `x'=="ZZ"

}

gen stateusps97=""
gen stateusps99=""

forvalues i= 1(2)15{
gen stateusps`i'=""
gen zipcode`i' = ""
}

forvalues i=0(2)8{
rename stateusps0`i' stateusps`i'
rename zipcode0`i' zipcode`i'
}
reshape long stateusps zipcode, i(hhid pn) j(c_ivw_year)

forvalues i=0/99{
qui replace c_ivw_year=200`i' if c_ivw_year==`i' & c_ivw_year<=9
qui replace c_ivw_year=20`i' if c_ivw_year==`i' & inrange(c_ivw_year, 10,16)
qui replace c_ivw_year=19`i' if c_ivw_year==`i' & c_ivw_year>=90
}

gen id= hhid+pn
sort id c_ivw_year
drop if id==""
by id: carryforward stateusps, replace

gsort id -c_ivw_year
by id: carryforward stateusps, replace

merge m:1 c_ivw_year using "`cpi'", keepus(cpi_rate)
cap drop _m

tempfile state
save "`state'"

rename c_ivw_year c_ivw_year_n1
rename stateusps stateusps_n1
rename cpi_rate cpi_rate_n1
tempfile state_n1
save `state_n1'

rename c_ivw_year_n1 c_ivw_year_n2
rename stateusps_n1 stateusps_n2 
rename cpi_rate_n1 cpi_rate_n2
tempfile state_n2
save `state_n2'

use R01_f.dta, clear
merge m:1 id c_ivw_year using "`state'"
drop if _m==2
cap drop _m
merge m:1 id c_ivw_year_n1 using "`state_n1'"
drop if _m==2
cap drop _m
merge m:1 id c_ivw_year_n2 using "`state_n2'"
drop if _m==2
cap drop _m

save R01_g.dta, replace

//merging with the Genworth/Metlife hourly home health aide cost. 
import excel "E:\data\burden_dementia\ref_data\Cost Care Survey (Genworth-Metlife)\HHA_hourly_genworth.xlsx", sheet("Sheet1") firstrow clear

rename A c_ivw_year
rename B stateusps
rename HomeHealthAideServicesHourly state_hha
rename MedianHourlyRate hr_rate

drop if c_ivw_year==.
destring hr_rate, replace

expand 2 if c_ivw_year==1998, gen(duptag)

replace c_ivw_year = c_ivw_year - 1 if duptag==1
cap drop duptag

expand 2 if c_ivw_year==1997, gen(duptag)

replace c_ivw_year = c_ivw_year - 1 if duptag==1
drop duptag

rename c_ivw_year c_ivw_year_n0

tempfile rate
save "`rate'" // hourly rate for calendar c_ivw_year of i

rename c_ivw_year_n0 c_ivw_year_n1
rename stateusps stateusps_n1
rename state_hha state_hha_n1
rename hr_rate hr_rate_n1

tempfile rate_n1
save "`rate_n1'"

rename c_ivw_year_n1 c_ivw_year_n2
rename stateusps_n1 stateusps_n2
rename state_hha_n1 state_hha_n2
rename hr_rate_n1 hr_rate_n2

tempfile rate_n2
save "`rate_n2'"

use R01_g.dta, clear
cap drop _m
merge m:1 c_ivw_year_n0 stateusps using "`rate'"
drop if _m==2
cap drop _m
merge m:1 c_ivw_year_n1 stateusps_n1 using "`rate_n1'"
drop if _m==2
cap drop _m
merge m:1 c_ivw_year_n2 stateusps_n2 using "`rate_n2'"
drop if _m==2
cap drop _m

save R01_h.dta, replace

/********** Final Calculations For Sample Derivation *********/

use R01_h.dta, clear

gsort id nflag

by id: gen next_ivw_date = ivw_date[_n+1] // bringing forward date from prior core away from death

format %td next_ivw_date

gen n1_2_death = index_date - c_ivw_date if nflag==1
replace n1_2_death = n1_2_death * 0.0329
replace n1_2_death = ceil(n1_2_death)
replace n1_2_death = 24 if n1_2_death>=24 & n1_2_death!=.
replace n1_2_death = 1 if n1_2_death<=0

gen core_b4_death = 0
replace core_b4_death = 1 if nflag==1

gsort id -core_b4_death

gen n1_ivw_date = c_ivw_date if nflag==1

by id: carryforward n1_2_death n1_ivw_date, replace



gen ivw_time = ivw_date - next_ivw_date
replace ivw_time = ivw_time * 0.0329
label var ivw_time "Months between previous ivw & current ivw"

gen n1_2_ivw = n1_ivw_date - ivw_date
replace n1_2_ivw = n1_2_ivw * 0.0329
label var n1_2_ivw "Months between current ivw & N1 interview"



gen last_core = 1 if ivw_time==. & nflag>0
label var last_core "Last observable core, ivw_time imputed at 24 months"
replace ivw_time = 24 if ivw_time==. & nflag>0

sum ivw_time if nflag>0
/*Average time between core ivws is 24 months. So if we subtract ivw date from death, 
only need it to be >=60 since interview data extends ~24 months back */

gen months_obs = n1_2_ivw + ivw_time + n1_2_death
replace months_obs = ceil(months_obs) // round up to keep integers. Makes subsequent math easier
label var months_obs "# of months person is observed in sample"

gen hrs_gte_84m = 0
replace hrs_gte_84m = 1 if months_obs>=83.5 & months_obs!=.
label var hrs_gte_84m ">=84 months of HRS ivw data"

gen hrs_gte_60m = 0
replace hrs_gte_60m = 1 if months_obs>=60 & months_obs!=.

levelsof id if hrs_gte_60m, local(moredata)
foreach x of local moredata {
replace hrs_gte_60m = 1 if id=="`x'"
}

gen hrs_lt_60m = .
replace hrs_lt_60m = 1 if hrs_gte_60m==0
label var hrs_lt_60m "<60m of HRS ivw data, to be dropped"



levelsof id if hrs_gte_84m, local(havedata)
foreach x of local havedata {
replace hrs_gte_84m = 1 if id=="`x'"
}

gen hrs_lt_84m = .
replace hrs_lt_84m = 1 if hrs_gte_84m==0
label var hrs_lt_84m "<84 months of HRS ivw data, to be dropped"

gen ffs_84m = 0
replace ffs_84m = 1 if cont_ffs_n_mos>=84 & cont_ffs_n_mos!=. & nflag==0
label var ffs_84m "84 months of continuous FFS prior to death"


gen ffs_60m = 0
replace ffs_60m = 1 if cont_ffs_n_mos>=60 & cont_ffs_n_mos!=. & nflag==0
label var ffs_84m "60 months of continuous FFS prior to death"


gen has_imputed = imputed
label var has_imputed "Has an imputed core ivw"

levelsof id if dem_cohort==0, local(demb)
foreach x of local demb {
replace dem_cohort=0 if id=="`x'"

}

levelsof id if dem_cohort==1, local(demc)
foreach x of local demc {
replace dem_cohort=1 if id=="`x'"
}


local samplevars age_lt_72 age_lt_70 no_exit miss_core no_core nocore4yr hrs_lt_84m hrs_lt_60m has_imputed death_b4_core ffs_84m ffs_60m

foreach x of local samplevars {

levelsof id if `x'==1, local(samp)

foreach y of local samp {

replace `x'=1 if id=="`y'"
replace `x'=0 if `x'!=1

}
} 


save R01_i.dta, replace


H="Experimental - Simultaneous 5yr &  7yr Sample Derivation"
clear all
capture log close

global datapath "E:\data\burden_dementia\int_data"
local logpath "E:\data\burden_dementia\logs"
global ooppath "E:\data\burden_dementia\oopdata"
global output "E:\projects\burden_dementia\archive logs"

*log using `logpath'\sample_derivation.txt, text replace
cd $datapath

use R01_i.dta, clear
*preserve

drop if dem_cohort==.

gen ffs_lt_60m = 0
replace ffs_lt_60m = 1 if ffs_60m==0

gen ffs_lt_84m = 0
replace ffs_lt_84m = 1 if ffs_84m==0

local deri age_lt_70 no_exit miss_core no_core nocore4yr hrs_lt_60m death_b4_core ffs_lt_60m


gen final = 1
label var final "5yr Sample Size, includes decedents w/imputed core"

foreach x of local deri {
replace final = 0 if `x'==1
}

gen final_7yr = 1 if final==1
label var final_7yr "7yr Sample Size, includes decedents w/imputed core"


gen final_noimp = 0
replace final_noimp = 1 if final==1 & has_imputed==0
label var final_noimp "5yr Sample Size, excludes decedents w/imputed core"

foreach x of varlist age_lt_72 hrs_lt_84m ffs_lt_84m {
replace final_7yr = 0 if `x'==1
}

gen final_7yr_noimp = 0
replace final_7yr_noimp = 1 if final_7yr==1 & has_imputed==0
label var final_7yr_noimp "7yr Sample Size, excludes decedents w/imputed core"

label var ffs_lt_60m "<60m continuous FFS prior to death"
label var ffs_lt_84m "<84m continuous FFS prior to death"


gen dropped_7yr = 0
replace dropped_7yr = 1 if final_7yr==0 & final==1


preserve
keep if nflag==0

gen all = 1
label var all "All HRS respondents Deceased 2004-2015"
/*
local full all age_lt_72 no_exit miss_core no_core nocore4yr death_b4_core hrs_lt_84m final final_noimp final_ffs final_noimp_ffs

local rd: word count `full'

mat tab1 = J(`rd',3,.)

local r = 1

foreach x of local full {

sum `x'
mat tab1[`r',1] = r(sum)

sum `x' if dem_cohort==1
mat tab1[`r',2] = r(sum)

sum `x' if dem_cohort==0
mat tab1[`r',3] = r(sum)

local ++r
}

mat rownames tab1 = `full'


frmttable using "E:\projects\burden_dementia\archive logs\Sample_Derivation.doc", replace statmat(tab1) ///
varlabels title("Sample Derivation for R01 (Deceased 2004-2015, Age 72+)") ctitles("Reason for Exclusion" "All" "Dementia" "Non-Dementia") sdec(0) ///
annotate(stars) asymbol(*,**)note("Death Date was determined by NDI, Medicare MBSF or HRS Exit in that order. Reasons for exclusion are NOT mutally exclusive.")


 */


local full1 age_lt_70 death_b4_core no_exit miss_core no_core nocore4yr hrs_lt_60m ffs_lt_60m
local full2 final final_noimp
local full3 age_lt_72 hrs_lt_84m ffs_lt_84m 
local full4 final_7yr final_7yr_noimp

local rd: word count 1 `full1' `full2' `full3' `full4'

mat tab1 = J(`rd',3,.)

sum all
mat tab1[1,1] = r(sum)

sum all if dem_cohort==1
mat tab1[1,2] = r(sum)

sum all if dem_cohort==0
mat tab1[1,3] = r(sum)


local r = 2

foreach x of local full1 {

sum `x'
mat tab1[`r',1] = r(sum)

sum `x' if dem_cohort==1
mat tab1[`r',2] = r(sum)

sum `x' if dem_cohort==0
mat tab1[`r',3] = r(sum)

drop if `x'==1
local ++r
}

foreach x of local full2 {

sum `x'
mat tab1[`r',1] = r(sum)

sum `x' if dem_cohort==1
mat tab1[`r',2] = r(sum)

sum `x' if dem_cohort==0
mat tab1[`r',3] = r(sum)

local ++r
}

foreach x of local full3 {

sum `x'
mat tab1[`r',1] = r(sum)

sum `x' if dem_cohort==1
mat tab1[`r',2] = r(sum)

sum `x' if dem_cohort==0
mat tab1[`r',3] = r(sum)

drop if `x'==1
local ++r
}

foreach x of local full4 {

sum `x'
mat tab1[`r',1] = r(sum)

sum `x' if dem_cohort==1
mat tab1[`r',2] = r(sum)

sum `x' if dem_cohort==0
mat tab1[`r',3] = r(sum)

local ++r
}




mat rownames tab1 = all `full1' `full2' `full3' `full4'


frmttable using "E:\projects\burden_dementia\archive logs\Sample_Derivation.doc", replace statmat(tab1) ///
varlabels title("Sample Derivation for R01 (Deceased 2004-2015, Age 72+)") ctitles("Reason for Exclusion" "All" "Dementia" "Non-Dementia") sdec(0) ///
annotate(stars) asymbol(*,**)note("Death Date was determined by NDI, Medicare MBSF or HRS Exit in that order. Reasons for exclusion are ARE mutally exclusive.")

cap log close


restore
keep if final==1
save R01_j.dta, replace




H="Experimental - Annual Calculations Full Sample"

/**************** calculations *********************/
clear all
capture log close

global datapath "E:\data\burden_dementia\int_data"
local logpath "E:\data\burden_dementia\logs"
global ooppath "E:\data\burden_dementia\oopdata"
global output "E:\projects\burden_dementia\archive logs"


*log using `logpath'\R01_annual_calculations.txt, text replace

cd $datapath

use R01_j.dta, clear

/*
gen n1_2_death = index_date - c_ivw_date if nflag==1
replace n1_2_death = n1_2_death * 0.0329
replace n1_2_death = ceil(n1_2_death)
replace n1_2_death = 24 if n1_2_death>=24 & n1_2_death!=.
replace n1_2_death = 1 if n1_2_death<=0

gen core_b4_death = 0
replace core_b4_death = 1 if nflag==1

gsort id -core_b4_death

by id: carryforward n1_2_death, replace
*/
gen death_cat = .
replace death_cat = 1 if n1_2_death<12
replace death_cat = 2 if n1_2_death==12
replace death_cat = 3 if n1_2_death>12

cap drop mar_n0 mar_n1 mar_n2
cap drop mar

gen mar_n0 = . //months observed (aka "at risk") within a calendar year for helper hours cost imputation
gen mar_n1 = .
gen mar_n2 = .

replace mar_n0 = index_month if nflag==0
replace mar_n0 = n1_2_death if (n1_2_death-mar_n0 < 0) & nflag==0 // if they died the same year as their N1 ivw, then

replace mar_n1 = n1_2_death - mar_n0 if nflag==0
replace mar_n1 = 0 if mar_n1<0 & nflag==0
replace mar_n1 = 12 if (mar_n1>12 & mar_n1!=.) & nflag==0

replace mar_n2 = n1_2_death - mar_n0 -mar_n1 if nflag==0
replace mar_n2 = 0 if mar_n2<0


replace mar_n0 = c_ivw_month if nflag>0
replace mar_n1 = ivw_time - c_ivw_month if nflag>0
replace mar_n1 = 0 if mar_n1<0 & nflag>0
replace mar_n1 = 12 if (mar_n1>12 & mar_n1!=.) & nflag>0

replace mar_n2 = ivw_time - 12 - c_ivw_month if nflag>0
replace mar_n2 = 0 if mar_n2<0 & nflag>0
*replace mar_n2 = 12 if (mar_n2>12 & mar_n2!=.) & nflag>0

gen mar = mar_n0+mar_n1+mar_n2
corr mar n1_2_death if nflag==0
corr mar ivw_time if nflag>0 // checks to see if months at risk (mar) = months between ivw

gsort id +nflag

gen hlp_cost = hlphrs_i
replace hlp_cost = hlphrs_i_exit if nflag==0
replace hlp_cost = hlphrs_i_b if imputed==1

replace hlp_cost = 720 if hlp_cost>720 // capping hlphrs to 24 hours per day for each person

by id: gen hlp_cost_n = hlp_cost[_n+1]

/* Helper hours are currently 30 day estimates. Will create ~2 year totals using the
4 months at current ivw + remainder months*((current+previous)/2) */

gen hlp_cost_ivw = .
replace hlp_cost_ivw = n1_2_death*hlp_cost if n1_2_death<=4 & nflag==0
replace hlp_cost_ivw = (4*hlp_cost) + (n1_2_death-4)*((hlp_cost+hlp_cost_n)/2) if n1_2_death>4 & nflag==0
replace hlp_cost_ivw = (4*hlp_cost) + (ivw_time-4)*((hlp_cost+hlp_cost_n)/2) if nflag>0 & hlp_cost_n>0
replace hlp_cost_ivw = (4*hlp_cost) if nflag>0 & (hlp_cost_n==0 | hlp_cost_n==.)


egen hr_mean = mean(hr_rate)
egen hr_mean_n1 = mean(hr_rate_n1)
egen hr_mean_n2 = mean(hr_rate_n2)

replace hr_rate = hr_mean if hr_rate==.
replace hr_rate_n1 = hr_mean_n1 if hr_rate_n1==.
replace hr_rate_n2 = hr_mean_n2 if hr_rate_n2==.

foreach x of varlist hlp_cost_ivw  {

replace `x' = `x'/n1_2_death if nflag==0
replace `x' = `x'/ivw_time if nflag>0
replace `x' = (`x'*mar_n0*hr_rate) +  (`x'*mar_n1*hr_rate_n1) + (`x'*mar_n2*hr_rate_n2)

}


gen oop_cost = total_oop
replace oop_cost = total_imp_b if imputed==1
replace oop_cost = total_oop_exit if nflag==0

replace ivw_time = ceil(ivw_time)
replace ivw_time = 1 if ivw_time==0 & nflag==0

// Combining original OOP and imputed OOP into a single variable 


keep id death_cat nflag oop_cost hlp_cost_ivw n1_2_death c_ivw_year ivw_time

reshape wide oop_cost hlp_cost_ivw c_ivw_year ivw_time, i(id) j(nflag)


gen a = n1_2_death
gen b = ivw_time1
gen c = ivw_time2
gen d = ivw_time3
gen e = ivw_time4

*keep if death_cat<3

/* Year 1 cost imputation */


gen oop_y1 = ((a*oop_cost0)/ivw_time0) + (((12-a)*oop_cost1)/ivw_time1) if death_cat<=2
gen informal_y1 = ((a*hlp_cost_ivw0)/ivw_time0) + (((12-a)*hlp_cost_ivw1)/ivw_time1) if death_cat<=2

replace oop_y1 = ((12*oop_cost0)/ivw_time0) if death_cat==3
replace informal_y1 = ((12*hlp_cost_ivw0)/ivw_time0) if death_cat==3

replace b = b-(12-a) if death_cat<=2 // subtract the amount of months of N1 ivw that was used in Year 1
replace a = a - 12 if death_cat==3
replace a = 0 if death_cat<3

/* Year 2 cost */


gen oop_y2 = ((a*oop_cost0)/ivw_time0) +  (((12-a)*oop_cost1)/ivw_time1) if death_cat==3

gen informal_y2 = ((a*hlp_cost_ivw0)/ivw_time0) +  (((12-a)*hlp_cost_ivw1)/ivw_time1) if death_cat==3


replace b = b-(12-a) if death_cat==3

replace oop_y2 = ((b*oop_cost1)/ivw_time1) if b>=12 & death_cat<3
replace oop_y2 = ((b*oop_cost1)/ivw_time1) + (((12-b)*oop_cost2)/ivw_time2) if b<12 & death_cat<3


replace informal_y2 = ((b*hlp_cost_ivw1)/ivw_time1) if b>=12 & death_cat<3
replace informal_y2 = ((b*hlp_cost_ivw1)/ivw_time1) + (((12-b)*hlp_cost_ivw2)/ivw_time2) if b<12 & death_cat<3


replace c = c-(12-b) if b<12 & death_cat<2 // if b<12, part of the year came from N2 and needs to be subtracted
replace b = 0 if b<12 & death_cat<2 // recoding b to 0 to show that N1 interview will no longer contribute to cost
replace b = b-12 if b>=12 & death_cat<2 // if b>=12, used a full year of data from N1


/* Year 3 cost */

gen oop_y3 = ((b*oop_cost1)/ivw_time1) if b>=12
replace oop_y3 = ((b*oop_cost1)/ivw_time1) + (((12-b)*oop_cost2)/ivw_time2) if b<12


gen informal_y3 = ((b*hlp_cost_ivw1)/ivw_time1) if b>=12
replace informal_y3 = ((b*hlp_cost_ivw1)/ivw_time1) + (((12-b)*hlp_cost_ivw2)/ivw_time2) if b<12


replace c = c-(12-b) if b<12 // if b<12, part of the year came from N2 and needs to be subtracted
replace b = 0 if b<12 // recoding b to 0 to show that N1 interview will no longer contribute to cost
replace b = b-12 if b>=12 // if b>=12, used a full year of data from N1


/* Year 4 cost */

tab b
tab ivw_time1 /* not sure why so many people have >24 months attributed to 1 interview
there are weird cases e.g. 2010 core has a 2011 ivw date, so it ends up being ~ 3 years
between 2008 core and 2010. But expecting those to be in the minority */

*replace b = 12 if b>12 // need to remove and properly fix later

gen oop_y4 = ((b*oop_cost1)/ivw_time1) + (((12-b)*oop_cost2)/ivw_time2) if b>0 & b<=12 // if b = 12 the second term is zero
gen informal_y4 = ((b*hlp_cost_ivw1)/ivw_time1) + (((12-b)*hlp_cost_ivw2)/ivw_time2) if b>0 & b<=12 // if b = 12 the second term is zero

replace oop_y4 = ((b*oop_cost1)/ivw_time1) if b>=12
replace informal_y4 = ((b*hlp_cost_ivw1)/ivw_time1) if b>=12

gen tempflag = 1 if oop_y4!=.

replace c = c-(12-b) if b>0 & b<12 & tempflag==1 // if b<12, part of the year came from N2 and needs to be subtracted
replace b = 0 if b<12 & tempflag==1 // recoding b to 0 to show that N1 interview will no longer contribute to cost
replace b = b-12 if b>=12 & tempflag==1 // if b>=12, used a full year of data from N1

tab b


replace oop_y4 = ((c*oop_cost2)/ivw_time2) + (((12-c)*oop_cost3)/ivw_time3) if c<=12 & oop_y4==.
replace oop_y4 = ((c*oop_cost2)/ivw_time2) if c>12 & oop_y4==.

replace informal_y4 = ((c*hlp_cost_ivw2)/ivw_time2) + (((12-c)*hlp_cost_ivw3)/ivw_time3) if c<=12 & informal_y4==.
replace informal_y4 = ((c*hlp_cost_ivw2)/ivw_time2) if c>12 & informal_y4==.

replace d = d - (12-c) if c<12 & tempflag==.
replace c = 0 if c<12 & tempflag==.
replace c = c - 12 if c>=12 & tempflag==.

drop tempflag

/* Year 5 */

tab b

gen oop_y5 = ((b*oop_cost1)/ivw_time1) + (((12-b)*oop_cost2)/ivw_time2) if b>0 & b<=12
gen informal_y5 = ((b*hlp_cost_ivw1)/ivw_time1) + (((12-b)*hlp_cost_ivw2)/ivw_time2) if b>0 & b<=12 

replace oop_y5 = ((b*oop_cost1)/ivw_time1) if b>=12
replace informal_y5 = ((b*hlp_cost_ivw1)/ivw_time1) if b>=12

gen tempflag = 1 if oop_y5!=.

replace c = c-(12-b) if b>0 & b<12 & tempflag==1 // if b<12, part of the year came from N2 and needs to be subtracted
replace b = 0 if b<12 & tempflag==1 // recoding b to 0 to show that N1 interview will no longer contribute to cost
replace b = b-12 if b>=12 & tempflag==1 // if b>=12, used a full year of data from N1

replace oop_y5 = ((c*oop_cost2)/ivw_time2) + (((12-c)*oop_cost3)/ivw_time3) if c<=12 & oop_y5==.
replace oop_y5 = ((c*oop_cost2)/ivw_time2) if c>12 & oop_y5==.

replace informal_y5 = ((c*hlp_cost_ivw2)/ivw_time2) + (((12-c)*hlp_cost_ivw3)/ivw_time3) if c<=12 & informal_y5==.
replace informal_y5 = ((c*hlp_cost_ivw2)/ivw_time2) if c>12 & informal_y5==.

replace d = d - (12-c) if c<12 & tempflag==.
replace c = 0 if c<12 & tempflag==.
replace c = c - 12 if c>=12 & tempflag==.

drop tempflag

/* Year 6 */


gen oop_y6 = ((b*oop_cost1)/ivw_time1) + (((12-b)*oop_cost2)/ivw_time2) if b>0 & b<=12
gen informal_y6 = ((b*hlp_cost_ivw1)/ivw_time1) + (((12-b)*hlp_cost_ivw2)/ivw_time2) if b>0 & b<=12 

replace c = c-(12-b) if b>0 & b<12 & oop_y6!=. // if b<12, part of the year came from N2 and needs to be subtracted
replace b = 0 if b<12 & oop_y6!=. // recoding b to 0 to show that N1 interview will no longer contribute to cost
replace b = b-12 if b>=12 & oop_y6!=. // if b>=12, used a full year of data from N1

gen tempflag = 1 if c<=12 & oop_y6==.

replace oop_y6 = ((c*oop_cost2)/ivw_time2) + (((12-c)*oop_cost3)/ivw_time3) if c<=12 & oop_y6==.
replace informal_y6 = ((c*hlp_cost_ivw2)/ivw_time2) + (((12-c)*hlp_cost_ivw3)/ivw_time3) if c<=12 & informal_y6==.

replace d = d-(12-c) if c<12 & tempflag==1 // if b<12, part of the year came from N2 and needs to be subtracted
replace d = 0 if d<0 // temporary fix. 
replace c = 0 if c<12 & tempflag==1
replace c = c-12 if c>=12 & tempflag==1

gen tempflag1 = 1 if oop_y6==.

replace oop_y6 = ((d*oop_cost3)/ivw_time3) + (((12-d)*oop_cost4)/ivw_time4) if d<=12 & oop_y6==.
replace oop_y6 = ((d*oop_cost3)/ivw_time3) if d>12 & oop_y6==.

replace informal_y6 = ((d*hlp_cost_ivw3)/ivw_time3) + (((12-d)*hlp_cost_ivw4)/ivw_time4) if d<=12 & informal_y6==.
replace informal_y6 = ((d*hlp_cost_ivw3)/ivw_time3) if d>12 & informal_y6==.

replace e = e-(12-d) if d<12 & tempflag1==1
replace d = 0 if d<12 & tempflag1==1
replace d = d-12 if d>=12 & tempflag1==1

drop tempf*


/* Year 7 */

gen oop_y7 = ((c*oop_cost2)/ivw_time2) + (((12-c)*oop_cost3)/ivw_time3) if c>0 & c<=12 
replace oop_y7 = ((12*oop_cost2)/ivw_time2) if c>=12

replace oop_y7 = ((12*oop_cost3)/ivw_time3) if d>12 & oop_y7==.
replace oop_y7 = ((d*oop_cost3)/ivw_time3) + (((12-d)*oop_cost4)/ivw_time4) if d<=12 & oop_y7==.


gen informal_y7 = ((c*hlp_cost_ivw2)/ivw_time2) + (((12-c)*hlp_cost_ivw3)/ivw_time3) if c>0 & c<=12
replace informal_y7 = ((12*hlp_cost_ivw2)/ivw_time2) if c>12
replace informal_y7 = ((12*hlp_cost_ivw3)/ivw_time3) if d>12 & informal_y7==.
replace informal_y7 = ((d*hlp_cost_ivw3)/ivw_time3) + (((12-d)*hlp_cost_ivw4)/ivw_time4) if d<=12 & informal_y7==.




/* Visual check */

foreach x of varlist oop_y* informal_y* {

sum `x' 
}

save R01_annualized.dta, replace

*log close


H="experimental-adding kids to helper file"


H="Experimental - Comparison of 5yr vs 7yr Sample"
clear all
capture log close

global datapath "E:\data\burden_dementia\int_data"
global final "E:\data\burden_dementia\final_data"
local logpath "E:\data\burden_dementia\logs"
global ooppath "E:\data\burden_dementia\oopdata"
global output "E:\projects\burden_dementia\archive logs"

cd $datapath

use "E:\data\burden_dementia\int_data\predicted_annual_medicaid_costs.dta", clear

rename year index_year

tempfile predict
save `predict'


use R01_j.dta, clear

merge m:1 id using R01_annualized.dta, keepus(oop_y* informal_y*)
drop _m

merge m:1 id using tot_paid_maid.dta, keepus(tot_paid_m*)
drop if _m==2
cap drop _m

merge m:1 id index_year using `predict', keepus(buyin_mo generous)
drop if _m==2
cap drop _m



gen ffs_7yr = 0 
replace ffs_7yr = 1 if cont_ffs_n_mos>=84 & cont_ffs_n_mos!=.

gen ffs_6yr = 0 
replace ffs_6yr = 1 if cont_ffs_n_mos>=72 & cont_ffs_n_mos!=.

gen ffs_5yr = 0
replace ffs_5yr = 1 if cont_ffs_n_mos>=60 & cont_ffs_n_mos!=.

gen ffs_4yr = 0
replace ffs_4yr = 1 if cont_ffs_n_mos>=48 & cont_ffs_n_mos!=.

gen ffs_3yr = 0
replace ffs_3yr = 1 if cont_ffs_n_mos>=36 & cont_ffs_n_mos!=.

gen ffs_2yr = 0
replace ffs_2yr = 1 if cont_ffs_n_mos>=24 & cont_ffs_n_mos!=.

gen ffs_1yr = 0
replace ffs_1yr = 1 if cont_ffs_n_mos>=12 & cont_ffs_n_mos!=.


gen white = 0 if nflag==0
replace white = 1 if race==1 & hisp_eth==0 & nflag==0

gen black = 0 if nflag==0
replace black = 1 if race==2 & hisp_eth==0 & nflag==0

gen other = 0 if nflag==0
replace other = 1 if white==0 & black==0 & hisp_eth==0 & nflag==0

label var white "Non-Hispanic White"
label var black "Non-Hispanic Black"
label var other "Non-Hispanic Other"

label var tot_paid_maid_n1 "Total Medicaid Spending Y1"
label var tot_paid_maid_n2 "Total Medicaid Spending Y2"
label var tot_paid_maid_n3 "Total Medicaid Spending Y3"
label var tot_paid_maid_n4 "Total Medicaid Spending Y4"
label var tot_paid_maid_n5 "Total Medicaid Spending Y5"
label var tot_paid_maid_n6 "Total Medicaid Spending Y6"
label var tot_paid_maid_n7 "Total Medicaid Spending Y7"

forvalues i = 1/7 {
rename tot_paid_maid_n`i' tot_paid_maid_y`i'
}

local y = 1
forvalues i = 12(12)84 {



rename tot_paid_by_mc_`i'm tot_paid_by_mc_y`y'

label var tot_paid_by_mc_y`y' "Total Medicare Spending Y`y'"

local ++y
}

gen adl_dep_n1 = 0 if nflag<=1 & adl_index_core!=.
replace adl_dep_n1 = 1 if adl_index_core>0 & adl_index_core!=. & nflag==1
label var adl_dep_n1 "ADL Dependent at N1"

gen iadl_dep_n1 = 0 if nflag<=1 & iadl_ind_core!=.
replace iadl_dep_n1 = 1 if nflag==1 & iadl_ind_core>0 & iadl_ind_core!=.
label var iadl_dep_n1 "IADL Dependent at N1"

levelsof id if adl_dep_n1==1, local(adldep)

foreach x of local adldep {
replace adl_dep_n1 = 1 if id=="`x'" & nflag==0
}

levelsof id if iadl_dep_n1==1, local(iadldep)
foreach x of local iadldep {
replace iadl_dep_n1 = 1 if id=="`x'" & nflag==0
}


local ivars female_exit hseduc white black hisp_eth other nhres_exit married_exit reschil_d_exit resspouse_exit livealone_exit adl_dep_n1 iadl_dep_n1 medicare_exit medicareb_exit medicaid_exit champus_exit dem_cohort ffs_7yr ffs_6yr ffs_5yr ffs_4yr ffs_3yr ffs_2yr ffs_1yr
local cvars age_at_death comor_in_hrs 
local medcost age_at_death tot_paid_maid_y1 tot_paid_maid_y2 tot_paid_maid_y3 tot_paid_maid_y4 tot_paid_maid_y5 tot_paid_maid_y6 tot_paid_maid_y7 tot_paid_by_mc_y1 tot_paid_by_mc_y2 tot_paid_by_mc_y3 tot_paid_by_mc_y4 tot_paid_by_mc_y5 tot_paid_by_mc_y6 tot_paid_by_mc_y7 ///
oop_y1 oop_y2 oop_y3 oop_y4 oop_y5 oop_y6 oop_y7 informal_y1 informal_y2 informal_y3 informal_y4 informal_y5 informal_y6 informal_y7 


gsort id nflag
by id: carryforward `ivars', replace



save $final\R01_final.dta, replace

preserve 
keep if nflag==1

gen all = 1



local rd: word count `ivars' `cvars' 1

mat tab1=J(`rd', 3,.)
mat stars=J(`rd',3,0)
local r = 1

foreach x of local ivars {

sum `x' if all==1

mat tab1[`r',1] = r(mean)*100

sum `x' if all==1 & final_7yr==1
mat tab1[`r',2] = r(mean)*100

sum `x' if all==1 & final_7yr==0
mat tab1[`r',3] = r(mean)*100

tab `x' final_7yr if all==1, chi2
mat stars[`r',2] = (r(p)<.01) + (r(p)<0.05)



local ++r
}

foreach x of local cvars {

sum `x' if all==1 

mat tab1[`r',1] = r(mean)

sum `x' if all==1 & final_7yr==1
mat tab1[`r',2] = r(mean)

sum `x' if all==1 & final_7yr==0
mat tab1[`r',3] = r(mean) 

ttest `x' if all==1, by(final_7yr)
mat stars[`r',2] = (r(p)<.01) + (r(p)<.05)


local ++r
}


sum nflag if all==1
mat tab1[`r',1] = r(N)

sum nflag if all==1 & final_7yr==1
mat tab1[`r',2] = r(N)

sum nflag if all==1 & final_7yr==0
mat tab1[`r',3] = r(N)





mat rownames tab1 = `ivars' `medcost' N

frmttable using "E:\projects\burden_dementia\archive logs\Sample_comparison.doc", replace statmat(tab1) ///
varlabels title("Summary Statistics For R01 Sample (Deceased 2004-2015, Age 72+ at Death)") ctitles("", "", "Full Sample", "", "Excludes Decedents", " w/Imputated Core", "" \"Variables", "All","Dementia","No Dementia", "All","Dementia","No Dementia"  ) sdec(2) ///
vlines(01001001) annotate(stars) asymbol(*,**)note("All costs have been inflation adjusted to 2016 dollars. <0.05*, p<0.01**")


H="Comparison table 5 v 7 yrs"
clear all
capture log close

global datapath "E:\data\burden_dementia\int_data"
global final "E:\data\burden_dementia\final_data"
local logpath "E:\data\burden_dementia\logs"
global ooppath "E:\data\burden_dementia\oopdata"
global output "E:\projects\burden_dementia\archive logs"

cd `logpath'

use ${final}\R01_final.dta, clear

gsort id -nflag
by id: carryforward pdem, replace

keep if nflag==0 & ffs_60==1 & age_at_death>=70 
replace ffs_84=0 if age_at_death<72


keep if !missing(pdem)

gen n=1

local cvars1 age_at_death
local cvars2 pdem
local cvars3
local ivars1 age_lt_70 age_lt_72 
local ivars2 dem_cohort female_exit white black other hospice_exit nhres_exit married_exit ///
reschil_d_exit resspouse_exit livealone_exit adl_independent_exit ///
adl_severe_exit medicare_exit medicareb_exit medicaid_exit champus_exit
local ivars3
local catvars1
local catvars2 
local catvars3

local rn : word count `cvars1' `cvars2' `cvars3' `ivars1' `ivars2' `ivars3'

mat tab=J(`rn'+1,3,.)
mat stars=J(`rn'+1,3,0)

local r=1
local c=1


forvalues i=1/2 {
	foreach x of local cvars`i' {
		forvalues j=0/1 {
			sum `x' if ffs_84==`j'
			mat tab[`r',`c']=r(mean)
			if `j'==1 {
				ttest `x', by(ffs_84)
				mat tab[`r',`c'+1]=r(p)
				mat stars[`r',`c'+1]=(r(p)<.05)+(r(p)<.01)
}
			local c=`c'+1
}
		local c=1
		local r=`r'+1
}
	foreach x of local ivars`i' {
		forvalues j=0/1 {
			sum `x' if ffs_84==`j'
			mat tab[`r',`c']=r(mean)*100
			if `c'==2 {
				tab `x' ffs_84, chi2
				mat tab[`r',`c'+1]=r(p)
				mat stars[`r',`c'+1]=(r(p)<.05)+(r(p)<.01)
}
			local c=`c'+1
}
		local c=1
		local r=`r'+1
		
}	
}	
forvalues i=0/1 {
	sum n if ffs_84==`i'
	mat tab[`r',`i'+1]=r(N)
}

mat rownames tab=`cvars1' `ivars1' `cvars2'  `ivars2' `ivars3' `cvars3'  N

frmttable using characteristics_comparison_5_7_yrs_ffs.rtf, statmat(tab) title("Comparison of those w/ 60m FFS only and 84m FFS") ///
ctitles("" "60-83m FFS" "84+m FFS" "P-value") ///
annotate(stars) asymbol(*,**) varlabels sdec(2) replace


H="********************************"


H="Sample derivation"
clear all
capture log close

local datapath "E:\data\burden_dementia\int_data"
local logpath "E:\data\burden_dementia\logs"
local ooppath "E:\data\burden_dementia\oopdata"

/****************** START WITH EXIT **********************/

use "E:\data\hrs_cleaned\exit_02_to_14_dt.dta", clear

foreach x of varlist * {

rename `x' `x'_exit
}

rename id_exit id

gen nflag = 0
cap drop _m
tempfile exit
gen year = exit_year_exit
save `exit' // all exit interviews 2002-14

/**************** MERGE TRACKER WITH DECEDENT DATASET ***********/

use "E:\data\hrs_cleaned\restr_tracker_v2014.dta", clear
drop id
gen id=hhid+pn
drop if id==""
keep id race hisp_eth birthmo birthday birthyr birth_date gender degree
tempfile track
save `track' // all restricted tracker

cd `datapath'

use decedent_dataset.dta if inrange(index_year,2006,2015), clear
cap drop year
cap drop _m
format %td index_date
merge m:1 id using "`track'"
keep if _m==3

replace birth_date=mdy(6,birthd,birthy) if missing(birth_date)
cap drop death_date
gen death_date = index_date
gen age_at_death=floor((death_date-birth_date)/365.25)

cap drop _m


/* Sample derivation Dataset 
tempfile sample
preserve
gen age_lt_70 = 0
replace age_lt_70 = 1 if age_at_death<70
label var age_lt_70 "Age at death <70"
save `sample'
restore 
*/

levelsof id if age_at_death<72, local(agedrop)

drop if age_at_death<70 /////////////// drop people <70 at death (800)

merge 1:1 id using "`exit'"

/* Sample derivation
preserve
gen no_exit = 1 if _m==1
keep if no_exit
keep id no_exit
tempfile noexit
save `noexit'

use "`sample'", clear
merge 1:1 id using "`noexit'", keepus(no_exit)
label var no_exit "No exit ivw 2002-2014"
cap drop _m
save `sample', replace
restore
************ */
levelsof id if _m==1, local(exitdrop) 
keep if _m==3 /////////// drop people with no exit (387)

cap drop _m

tempfile r01
save `r01'

keep id index_date index_year
tempfile id 
save `id' //decedents with exit 

/*************** MERGE WITH CORE INTERVIEW **************/

use "E:\data\hrs_cleaned\core_00_to_14.dta", clear

merge m:1 id using "`id'", keepus(index_date index_year)
levelsof id if _m==2, local(nocoredrop)
keep if _m==3 ///////////// 25 people no core interviews ever

cap drop _m

gsort id -core_year

by id: gen obs=_n

keep if obs<=4

gen ivw_date = c_ivw_date

by id: gen next_ivw_date = ivw_date[_n+1] // date prev ivw chronologically

by id: gen next_ivw_year = core_year[_n+1]

gen earliest = 0
replace earliest = 1 if next_ivw_year==.
label var earliest "flag for earliest observable core"


keep if obs<=4 // keep last 3 hrs interviews


by id: gen diff = core_year - core_year[_n-1] // -4 or higher denotes a gap year

bysort id: egen gap = min(diff)

replace gap = abs(gap) // max number of years between consecutive core
label var gap "max # of yrs between consecutive core ivw"
tab gap
preserve
keep if gap>4
keep id
duplicates drop 
levelsof id, local(misscore)
tempfile droplist
save `droplist' ///////// people with more than 4 year gap between cores

restore

drop obs gap diff
gen year = core_year

cap drop _m

/* merge with dementia dataset */

merge 1:1 id core_year using "E:\data\hrs_public_2014\dementia\pdem_withvarnames_00_14", keepus(pdem)
drop if _m==2

gen dementia = 0
replace dementia = 1 if pdem>=.5 & pdem!=.
cap drop _m


tempfile core
save `core'

use "`r01'", clear
append using "`core'"

merge m:1 id using "`droplist'" //dropping people with >4 years between core

codebook id if _m==3
drop if _m==3
cap drop _m

codebook id

gsort id -year

by id: gen obs=_n

foreach x of local nocoredrop {

drop if obs==1 & id=="`x'" // dropping exit ivw for people with no core ever (2000-12)

}

gen nflag_ivw = obs - 1
label var nflag_ivw "Interview type, 0 = exit, 1 = N1, etc."

gen dem_cohort = 0

levelsof id if dementia==1 & nflag_ivw==1, local(demlist)

foreach x of local demlist {

replace dem_cohort = 1 if id=="`x'"

}




gen core_5yr = index_year - core_year if obs==2 
preserve 

keep if core_5yr>4 & obs==2
keep id
levelsof id, local(core4yr) 
tempfile core_2_far 
save `core_2_far' /////////////// no core ivw within 4yrs of death

restore

merge m:1 id using "`core_2_far'"
codebook id if _m==3
drop if _m==3 // dropping ppl with no core_ivw within 4 yrs
cap drop _m

gsort id -year


by id: gen diff = year - year[_n-1] // -4 or higher denotes a gap year

/*
gen ivw_date = c_ivw_date
replace ivw_date = e_ivw_date_exit if nflag_ivw==0

 by id: gen next_ivw_date = ivw_date[_n+1] */

gen ex2far = 0
replace ex2far = 1 if diff<-4 & obs==2

gen divide = 1
replace divide = 2 if diff<=-4  & ex2far==0

expand 2 if diff<=-4, gen(imputed) 

replace year = year + 2 if imputed==1 // imputed core interview

levelsof id if imputed==1, local(impu)

cap drop nflag

gsort id -year
by id: gen nflag = _n
replace nflag = nflag - 1

drop if nflag>4

cd "E:\data\burden_dementia\int_data"
save R01_int_2015.dta, replace

use R01_int_2015.dta, clear

keep if nflag_ivw==0
keep id index_date index_year exit_year_exit year
tempfile index
save `index'

/*
drop nflag obs

gsort id -year
by id: gen nflag==_n-1
*/

/**************** GET OOP DATA ********************/

local ooppath "E:\data\burden_dementia\oopdata"

use `ooppath'\oopme_final_2016.dta, clear
rename *, l
gen id=hhid+pn

merge m:1 id using "`index'", keepus(index_year index_date)
keep if _m==3 // only keep oop data for people in cohort

tab year if total_oop==.
drop if total_oop==.
preserve
*keep if iwtype==0 // keep non-imputed non-exit ivw
tempfile oop_mer
save `oop_mer' // original dataset, not imputed
restore 


gsort id -year

by id: gen obs=_n

keep if obs<=4

by id: gen diff = year - year[_n-1] // -4 or higher denotes a gap year


replace diff = -4 if diff<=-4 & obs==2 // recoding people with >4 gap between exit and N1 to be 4yrs


/*
bysort id: egen gap = min(diff)
keep if gap==-4 /* only keep people without consecutive missing interviews */
*/


expand 2 if diff==-4, gen(ooptag) //created imputed interview

replace year = year + 2 if ooptag==1

gsort id -year

cap drop obs
by id: gen obs=_n

by id: gen total_imp_a = total_oop[_n+1] if ooptag==1
by id: gen total_imp_b = (total_oop[_n+1] + total_oop[_n-1])/2 if ooptag==1

label var ooptag "imputed oop"

keep if ooptag==1

tempfile imputed
save `imputed'


use "`oop_mer'", clear

append using "`imputed'"
cap drop _m 
preserve
drop if iwtype==1

tempfile oop
save `oop'
restore 

keep if iwtype==1

gen nflag = 0

foreach x of varlist total* {

rename `x' `x'_exit
}
rename year exit_year_exit

tempfile oop_exit
save `oop_exit'

use R01_int_2015.dta, clear
cap drop _m
merge 1:1 id year using "`oop'", keepus(total* ooptag)
*merge 1:1 id year using "`oop'", keepus(total* ooptag)
drop if _m==2
cap drop _m

merge 1:1 id nflag using "`oop_exit'", keepus(total* ooptag)

drop if _m==2
cap drop _m

save R01_int_2015.dta, replace

/*
use R01_int_2015.dta, clear

keep if nflag_ivw==0
keep id index_date index_year exit_year_exit year
tempfile index
save `index'
*/


/************ Get Helper data ***********/

use id year ivw_type *_k *_s *_i *_u using "E:\data\hrs_cleaned\helper_hours_2014.dta", clear
*rename year core_year
//cap number of hours at 720 (24 hrs for 30 days) for spouses and other informal
gen hlphrs_nk=hlphrs_u-hlphrs_k

foreach x in s u k nk {
replace hlphrs_`x'=720 if hlphrs_`x'>720
replace hlphrs_`x' = 0 if hlphrs_`x'==.
}
replace hlphrs_i=hlphrs_s+hlphrs_u

merge m:1 id using "`index'", keepus(index_year index_date)
keep if _m==3 // only keep helper data for people in cohort
drop _m

tempfile hlp_mer

save `hlp_mer'

merge 1:1 id year using "`index'", keepus(id exit_year_exit year)

gen inx = ivw_type-1
replace inx = 1 if _m==2
foreach x in i s u k {
replace hlphrs_`x' = 0 if _m==2
}


gsort id -year

by id: gen obs=_n

tab inx if obs==2

by id: gen diff = year - year[_n-1] // -4 or higher denotes a gap year

replace diff = -4 if diff<=-4 & obs==2 // replacing obs where gap between exit and N1 was >4yrs, since we already kept people who had core in last years of life

expand 2 if diff==-4, gen(hlptag)



replace year = year + 2 if hlptag==1

replace hlptag=1 if _m==2

cap drop obs

gsort id -year

by id: gen obs=_n

foreach x in i s u k nk {
by id: gen hlphrs_`x'_a = hlphrs_i[_n+1] if hlptag==1
by id: gen hlphrs_`x'_b = (hlphrs_i[_n+1] + hlphrs_i[_n-1])/2 if hlptag==1
}

label var hlptag "imputed hlp hrs"

gen hlp_exit = 1 if hlptag==1 & _m==2
label var hlp_exit "hlp exit imputed"
replace hlptag = 0 if _m==2
preserve
keep if hlptag==1 

tempfile hlp
save `hlp'


use "`hlp_mer'", clear

append using "`hlp'"
cap drop _m

drop if inx==1


tempfile help
save `help'
restore 

keep if inx==1

gen nflag = 0

foreach x of varlist hlphrs_* {

rename `x' `x'_exit
}

tempfile hlp_exit 
save `hlp_exit'


use R01_int_2015.dta, clear
cap drop _m
merge 1:1 id year using "`help'", keepus(hlphrs_* hlptag hlp_exit)
*merge 1:1 id year using "`help'", keepus(hlphrs_* hlptag)
drop if _m==2

cap drop _m

merge 1:1 id nflag using "`hlp_exit'", keepus(hlphrs_* hlptag hlp_exit) update

drop if _m==2
cap drop _m

foreach x of varlist hlphrs_* {

replace `x' = 0 if (hlptag==1 & imputed==0)
replace `x' = 0 if `x'==.
}

gen year_n0 = year
replace year_n0 = index_year if nflag==0
gen year_n1 = year_n0 - 1
label var year_n1 "calendar year prior to ivw date"
gen year_n2 = year_n0 - 2
label var year_n2 "calendar year 2 yrs prior to ivw date"


save R01_int_2015.dta, replace


use R01_int_2015.dta, clear
keep id

duplicates drop id, force
tempfile id
save `id'

/************** Get State information *************/

use "E:\data\hrs_cleaned\restr_tracker_v2014.dta", clear
drop id
gen id=hhid+pn

merge 1:1 id using "`id'"
keep if _m==3

keep hhid pn stateusps* zipcode*

foreach x of varlist stateusps* {

replace `x' = "" if `x'=="ZZ"

}

gen stateusps97=""
gen stateusps99=""

forvalues i= 1(2)13{
gen stateusps`i'=""
gen zipcode`i' = ""
}

forvalues i=0(2)8{
rename stateusps0`i' stateusps`i'
rename zipcode0`i' zipcode`i'
}
reshape long stateusps zipcode, i(hhid pn) j(year)

forvalues i=0/99{
qui replace year=200`i' if year==`i' & year<=9
qui replace year=20`i' if year==`i' & inrange(year, 10,14)
qui replace year=19`i' if year==`i' & year>=90
}

gen id= hhid+pn
sort id year
drop if id==""
by id: carryforward stateusps, replace

gsort id -year
by id: carryforward stateusps, replace

/*
expand 2 if year==2012, gen(dupkey)

replace year = 2014 if dupkey==1


expand 2 if year==2014, gen(dup2)
replace year= 2013 if dup2==1
*/

tempfile state
save "`state'"

rename year year_n1
rename stateusps stateusps_n1
tempfile state_n1
save `state_n1'

rename year_n1 year_n2
rename stateusps_n1 stateusps_n2 
tempfile state_n2
save `state_n2'

use R01_int_2015.dta, clear
merge 1:1 id year using "`state'"
keep if _m==3
cap drop _m
merge m:1 id year_n1 using "`state_n1'"
keep if _m==3
cap drop _m
merge m:1 id year_n2 using "`state_n2'"
keep if _m==3
cap drop _m


save R01_int_2015.dta, replace

//merging with the Genworth/Metlife hourly home health aide cost. 
import excel "E:\data\burden_dementia\ref_data\Cost Care Survey (Genworth-Metlife)\HHA_hourly_genworth.xlsx", ///
sheet("Sheet1") firstrow clear

rename A year
rename B stateusps
rename HomeHealthAideServicesHourly state_hha
rename MedianHourlyRate hr_rate

drop if year==.
destring hr_rate, replace

expand 2 if year==1998, gen(duptag)

replace year = year - 1 if duptag==1
cap drop duptag

expand 2 if year==1997, gen(duptag)

replace year = year - 1 if duptag==1
drop duptag

rename year year_n0

tempfile rate
save "`rate'"

rename year_n0 year_n1
rename stateusps stateusps_n1
rename state_hha state_hha_n1
rename hr_rate hr_rate_n1

tempfile rate_n1
save "`rate_n1'"

rename year_n1 year_n2
rename stateusps_n1 stateusps_n2
rename state_hha_n1 state_hha_n2
rename hr_rate_n1 hr_rate_n2

tempfile rate_n2
save "`rate_n2'"

use R01_int_2015.dta, clear
cap drop _m
merge m:1 year_n0 stateusps using "`rate'"
keep if _m==3
cap drop _m
merge m:1 year_n1 stateusps_n1 using "`rate_n1'"
keep if _m==3
cap drop _m
merge m:1 year_n2 stateusps_n2 using "`rate_n2'"
keep if _m==3
cap drop _m

/**************** calculations *********************/

gen core_b4_death = 0
replace core_b4_death = 1 if nflag==1

gen n1_2_death = index_date - c_ivw_date if core_b4_death==1
replace n1_2_death = n1_2_death * 0.033
replace n1_2_death = ceil(n1_2_death)
replace n1_2_death = 24 if n1_2_death>=24 & n1_2_death!=.
replace n1_2_death = 1 if n1_2_death<=0


gen death_cat = .
replace death_cat = 1 if n1_2_death<12
replace death_cat = 2 if n1_2_death==12
replace death_cat = 3 if n1_2_death>12 & n1_2_death!=.

gsort id -core_b4_death

carryforward death_cat n1_2_death, replace

gen all = 1
bysort id: egen count = total(all)

codebook id if count==4
levelsof id if count==4 & death_cat==1, local(non4)

drop if count==4 & death_cat==1 /////////// dropping people with no N3 but death_cat ==1


cap drop ivw_time
gen ivw_time = ivw_date - next_ivw_date
*replace ivw_time = index_date - ivw_date if ex2far==1

replace ivw_time = ivw_time * 0.03
gen imp = core_year-next_ivw_year
replace ivw_time = 48 if imp>=6 & imp!=. // recode people with exit >2yrs from death  to cap it at 48m
replace ivw_time = 24 if earliest==1
replace imp = 1 if imp>=4 & imp!=.

replace ivw_time = ivw_time/2 if imp==1
replace ivw_time = ceil(ivw_time)

tab ivw_time
label var ivw_time "interview weight" 

cap drop mar_n0 mar_n1 mar_n2
cap drop mar

gen mar_n0 = . //months at risk
gen mar_n1 = .
gen mar_n2 = .
gen mar_n3 = .

replace mar_n0 = index_month if nflag==0
*replace mar_n0 = n1_2_death if n1_2_death<12 & nflag==0
replace mar_n0 = n1_2_death if (n1_2_death-mar_n0 < 0) & nflag==0

replace mar_n1 = n1_2_death - mar_n0 if nflag==0
replace mar_n1 = 0 if mar_n1<0 & nflag==0
replace mar_n1 = 12 if (mar_n1>12 & mar_n1!=.) & nflag==0



replace mar_n2 = n1_2_death - mar_n0 -mar_n1 if nflag==0
replace mar_n2 = 0 if mar_n2<0
*replace mar_n2 = 12 if (mar_n2>12 & mar_n2!=.) & nflag==0

replace mar_n3 = n1_2_death - mar_n0 -mar_n1 -mar_n2 if nflag==0
replace mar_n3 = 0 if mar_n3<0


replace mar_n0 = c_ivw_month if nflag>0


replace mar_n1 = ivw_time - c_ivw_month if nflag>0
replace mar_n1 = 0 if mar_n1<0 & nflag>0
replace mar_n1 = 12 if (mar_n1>12 & mar_n1!=.) & nflag>0

replace mar_n2 = ivw_time - 12 - c_ivw_month if nflag>0
replace mar_n2 = 0 if mar_n2<0 & nflag>0
*replace mar_n2 = 12 if (mar_n2>12 & mar_n2!=.) & nflag>0

replace mar_n3 = ivw_time - 12 - c_ivw_month if nflag>0
replace mar_n3 = 0 if mar_n3<0 & nflag>0

gen mar = mar_n0+mar_n1+mar_n2+mar_n3
corr mar n1_2_death if nflag==0
corr mar ivw_time if nflag>0 // checks to see if months at risk (mar) = months between ivw

foreach x of varlist hlphrs_* {

replace `x' = (`x'*mar_n0*hr_rate) +  (`x'*mar_n1*hr_rate_n1) + (`x'*mar_n2*hr_rate_n2)

}


gen has_imputed = 0
foreach x of local impu {

replace has_imputed=1 if id=="`x'"

}


save R01_int_2015.dta, replace

/* Sample Derivation */

use decedent_dataset.dta if inrange(index_year,2006,2015), clear

gen age_lt_70 = 0
label var age_lt_70 "Dropped because age at death <72"
foreach x of local agedrop {

replace age_lt_70 = 1 if id=="`x'"

}

gen exdrop = 0
label var exdrop "Dropped because no Exit Ivw 2002-2014"
foreach x of local exitdrop {
replace exdrop = 1 if id=="`x'"
}

gen nocore = 0
label var nocore "Dropped because no Core Ivw 2000-2012"
foreach x of local nocoredrop {

replace nocore = 1 if id=="`x'"
}

gen misscore = 0
label var misscore "Dropped because missing consecutive cores"
foreach x of local misscore {

replace misscore = 1 if id=="`x'"
}

gen core4yr = 0
label var core4yr "Dropped because no Core within last 4 years of life"
foreach x of local core4yr {
replace core4yr = 1 if id=="`x'"
}

gen impu = 0
label var impu "Had a core imputed"
foreach x of local impu {
replace impu = 1 if id=="`x'"
}

gen non4 = 0
label var non4 "Dropped because Died <12m after N1 and missing N4"
foreach x of local non4 {

replace non4 = 1 if id=="`x'"

}

local deri age_lt_70 exdrop nocore misscore core4yr non4 

gen final = 1
label var final "Final Sample Size, includes decedents w/imputed core"

foreach x of local deri {

replace final = 0 if `x'==1

}

gen final_noimp = 0
replace final_noimp = 1 if final==1 & impu==0
label var final_noimp "Final Sample Size, excludes decedents with imputed core"

gen all = 1
label var all "All HRS respondents Deceased 2006-2015"

local full all age_lt_70 exdrop nocore misscore core4yr non4 final final_noimp

local rd: word count `full'

mat tab1 = J(`rd',1,.)

local r = 1

foreach x of local full {

sum `x'
mat tab1[`r',1] = r(sum)
local ++r
}

mat rownames tab1 = `full'


frmttable using "E:\projects\burden_dementia\archive logs\Sample_Derivation_7yrs.doc", replace statmat(tab1) ///
varlabels title("Sample Derivation for R01 (Deceased 2006-2015, Age 72+)") ctitles("Reason for Exclusion" "N" ) sdec(0) ///
annotate(stars) asymbol(*,**)note("Death Date was determined by NDI, Medicare MBSF or HRS Exit in that order. //If NDI death date was after HRS Exit Interview and respondent had no subsequent data, then HRS death date was used.")




H="Dataset and table 1"

/********* Constructing Final Dataset *********/

use "E:\data\burden_dementia\int_data\R01_int_2015.dta", clear

*gen n_nk=n_u-n_k


forvalues j = 1/3 {

	preserve

	if `j'==1 local y "0"
	if `j'==2 local y "a"
	if `j'==3 local y "b"

	drop if has_imputed==1 & `j'==1 // 


	// replace total_oop_exit = total_imp_a_exit if `j'==2 no imputed exits
	replace total_oop = total_imp_a if `j'==2 & imputed==1
		foreach x in i s u k nk {
		replace hlphrs_`x'_exit = hlphrs_`x'_a_exit if `j'==2 & hlp_exit==1
		replace hlphrs_`x' = hlphrs_`x'_a if `j'==2 & imputed==1
}

	// replace total_oop_exit = total_imp_b_exit if `j'==3
	replace total_oop = total_imp_b if `j'==3 & imputed==1

	foreach x in i s u k nk {
		replace hlphrs_`x'_exit = hlphrs_`x'_b_exit if `j'==3 & hlp_exit==1
		replace hlphrs_`x' = hlphrs_`x'_b if `j'==3 & imputed==1
}


	keep id death_cat nflag total_* hlphrs_* n1_2_death year ivw_time
	 
	reshape wide total_* hlphrs_* year ivw_time, i(id) j(nflag)

	forvalues i = 1/7 {

		gen oop_n`i' = .
		gen informal_n`i' = .
		gen informal_i_n`i' = .
		gen informal_s_n`i' = .
		gen informal_u_n`i' = .
		gen informal_k_n`i' = .
		gen informal_nk_n`i'= .

}


	/* OOP */
	replace oop_n1 = total_oop_exit0 + ((12 - n1_2_death)*(total_oop1/ivw_time1)) if death_cat==1
	replace oop_n1 = total_oop_exit0 if death_cat==2
	replace oop_n1 = total_oop_exit0*(12/n1_2_death) if death_cat==3

	replace oop_n2 = ((12)*(total_oop1/ivw_time1)) if death_cat==1
	replace oop_n2 = ((12)*(total_oop1/ivw_time1)) if death_cat==2
	replace oop_n2 = ((n1_2_death-12)/n1_2_death)*total_oop_exit0 + (24-n1_2_death)*(total_oop1/ivw_time1) if death_cat==3

	replace oop_n3 = ((n1_2_death)*(total_oop1/ivw_time1)) + ((12-n1_2_death)*(total_oop2/ivw_time2)) if death_cat==1
	replace oop_n3 = ((12)*(total_oop1/ivw_time1)) if death_cat==2
	replace oop_n3 = ((12)*(total_oop1/ivw_time1)) if death_cat==3

	replace oop_n4 = ((12)*(total_oop2/ivw_time2)) if death_cat==1
	replace oop_n4 = ((12)*(total_oop2/ivw_time2)) if death_cat==2
	replace oop_n4 = (((n1_2_death-12)/ivw_time1))*(total_oop1) + ((24-n1_2_death)*(total_oop2/ivw_time2)) if death_cat==3

	replace oop_n5 = ((12)*(total_oop3/ivw_time3)) if death_cat==1
	replace oop_n5 = ((12)*(total_oop3/ivw_time3)) if death_cat==2
	replace oop_n5 = (((n1_2_death-12)/ivw_time2))*(total_oop2) + ((24-n1_2_death)*(total_oop3/ivw_time3)) if death_cat==3

	replace oop_n6 = ((12)*(total_oop3/ivw_time3)) if death_cat==1
	replace oop_n6 = ((12)*(total_oop3/ivw_time3)) if death_cat==2
	replace oop_n6 = (((n1_2_death-12)/ivw_time2))*(total_oop1) + ((24-n1_2_death)*(total_oop2/ivw_time2)) if death_cat==3

	replace oop_n7 = ((n1_2_death)*(total_oop3/ivw_time3)) + ((12-n1_2_death)*(total_oop4/ivw_time4)) if death_cat==1
	replace oop_n7 = ((12)*(total_oop4/ivw_time3)) if death_cat==2
	replace oop_n7 = ((12)*(total_oop4/ivw_time3)) if death_cat==3

	forvalues i=1/7 {

		sum oop_n`i'

}

/* Informal */

	foreach x in _i _s _u _k _nk {

		replace informal`x'_n1 = hlphrs`x'_exit0 + ((12 - n1_2_death)*(hlphrs`x'1/ivw_time1)) if death_cat==1
		replace informal`x'_n1 = hlphrs`x'_exit0 if death_cat==2
		replace informal`x'_n1 = hlphrs`x'_exit0*(12/n1_2_death) if death_cat==3

		replace informal`x'_n2 = ((12)*(hlphrs`x'1/ivw_time1)) if death_cat==1
		replace informal`x'_n2 = ((12)*(hlphrs`x'1/ivw_time1)) if death_cat==2
		replace informal`x'_n2 = ((n1_2_death-12)/n1_2_death)*hlphrs`x'_exit0 + (24-n1_2_death)*(hlphrs`x'1/ivw_time1) if death_cat==3

		replace informal`x'_n3 = ((n1_2_death)*(hlphrs`x'1/ivw_time1)) + ((12-n1_2_death)*(hlphrs`x'2/ivw_time2)) if death_cat==1
		replace informal`x'_n3 = ((12)*(hlphrs`x'1/ivw_time1)) if death_cat==2
		replace informal`x'_n3 = ((12)*(hlphrs`x'1/ivw_time1)) if death_cat==3

		replace informal`x'_n4 = ((12)*(hlphrs`x'2/ivw_time2)) if death_cat==1
		replace informal`x'_n4 = ((12)*(hlphrs`x'2/ivw_time2)) if death_cat==2
		replace informal`x'_n4 = (((n1_2_death-12)/ivw_time2))*(hlphrs`x'1) + ((24-n1_2_death)*(hlphrs`x'2/ivw_time2)) if death_cat==3

		replace informal`x'_n5 = ((12)*(hlphrs`x'2/ivw_time2)) if death_cat==1
		replace informal`x'_n5 = ((12)*(hlphrs`x'2/ivw_time2)) if death_cat==2
		replace informal`x'_n5 = (((n1_2_death-12)/ivw_time2))*(hlphrs`x'1) + ((24-n1_2_death)*(hlphrs`x'2/ivw_time2)) if death_cat==3

		replace informal`x'_n6 = ((12)*(hlphrs`x'3/ivw_time3)) if death_cat==1
		replace informal`x'_n6 = ((12)*(hlphrs`x'3/ivw_time3)) if death_cat==2
		replace informal`x'_n6 = (((n1_2_death-12)/ivw_time2))*(hlphrs`x'1) + ///
		((24-n1_2_death)*(hlphrs`x'3/ivw_time3)) if death_cat==3

		replace informal`x'_n7 = ((n1_2_death)*(hlphrs`x'4/ivw_time4)) + ((12-n1_2_death)*(hlphrs`x'3/ivw_time3)) if death_cat==1
		replace informal`x'_n7 = ((12)*(hlphrs`x'4/ivw_time4)) if death_cat==2
		replace informal`x'_n7 = ((12)*(hlphrs`x'4/ivw_time4)) if death_cat==3


		forvalues i=1/7 {

			replace informal`x'_n`i'= (informal`x'_n`i')*(20/19)
			sum informal`x'_n`i'

}
}
	forvalues i=1/7 {
		di `i'
		replace informal_n`i'=informal_i_n`i'
		drop informal_i_n`i'
}

	gen impute = `j'
	save "E:\data\burden_dementia\int_data\oop_impute_`y'.dta", replace
	restore

}






keep if nflag==0
expand 3

bysort id: gen impute = _n
cap drop _m
merge 1:1 id impute using "E:\data\burden_dementia\int_data\oop_impute_0.dta", keepus(oop_n* informal_*n*)
replace impute = . if impute==1 & _m==1
cap drop _m
merge 1:1 id impute using "E:\data\burden_dementia\int_data\oop_impute_a.dta", keepus(oop_n* informal_*n*) update
cap drop _m
merge 1:1 id impute using "E:\data\burden_dementia\int_data\oop_impute_b.dta", keepus(oop_n* informal_*n*) update
cap drop _m


merge m:1 id using "E:\data\burden_dementia\int_data\tot_paid_maid.dta", keepus(tot_paid_maid_*)
drop if _m==2

cd "E:\data\burden_dementia\final_data\"


forvalues i=1/7 {
	gen ffs_`i'yr=cont_ffs_n_mos>=`i'*12 & cont_ffs_n_mos!=.
}





gen white = 0
replace white = 1 if race==1 & hisp_eth==0

gen black = 0
replace black = 1 if race==2 & hisp_eth==0

gen other = 0 
replace other = 1 if white==0 & black==0 & hisp_eth==0

label var white "Non-Hispanic White"
label var black "Non-Hispanic Black"
label var other "Non-Hispanic Other"

label var tot_paid_maid_n1 "Total Medicaid Spending N1"
label var tot_paid_maid_n2 "Total Medicaid Spending N2"
label var tot_paid_maid_n3 "Total Medicaid Spending N3"
label var tot_paid_maid_n4 "Total Medicaid Spending N4"
label var tot_paid_maid_n5 "Total Medicaid Spending N5"

gen tot_paid_maid_7yr = tot_paid_maid_n1 + tot_paid_maid_n2 + tot_paid_maid_n3 + tot_paid_maid_n4 + tot_paid_maid_n5 ///
+ tot_paid_maid_n6 + tot_paid_maid_n7
gen tot_paid_mc_7yr = tot_paid_by_mc_12m + tot_paid_by_mc_24m + tot_paid_by_mc_36m + ///
tot_paid_by_mc_48m + tot_paid_by_mc_60m + tot_paid_by_mc_72m + tot_paid_by_mc_84m
gen oop_7yr = oop_n1 + oop_n2 + oop_n3 + oop_n4 + oop_n5 + oop_n6 + oop_n7
gen informal_7yr = informal_n1 + informal_n2 + informal_n3 + informal_n4 + informal_n5 ///
+ informal_n6 + informal_n7

gen tot_paid_maid_6yr = tot_paid_maid_n1 + tot_paid_maid_n2 + tot_paid_maid_n3 + tot_paid_maid_n4 + tot_paid_maid_n5 ///
+ tot_paid_maid_n6  
gen tot_paid_mc_6yr = tot_paid_by_mc_12m + tot_paid_by_mc_24m + tot_paid_by_mc_36m + ///
tot_paid_by_mc_48m + tot_paid_by_mc_60m + tot_paid_by_mc_72m  
gen oop_6yr = oop_n1 + oop_n2 + oop_n3 + oop_n4 + oop_n5 + oop_n6 
gen informal_6yr = informal_n1 + informal_n2 + informal_n3 + informal_n4 + informal_n5 ///
+ informal_n6 

gen tot_paid_maid_5yr = tot_paid_maid_n1 + tot_paid_maid_n2 + tot_paid_maid_n3 + tot_paid_maid_n4 + tot_paid_maid_n5
gen tot_paid_mc_5yr = tot_paid_by_mc_12m + tot_paid_by_mc_24m + tot_paid_by_mc_36m + tot_paid_by_mc_48m + tot_paid_by_mc_60m
gen oop_5yr = oop_n1 + oop_n2 + oop_n3 + oop_n4 + oop_n5
gen informal_5yr = informal_n1 + informal_n2 + informal_n3 + informal_n4 + informal_n5

gen tot_paid_maid_4yr = tot_paid_maid_n1 + tot_paid_maid_n2 + tot_paid_maid_n3 + tot_paid_maid_n4
gen tot_paid_mc_4yr = tot_paid_by_mc_12m + tot_paid_by_mc_24m + tot_paid_by_mc_36m + tot_paid_by_mc_48m
gen oop_4yr = oop_n1 + oop_n2 + oop_n3 + oop_n4
gen informal_4yr = informal_n1 + informal_n2 + informal_n3 + informal_n4

gen tot_paid_maid_3yr = tot_paid_maid_n1 + tot_paid_maid_n2 + tot_paid_maid_n3
gen tot_paid_mc_3yr = tot_paid_by_mc_12m + tot_paid_by_mc_24m + tot_paid_by_mc_36m
gen oop_3yr = oop_n1 + oop_n2 + oop_n3
gen informal_3yr = informal_n1 + informal_n2 + informal_n3

gen tot_paid_maid_2yr = tot_paid_maid_n1 + tot_paid_maid_n2
gen tot_paid_mc_2yr = tot_paid_by_mc_12m + tot_paid_by_mc_24m
gen oop_2yr = oop_n1 + oop_n2 
gen informal_2yr = informal_n1 + informal_n2




label var tot_paid_maid_5yr "Total 5yr Medicaid Spending"
label var tot_paid_mc_5yr "Total 5yr Medicare Spending"
label var oop_5yr "Total 5yr OOP Spending"
label var informal_5yr "Total 5yr Informal Cost"

label var tot_paid_maid_4yr "Aggregate 4yr Medicaid Spending"
label var tot_paid_mc_4yr "Aggregate 4yr Medicare Spending"
label var oop_4yr "Aggregate 4yr OOP Spending"
label var informal_4yr "Aggregate 4yr Informal Cost"

label var tot_paid_maid_3yr "Aggregate 3yr Medicaid Spending"
label var tot_paid_mc_3yr "Aggregate 3yr Medicare Spending"
label var oop_3yr "Aggregate 3yr OOP Spending"
label var informal_3yr "Aggregate 3yr Informal Cost"

forvalues i=2/7 {

	label var tot_paid_maid_`i'yr "Aggregate `i'yr Medicaid Spending"
	label var tot_paid_mc_`i'yr "Aggregate `i'yr Medicare Spending"
	label var oop_`i'yr "Aggregate `i'yr OOP Spending"
	label var informal_`i'yr "Aggregate `i'yr Informal Cost"
}

save R01_final_2015.dta, replace

local ivars female white black other hospice_exit nhres_exit married_exit reschil_d_exit resspouse_exit livealone_exit adl_independent_exit adl_severe_exit medicare_exit medicareb_exit medicaid_exit champus_exit ffs_5yr ffs_4yr ffs_3yr ffs_2yr ffs_1yr


local medcost age_at_death tot_paid_maid_n1 tot_paid_maid_n2 tot_paid_maid_n3 ///
tot_paid_maid_n4 tot_paid_maid_n5 tot_paid_maid_n6 tot_paid_maid_n7  ///
tot_paid_by_mc_12m tot_paid_by_mc_24m tot_paid_by_mc_36m tot_paid_by_mc_48m ///
tot_paid_by_mc_60m tot_paid_by_mc_72m tot_paid_by_mc_84m oop_n1 oop_n2 oop_n3 ///
oop_n4 oop_n5 oop_n6 oop_n7 ///
informal_n1 informal_n2 informal_n3 informal_n4 informal_n5 informal_n6 informal_n7 ///
tot_paid_maid_7yr tot_paid_mc_7yr oop_7yr informal_7yr ///
tot_paid_maid_6yr tot_paid_mc_6yr oop_6yr informal_6yr ///
tot_paid_maid_5yr tot_paid_mc_5yr oop_5yr informal_5yr ///
tot_paid_maid_4yr tot_paid_mc_4yr ///
oop_4yr informal_4yr tot_paid_maid_3yr tot_paid_mc_3yr oop_3yr informal_3yr tot_paid_maid_2yr ///
tot_paid_mc_2yr oop_2yr informal_2yr


local rd: word count `ivars' `medcost' 1

mat tab1=J(`rd', 9,.)
mat stars=J(`rd',9,0)
local r = 1

foreach x of local ivars {

sum `x' if impute==1

mat tab1[`r',1] = r(mean)*100

sum `x' if impute==1 & dem_cohort==1
mat tab1[`r',2] = r(mean)*100

sum `x' if impute==1 & dem_cohort==0
mat tab1[`r',3] = r(mean)*100

tab `x' dem_cohort if impute==1, chi2
mat stars[`r',2] = (r(p)<.01) + (r(p)<0.05)


sum `x' if impute==2

mat tab1[`r',4] = r(mean)*100

sum `x' if impute==2 & dem_cohort==1
mat tab1[`r',5] = r(mean)*100

sum `x' if impute==2 & dem_cohort==0
mat tab1[`r',6] = r(mean)*100

tab `x' dem_cohort if impute==2, chi2
mat stars[`r',5] = (r(p)<.01) + (r(p)<0.05)


sum `x' if impute==3

mat tab1[`r',7] = r(mean)*100

sum `x' if impute==3 & dem_cohort==1
mat tab1[`r',8] = r(mean)*100

sum `x' if impute==3 & dem_cohort==0
mat tab1[`r',9] = r(mean)*100

tab `x' dem_cohort if impute==3, chi2
mat stars[`r',8] = (r(p)<.01) + (r(p)<0.05)


local ++r
}

foreach x of local medcost {

sum `x' if impute==1 

mat tab1[`r',1] = r(mean)

sum `x' if impute==1 & dem_cohort==1
mat tab1[`r',2] = r(mean)

sum `x' if impute==1 & dem_cohort==0
mat tab1[`r',3] = r(mean) 

ttest `x' if impute==1, by(dem_cohort)
mat stars[`r',2] = (r(p)<.01) + (r(p)<.05)


sum `x' if impute==2

mat tab1[`r',4] = r(mean)

sum `x' if impute==2 & dem_cohort==1
mat tab1[`r',5] = r(mean)

sum `x' if impute==2 & dem_cohort==0
mat tab1[`r',6] = r(mean) 

ttest `x' if impute==2, by(dem_cohort)
mat stars[`r',5] = (r(p)<.01) + (r(p)<.05)


sum `x' if impute==3

mat tab1[`r',7] = r(mean)

sum `x' if impute==3 & dem_cohort==1
mat tab1[`r',8] = r(mean)

sum `x' if impute==3 & dem_cohort==0
mat tab1[`r',9] = r(mean) 

ttest `x' if impute==3, by(dem_cohort)
mat stars[`r',8] = (r(p)<.01) + (r(p)<.05)


local ++r
}


sum nflag_ivw if impute==1
mat tab1[`r',1] = r(N)

sum nflag_ivw if impute==1 & dem_cohort==1
mat tab1[`r',2] = r(N)

sum nflag_ivw if impute==1 & dem_cohort==0
mat tab1[`r',3] = r(N)

sum nflag_ivw if impute==2
mat tab1[`r',4] = r(N)

sum nflag_ivw if impute==2 & dem_cohort==1
mat tab1[`r',5] = r(N)

sum nflag_ivw if impute==2 & dem_cohort==0
mat tab1[`r',6] = r(N)

sum nflag_ivw if impute==3
mat tab1[`r',7] = r(N)

sum nflag_ivw if impute==3 & dem_cohort==1
mat tab1[`r',8] = r(N)

sum nflag_ivw if impute==3 & dem_cohort==0
mat tab1[`r',9] = r(N)



mat rownames tab1 = `ivars' `medcost' N

frmttable using "E:\projects\burden_dementia\archive logs\R01_imputed.doc", replace statmat(tab1) ///
varlabels title("Summary Statistics For R01 Sample (Deceased 2004-2012, Age 70+)") ctitles("", "", "No Imputation", "", "", "Imputed - Method A", "", "", "Imputed - Method B", "" \"Variables", "All","Dementia","No Dementia", "All","Dementia","No Dementia", "All","Dementia","No Dementia"  ) sdec(2) ///
vlines(01001001001) annotate(stars) asymbol(*,**)note("All costs have been inflation adjusted to 2014 dollars. <0.05*, p<0.01**")

/* FFS Only */

preserve
keep if ffs_7yr==1


mat tab1=J(`rd', 9,.)
mat stars=J(`rd',9,0)
local r = 1

foreach x of local ivars {

sum `x' if impute==1

mat tab1[`r',1] = r(mean)*100

sum `x' if impute==1 & dem_cohort==1
mat tab1[`r',2] = r(mean)*100

sum `x' if impute==1 & dem_cohort==0
mat tab1[`r',3] = r(mean)*100

tab `x' dem_cohort if impute==1, chi2
mat stars[`r',2] = (r(p)<.01) + (r(p)<0.05)


sum `x' if impute==2

mat tab1[`r',4] = r(mean)*100

sum `x' if impute==2 & dem_cohort==1
mat tab1[`r',5] = r(mean)*100

sum `x' if impute==2 & dem_cohort==0
mat tab1[`r',6] = r(mean)*100

tab `x' dem_cohort if impute==2, chi2
mat stars[`r',5] = (r(p)<.01) + (r(p)<0.05)


sum `x' if impute==3

mat tab1[`r',7] = r(mean)*100

sum `x' if impute==3 & dem_cohort==1
mat tab1[`r',8] = r(mean)*100

sum `x' if impute==3 & dem_cohort==0
mat tab1[`r',9] = r(mean)*100

tab `x' dem_cohort if impute==3, chi2
mat stars[`r',8] = (r(p)<.01) + (r(p)<0.05)


local ++r
}

foreach x of local medcost {

sum `x' if impute==1 

mat tab1[`r',1] = r(mean)

sum `x' if impute==1 & dem_cohort==1
mat tab1[`r',2] = r(mean)

sum `x' if impute==1 & dem_cohort==0
mat tab1[`r',3] = r(mean) 

ttest `x' if impute==1, by(dem_cohort)
mat stars[`r',2] = (r(p)<.01) + (r(p)<.05)


sum `x' if impute==2

mat tab1[`r',4] = r(mean)

sum `x' if impute==2 & dem_cohort==1
mat tab1[`r',5] = r(mean)

sum `x' if impute==2 & dem_cohort==0
mat tab1[`r',6] = r(mean) 

ttest `x' if impute==2, by(dem_cohort)
mat stars[`r',5] = (r(p)<.01) + (r(p)<.05)


sum `x' if impute==3

mat tab1[`r',7] = r(mean)

sum `x' if impute==3 & dem_cohort==1
mat tab1[`r',8] = r(mean)

sum `x' if impute==3 & dem_cohort==0
mat tab1[`r',9] = r(mean) 

ttest `x' if impute==3, by(dem_cohort)
mat stars[`r',8] = (r(p)<.01) + (r(p)<.05)


local ++r
}


sum nflag_ivw if impute==1
mat tab1[`r',1] = r(N)

sum nflag_ivw if impute==1 & dem_cohort==1
mat tab1[`r',2] = r(N)

sum nflag_ivw if impute==1 & dem_cohort==0
mat tab1[`r',3] = r(N)

sum nflag_ivw if impute==2
mat tab1[`r',4] = r(N)

sum nflag_ivw if impute==2 & dem_cohort==1
mat tab1[`r',5] = r(N)

sum nflag_ivw if impute==2 & dem_cohort==0
mat tab1[`r',6] = r(N)

sum nflag_ivw if impute==3
mat tab1[`r',7] = r(N)

sum nflag_ivw if impute==3 & dem_cohort==1
mat tab1[`r',8] = r(N)

sum nflag_ivw if impute==3 & dem_cohort==0
mat tab1[`r',9] = r(N)



mat rownames tab1 = `ivars' `medcost' N

frmttable using "E:\projects\burden_dementia\archive logs\R01_imputed.doc", addtable statmat(tab1) ///
varlabels title("Summary Statistics For R01 Sample (Deceased 2004-2012, Age 72+, Continuous FFS 84 months prior)") ctitles("", "", "No Imputation", "", "", "Imputed - Method A", "", "", "Imputed - Method B", "" \"Variables", "All","Dementia","No Dementia", "All","Dementia","No Dementia", "All","Dementia","No Dementia" ) sdec(2) ///
vlines(01001001001) annotate(stars) asymbol(*,**)note("All costs have been inflation adjusted to 2014 dollars. p<0.05*, p<0.01** No imputation = anyone with gap ivw dropped. Method A = Carry forward prev ivw. Method B = Average prev and later ivw.")


H="Graphs"

use "E:\data\hrs_cleaned\core_00_to_14.dta", clear
sort id core_year
by id: keep if _n==_N
keep id reschil_d
rename reschil_d reschil_d_n1
tempfile core
save `core'

clear all
set more off
capture log close

cd "E:\data\burden_dementia\logs"
use "E:\data\burden_dementia\final_data\R01_final_2015.dta", clear
keep if ffs_7==1

	
keep if impute==2
drop tot_paid*p*
merge 1:1 id using `core', keep(match master) nogen

foreach x of varlist tot* oop* informal* {
	replace `x'=0 if missing(`x')
}


	forvalues i=12(12)60 {
		rename tot_paid_by_mc_`i'm tot_paid_by_mc`=`i'/12'
		rename tot_paid_maid_n`=`i'/12' tot_paid_by_mcaid`=`i'/12'
		rename oop_n`=`i'/12' tot_paid_oop`=`i'/12'
		foreach x in "" _s _u _k _nk {
			rename informal`x'_n`=`i'/12' tot_paid_informal`x'`=`i'/12'
}
}

foreach x in by_mc by_mcaid oop informal informal_s informal_u informal_k informal_nk {
	gen cum1_paid_`x'5=tot_paid_`x'5
	forvalues i=4(-1)1 {
		gen cum1_paid_`x'`i'=cum1_paid_`x'`=`i'+1'+tot_paid_`x'`i'
}
}

keep id tot_paid* cum1_* dem_cohort reschil_d_n1 married_or_part


reshape long tot_paid_by_mc tot_paid_by_mcaid tot_paid_oop cum1_paid_by_mc ///
cum1_paid_by_mcaid cum1_paid_oop tot_paid_informal cum1_paid_informal ///
tot_paid_informal_u cum1_paid_informal_u tot_paid_informal_s cum1_paid_informal_s ///
tot_paid_informal_k cum1_paid_informal_k tot_paid_informal_nk cum1_paid_informal_nk ///
, i(id) j(year_bef_death)
replace tot_paid_by_mcaid=0 if missing(tot_paid_by_mcaid)


*preserve
replace year=-year+6
label define year 1 "4-5" 2 "3-4" 3 "2-3" 4 "1-2" 5 "0-1"
foreach x of varlist tot* cum* {
	*replace `x'=`x'/1.03^(year_bef-1)
}
label values year year

foreach x in tot cum1 {
	egen `x'_paid_by_all=rowtotal(`x'_paid_by_mc `x'_paid_by_mcaid `x'_paid_oop ///
	`x'_paid_informal)
}

foreach x in by_mc by_mcaid oop informal informal_s informal_u informal_k informal_nk by_all {
	by dem_cohort year_bef_death, sort: egen annu_`x'=mean(tot_paid_`x')
	by dem_cohort year_bef_death, sort: egen cum_`x'=mean(cum1_paid_`x')
	by dem_cohort year_bef_death reschil_d_n1, sort: egen annu_resch_`x'=mean(tot_paid_`x')
	by dem_cohort year_bef_death married_or_part, sort: egen annu_married_`x'=mean(tot_paid_`x')
}


	
foreach x in by_mc by_mcaid oop informal informal_s informal_u informal_k informal_nk by_all {
	by dem_cohort year_bef_death, sort: egen annu_sd_`x'=sd(tot_paid_`x')
	by dem_cohort year_bef_death, sort: egen cum_sd_`x'=sd(cum1_paid_`x')
}


foreach x in s u k nk {
	foreach y in "" resch_ married_ {
		gen hlphrs_`y'`x'=((annu_`y'informal_`x'/20)/12)
}	
}

by dem_cohort year_bef_death: gen n=_N

rename *informal* *inf*
drop cum1*
*preserve
drop id tot*
duplicates drop
format cum* %16.0g

foreach x of varlist annu* cum* {
	replace `x'=`x'/1000
}

label var dem_c "Dementia" 
label var year_bef "Years before death"
label var annu_by_mc "Annual Medicarenditures"
label var cum_by_mc "Cumulative Medicare "
label var annu_by_mca "Annual Medicaid "
label var cum_by_mca "Cumulative Medicaid "
label var annu_oop "Annual OOP"
label var cum_oop "Cumulative OOP"
label var annu_inf "Annual imputed inf. caregiving"
label var cum_inf "Cumulative imputed inf. caregiving "

format annu* cum* %9.2fc

log using spending_tables.txt, text replace
foreach x in by_mc by_mcaid oop inf by_all {
	list year_bef_death dem_cohort annu_`x' cum_`x', abbreviate(16)
}
log close

foreach x in annu_ cum_ {
	gen hi_`x'all=`x'by_all+ invttail(n-1,0.025)*(`x'sd_by_all/sqrt(n))
	gen lo_`x'all=`x'by_all-invttail(n-1,0.025)*(`x'sd_by_all/sqrt(n))
}

/* error bars (can we do serrbar?)
twoway (rcap lo_annu hi_annu year if dem_cohort==0) (connected annu_by_all year if dem_cohort==0) (connected annu_by_all year if dem_cohort==1), ///
legend(label(1 "Non-dementia") label(2 "Probable dementia")) xlabel(1 "4-5" 2 "3-4" 3 "2-3" 4 "1-2" 5 "0-1") 



graph save annu_all_spending_over_time.gph, replace
graph export annu_all_spending_over_time.pdf, replace
*/






twoway (connected annu_by_mc year if dem_cohort==0) (connected annu_by_mc year if dem_cohort==1), ///
legend(label(1 "Non-dementia") label(2 "Probable dementia")) xlabel(1 "4-5" 2 "3-4" 3 "2-3" 4 "1-2" 5 "0-1")
graph save annu_mc_spending_over_time.gph, replace
graph export annu_mc_spending_over_time.pdf, replace
twoway (connected annu_by_mca year if dem_cohort==0) (connected annu_by_mca year if dem_cohort==1), ///
legend(label(1 "Non-dementia") label(2 "Probable dementia")) xlabel(1 "4-5" 2 "3-4" 3 "2-3" 4 "1-2" 5 "0-1")
graph save annu_mcaid_spending_over_time.gph, replace
graph export annu_mcaid_spending_over_time.pdf, replace
twoway (connected cum_by_mc year if dem_cohort==0) (connected cum_by_mc year if dem_cohort==1), ///
legend(label(1 "Non-dementia") label(2 "Probable dementia")) xlabel(1 "4-5" 2 "3-4" 3 "2-3" 4 "1-2" 5 "0-1")
graph save cum_mc_spending_over_time.gph, replace
graph export cum_mc_spending_over_time.pdf, replace
twoway (connected cum_by_mca year if dem_cohort==0) (connected cum_by_mca year if dem_cohort==1), ///
legend(label(1 "Non-dementia") label(2 "Probable dementia")) xlabel(1 "4-5" 2 "3-4" 3 "2-3" 4 "1-2" 5 "0-1")
graph save cum_mcaid_spending_over_time.gph, replace
graph export cum_mcaid_spending_over_time.pdf, replace

twoway (connected annu_oop year if dem_cohort==0) (connected annu_oop year if dem_cohort==1), ///
legend(label(1 "Non-dementia") label(2 "Probable dementia")) xlabel(1 "4-5" 2 "3-4" 3 "2-3" 4 "1-2" 5 "0-1")
graph save annu_oop_spending_over_time.gph, replace
graph export annu_oopid_spending_over_time.pdf, replace
twoway (connected cum_oop year if dem_cohort==0) (connected cum_oop year if dem_cohort==1), ///
legend(label(1 "Non-dementia") label(2 "Probable dementia")) xlabel(1 "4-5" 2 "3-4" 3 "2-3" 4 "1-2" 5 "0-1")
graph save cum_oop_spending_over_time.gph, replace
graph export cum_oop_spending_over_time.pdf, replace


twoway (connected annu_inf year if dem_cohort==0) (connected annu_inf year if dem_cohort==1), ///
legend(label(1 "Non-dementia") label(2 "Probable dementia")) xlabel(1 "4-5" 2 "3-4" 3 "2-3" 4 "1-2" 5 "0-1")
graph save annu_informal_spending_over_time.gph, replace
graph export annu_informal_spending_over_time.pdf, replace
twoway (connected cum_inf year if dem_cohort==0) (connected cum_inf year if dem_cohort==1), ///
legend(label(1 "Non-dementia") label(2 "Probable dementia")) xlabel(1 "4-5" 2 "3-4" 3 "2-3" 4 "1-2" 5 "0-1")
graph save cum_informal_spending_over_time.gph, replace
graph export cum_informal_spending_over_time.pdf, replace

twoway (connected annu_by_all year if dem_cohort==0) (connected annu_by_all year if dem_cohort==1), ///
legend(label(1 "Non-dementia") label(2 "Probable dementia")) xlabel(1 "4-5" 2 "3-4" 3 "2-3" 4 "1-2" 5 "0-1") 
graph save annu_all_spending_over_time.gph, replace
graph export annu_all_spending_over_time.pdf, replace
twoway (connected cum_by_all year if dem_cohort==0) (connected cum_by_all year if dem_cohort==1), ///
legend(label(1 "Non-dementia") label(2 "Probable dementia")) xlabel(1 "4-5" 2 "3-4" 3 "2-3" 4 "1-2" 5 "0-1")
graph save cum_all_spending_over_time.gph, replace
graph export cum_all_spending_over_time.pdf, replace


twoway (connected cum_by_mc year if dem_cohort==1) (connected cum_by_mca year if dem_cohort==1) ///
(connected cum_oop year if dem_cohort==1) ///
(connected cum_inf year if dem_cohort==1), title("Dementia") ///
legend(label(1 "Medicare") label(2 "Medicaid") label(3 "OOP") label(4 "Informal")) ///
saving(cum_spending_diff_dem, replace) xlabel(1 "4-5" 2 "3-4" 3 "2-3" 4 "1-2" 5 "0-1") 


twoway (connected cum_by_mc year if dem_cohort==0) (connected cum_by_mca year if dem_cohort==0) ///
(connected cum_oop year if dem_cohort==0) ///
(connected cum_inf year if dem_cohort==0), title("No Dementia") ///
legend(label(1 "Medicare") label(2 "Medicaid") label(3 "OOP") label(4 "Informal")) ///
saving(cum_spending_diff_no_dem, replace) xlabel(1 "4-5" 2 "3-4" 3 "2-3" 4 "1-2" 5 "0-1") 



graph bar annu_by_mca annu_by_mc annu_oop annu_inf, over(dem_cohort)  over(year) ///
 stack saving(annu_stack_1, replace)
graph export annu_stack_1.pdf, replace

graph bar annu_by_mca annu_by_mc annu_oop annu_inf,over(year)  over(dem_cohort)  ///
saving(annu_stack_2, replace) stack
graph export annu_stack_2.pdf, replace

preserve
tokenize inf oop by_mc by_mca 
forvalues i=2/4 {
	replace annu_``i''=annu_``=`i'-1''+annu_``i''
	replace cum_``i''=cum_``=`i'-1''+cum_``i''
}


foreach x in cum annu {
	twoway (area `x'_by_mca year if dem_cohort==1) (area `x'_by_mc year if dem_cohort==1) (area `x'_oop year if dem_cohort==1) ///
	(area `x'_inf year if dem_cohort==1), title("Dementia") ///
	legend(label(1 "Medicaid") label(2 "Medicare") label(3 "OOP") label(4 "Informal")) ///
	saving(`x'_spending_diff_dem_stacked, replace) xlabel(1 "4-5" 2 "3-4" 3 "2-3" 4 "1-2" 5 "0-1") 


	twoway (area `x'_by_mca year if dem_cohort==0) (area `x'_by_mc year if dem_cohort==0) ///
	(area `x'_oop year if dem_cohort==0) ///
	(area `x'_inf year if dem_cohort==0), title("No Dementia") ///
	legend(label(1 "Medicaid") label(2 "Medicare") label(3 "OOP") label(4 "Informal")) ///
	saving(`x'_spending_diff_no_dem_stacked, replace) xlabel(1 "4-5" 2 "3-4" 3 "2-3" 4 "1-2" 5 "0-1") 


	graph combine `x'_spending_diff_no_dem_stacked.gph `x'_spending_diff_dem_stacked.gph, ///
	ycommon saving(`x'_spending_stacked, replace)
	graph export `x'_spending_stacked.pdf, replace

	twoway (connected `x'_inf_s year if dem_cohort==0) (connected `x'_inf_u year if dem_cohort==0), ///
	legend(label(1 "Spouses") label(2 "Other informal helpers")) xlabel(1 "4-5" 2 "3-4" 3 "2-3" 4 "1-2" 5 "0-1") ///
	name(`x'_no_dem_basic, replace) title("No Dementia")

	twoway (connected `x'_inf_s year if dem_cohort==1) (connected `x'_inf_u year if dem_cohort==1), ///
	legend(label(1 "Spouses") label(2 "Other informal helpers")) xlabel(1 "4-5" 2 "3-4" 3 "2-3" 4 "1-2" 5 "0-1") ///
	name(`x'_dem_basic, replace) title("Dementia")

	graph combine `x'_no_dem_basic `x'_dem_basic, ycommon
	graph save `x'_informal_spending_by_type_basic.gph, replace
	graph export `x'_informal_spending_by_type_basic.pdf, replace



	twoway (connected `x'_inf_s year if dem_cohort==0) (connected `x'_inf_k year if dem_cohort==0) ///
	(connected `x'_inf_nk year if dem_cohort==0), ///
	legend(label(1 "Spouses") label(2 "Kids") label(3 "Other informal helpers")) ///
	xlabel(1 "4-5" 2 "3-4" 3 "2-3" 4 "1-2" 5 "0-1") ///
	name(`x'_no_dem_kids, replace) title("No Dementia")

	twoway (connected `x'_inf_s year if dem_cohort==1) (connected `x'_inf_k year if dem_cohort==1) ///
	(connected `x'_inf_nk year if dem_cohort==1), ///
	legend(label(1 "Spouses") label(2 "Kids") label(3 "Other informal helpers")) ///
	xlabel(1 "4-5" 2 "3-4" 3 "2-3" 4 "1-2" 5 "0-1") ///
	name(`x'_dem_kids, replace) title("Dementia")

	graph combine `x'_no_dem_kids `x'_dem_kids, ycommon
	graph save `x'_informal_spending_by_type_kids.gph, replace
	graph export `x'_informal_spending_by_type_kids.pdf, replace


/*
	twoway (connected `x'_inf_s year if dem_cohort==0 & reschil_d_n1==1) ///
	(connected `x'_inf_k year if dem_cohort==0 & reschil_d_n1==1) ///
	(connected `x'_inf_nk year if dem_cohort==0 & reschil_d_n1==1), ///
	legend(label(1 "Spouses") label(2 "Kids") label(3 "Other informal helpers")) xlabel(1 "4-5" 2 "3-4" 3 "2-3" 4 "1-2" 5 "0-1") ///
	name(`x'_no_dem_res_kids, replace) title("No Dementia")

	twoway (connected `x'_inf_s year if dem_cohort==1 & reschil_d_n1==1) ///
	(connected `x'_inf_k year if dem_cohort==1 & reschil_d_n1==1) ///
	(connected `x'_inf_nk year if dem_cohort==1 & reschil_d_n1==1), ///
	legend(label(1 "Spouses") label(2 "Kids") label(3 "Other informal helpers")) xlabel(1 "4-5" 2 "3-4" 3 "2-3" 4 "1-2" 5 "0-1") ///
	name(`x'_dem_res_kids, replace) title("Dementia")

	graph combine `x'_no_dem_res_kids `x'_dem_res_kids, ycommon
	graph save `x'_informal_spending_by_type_res_kids.gph, replace
	graph export `x'_informal_spending_by_type_res_kids.pdf, replace




	twoway (connected `x'_inf_s year if dem_cohort==0 & married_or==1) ///
	(connected `x'_inf_k year if dem_cohort==0 & married_or==1) ///
	(connected `x'_inf_nk year if dem_cohort==0 & married_or==1), ///
	legend(label(1 "Spouses") label(2 "Kids") label(3 "Other informal helpers")) xlabel(1 "4-5" 2 "3-4" 3 "2-3" 4 "1-2" 5 "0-1") ///
	name(`x'_no_dem_married, replace) title("No Dementia")

	twoway (connected `x'_inf_s year if dem_cohort==1 & married_or==1) ///
	(connected `x'_inf_k year if dem_cohort==1 & married_or==1) ///
	(connected `x'_inf_nk year if dem_cohort==1 & married_or==1), ///
	legend(label(1 "Spouses") label(2 "Kids") label(3 "Other informal helpers")) xlabel(1 "4-5" 2 "3-4" 3 "2-3" 4 "1-2" 5 "0-1") ///
	name(`x'_dem_married, replace) title("Dementia")

	graph combine `x'_no_dem_married `x'_dem_married, ycommon
	graph save `x'_informal_spending_by_type_married.gph, replace
	graph export `x'_informal_spending_by_type_married.pdf, replace	
*/

}

	twoway (connected hlphrs_s year if dem_cohort==0) (connected hlphrs_u year if dem_cohort==0), ///
	legend(label(1 "Spouses") label(2 "Other informal helpers")) xlabel(1 "4-5" 2 "3-4" 3 "2-3" 4 "1-2" 5 "0-1") ///
	name(`x'_no_dem, replace) title("No Dementia")

	twoway (connected hlphrs_s year if dem_cohort==1) (connected hlphrs_u year if dem_cohort==1), ///
	legend(label(1 "Spouses") label(2 "Other informal helpers")) xlabel(1 "4-5" 2 "3-4" 3 "2-3" 4 "1-2" 5 "0-1") ///
	name(`x'_dem, replace) title("Dementia")

	graph combine `x'_no_dem `x'_dem, ycommon
	graph save hlphrs_hrs_by_type_basic.gph, replace
	graph export hlphrs_hrs_by_type_basic.pdf, replace




	twoway (connected hlphrs_s year if dem_cohort==0) (connected hlphrs_k year if dem_cohort==0) ///
	(connected hlphrs_nk year if dem_cohort==0), ///
	legend(label(1 "Spouses") label(2 "Kids") label(3 "Other informal helpers")) ///
	xlabel(1 "4-5" 2 "3-4" 3 "2-3" 4 "1-2" 5 "0-1") ///
	name(`x'_no_dem, replace) title("No Dementia")

	twoway (connected hlphrs_s year if dem_cohort==1) (connected hlphrs_k year if dem_cohort==1) ///
	(connected hlphrs_nk year if dem_cohort==1), ///
	legend(label(1 "Spouses") label(2 "Kids") label(3 "Other informal helpers")) ///
	xlabel(1 "4-5" 2 "3-4" 3 "2-3" 4 "1-2" 5 "0-1") ///
	name(`x'_dem, replace) title("Dementia")

	graph combine `x'_no_dem `x'_dem, ycommon
	graph save hlphrs_hrs_by_type_kids.gph, replace
	graph export hlphrs_hrs_by_type_kids.pdf, replace




	twoway (connected hlphrs_resch_s year if dem_cohort==0 & reschil_d_n1==1) (connected hlphrs_resch_k year if dem_cohort==0 & reschil_d_n1==1) ///
	(connected hlphrs_resch_nk year if dem_cohort==0 & reschil_d_n1==1), ///
	legend(label(1 "Spouses") label(2 "Kids") label(3 "Other informal helpers")) xlabel(1 "4-5" 2 "3-4" 3 "2-3" 4 "1-2" 5 "0-1") ///
	name(`x'_no_dem, replace) title("No Dementia")

	twoway (connected hlphrs_resch_s year if dem_cohort==1 & reschil_d_n1==1) ///
	(connected hlphrs_resch_k year if dem_cohort==1 & reschil_d_n1==1) ///
	(connected hlphrs_resch_nk year if dem_cohort==1 & reschil_d_n1==1), ///
	legend(label(1 "Spouses") label(2 "Kids") label(3 "Other informal helpers")) xlabel(1 "4-5" 2 "3-4" 3 "2-3" 4 "1-2" 5 "0-1") ///
	name(`x'_dem, replace) title("Dementia")

	graph combine `x'_no_dem `x'_dem, ycommon
	graph save hlphrs_hrs_by_type_res_kids.gph, replace
	graph export hlphrs_hrs_by_type_res_kids.pdf, replace

	

	twoway (connected hlphrs_married_s year if dem_cohort==0 & married_or==1) (connected hlphrs_married_k year if dem_cohort==0 & married_or==1) ///
	(connected hlphrs_married_nk year if dem_cohort==0 & married_or==1), ///
	legend(label(1 "Spouses") label(2 "Kids") label(3 "Other informal helpers")) xlabel(1 "4-5" 2 "3-4" 3 "2-3" 4 "1-2" 5 "0-1") ///
	name(`x'_no_dem, replace) title("No Dementia")

	twoway (connected hlphrs_married_s year if dem_cohort==1 & married_or==1) ///
	(connected hlphrs_married_k year if dem_cohort==1 & married_or==1) ///
	(connected hlphrs_married_nk year if dem_cohort==1 & married_or==1), ///
	legend(label(1 "Spouses") label(2 "Kids") label(3 "Other informal helpers"))  xlabel(1 "4-5" 2 "3-4" 3 "2-3" 4 "1-2" 5 "0-1") ///
	name(`x'_dem, replace) title("Dementia")

	graph combine `x'_no_dem `x'_dem, ycommon
	graph save hlphrs_hrs_by_type_married.gph, replace
	graph export hlphrs_hrs_by_type_married.pdf, replace	




graph dir, m

graph combine annu_spending_diff_no_dem_stacked.gph annu_spending_diff_dem_stacked.gph ///
cum_spending_diff_no_dem_stacked.gph cum_spending_diff_dem_stacked.gph, ycommon ///
saving(spending_stacked, replace) rows(1) ysize(4) xsize(12)
graph export spending_stacked.pdf, replace

graph combine annu_mc_spending_over_time.gph cum_mc_spending_over_time.gph, ycommon
graph combine annu_mcaid_spending_over_time.gph cum_mcaid_spending_over_time.gph, ycommon
graph combine annu_oop_spending_over_time.gph cum_oop_spending_over_time.gph, ycommon
graph combine annu_informal_spending_over_time.gph cum_informal_spending_over_time.gph, ycommon
graph combine annu_all_spending_over_time.gph cum_all_spending_over_time.gph, ycommon






restore


H="7 year graphs"
use "E:\data\serious_ill\int_data\core_ids_1yr_criteria_5.dta", clear
sort id core_year
by id: keep if _n==_N
keep id wage*
duplicates drop
tempfile t1
save `t1'

use "E:\data\burden_dementia\final_data\R01_final.dta", clear
merge m:1 id using `t1', nogen keep(match master)
cd "E:\data\burden_dementia\logs\graphs"

keep if nflag==0
keep if ffs_84==1

forvalues i=1/7 {
	gen wi_mc`i'=tot_paid_by_mc_y`i'/wage_index_2012
}

keep id tot_paid_by_mc_y* tot_paid_maid_y* oop_y* informal_y* dem_cohort wi_*

rename tot_paid_by_mc_y* mc*
rename tot_paid_maid_y* mcaid*

foreach x of varlist mcaid* {
	replace `x'=0 if missing(`x')
}

rename (oop_y* informal_y*) (oop* informal*)

foreach x in mc mcaid oop informal wi_mc {
	forvalues i=1/7 {
		replace `x'`i'=`x'`i'/1000
}
	gen cum`x'7=`x'7
	forvalues i=6(-1)1 {
		gen cum`x'`i'=cum`x'`=`i'+1'+`x'`i'
}
}

keep id mc* mcaid* oop* informal* cum* dem_cohort wi*


reshape long mc mcaid oop informal cummc cummcaid cumoop cuminformal wi_mc, ///
i(id) j(year_before_death)

replace year=-year+8

label define year 1 "6-7" 2 "5-6" 3 "4-5" 4 "3-4" 5 "2-3" 6 "1-2" 7 "0-1"
label values year year

foreach x in "" cum {
	egen `x'all=rowtotal(`x'mc `x'mcaid `x'oop `x'informal)
}



collapse (mean) mc mcaid oop informal all cummc cummcaid cumoop cuminformal cumall wi_mc, ///
by(dem_cohort year_before_death)

foreach x in mc mcaid oop informal all {
	twoway (connected `x' year if dem_cohort==0) (connected `x' year if dem_cohort==1), ///
	legend(label(1 "Non-dementia") label(2 "Probable dementia")) ///
	xlabel(1 "6-7" 2 "5-6" 3 "4-5" 4 "3-4" 5 "2-3" 6 "1-2" 7 "0-1") ytitle("")
	graph save annu_`x'_spending_over_time.gph, replace
	graph export annu_`x'_spending_over_time.pdf, replace
	
	twoway (connected cum`x' year if dem_cohort==0) (connected cum`x' year if dem_cohort==1), ///
	legend(label(1 "Non-dementia") label(2 "Probable dementia")) ///
	xlabel(1 "6-7" 2 "5-6" 3 "4-5" 4 "3-4" 5 "2-3" 6 "1-2" 7 "0-1") ytitle("")
	graph save cum_`x'_spending_over_time.gph, replace
	graph export cum_`x'_spending_over_time.pdf, replace
	
	graph combine annu_`x'_spending_over_time.gph cum_`x'_spending_over_time.gph, ycommon
	graph save `x'_spending_7yrs.gph, replace
	graph export `x'_spending_7yrs.pdf, replace
}

twoway (connected mc year if dem_cohort==0) (connected mc year if dem_cohort==1) ///
(connected wi_mc year if dem_cohort==0) (connected wi_mc year if dem_cohort==1), ///
legend(label(1 "MC, No-D") label(2 "MC-D") label(3 "WIMC, No-D") label(4 "WIMC-D")) ///
xlabel(1 "6-7" 2 "5-6" 3 "4-5" 4 "3-4" 5 "2-3" 6 "1-2" 7 "0-1") ytitle("")
graph save annu_`x'_spending_over_time_wi.gph, replace
graph export annu_`x'_spending_over_time_wi.pdf, replace


foreach x in mc mcaid oop informal all {
	rename `x' annu`x'
}

preserve




graph bar annumca annumc annuoop annuinf, over(dem_cohort)  over(year) ///
stack saving(annu_stack_1, replace) percent 
graph export annu_stack_1.pdf, replace

graph bar annumca annumc annuoop annuinf if dem_cohort==0, over(year) stack percent ///
saving(annu_stack_no_dem, replace) legend(off ) title("No dementia" "Annual")
graph bar annumca annumc annuoop annuinf if dem_cohort==1,over(year)  ///
saving(annu_stack_dem, replace) stack percent legend(off )title("Dementia" "Annual")

graph bar cummca cummc cumoop cuminf if dem_cohort==0,over(year)  ///
saving(cum_stack_no_dem, replace) stack percent legend(off ) title("No dementia" "Cumulative")
graph bar cummca cummc cumoop cuminf if dem_cohort==1,over(year)  ///
saving(cum_stack_dem, replace) stack percent legend(off ) title("Dementia" "Cumulative")

graph combine annu_stack_no_dem.gph annu_stack_dem.gph cum_stack_no_dem.gph cum_stack_dem.gph, ///
row(1) xsize(12) ysize(4)
graph save stacked_percentage_bars_7yrs.gph, replace
graph export stacked_percentage_bars_7yrs.pdf, replace


tokenize inf oop mc mca 
forvalues i=2/4 {
	replace annu``i''=annu``=`i'-1''+annu``i''
	replace cum``i''=cum``=`i'-1''+cum``i''
}

foreach x in annu cum {
	twoway (area `x'mcaid year if dem_cohort==0) (area `x'mc year if dem_cohort==0) ///
	(area `x'oop year if dem_cohort==0) (area `x'inf year if dem_cohort==0), ///
	title("No Dementia") legend(label(1 "Medicaid") label(2 "Medicare") label(3 "OOP") label(4 "Informal")) ///
	saving(`x'_spending_diff_no_dem_stacked, replace) ///
	xlabel(1 "6-7" 2 "5-6" 3 "4-5" 4 "3-4" 5 "2-3" 6 "1-2" 7 "0-1") ytitle("")

	twoway (area `x'mcaid year if dem_cohort==1) (area `x'mc year if dem_cohort==1) ///
	(area `x'oop year if dem_cohort==1) (area `x'inf year if dem_cohort==1), ///
	title("Dementia") legend(label(1 "Medicaid") label(2 "Medicare") label(3 "OOP") label(4 "Informal")) ///
	saving(`x'_spending_diff_dem_stacked, replace) ///
	xlabel(1 "6-7" 2 "5-6" 3 "4-5" 4 "3-4" 5 "2-3" 6 "1-2" 7 "0-1") ytitle("")

	graph combine `x'_spending_diff_no_dem_stacked.gph `x'_spending_diff_dem_stacked.gph, ///
	ycommon saving(`x'_spending_stacked_7yrs, replace)
	graph export `x'_spending_stacked_7yrs.pdf, replace	
}


graph combine cum_spending_diff_no_dem_stacked.gph cum_spending_diff_dem_stacked.gph, ///
ycommon saving(cum_spending_stacked_7yrs, replace) rows(1)
graph export cum_spending_stacked_7yrs.pdf, replace


graph combine cum_spending_diff_no_dem_stacked.gph cum_spending_diff_dem_stacked.gph, ///
ycommon saving(cum_spending_stacked_7yrs, replace) rows(1)
graph export cum_spending_stacked_7yrs.pdf, replace

graph combine annu_spending_diff_no_dem_stacked.gph annu_spending_diff_dem_stacked.gph ///
cum_spending_diff_no_dem_stacked.gph cum_spending_diff_dem_stacked.gph, ycommon ///
saving(spending_stacked_7yrs, replace) rows(1) ysize(4) xsize(12)
graph export spending_stacked_7yrs.pdf, replace


H="Medicaid graphs"


cd "E:\data\burden_dementia\logs\graphs"

use bid_hrs_22 ffs_84 using "E:\data\burden_dementia\final_data\R01_final.dta", clear
keep if ffs_84==1
drop if missing(bid)
duplicates drop
merge 1:m bid_hrs_22 using "E:\data\CMS_DUA_51675_2014\Merged\Stata\basf_1998_2015.dta", ///
keep(match) nogen
keep bid buyin_mo start_dt
gen year=year(start_dt)
drop if missing(bid_hrs)
tempfile mbsf
save `mbsf'

import excel "E:\data\hrs_restricted_2014\Ref Docs\Medicaid generosity.xlsx", sheet("Sheet1") firstrow case(lower) clear
rename location stateusps
tempfile generosity
save `generosity'

use "E:\data\burden_dementia\final_data\R01_final.dta" if ffs_84==1, clear
drop buyin_mo
sort id nflag
by id: carryforward bid_hrs_22, replace
replace year=index_year if nflag==0
sort id year nflag
by id year: keep if _n==1
merge m:1 stateusps using `generosity', gen(gm)
drop if gm==2
duplicates report bid_hrs_22 year
merge 1:1 bid_hrs_22 year using `mbsf', gen(mbsf)
drop if mbsf==2
tab mbsf
tab medicaid
gen mbsf_medicaid=buyin_mo>=1 if !missing(buyin_mo)
tab mbsf_medicaid
tab nflag
gen t2d=index_date-c_ivw_date
replace t2d=0 if index_year==year
sum t2d
gen y2d=ceil(t2d/365.25)
tab y2d
gen baseline=1 if year>=7
replace baseline=y2d>=7
sort id baseline y2d
by id baseline: drop if baseline & _n>1
replace y2d=7 if y2d>7
replace year=-y2d+8
replace medicaid=medicaid_exit if missing(medicaid)
replace medicaid=0 if missing(medicaid)
preserve
collapse (mean) medicaid mbsf_medicaid generous (count) nmcaid=medicaid nmbsf=mbsf_medicaid n=generous, by(year)



twoway (connected medicaid year) (connected mbsf_ year) (connected generous year), ///
xlabel(1 "6-7" 2 "5-6" 3 "4-5" 4 "3-4" 5 "2-3" 6 "1-2" 7 "0-1" 8 "at death")xtitle("")  ytitle("") ///
legend(label(1 "SR Medicaid") label(2 "Medicaid from Buy-in") ///
label(3 "Resides in Generous State")) saving(medicaid_over_time, replace)

restore
preserve
collapse (mean) medicaid mbsf_medicaid generous (count) ///
nmcaid=medicaid nmbsf=mbsf_medicaid n=generous, by(year dem_cohort)

twoway (connected medicaid year if dem_cohort==1) (connected mbsf_ year if dem_cohort==1) (connected generous year if dem_cohort==1), ///
xlabel(1 "6-7" 2 "5-6" 3 "4-5" 4 "3-4" 5 "2-3" 6 "1-2" 7 "0-1" 8 "at death")xtitle("")  ytitle("") ///
legend(label(1 "SR Medicaid") label(2 "Medicaid from Buy-in") ///
label(3 "Resides in Generous State")) saving(medicaid_over_time_dem, replace) ///
title("No Dementia")

twoway (connected medicaid year if dem_cohort==0) (connected mbsf_ year if dem_cohort==0) (connected generous year if dem_cohort==0), ///
xlabel(1 "6-7" 2 "5-6" 3 "4-5" 4 "3-4" 5 "2-3" 6 "1-2" 7 "0-1" 8 "at death")xtitle("")  ytitle("") ///
legend(label(1 "SR Medicaid") label(2 "Medicaid from Buy-in") ///
label(3 "Resides in Generous State")) saving(medicaid_over_time_no_dem, replace) title("Dementia") 

graph combine medicaid_over_time_no_dem.gph medicaid_over_time_dem.gph, ycommon ///
saving(medicaid_combined, replace)
graph export medicaid_combined.pdf, replace

twoway (connected medicaid year if dem_cohort==1) (connected mbsf_ year if dem_cohort==1) ///
(connected medicaid year if dem_cohort==0) (connected mbsf_ year if dem_cohort==0), ///
xlabel(1 "6-7" 2 "5-6" 3 "4-5" 4 "3-4" 5 "2-3" 6 "1-2" 7 "0-1" 8 "at death")xtitle("")  ytitle("") ///
legend(label(1 "SR Medicaid-Dem") label(2 "Medicaid from Buy-in-Dem") ///
label(3 "SR Medicaid-no-Dem") label(4 "Medicaid from Buy-in-no-Dem")) ///
saving(medicaid_over_time_7yrs, replace)
graph export medicaid_over_time_7yrs.pdf, replace



H="*********************************"


H="long form dataset"
/******************
things from the exit, need to figure this out
-death date, adls/iadls, location of death, hospice medicaid/gap/va, value estate
	
things that are t:
-MC expenditures
-i

things that are in waves, need to be converted to annual:
-fixed characteristics
    -gender, birth date, death date, race, education
-mutable
	-age (computed at each year, from birth date above, rather than filled)
	-net worth, financial wealth, adl/iadls, srh, medicaid, champus, medigap, married or partnered
	-nursing home resident
	-dementia
	-region
	-family vars-resident children, transfers, help from kids 
	-out of pocket spending
	-number of helpers, helper hours, any helpers, imputed social costs

******************/
clear all
set more off
capture log close

local datapath "E:\data\burden_dementia\int_data"
local fdpath "E:\data\burden_dementia\final_data"
local logpath "E:\data\burden_dementia\logs"
local ooppath "E:\data\burden_dementia\oopdata"

cd `datapath'

/*first pull an index file from the decedent dataset*/
use id index_date index_year cont_ffs_n_mos using decedent_dataset.dta if inrange(index_year,2006,2014), clear
gen ffs_yrs=floor(cont_ffs_n_mos/12)
*keep if ffs_y==5
tempfile index
save `index'


/*2nd, connect decedent dataset to exit*/
local vars female married_or_ medicaid champus medigap nhres hospice ///
e_ivw* *year loc_hosp adl_independent iadl_independent reschil_d livealone ///
comor_c_hrs 

use id `vars' using "E:\data\hrs_cleaned\exit_02_to_14_dt.dta" if !missing(e_ivw_date)
foreach x in married_o medicaid champus medigap nhres hospice loc_hosp ///
adl_independent iadl_independent reschil_d livealone {
rename `x' `x'_x
}
tempfile exit1
save `exit1'

merge 1:1 id using `index', nogen keep(match)
//set time=0 so it can be appended to the core
gen t2=0
drop if e_ivw_date<index_date
tempfile exit
save `exit'

/*3rd, save tracker, oop, dementia, rand family, and helpers*/


use "E:\data\hrs_public_2014\dementia\pdem_withvarnames_ebl.dta", clear
gsort id -core_year 
replace pdem=prob_hurd if !missing(prob_hurd)
by id: egen firstdem=min(cond(inrange(pdem,0.5,1),core_year,.))
by id: keep if _n<5
tempfile dem
save `dem'

use "E:\data\hrs_cleaned\restr_tracker_v2014.dta", clear
drop id
gen id=hhid+pn
tempfile track
save `track'


use `ooppath'\oopme_final_2014.dta, clear
rename *, l
gen id=hhid+pn
/*gsort id -year
by id: gen n=_n
keep if n<5
by id: gen lastyear=year[1]
keep id lastyear total_oop n year
rename year core_year
*reshape wide total_oop year, i(id) j(n)*/
tempfile oop
save `oop'


use "E:\data\hrs_cleaned\helper_hours_2014.dta", clear
gen id=hhid+pn 
//cap number of hours at 720 (24 hrs for 30 days) for spouses and other informal
foreach x in s u {
replace hlphrs_`x'=720 if hlphrs_`x'>720
}
replace hlphrs_i=hlphrs_s+hlphrs_u
tempfile help
save `help'


/*5th, connect decedent dataset to core
	1) merge 1:m to restrict to decedents
	2) flag those that have two+ cores within 5 years
	3) keep all within 5 years and the one before for baseline
	4) merge by core year with dementia prob, rand fam, helpers, oop datasets
	5) reset so that it's in annual long format
*/

use `index', clear
merge 1:m id using "E:\data\hrs_cleaned\core_00_to_14.dta", nogen ///
keep(match master)
sort id core_year
replace wgthh=. if wgthh==0
carryforward wgthh, replace
gsort id -core_year
carryforward wgthh, replace
by id: gen n=_n
gen time=(index_date-c_ivw_date)/365.25
gen t2=ceil(time)
by id: egen yes=min(time)
gen y1=inrange(yes,0,5)
gen inn=n if time<=7
gen outn=n if time>7
by id: egen y2=max(inn)
//get the first interview outside the window
by id: egen y3=min(outn)

/*keep all ivws within 5 years and a baseline for those who have at least one 
ivw w/in 5 years*/
keep if y1 & (inrange(time,0.00001,7) | y3==n)

/*drop baselines if >9 years out*/
drop if time>9

//locals to keep relevant vars
local corevars networth_adj2012 finwealth_adj2012 medicaid champus medigap srh_pf adl_independent_core ///
iadl_independent_core nhres reschil_d wgthh comor_c smoke_ever smoke_curr
local helpvars n_hp hlphrs_i n_i hlphrs_u hlphrs_s
local famvars resd_kid_ind help_adls_kid_adult help_iadls_kid_adult ///
transf_from_kid_adult_ind
local oopvars total_oop
local trackvars birth_date hisp_eth white black other_na_api cause_death degree
local demvars pdem ldem firstdem prob_hurd
keep id `corevars' core_year c_ivw_* index_date t2 time

append using `exit'

//keep only those with an exit
sort id t2
by id: egen min=min(t2)
keep if min==0
drop min

//keep only those with at least one core
by id: gen n=_n
by id: gen obs=_N
by id: drop if _N==1

//gen year to merge with oop & helper
gen year=core_year
replace year=exit_year if missing(year)

merge 1:1 id year using `oop', gen(oopmerge) keep(match master)  ///
keepusing(`oopvars')
merge 1:1 id year using `help', gen(helpmerge) keep(match master) ///
keepusing(`helpvars')
merge 1:1 id core_year using `dem', gen(demmerge) keep(match master) ///
keepusing(`demvars')
merge m:1 id core_year using ///
"E:\data\hrs_public_2014\rand2014\family\family_r_clean_98_12.dta", ///
gen(randfammerge) keep(match master) keepusing(`famvars')
merge m:1 id using `track', nogen keep(match) keepusing(`trackvars')

//hs+ (including ged)
gen hseduc=degree>0
label var hseduc "HS Degree+ (including GED)"

replace t2=8 if t2>8
gsort id -year
by id: replace pdem=pdem[_n+1] if t2==0
gen no=0
by id: replace no=1 if year>year[_n+1]+2 & _n!=_N
by id: replace no=1 if _n==_N & t2<4
by id: egen anyno=max(no)
*drop if anyno==1 | obs==3
/*
foreach x of varlist * {
	if !inlist("`x'","id","t2") local allvars `allvars' `x'
}

reshape wide `allvars', i(id) j(t2)
*/

foreach x in `helpvars' {
	replace `x'=0 if missing(`x')
}
drop year
gen yearfromdeath=t2
tempfile t1
save `t1'

keep id t2 time *oop c_ivw_date n hlphrs_*
replace time=0 if t2==0
sort id t2 
by id: gen timetonext=time[_n+1]-time
by id: replace timetonext=7-time if missing(timetonext) & time<3
by id: replace timetonext=2 if missing(timetonext) & time>=3
replace timetonext=0 if t2==8
gen wave_oop=total_oop
gen og=wave_oop
//convert total oop to annual measure
replace total_oop=total_oop/timetonext
by id: gen timefromlast=time-time[_n-1]
by id: gen yearnext=t2[_n+1]
by id: gen lastoop=total_oop[_n-1]
by id: replace lastoop=lastoop[_n-1] if missing(lastoop)
replace total_oop=0 if t2==6
/*helper hours--get previous and do the same as oop, but avg between two
from OOP code--use 4 months if previous wave there was no help, otherwise use 4 
months at current and rest between*/

foreach x in _u _s {
by id: gen last`x'=hlphrs`x'[_n-1]
by id: gen next`x'=hlphrs`x'[_n+1]
replace next`x'=0 if missing(next`x')
replace last`x'=hlphrs`x' if missing(last`x')
replace last`x'=0 if missing(last`x')
gen avg`x'=(hlphrs`x'+next`x')/2
}
gen hlphrs_ann=(avg_u+avg_s)*12
by id: gen lasthelp=hlphrs_ann[_n-1]
replace lasthelp=hlphrs_ann if t2==0
by id: gen nexthelp=hlphrs_ann[_n+1]
replace hlphrs_ann=0 if missing(nexthelp)
replace nexthelp=hlphrs_ann if missing(nexthelp)
reshape wide og time total_oop c_ivw_date hlphrs_ann hlphrs_i hlphrs_u hlphrs_s last_u last_s next_u next_s ///
avg_u avg_s lasthelp nexthelp timetonext timefromlast yearnext lastoop wave_oop n, i(id) j(t2)
reshape long time og total_oop c_ivw_date hlphrs_ann hlphrs_i hlphrs_u hlphrs_s last_u last_s next_u next_s ///
avg_u avg_s l lasthelp nexthelp timetonext timefromlast yearnext lastoop wave_oop n, i(id) j(year)

sort id year
*by id: carryforward total_oop, gen(annual_oop)
by id: carryforward time, gen(antime)
by id: replace lastoop=total_oop[_n-1] if missing(lastoop)
by id: replace lastoop=lastoop[_n-1] if missing(lastoop)
by id: carryforward timetonext timefromlast lasthelp hlphrs_ann, replace
gsort id -year
by id: carryforward nexthelp, replace
sort id year
gen pct1=(year-time) if year<6
gen pct2=1-(year-time) if year<6
by id: replace pct2=1 if missing(time) & year<6


gen annual_oop=pct2*lastoop if inrange(year,1,5)
replace annual_oop=annual_oop+pct1*total_oop if !missing(pct1)
/*for annual helper hours 
-4 months at current
-if any at previous, 4 months at current and 8 months at avg current and former*/
gen annual_hlphrs=hlphrs_ann*2/3 + hlphrs_i*12/3
replace annual_hlphrs=hlphrs_ann if missing(annual_hlphrs) 
replace annual_hlphrs=. if inlist(year,0,6)
/*gen annual_hlphrs=hlphrs_ann/3+(hlphrs_ann+nexthelp)/3
replace annual_hlphrs=(lasthelp+nexthelp)/2 if missing(n)
gen annual_hlphrs=(nexthelp) if inrange(year,1,5) & missing(n)
replace annual_hlphrs=pct2*lasthelp if  missing(annual_h) & inrange(year,1,5)
replace annual_hlphrs=annual_h+pct1*hlphrs_a if !missing(pct1)*/
replace wave_oop=wave_oop*timetonext/(time[_n+1]-time) if time[_n+1]>5 & ///
!missing(time[_n+1])
replace wave_oop=wave_oop*(5-time)/2 if missing(time[_n+1]) & time>=3
replace wave_oop=0 if time>5

by id: egen all=total(wave)
by id: egen a2=total(annual_oop)
sum all a2
sum all a2 if year==0
keep id all a2 year annual_* hlphrs*

rename (year ) (yearfromdeath )
tempfile t2
save `t2'

use decedent_dataset.dta if inrange(index_year,2001,2012), clear
drop *bef

gen ffs_yrs=floor(cont_ffs_n_mos/12)
foreach x in 12 24 36 48 60 {
rename tot_paid_by_mc_`x'm tot_paid_by_mc`=`x'/12'
}

forvalues i=1/5 {
replace tot_paid_by_mc`i'=. if ffs_yrs<`i'
}

reshape long tot_paid_by_mc, i(id) j(yearfromdeath)
keep id tot* yearfr
tempfile t3
save `t3'
/*
merge 1:1 id yearfromdeath using `t2', gen(oopme2) keep(match using)
merge 1:1 id yearfromdeath using `t1', gen(fullmerge)
*/
use `t1', clear
merge 1:1 id yearfromdeath using `t2', gen(oopme2) keep(match using)
merge 1:1 id yearfromdeath using `t3', gen(mcmerge) keep(match master)
sort id yearf

by id: replace ffs_y=ffs_y[_n+1] if missing(ffs_y)
by id: replace pdem=pdem[_n+1] if n==1 & missing(pdem)
gen likely_dem=inrange(pdem,.5,1) if !missing(pdem)
by id: egen pdem_gt50_n1=max(cond(n==2,likely_dem,.))
drop if missing(pdem_g) 
gen age_at_death=floor((index_dat-birth_date)/365.25)
drop if age_<70
label var age_ "Age at death"
foreach x of varlist `helpvars' {
replace `x'=0 if missing(`x')
}
gen ind_hp=n_hp>0
label var ind_hp "any helpers"
gen comorb_modsev=comor_c>=2 if !missing(comor_c)
label var comorb_modsev "4+ SR conditions"
label var likely_dem "Probable demntia (Pr>.5)"
label var time "Time from ivw to death, years"
foreach x in pdem likely_dem medicaid adl_independent_core iadl_independent_core ///
smoke_curr comorb_modsev time ind_hp `helpvars' networth_adj2012 finwealth_adj2012 {
gen `x'_ba=`x' if n==obs
by id: egen `x'_b=max(`x'_ba)
drop `x'_ba
local lab : var label `x'
label var `x'_b "`lab' at baseline"
}
replace networth_adj2012_b=1 if networth_adj2012_b<=0
//discounting--why?
forvalues i=1/5 {
	foreach x in tot_paid_by_mc annual_oop annual_hlp {
		*replace `x'=`x'/1.03^`=`i'-1' if year==`i'
}
}
by id: egen tottot=total(tot_paid_by_mc)
by id: egen alloop=total(annual_oop)
by id: egen allhelp=total(annual_hlp)
replace allhelp=allhelp*20
label var allhelp "Imputed informal help over 5 years (at $20/hr)"
label var tottot "Total paid by MC over 5 years"
label var alloop "Total paid OOP over 5 years"
gen time_x=(e_ivw_date-index_date)/365.25
label var time_x "Time from death to exit, years"
gen baseline_out=time_b>=5
label var baseline_out "% with a baseline outside the 5 year window"

replace likely_dem=pdem_g if year==0



gen oopsofar=0
forvalues i=7(-1)1 {
by id: replace oopsofar=annual_oop+oopsofar[_n+1] if year==`i'
}
replace oopsofar=alloop if year==0
gen oop_gt_nw=oopsofar>=networth_adj2012_b
gen nw_remaining=100*(networth_adj2012_b-oopsofar)/networth_adj2012_b
replace nw_r=0 if nw_r<0
replace nw_r=0 if networth_adj2012_b<0
//table
local cvars1 time_x time_b 
local ivars1 baseline_out
local cvars2 age_at_death
local cvars3 n_i n_i_b pdem pdem_b
local ivars2 white black hisp_eth other_na_api_race female married_o_x hseduc medicaid_x medicaid_b ///
medigap_x champus_x ind_hp ind_hp_b 
local ivars3 likely_dem likely_dem_b ///
adl_independent_x adl_independent_core_b iadl_independent_x ///
iadl_independent_core_b smoke_curr_b comorb_modsev comorb_modsev_b
local coutcomes3 tottot alloop allhelp
local rn : word count `cvars1' `cvars2' `ivars1' `ivars2' `cvars3' `ivars3' `coutcomes3' 1

mat tab=J(`rn',4,.)
local r=1
local c=1
gsort id -year
by id: carryforward wgthh, replace
sort id year
preserve

keep if n==1
foreach group in "0,1" 0 1 {
	sum likely_dem if inlist(likely_dem,`group')
	local denom=r(N)
	foreach round in 1 2 3 {
		foreach x of local cvars`round' {
			sum `x' if inlist(likely_dem,`group') [aw=wgthh]
			if !inrange(r(N),1,10) mat tab[`r',`c']=r(mean)
			if "`group'"=="0,1" & !inrange(`denom'-r(N),1,10) mat tab[`r',`c'+3]=`denom'-r(N)
			local r=`r'+1
}
		foreach x of local ivars`round' {
			sum `x' if inlist(likely_dem,`group') [aw=wgthh]
			if !inrange(r(mean)*r(N),1,10) mat tab[`r',`c']=r(mean)*100
			if "`group'"=="0,1" & !inrange(`denom'-r(N),1,10) mat tab[`r',`c'+3]=`denom'-r(N)
			local r=`r'+1
}
		foreach x of local coutcomes`round' {
			sum `x' if inlist(likely_dem,`group') [aw=wgthh]
			if !inrange(r(N),1,10) mat tab[`r',`c']=r(mean)
			if "`group'"=="0,1" & !inrange(`denom'-r(N),1,10) mat tab[`r',`c'+3]=`denom'-r(N)
			local r=`r'+1
}


}	
	mat tab[`r',`c']=`denom'
	local r=1
	local c=`c'+1
}
mat rownames tab=`cvars1' `ivars1'  `cvars2' `ivars2' `cvars3' `ivars3' `coutcomes3' N

frmttable using "E:\data\burden_dementia\logs\table_baseline_death.rtf", replace ///
statmat(tab) title("Sample Characteristics by dementia status at n1 ivw") ///
ctitles("" "Full Sample" "No dementia" "Dementia" "N missing") sdec(2,2,2,0) ///
varlabels note("Decedents 2006-2012 with 60m continuous FFS pre-death, an exit and all core ivws" ///
"Household weights applied")

restore
preserve

egen totalpaid=rowtotal(tot_paid_by_mc total_oop annual_hlp)
collapse tot_paid_by_mc total_oop annual_hlp pdem likely_dem totalpaid networth_adj2012_b ///
oopsofar oop_gt_nw nw_remaining [pw=wgthh], by(pdem_gt50_n1 year)
replace year=-year+6

label define year 0 "Baseline" 6 "Death"
label values year year

twoway (line pdem year if pdem_g==1) (line pdem year if pdem_g==0) ///
(line likely_dem year if pdem_g==1) (line likely_dem year if pdem_g==0) if year<6, ///
xlabel(0.1 "Baseline" 1 2 3 4  5 "Death") xtitle("")
graph save "E:\data\burden_dementia\logs\dementia_prob_over_time", replace
graph export "E:\data\burden_dementia\logs\dementia_prob_over_time.pdf", replace

twoway (line nw_remaining yearfromdeath if pdem_g==1)(line nw_remaining yearfromdeath if pdem_g==0) ///
(line oop_gt yearfromdeath if pdem_g==1 , yaxis(2)) (line oop_gt yearfromdeath if pdem_g==0, yaxis(2)) ///
if year<6, xlabel(0.1 "Baseline" 1 2 3 4  5 "Death") xtitle("") ///
legend(label(1 "% NW remaining, demented") label(2 "% remaining, nondemented") ///
label(3 "% OOP>NW, demented") label(4 "% OOP>NW, nondemented"))
graph save "E:\data\burden_dementia\logs\networth_oop_over_time", replace
graph export "E:\data\burden_dementia\logs\networth_oop_over_time.pdf", replace
restore
save "`fdpath'/burden_dementia_sample_long.dta", replace


H="changelog"
02/05/19 - Added header "Comparison table 5 v 7 yrs." Evan

01/29/19 - Brought the predicted Medicaid into the sample.  Evan

01/22/19 - Updated the graphs and added graph of Medicaid over time. Evan

01/17/19 - Added the predicted Medicaid. Evan

01/16/2019 - Calculating annualized costs for the 7 years prior to death. Omari

01/15/2019 - Inflation adjusted all figures 2016 and correct sample derivation. Omari

01/11/2019 - Updated Sample to include death dates to 2015, Exit 2016 and 7 year lookback. Omari

01/04/19 - Continued working on separating the Dataset construction from Sample Derivation. Omari

01/03/19 - Continued working on separating the Dataset construction from Sample Derivation. Omari

01/02/19 - Continued working on separating the Dataset construction from Sample Derivation. Omari

12/31/18 - Worked on separating the Dataset construction from Sample Derivation. Omari

12/20/18-finished update for 2015 claims and worked on 7-years.


