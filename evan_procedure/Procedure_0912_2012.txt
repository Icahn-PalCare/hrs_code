= V4 Outline MultiLine NoSorting TabWidth=30

H="Raw Data from HRS"


H="Raw data from HRS--restricted"


/*organize the restricted file
*******************************************************************************************
**HRS has provided a CD with several separate datafiles containing the restricted data elements.
**These include date of birth, interview date, zip code (region), race, date of death, and cause of death.
**The following sections of code format each restricted data file, create/clean variables as needed, 
**and then merge selected files together, and finally merge with the hrslimited dataset.
*******************************************************************************************
*/



/*to get the one id per row information
such as dod,dob,race,
note that inteview date has been merged into core data files,
geo  geographic data(used the zip),and cause of death,information need to be reorganize,one id has multiple zipcodes for each year
*/

libname data2 "C:\data\hrs_2011_v2";
*dod;
%let file=exitdeathdate;

proc contents data= data2.&file;
run;
proc sort data=data2.&file nodupkey;
by hhid pn;
run;

data data2.&file.2;
set data2.&file;
death_date=mdy(deathmonth,deathday,deathyear);

length id $9 hhid $6 pn $3;
id=hhid||pn;keep id hhid pn death_date;
run;
proc sort data=data2.&file.2;
by id;
run;
proc sql;
select count(*) from data2.&file.2 where death_date=.;
quit;
proc sort data=data2.&file.2;
by id;
run;
*dob;
%let file=dob2008;

proc contents data= data2.&file;
run;
proc sort data=data2.&file nodupkey;
by hhid pn;
run;
*note there is 674 missing birthday,while they have birth_month,and birthyr,
369 are missing death_mo,86 missing year;
*so put those birthday=15,;
data data2.&file.2;
set data2.&file;
if birthday=. then birthday=15;
*if birthmo=. then birthmo=6;


if  birthmo=2 and birthday>28 then birthday=28;
if  birthmo in (4,11) and birthday>30 then birthday=30;

birth_date=mdy(birthmo,birthday,birthyr);
length id $9 hhid $6 pn $3;
id=hhid||pn;
keep hhid pn 
birth_date birthyr id ;run;
proc sort data=data2.&file.2;
by id;
run;

proc sql;
select count(*) from data2.&file.2 where birth_date=.;
select hhid,pn from data2.&file.2 where birth_date=.;
select count(*) from data2.&file where birthday=.;
select count(*) from data2.&file where  birthmo=.;
select count(*) from data2.&file where  birthyr=.;
quit;



*race, race1 and hispanic1 is for those <=2004;
/*
RACE2M1        RACE/ETHNICITY - MULTIPLE MENTION 1
         Section: RE    Level: Respondent      Type: Numeric    Width: 2   Decimals: 0
         Ref: SecB.OtherBackground.B089M[1]

         What race do you consider yourself to be: White, Black or African American,
         American Indian, Alaska Native, Asian, Native Hawaiian, Pacific Islander, or
         something else?

         .................................................................................
         12054           0.  Not obtained
         15252           1.  White/Caucasian
          2695           2.  Black/African-American
           194           3.  American Indian
             2           4.  Alaskan Native
           167           5.  Asian
             3           6.  Native Hawaiian
            15           7.  Pacific Islander
           573          97.  Other (Specify)
            55          98.  DK
            12          99.  Unknown

RACE1          RACE/ETHNICITY 2004
         Section: RE    Level: Respondent      Type: Numeric    Width: 1   Decimals: 0

         This is the race/ethnicity of a respondent through 2004

         .................................................................................
           482           0.  Not obtained
         24288           1.  White/Caucasian
          4537           2.  Black/African-American
           332           3.  American Indian or Alaskan Native
           325           4.  Asian or Pacific Islander
           732           7.  Other
             8           8.  DK
             6           9.  Refused
           312       Blank.  Entered sample after 2004


==========================================================================================

HISPANIC1      HISPANIC TYPE 2004
         Section: RE    Level: Respondent      Type: Numeric    Width: 1   Decimals: 0

         This is the hispanicity of a respondent through 2004.

         .................................................................................
           444           0.  Not obtained
          1536           1.  Mexican-American/Chicano
           238           2.  Puerto Rican
           257           3.  Cuban American
           591           5.  Other
         27644           7.  Not Hispanic
           312       Blank.  Entered sample after 2004


HISPANIC2M1
==========================================================================================

HISPANIC2M1    HISPANIC TYPE - MULTIPLE MENTION 1
         Section: RE    Level: Respondent      Type: Numeric    Width: 1   Decimals: 0
         Ref: SecB.OtherBackground.B029M[1]

         Would you say you are Mexican American, Puerto Rican, Cuban American or
         something else?

         .................................................................................
         12123           0.  Not obtained
          1088           1.  Mexican-American/Chicano
           150           2.  Puerto Rican
           130           3.  Cuban American
         17085           6.  Not Hispanic
           413           7.  Other (Specify)
            32           8.  DK
             1           9.  Refused
*/
%let file=re2008;

proc contents data= data2.&file;
run;
*notice that hhis pn is $12 rather than $6 $3;
proc sort data=data2.&file nodupkey;
by hhid pn;
run;
proc freq;
table RACE1 FIRSTIW;
run;
proc sql;
select * from data2.&file where RACE1=.;
quit;

data data2.&file.2(rename=(hhid2=hhid pn2=pn));
set data2.&file;
if race1~=. then race=race1;

if race1=. then do;
race=race2m1;
if race2m1 in (3,4) then race=3;
if race2m1 in (5,6,7) then race=4;
if race2m1 in (97) then race=7;
if race2m1 in (98,99) then race=8;
end;

if hispanic1~=. then hispanic=hispanic1;

if hispanic1=. then do;
hispanic=hispanic2m1;
if hispanic2m1 in (7) then hispanic=5;
if hispanic2m1 in (6) then hispanic=7;
end;


** Hispanic Ethnicity and Subgroups **
generate hisp_eth=.
replace hisp_eth=0 if (hispanic==7)
replace hisp_eth=1 if ((hispanic==1)|(hispanic==2)|(hispanic==3)|(hispanic==5))
label variable hisp_eth "Hispanic Ethnicity"
;
hisp_eth=.;
if ((hispanic=1)|(hispanic=2)|(hispanic=3)|(hispanic=5)) then hisp_eth=1;
if (hispanic=7) then hisp_eth=0;
label hisp_eth= "Hispanic Ethnicity";

white=0;
if (race=1 & hisp_eth=0) then white=1;
if race in (0,8,9) then white=.;
label white= "Non-Hispanic White/Caucasian";

black=0;
if (race=2 & hisp_eth=0) then black=1;
if race in (0,8,9) then black=.;
label black= "Non-Hispanic black or African American";

native_amer=0;
if (race=3 & hisp_eth=0) then native_amer=1;
if race in (0,8,9) then native_amer=.;
label native_amer= " American Indian or Alaskan Native" ;

asian_pi=0;
if (race=4 & hisp_eth=0) then asian_pi=1;
if race in (0,8,9) then asian_pi=.;
label asian_pi= "Asian or Pacific Islander" ;

other_race=0;
if (race=7 & hisp_eth=0) then other_race=1;
if race in (0,8,9) then other_race=.;
label other_race= "Other Non-Hispanic Race" ;
**Due to small number of subjects that are native american, asian/pi, those groups are combined with 'other' race in this new variable;
other_na_api_race=0;
if (race in (3,4,7) & hisp_eth=0) then other_na_api_race=1;
if race in (0,8,9) then other_na_api_race=.;
label other_na_api_race= "Native American, Asian Pacific Islander, or Other Non-Hispanic Race" ;



length id $9 hhid2 $6 pn2 $3;
hhid2=put(hhid,$6.);
pn2=put(pn,$3.);
drop hhid pn;

id=hhid2||pn2;
label id="hhid+pn";
label race="raw race,multiple";
label hispanic="raw hispanic,1,2,3,5=hispanic eth";
keep id hhid2 pn2 race hispanic hisp_eth white black native_amer asian_pi  other_race other_na_api_race;
run;

proc contents data=data2.&file.2;

run;
proc sort data=data2.&file.2;
by id;
run;

proc freq;
table RACE hispanic  white black native_amer asian_pi other_race other_na_api_race;
run;
*


generate other_na_api_race=.
replace other_na_api_race=1 if (race==7)|(race==3)|(race==4)
replace other_na_api_race=0 if ((race==1)|(race==2)|(hispanic==1)|(hispanic==2)|(hispanic==3)|(hispanic==5))
label variable other_na_api_race "Native American, Asian Pacific Islander, or Other Non-Hispanic Race"
label define other_na_api_race 1 "Other Race", modify
label values other_na_api_race other_na_api_race 
tab other_na_api_race, missing;
/*
** Race Variable Cleaning **

generate white=.
replace white=1 if (race==1)
replace white=0 if ((race==2)|(race==3)|(race==4)|(race==7)|(hispanic==1)|(hispanic==2)|(hispanic==3)|(hispanic==5))
label variable white "Non-Hispanic White/Caucasian"
label define white 1 "Non-Hispanic White/Caucasian", modify
label values white white
tab white, missing

generate black =.
replace black=1 if (race==2)
replace black=0 if ((race==1)|(race==3)|(race==4)|(race==7)|(hispanic==1)|(hispanic==2)|(hispanic==3)|(hispanic==5))
label variable black "Black or African American"
label define black 1 "Black or African American", modify
label values black black
tab black, missing

generate native_amer =.
replace native_amer =1 if (race==3)
replace native_amer =0 if ((race==1)|(race==2)|(race==4)|(race==7)|(hispanic==1)|(hispanic==2)|(hispanic==3)|(hispanic==5))
label variable native_amer "American Indian or Alaskan Native"
label define native_amer 1 "American Indian or Alaskan Native", modify
label values native_amer native_amer 
tab native_amer, missing

generate asian_pi =.
replace asian_pi =1 if (race==4)
replace asian_pi =0 if ((race==1)|(race==2)|(race==3)|(race==7)|(hispanic==1)|(hispanic==2)|(hispanic==3)|(hispanic==5))
label variable asian_pi "Asian or Pacific Islander"
label define asian_pi 1 "Asian or Pacific Islander", modify
label values asian_pi asian_pi 
tab asian_pi, missing


generate other_race=.
replace other_race =1 if (race==7)
replace other_race=0 if ((race==1)|(race==2)|(race==3)|(race==4)|(hispanic==1)|(hispanic==2)|(hispanic==3)|(hispanic==5))
label variable other_race "Other Non-Hispanic Race"
label define other_race 1 "Other Race", modify
label values other_race other_race 
tab other_race, missing

**Due to small number of subjects that are native american, asian/pi, those groups are combined with 'other' race in this new variable

generate other_na_api_race=.
replace other_na_api_race=1 if (race==7)|(race==3)|(race==4)
replace other_na_api_race=0 if ((race==1)|(race==2)|(hispanic==1)|(hispanic==2)|(hispanic==3)|(hispanic==5))
label variable other_na_api_race "Native American, Asian Pacific Islander, or Other Non-Hispanic Race"
label define other_na_api_race 1 "Other Race", modify
label values other_na_api_race other_na_api_race 
tab other_na_api_race, missing
*/




/*format of race,hispanic
RACE1          RACE/ETHNICITY 2004
         Section: RE    Level: Respondent      Type: Numeric    Width: 1   Decimals: 0

         This is the race/ethnicity of a respondent through 2004

         .................................................................................
           482           0.  Not obtained
         24288           1.  White/Caucasian
          4537           2.  Black/African-American
           332           3.  American Indian or Alaskan Native
           325           4.  Asian or Pacific Islander
           732           7.  Other
             8           8.  DK
             6           9.  Refused
           312       Blank.  Entered sample after 2004


==========================================================================================

HISPANIC1      HISPANIC TYPE 2004
         Section: RE    Level: Respondent      Type: Numeric    Width: 1   Decimals: 0

         This is the hispanicity of a respondent through 2004.

         .................................................................................
           444           0.  Not obtained
          1536           1.  Mexican-American/Chicano
           238           2.  Puerto Rican
           257           3.  Cuban American
           591           5.  Other
         27644           7.  Not Hispanic
           312       Blank.  Entered sample after 2004
*/


proc contents data=data2.dob20082;
run;
proc contents data=data2.race20082;
run;

*z905 is the cause of death,48 cat,will make them as the 12 cat as request,cause_death_12;
data data2.ndicause2(keep=id z905_n);
set data2.ndicause;
length id $9 hhid2 $6 pn2 $3;
hhid2=put(hhid,$6.);
pn2=put(pn,$3.);
drop hhid pn;

id=hhid2||pn2;
label id="hhid+pn";
z905_n=z905+0;
run;
libname ling "C:\Documents and Settings\kellea03\Desktop\From_Ling\Final_data";
proc sql;
create table data2.ndicause3 as 
select a.id,b.cause_death_12
from data2.ndicause2 a
left join
ling.cause_death b
on a.z905_n=b.id;
quit;
proc freq;
table cause_death_12;
run;

proc sort data=data2.ndicause3 nodupkey;
by id;
run;



data data2.HRSXGEO2;
set data2.HRSXGEO;
length id $9 hhid2 $6 pn2 $3;
hhid2=put(hhid,$6.);
pn2=put(pn,$3.);
drop hhid pn;

id=hhid2||pn2;
label id="hhid+pn";

keep id zip:;
run;

proc contents data=data2.HRSXGEO2;
run;

proc sort data=data2.HRSXGEO2 nodupkey;
by id;
run;

data data2.hrs_dod_dob_race;
merge data2.dob20082 data2.re20082 data2.exitdeathdate2 data2.ndicause3 data2.HRSXGEO2;
by id;
run;

proc contents data=data2.hrs_dod_dob_race;
run;
proc sort data=data2.hrs_dod_dob_race nodupkey;
by id ;
run;

H="Raw data from HRS--core"

*the raw da file should be in the folder,
"c:\hrs2000\data";
*the destiated file should be, EXTRACT 'c:\hrs2000\sas\
;

%let keep_var_list=hhid pn  merged_year proxy_core female marital married marital_sep marital_div marital_wid
marital_nev marital_sd educ medicare medicareb medicaid champus hmo medigap nhres
imprelig   reschil_d resspouse  friend rel_nb adl_dr_core
adl_wk_core adl_bh_core adl_e_core adl_tx_core adl_t_core adl_index_core adl_cat_core
adl_independent_core adl_partial_core adl_severe_core iadl_mp iadl_gr iadl_ph iadl_rx iadl_m
cancer_hrs lung_hrs heart_hrs chf_hrs stroke_hrs memory_hrs falls_hrs pain_hrs htn_hrs dm_hrs
psych_hrs arth_hrs comor_in_hrs comor_c_hrs srh srh_pf srh_g srh_ve hosp_last_2yr
networth child gchil allchil reschil hhm IADL_CAT
;
%let keep_var_list2=hhid pn  merged_year proxy_core female marital married marital_sep marital_div marital_wid
marital_nev marital_sd  medicare medicareb medicaid champus hmo medigap nhres
imprelig   reschil_d resspouse  friend rel_nb adl_dr_core
adl_wk_core adl_bh_core adl_e_core adl_tx_core adl_t_core adl_index_core adl_cat_core
adl_independent_core adl_partial_core adl_severe_core iadl_mp iadl_gr iadl_ph iadl_rx iadl_m
cancer_hrs lung_hrs heart_hrs chf_hrs stroke_hrs memory_hrs falls_hrs pain_hrs htn_hrs dm_hrs
psych_hrs arth_hrs comor_in_hrs comor_c_hrs srh srh_pf srh_g srh_ve hosp_last_2yr
networth child gchil allchil reschil hhm IADL_CAT
;


options fmterr=no;
options compress=yes;
libname hrs00 "C:\hrs2000\sas";


proc format;
value educ 
0= "No Formal Education"
1= "Grades 1-11" 
2 ="High School" 
3= "Some College" 
4 ="College" 
5 ="Post College"
;

value marital 1= "Married" 
2= "Separated" 
3= "Divorced" 
4= "Widowed" 
5= "Never Married" 
6= "Other/Don't Know"
;
value imprelig 
1= "Very Important" 
2= "Somewhat Important" 
3= "Not Too Important" 
4 ="Don't Know/Refused/Missing"
;
value adl_cat_core
0= "Independent" 
1 ="Partial Dependence" 
2 ="Severe Dependence"
;
value srh 
1= "Excellent" 
2= "Very Good" 
3= "Good" 
4= "Fair" 
5= "Poor"
;
value comor_c_hrs 
0 ="None (0)" 
1 ="Mild (1-3)" 
2 ="Moderate (4-6)" 
3 ="Severe (>7)"
;
value  
iadl_cat 
0= "Independent" 
1 ="Partial Dependence" 
2 ="Severe Dependence" 
3 ="Restricted to Bed"
;
run;

%let year=00;
libname HRS "c:\hrs20&year.\sas\";
proc sort data=HRS.H00a_r;
by hhid gsubhh pn;
proc sort data=HRS.H00b_r;
by hhid gsubhh pn;
proc sort data=HRS.H00c_r;
by hhid gsubhh pn;
proc sort data=HRS.H00e_r;
by hhid gsubhh pn;
proc sort data=HRS.H00cs_r;
by hhid gsubhh pn;
proc sort data=HRS.H00g_r;
by hhid gsubhh pn;
proc sort data=HRS.H00m_r;
by hhid gsubhh pn;
proc sort data=HRS.H00pr_r;
by hhid gsubhh pn;
proc sort data=HRS.H00r_r;
by hhid gsubhh pn;
proc sort data=HRS.H00i_er;
by hhid gsubhh pn;
proc sort data=HRS.H00i_jh;
by hhid gsubhh pn;
run;
/*end with _h is at the household level,
*end with _mc is at memer chile level,
_r is at respondent level,
proc sort data=HRS.H00cs_h;
by hhid gsubhh pn;
run;

proc freq data=hrs00.H00pr_mc;
table g10;
run;
*/
/*add the 2000 sex,should not do that since opn is different from pn,
there is no pn information in sex data(g10 is at member child level rather 
than respondent level),
instead,use 2002 gender to merge with 2000 gender;
proc sort data=HRS.H00pr_mc;
by hhid gsubhh;
run;
*/
data HRS.Core2000sub1;
merge HRS.H00i_er  HRS.H00a_r HRS.H00b_r HRS.H00c_r HRS.H00cs_r HRS.H00e_r HRS.H00g_r HRS.H00m_r HRS.H00pr_r HRS.H00r_r ;
by hhid gsubhh pn;
run;

proc sort data=HRS.H00i_jh;
by hhid gsubhh;
run;
proc sort data=HRS.H00d_h;
by hhid gsubhh;
run;
proc sort data=HRS.H00cs_h;
by hhid gsubhh;
run;

data HRS.Core2000;
merge HRS.Core2000sub1 HRS.H00d_h HRS.H00cs_h HRS.H00i_jh;
by hhid gsubhh;
run;



%let type=h;
%let year=02;

libname HRS "c:\hrs20&year.\sas\";
** Core2002: a_r, b_r, c_r, d_r, f_r, g_r, pr_r and imputed files: cr, eh, gr, nr, qh**
;


proc sort data=HRS.H02b_r;
by hhid pn hsubhh;
run;

proc sort data=HRS.H02a_r;
by hhid pn hsubhh;

proc sort data=HRS.H02c_r;
by hhid pn hsubhh;
proc sort data=HRS.H02d_r;
by hhid pn hsubhh;
proc sort data=HRS.H02f_r;
by hhid pn hsubhh;
proc sort data=HRS.H02g_r;
by hhid pn hsubhh;
proc sort data=HRS.H02m1_r;
by hhid pn hsubhh;
proc sort data=HRS.H02n_r;
by hhid pn hsubhh;
proc sort data=HRS.H02pr_r;
by hhid pn hsubhh;
proc sort data=HRS.H02i_cr;
by hhid pn hsubhh;
proc sort data=HRS.H02i_eh;
by hhid hsubhh;
proc sort data=HRS.H02i_gr;
by hhid pn hsubhh;
proc sort data=HRS.H02i_nr;
by hhid pn hsubhh;
proc sort data=HRS.H02i_qh;
by hhid hsubhh;
run;
proc sort data=HRS.H02a_h;
by hhid hsubhh;
run;
proc sort data=HRS.H02e_h;
by hhid hsubhh;
run;

data HRS.Core2002sub1;
merge HRS.H02b_r HRS.H02i_cr HRS.H02i_gr HRS.H02i_nr HRS.H02a_r HRS.H02c_r HRS.H02d_r HRS.H02f_r HRS.H02g_r HRS.H02m1_r HRS.H02n_r HRS.H02pr_r;
by hhid pn;
run;

proc sort data=HRS.Core2002sub1;
by hhid hsubhh;
run;
data HRS.Core2002;
merge HRS.Core2002sub1 HRS.H02i_eh  HRS.H02i_qh HRS.H02a_h  HRS.H02e_h;
by hhid hsubhh;
run;


**Core 2004:a_h, a_r, b_r, c_r, d_r, f_r, g_r, pr_r and imputed files: cr, eh, nr qh**
;
%let year=04;
libname HRS "c:\hrs20&year.\sas\";

proc sort data=HRS.H04a_r;
by hhid pn jsubhh;
proc sort data=HRS.H04a_h;
by hhid jsubhh;
proc sort data=HRS.H04b_r;
by hhid pn jsubhh;
proc sort data=HRS.H04c_r;
by hhid pn jsubhh;
proc sort data=HRS.H04d_r;
by hhid pn jsubhh;
proc sort data=HRS.H04f_r;
by hhid pn jsubhh;
proc sort data=HRS.H04g_r;
by hhid pn jsubhh;
proc sort data=HRS.H04m1_r;
by hhid pn jsubhh;
proc sort data=HRS.H04n_r;
by hhid pn jsubhh;
proc sort data=HRS.H04pr_r;
by hhid pn jsubhh;
proc sort data=HRS.H04i_cr;
by hhid pn jsubhh;
proc sort data=HRS.H04i_eh;
by hhid jsubhh;
proc sort data=HRS.H04i_nr;
by hhid pn jsubhh;
proc sort data=HRS.H04i_qh;
by hhid jsubhh;
run;
proc sort data=HRS.H04e_h;
by hhid jsubhh;
run;

data Core2004sub1_0;
merge   HRS.H04a_r HRS.H04b_r HRS.H04c_r HRS.H04d_r HRS.H04f_r HRS.H04g_r HRS.H04m1_r HRS.H04n_r HRS.H04pr_r;
by hhid pn;
run;
data imputed_04;
merge HRS.H04i_cr HRS.H04i_nr;
by hhid pn;
run;
proc sql;
create table HRS.Core2004sub1
as select *
from Core2004sub1_0 a 
left join
imputed_04 b
on a.hhid=b.hhid and a.pn=b.pn;
quit;


proc sort data=HRS.Core2004sub1;
by hhid jsubhh;
run;
data im_04_h;
merge  HRS.H04i_eh  HRS.H04i_qh ;
by hhid jsubhh;
run;
proc sql;
create table im_04_h2
as select *
from HRS.H04a_h a 
left join
im_04_h b
on a.hhid=b.hhid and a.jsubhh=b.jsubhh;
quit;
proc sort data=im_04_h2;
by hhid jsubhh;
run;

data HRS.Core2004;
merge HRS.Core2004sub1 im_04_h2 HRS.H04e_h;
by hhid jsubhh;
run;


libname hrs00 "C:\hrs2000\sas";
libname hrs02 "C:\hrs2002\sas";
libname hrs04 "C:\hrs2004\sas";
*select 2002 sex to replace 2000 sex, since there is no new enrollee in 2002,
g10 at the mememberchile level rather than respondent level so we wont use g10,
and year 2008 gender is not availabe,use the year 2006 instead since there is no
new enrolled from 2006 to 08;
*
2000 Core G10 
2002 Core HX060_R 
2002 Exit SX060_R 
2004 Core JX060_R 
2004 Exit TX060_R 
2006 Core KX060_R 
2006 Exit UX060_R 
;

proc contents data=hrs00.core2000;
run;

proc sql;
create table hrs00.core2000_sex as select a.*,b.HX060_R,b.HA113 
from hrs00.core2000 a left join
hrs02.core2002 b on
trim(left(a.hhid))=trim(left(b.hhid)) and trim(left(a.pn))=trim(left(b.pn));
quit;
proc freq data=hrs00.core2000_sex;
table HX060_R;
run;

proc freq data=hrs02.core2002;
table HX060_R;
run;


proc sql outobs=5;
select hhid,pn from hrs00.Core2000;
quit;




data hrs00.core_00_02_04;
set hrs00.core2000_sex(in=merged_2000) hrs02.core2002(in=merged_2002) hrs04.core2004(in=merged_2004);
if merged_2000 then merged_year=2000;
if merged_2002 then merged_year=2002;
if merged_2004 then merged_year=2004;
run;
proc freq;
table merged_year;
run;
data hrs00.core_00_02_04_obs300;
set hrs00.core2000_sex(obs=100 in=merged_2000) hrs02.core2002(obs=100) hrs04.core2004(obs=100);
if merged_2000 then merged_year=2000;
run;


proc freq data=hrs00.core2000_sex;
table HX060_R;
run;

*
gender
2000 Core G10 
2002 Core HX060_R 
2002 Exit SX060_R 
2004 Core JX060_R 
2004 Exit TX060_R 
2006 Core KX060_R 
2006 Exit UX060_R 
2008 na
;

;
options compress=yes;
libname hrs00 "C:\hrs2000\sas";
libname hrs02 "C:\hrs2002\sas";
libname hrs04 "C:\hrs2004\sas";
*%let var_list=HX060_R JX060_R ;
*%let data=hrs00.core_00_02_04_obs300;
*note that allchil is already in core dataset,we need to drop it first;
%let data=hrs00.core_00_02_04;

data hrs00.core_00_02_04_sub(keep=&keep_var_list);
set &data;

** Hospital Admission, Dichotomous: "Don't Know/Refused" coded as missing by removing replace hosp = 9 if ((sn099==8)|(tn099==8)|(un099==8)|(sn099==9)|(tn099==9)|(un099==9))
generate hosp = .
replace hosp = 1 if ((vn099==1))
replace hosp = 0 if ((vn099==5))
label variable hosp "Hospital Admission in 2 yrs"
label define hosp 0 "No" 1 "Yes", modify
label values hosp hosp
tab hosp, missing ;
/*Cross-Wave Equivalents for:
N099 OVERNIGHT STAY IN HOSP-SINCE PREV IW/2YR 
1995 Core D1664 
1996 Core E1770 
1998 Core F2295 
2000 Core G2567 
2002 Core HN099 
2002 Exit SN099 
2004 Core JN099 
2004 Exit TN099 
2006 Core KN099 
2006 Exit UN099 
2008 Core LN099 
2008 Exit VN099 
*/
hosp_last_2yr=.;
if G2567=1|HN099=1|JN099=1 then hosp_last_2yr=1;
if G2567=5|HN099=5|JN099=5 then hosp_last_2yr=0;

/*
** Proxy versus self, Core(1=self, 2=spouse, 3=non-spouse)
generate proxy_core = .
replace  proxy_core = 1 if ((g514==2)|(g514==3)|(ha009==2)|(ha009==3)|(ja009==2)|(ja009==3))
replace  proxy_core = 0 if ((g514==1)|(ha009==1)|(ja009==1))
label variable proxy_core "Proxy Respondent for Core Interview"
label define proxy_core 0 "No" 1 "Proxy", modify
label values proxy_core proxy_core
tab proxy_core, missing 
*/

proxy_core = .;
if ((g514=2)|(g514=3)|(ha009=2)|(ha009=3)|(ja009=2)|(ja009=3)) then  proxy_core = 1; 
if ((g514=1)|(ha009=1)|(ja009=1)) then  proxy_core = 0 ;
label  proxy_core= "Proxy Respondent for Core Interview";


*gender,;
*updated,not borrow from year 2002,directly from
G490      CS0Y16.R GENDER - UPDATED                 
          Section: CS           Level: Respondent      CAI Reference: Q490
          Type: Numeric         Width: 1               Decimals: 0

          User note:  This value was updated by Q510.
          ................................................................................
           8116         1. MALE
          11464         2. FEMALE
;
female = .;
 if ((HX060_R =2)| (JX060_R=2)) then  female = 1;
if ((HX060_R =1)| (JX060_R=1)) then  female = 0 ;
 if ((G490=2)) then  female = 1;
if ((G490 =1) ) then  female = 0 ;

*age according dob from restricted file and year(core_date),core_date is also in restricted
they are available on amy's computer;

*race and ethnicity is already in restricted data file;

** Marital status r1134;
/*
Cross-Wave Equivalents for:
B063 MARITAL STATUS ASSIGNED 
1995 Core N/A 
1996 Core N/A 
1998 Core N/A 
2000 Core N/A (amy use G1158)
2002 Core N/A (amy use HMARITAL)
2002 Exit N/A 
2004 Core JB063 
2004 Exit TB063 
2006 Core KB063 
2006 Exit UB063 
2008 Core LB063 
2008 Exit VB063 


Cross-Wave Equivalents for:
B061 MARITAL STATUS IF UNMARRIED 
1995 Core N/A 
1996 Core N/A 
1998 Core F1070 
2000 Core G1157 
2002 Core HB061 
2002 Exit SB061 
2004 Core JB061 
2004 Exit TB061 
2006 Core KB061 
2006 Exit UB061 
2008 Core LB061 
2008 Exit VB061 

Cross-Wave Equivalents for:
 
2000 Core G543 
2002 Core HA020 
2002 Exit SA020 
2004 Core JA020 
2004 Exit TA020 
2006 Core KA020 
2006 Exit UA020 
2008 Core LA020 
2008 Exit VA020 
*/

/*
2000 Core

G1158     A43A.MARITAL STATUS_ASSIGNED              
          Section: A            Level: Respondent      CAI Reference: Q1158
          Type: Numeric         Width: 1               Decimals: 0
          ................................................................................
              4         0. DK (don't know); NA (not ascertained); RF (refused)
          12520         1. MARRIED
            324         3. SEPARATED
           1865         4. DIVORCED
           4160         5. WIDOWED
            614         6. NEVER MARRIED
             93         7. OTHER (SPECIFY)


2002 Core


HMARITAL MARITAL STATUS
         Section: B     Level: Respondent      Type: Numeric    Width: 1   Decimals: 0

        ..................................................................................
        11415           1. Married
          293           3. Separated
         1752           4. Divorced
         4145           5. Widowed
          528           6. Never Married
           25           7. Other (Specify)
            1           8. DK (Don't Know)
            7           9. RF (Refused)
            1       Blank. INAP (Inapplicable)

All other Cores- ‘B061’ variable

2000 Core G1157 
2002 Core HB061 
2002 Exit SB061 
2004 Core JB061
*/
*change sa020(exit) into G543(core);

marital = .;
if ((G1158=1) | (HMARITAL=1)|(jb063=1)) then marital = 1 ;
if ((G1157=3)|(hb061=3)|(jb061=3) |(G1158=3) | (HMARITAL=3)|(jb063=3)) then marital = 2 ;
if ((G1157=4)|(hb061=4)|(jb061=4)  |(G1158=4) | (HMARITAL=4)|(jb063=4)) then marital = 3 ;
if ((G1157=5)|(hb061=5)|(jb061=5)  |(G1158=5) | (HMARITAL=5)|(jb063=5)) then marital = 4 ;
if ((G1157=6)|(hb061=6)|(jb061=6) |(G1158=6) | (HMARITAL=6)|(jb063=6)) then marital = 5 ;
if ((G1157=7)|(hb061=7)|(jb061=7) |(G1157=8)|(hb061=8)|(jb061=8) |(G1158=7) | (HMARITAL=7)|(jb063=7)|(G1158=8) | (HMARITAL=8)|(jb063=8)) then marital = 6 ;
label marital="Marital Status";
format marital marital.;


married = .;
if (marital=1) then married = 1 ;
if (marital>1) then married = 0 ;
label married= "Married";

marital_sep = .;
if (marital=2) then marital_sep = 1 ;
if (marital~=2 & marital ~=.) then marital_sep = 0 ;
label marital_sep= "Separated";

marital_div = .;
if (marital=3) then marital_div = 1 ;
if (marital~=3 & marital ~=.) then marital_div = 0 ;
label marital_div= "Divorced";

marital_wid = .;
if (marital=4) then marital_wid = 1 ;
if (marital~=4 & marital ~=.) then marital_wid = 0 ;
label marital_wid= "Widowed";

marital_nev = .;
if (marital=5) then marital_nev = 1 ;
if (marital~=5 & marital ~=.) then marital_nev = 0 ;
label marital_nev= "Never Married";

marital_sd = .;
if (marital_sep=1 | marital_div=1) then marital_sd  = 1 ;
if (marital_sep=0 & marital_div=0) then marital_sd  = 0 ;
label marital_sd = "Separated or Divorced";
/*
married = .
 then married = 1 ;if (marital=1)
 then married = 0 ;if (marital!=1 & marital <.)
label married "Married"
label define married 1 "Married" 0 "Not Married", mod;ify
label values married married
tab married, missing 

generate marital_sep = .
 then marital_sep = 1 ;if (marital=2)
 then marital_sep = 0 ;if (marital!=2 & marital <.)
label marital_sep "Separated"
label define marital_sep 1 "Separated" 0 "Not Separated", mod;ify
label values marital_sep marital_sep
tab marital_sep, missing 

generate marital_div = .
 then marital_div = 1 ;if (marital=3)
 then marital_div = 0 ;if (marital!=3 & marital <.)
label marital_div "Divorced"
label define marital_div 1 "Divorced" 0 "Not Divorced", mod;ify
label values marital_div marital_div
tab marital_div, missing 

generate marital_wid = .
 then marital_wid = 1 ;if (marital=4)
 then marital_wid = 0 ;if (marital!=4 & marital <.)
label marital_wid "Widowed"
label define marital_wid 1 "Widowed" 0 "Not Widowed", mod;ify
label values marital_wid marital_wid
tab marital_wid, missing 

generate marital_nev = .
 then marital_nev = 1 ;if (marital=5)
 then marital_nev = 0 ;if (marital!=5 & marital <.)
label marital_nev "Never Married"
label define marital_nev 1 "Never Married" 0 "Not Never Married", mod;ify
label values marital_nev marital_nev
tab marital_nev, missing 

generate marital_sd = .
 then marital_sd = 1 ;if (marital_sep=1 | marital_div=1)
 then marital_sd = 0 ;if (marital_sep=0 & marital_div=0)
label marital_sd "Separated or Divorced"
label define marital_sd 1 "Separated or Divorced" 0 "Not Separated or Divorced", mod;ify
label values marital_sd marital_sd
*/




*education,all related variables are already in the dataset,
not found in year 2006,2008,just use the education from year 2004,;
educ = .;
if ((g1074a=0)| (hb014a=0)| (jb014a=0)) then educ = 0 ;
if ((g1074a>=1)& (g1074a<=11)) then educ = 1 ;
if ((hb014a>=1)& (hb014a<=11)) then educ = 1 ;
if ((jb014a>=1)& (jb014a<=11)) then educ = 1 ;
if ((g1074a=12)| (hb014a=12)| (jb014a=12)) then educ = 2 ;
if ((g1074a>=13)& (g1074a<=15)) then educ = 3 ;
if ((hb014a>=13)& (hb014a<=15)) then educ = 3 ;
if ((jb014a>=13)& (jb014a<=15)) then educ = 3 ; 
if ((g1074a=16)| (hb014a=16)| (jb014a=16)) then educ = 4 ;
if ((g1074a=17)| (hb014a=17)| (jb014a=17)) then educ = 5 ;
label educ ="Eduction, Highest Level";
format educ educ.;

*cant find the networth in the concordance file,need to find it 
from codebook,http://hrsonline.isr.umich.edu/modules/meta/2000/impute/h2000icb.txt
it is imputed file
GNETWRTH  TOTAL NET WORTH: GASSETS+GHOME1+GHOME2
          Section: JH 
;
networth = .;
if ((hnetwrth=.) & (jnetwrth=.)) then networth = gnetwrth ;*2000;
if ((gnetwrth=.) & (jnetwrth=.)) then networth = hnetwrth ;*2002;
if ((gnetwrth=.) & (hnetwrth=.)) then networth = jnetwrth ;*2004;
label networth ="networth";


/*
Cross-Wave Equivalents for:
N001 MEDICARE COVERAGE 
1995 Core D5144 
1996 Core E5133 
1998 Core F5866 
2000 Core G6238 
2002 Core HN001 
2002 Exit SN001 
2004 Core JN001 
2004 Exit TN001 
2006 Core KN001 
2006 Exit UN001 
2008 Core LN001 
2008 Exit VN001 

G6238     R1.MEDICARE COVERAGE                      
          Section: R            Level: Respondent      CAI Reference: Q6238
          Type: Numeric         Width: 1               Decimals: 0

          R1.
                  Are you currently covered by Medicare health insurance?
          ................................................................................
          11085         1. YES
           8402         5. NO
             34         8. DK (don't know); NA (not ascertained)
             10         9. RF (refused)


Cross-Wave Equivalents for:
N004 MEDICARE PART B COVERAGE 
1995 Core N/A 
1996 Core E5134 
1998 Core N/A 
2000 Core G6240 
2002 Core HN004 
2002 Exit SN004 
2004 Core JN004 
2004 Exit TN004 
2006 Core KN004 
2006 Exit UN004 
2008 Core LN004 
2008 Exit VN004 

Cross-Wave Equivalents for:
N005 MEDICAID COVERAGE SINCE PREV WAVE 
1995 Core N/A 
1996 Core E5135 
1998 Core F5868 
2000 Core G6241 
2002 Core HN005 
2002 Exit SN005 
2004 Core JN005 
2004 Exit TN005 
2006 Core KN005 
2006 Exit UN005 
2008 Core LN005 
2008 Exit VN005 


*/
medicare = .;
if ((G6238=1) | (hn001=1)| (jn001=1)) then medicare= 1 ;
if ((G6238=5) | (hn001=5)| (jn001=5)) then medicare= 0 ;


** r2587
generate; medicareb = .;
 if ((G6240=1) | (hn004=1)| (jn004=1)) then medicareb= 1;
if ((G6240=5) | (hn004=5)| (jn004=5)) then medicareb= 0;
if medicare= 0 then medicareb= 0;

** r2588 r2589
generate; medicaid = 0;
if ((G6241=1) | (hn005=1)| (jn005=1)) then medicaid= 1 ;
if ((G6241=8) | (hn005=8)| (jn005=8)) then medicaid= . ;


** r2598
generate
Cross-Wave Equivalents for:
N007 CHAMPUS/CHAMPVA COVERAGE 
1995 Core N/A 
1996 Core E5145 
1998 Core F5878 
2000 Core G6251 
2002 Core HN007 
2002 Exit SN007 
2004 Core JN007 
2004 Exit TN007 
2006 Core KN007 
2006 Exit UN007 
2008 Core LN007 
2008 Exit VN007 

; champus = 0;
if ((G6251=1) | (hn007=1)| (jn007=1)) then champus= 1 ;
if ((G6251=8)|(hn007=8)|(jn007=8)) then champus = . ;


** r2601
generate
Cross-Wave Equivalents for:
N009 MEDICARE/MEDICAID HMO 
1995 Core N/A 
1996 Core E5148 
1998 Core F5881 
2000 Core G6254 
2002 Core HN009 
2002 Exit SN009 
2004 Core JN009 
2004 Exit TN009 
2006 Core KN009 
2006 Exit UN009 
2008 Core LN009 
2008 Exit VN009 
; hmo = 0;
if ((G6254 =1) | (hn009=1)| (jn009=1)) then hmo= 1 ;
if ((G6254 =8)|(hn009=8)|(jn009=8)) then hmo = . ;


** r2623
generate 
Cross-Wave Equivalents for:
N023 NUM PRIVATE HEALTH INS PLANS 
1995 Core N/A 
1996 Core N/A 
1998 Core N/A 
2000 Core N/A 
2002 Core HN023 
2002 Exit SN023 
2004 Core JN023 
2004 Exit TN023 
2006 Core KN023 
2006 Exit UN023 
2008 Core LN023 
2008 Exit VN023 
;
medigap = .;
if (  (hn023>=1)| (jn023>=1)) then medigap= 1 ;
if ( (hn023=0)| (jn023=0)) then medigap= 0 ;
if ( (hn023=98)| (jn023=98)|(hn023=99)| (jn023=99)) then medigap= . ;
if g6276=1 and merged_year=2000 then medigap=1;*amy suggest to for 2000,medigap=1 if answer is yes,all others=no even if the answer is blank;
if medigap=. and merged_year=2000 then medigap=0;

*variable other,;
/*
Cross-Wave Equivalents for:
A028 R IN NURSING HOME 
1995 Core N/A 
1996 Core E240 
1998 Core F517 
2000 Core G558 
2002 Core HA028 
2002 Exit SA028 
2004 Core JA028 
2004 Exit TA028 
2006 Core KA028 
2006 Exit N/A 
2008 Core LA028 
2008 Exit N/A 

Cross-Wave Equivalents for:
A167 R IN NURSING HOME 
1995 Core N/A 
1996 Core N/A 
1998 Core N/A 
2000 Core N/A 
2002 Core N/A 
2002 Exit N/A 
2004 Core N/A 
2004 Exit TA167 
2006 Core N/A 
2006 Exit UA167 
2008 Core N/A 
2008 Exit VA167 

**Nursing Home and Hospice Residence**

generate nhres = .
replace nhres = 1 if ((sa028==1)| (ta167==1)| (ua167==1))
replace nhres = 0 if ((sa028==5)| (ta167==5)| (ua167==5))|((sa028==2)|(ta167==2)|(ua167==2))
label variable nhres "Nursing Home Resident"
label define nhres 0 "No" 1 "Yes", modify
label values nhres nhres
tab nhres, missing 
*/
nhres = .;
if ((G558=1)| (HA028=1)| (JA028=1)) then nhres = 1 ; 
if ((G558=5)| (HA028=5)| (JA028=5)) then nhres = 0 ;
label nhres="Nursing Home Resident";

/*
** "Was R living in a NH or other health care facility at the time he/she died?" answer '2'=hospice, '1'=NH
Ling: we  can't generate this variable.
generate hospice = .
replace hospice = 0 if ((sa028==5)| (ta167==5)| (ua167==5))|((sa028==1)| (ta167==1)| (ua167==1))
replace hospice = 1 if ((sa028==2)|(ta167==2)|(ua167==2))
label variable hospice "Hospice Resident"
label define hospice 0 "No" 1 "Yes", modify
label values hospice hospice
tab hospice, missing 
*/

/*
Ling: so far dont generate this not very useful variable
**Immigrant Status: this variable is of limited value because 3889 did not answer due to a skip pattern that is unclear**
generate immig = .
 then immig = 0 ;if ((sb002=1)|(tb002=1)|(ub086=1)|(g1060=1)|(hb002=1)|(jb002=1))
 then immig = 1 ;if ((sb002=5)|(tb002=5)|(ub086=5)|(g1060=5)|(hb002=5)|(jb002=5))
label variable immig "Immigrant Status"
*/



/*
Ling: so far dont generate this not very useful variable
**Religion: this variable is of limited value because 3983 did not answer due to a skip pattern that is unclear**
generate relig = .
 then relig = 1 ;if ((g1139=1)|(hb050=1)|(jb050=1))
 then relig = 2 ;if ((g1139=2)|(hb050=2)|(jb050=2))
 then relig = 3 ;if ((g1139=3)|(hb050=3)|(jb050=3))
 then relig = 4 ;if ((g1139=4)|(hb050=4)|(jb050=4))
 then relig = 5 ;if ((g1139=7)|(hb050=7)|(jb050=7))
label variable relig "Religion"
label define relig 1 "Protestant" 2 "Catholic" 3 "Jewish" 4 "No Pref" 5 "Other", mod;ify
label values relig relig
tab relig, missing 
*/

/*
**Importance of Religion from Core interview
Cross-Wave Equivalents for:
B053 IMPORTANCE OF RELIGION 
1995 Core D735 
1996 Core E735 
1998 Core F1055 
2000 Core G1142 
2002 Core HB053 
2002 Exit N/A 
2004 Core JB053 
2004 Exit N/A 
2006 Core KB053 
2006 Exit N/A 
2008 Core LB053 
2008 Exit N/A 

generate imprelig = .
 then imprelig = 1 ;if ((g1142=1)|(hb053=1)|(jb053=1))
 then imprelig = 2 ;if ((g1142=3)|(hb053=3)|(jb053=3))
 then imprelig = 3 ;if ((g1142=5)|(hb053=5)|(jb053=5))
 then imprelig = 4 ;if ((g1142=8)|(hb053=8)|(jb053=8)|(g1142=9)|(hb053=9)|(jb053=9))
 then imprelig = 4 ;if ((g1142>=.)&(hb053>=.)&(jb053>=.))
label variable imprelig "Importance of Religion"
label define imprelig 1 "Very Important" 2 "Somewhat Important" 3 "Not Too Important" 4 "Don't Know/Refused/Missing", mod;ify
label values imprelig imprelig
tab imprelig, missing 
*/
imprelig = .;
if ((g1142=1)|(hb053=1)|(jb053=1)) then imprelig = 1 ;
if ((g1142=3)|(hb053=3)|(jb053=3)) then imprelig = 2 ;
if ((g1142=5)|(hb053=5)|(jb053=5)) then imprelig = 3 ;
if ((g1142=8)|(hb053=8)|(jb053=8)|(g1142=9)|(hb053=9)|(jb053=9)) then imprelig = 4 ;
if ((g1142=.)&(hb053=.)&(jb053=.)) then imprelig = 4 ;
label imprelig ="Importance of Religion";
format imprelig imprelig.;



/*
**Frequency of Religious Services "How often did R attend services in last year of l;ife?". 
Core 2004 (jb082) asks directly, but prior cores do not**
Ling:so we can't generate this variable
generate freqrelg = .
 then freqrelg = 1 ;if ((sb082=1)|(tb082=1)|(ub082=1))
 then freqrelg = 2 ;if ((sb082=2)|(tb082=2)|(ub082=2))
 then freqrelg = 3 ;if ((sb082=3)|(tb082=3)|(ub082=3))
 then freqrelg = 4 ;if ((sb082=4)|(tb082=4)|(ub082=4))
 then freqrelg = 5 ;if ((sb082=5)|(tb082=5)|(ub082=5))
 then freqrelg = 6 ;if ((sb082=8)|(tb082=8)|(ub082=8)|(sb082=9)|(tb082=9)|(ub082=9))
 then freqrelg = 6 ;if ((sb082>=.)&(tb082>=.)&(ub082>=.))
label variable freqrelg "Frequency of Religious Services per proxy"
label define freqrelg 1 "> Once a Week" 2 "Once a Week" 3 "2-3 Times a Month" 4 "2-3 Times a Year" 5 "Not at All" 6 "Don't Know / Refused/Missing", mod;ify
label values freqrelg freqrelg
tab freqrelg, missing 
*/



/*
** Number of Children
Cross-Wave Equivalents for:
A101 COUNT OF KIDS - NOT THEIR SPOUSES 
1995 Core D513 
1996 Core E513 
1998 Core F816 
2000 Core G893 
2002 Core HA101 
2002 Exit SA101 
2004 Core JA101 
2004 Exit TA101 
2006 Core KA101 
2006 Exit UA101 
2008 Core LA101 
2008 Exit VA101 

generate child = .
 then child = sa101 ;if ((ta101>=.) & (ua101>=.))
 then child = ta101 ;if ((sa101>=.) & (ua101>=.))
 then child = ua101 ;if ((ta101>=.) & (sa101>=.))
label child "Number of Children, not their children's spouses"
*/
child = .;
if ((ha101=.) & (ja101=.)) then child = G893 ;
if ((G893=.) & (ja101=.)) then child = ha101 ;
if ((ha101=.) & (G893=.)) then child = ja101 ;
label child ="Number of Children, not their children's spouses";
/*


** Number of Grandchildren
Cross-Wave Equivalents for:
E046 # GRANDCHILDREN TOTAL 
1995 Core D1443 
1996 Core E1413 
1998 Core F1819 
2000 Core G2035 
2002 Core HE046 
2002 Exit SE046 
2004 Core JE046 
2004 Exit TE046 
2006 Core KE046 
2006 Exit UE046 
2008 Core LE046 
2008 Exit VE046 

generate gchil = .
 then gchil = se046 ;if ((te046>=.) & (ue046>=.)& (se046!=98))
 then gchil = te046 ;if ((se046>=.) & (ue046>=.)& (te046!=98))
 then gchil = ue046 ;if ((te046>=.) & (se046>=.)& (ue046!=998)& (ue046!=999))
label gchil "Number of Grandchildren"
sum gchil, detail
*/
gchil = .;
if ((HE046=.) & (JE046=.)& (G2035<81)) then gchil = G2035  ;
if ((G2035=.) & (JE046=.)& (HE046<81)) then gchil = HE046 ;
if ((G2035=.) & (HE046=.)& (JE046<81)) then gchil = JE046 ;
label gchil= "Number of Grandchildren";


/*
** Total Number of Children, Children-in-law, and Grandchildren,
Ling,na in year 2000,so amy said borrow the variable from year 2002
Cross-Wave Equivalents for:
A113 COUNT OF CHILD CHILDLAW AND GRANDCHILD 
1995 Core N/A 
1996 Core N/A 
1998 Core N/A 
2000 Core N/A 
2002 Core HA113 
2002 Exit SA113 
2004 Core JA113 
2004 Exit TA113 
2006 Core KA113 
2006 Exit UA113 
2008 Core LA113 
2008 Exit VA113 

generate allchil = .
 then allchil = sa113 ;if ((ta113>=.) & (ua113>=.))
 then allchil = ta113 ;if ((sa113>=.) & (ua113>=.))
 then allchil = ua113 ;if ((ta113>=.) & (sa113>=.))
label allchil "Total Number of Children, Children-in-law, and Grandchildren"
sum allchil, detail
*/

if ((HA113>.)) then allchil = HA113 ;
if ((JA113>.)) then allchil = JA113 ;
label allchil= "Total Number of Children, Children-in-law, and Grandchildren";



/*
** Number of Resident Children

generate reschil = .
 then reschil = sa099 ;if ((ta099>=.) & (ua099>=.))
 then reschil = ta099 ;if ((sa099>=.) & (ua099>=.))
 then reschil = ua099 ;if ((ta099>=.) & (sa099>=.))
label reschil "Number of Resident Children"
sum reschil, detail
Cross-Wave Equivalents for:
A099 NUMBER OF RESIDENT CHILDREN 
1995 Core D506 
1996 Core E506 
1998 Core F809 
2000 Core G886 
2002 Core HA099 
2002 Exit SA099 
2004 Core JA099 
2004 Exit TA099 
2006 Core KA099 
2006 Exit UA099 
2008 Core LA099 
2008 Exit VA099 

*/
reschil= .;
if (G886=.) & (HA099 =.) then reschil= JA099   ;
if (JA099 =.) & (HA099 =.) then reschil= G886 ;
if (JA099 =.) & (G886=.) then reschil= HA099  ;
label reschil="Number of Resident Children";


/*Ling,lack of hospice variable,so we drop hospice variable as if the hospice is missing
** Resident Children as dummy variable;
 reschil_d = .;
 then reschil_d = 0 ;if ((reschil=0) & (reschil<.))|(nhres=1)|(hospice=1)
 then reschil_d = 1 ;if ((reschil>0) & (reschil<.))&(nhres!=1)&(hospice!=1)
label reschil_d "Living with Children"
label define reschil_d 1 "Live with 1 or more Children" 0 "Not Resident Children", mod;ify
tab reschil_d, missing
*/

reschil_d = .;
if ((reschil=0) )|(nhres=1) then reschil_d = 0 ;
if ((reschil>0) )&(nhres~=1) then reschil_d = 1 ;
label reschil_d= "Living with Children";


/*
** Living with spouse (at time of death/before move to hosp)
generate resspouse = .
 then resspouse = 0 ;if ((sa030=5)|(ta030=5)|(ua030=5)|(married=0))
 then resspouse = 1 ;if ((sa030=1)|(ta030=1)|(ua030=1))&(nhres!=1)&(hospice!=1)
label resspouse "Living with Spouse/Partner"
label define resspouse 1 "Live with Spouse" 0 "No", mod;ify
tab resspouse, missing
Cross-Wave Equivalents for:
A030 COUPLE LIVE TOGETHER 
1995 Core D241 
1996 Core E241 
1998 Core F521 
2000 Core G562 
2002 Core HA030 
2002 Exit SA030 
2004 Core JA030 
2004 Exit TA030 
2006 Core KA030 
2006 Exit UA030 
2008 Core LA030 
2008 Exit VA030 

*/
resspouse = .;
if ((G562=5)|(ha030=5)|(ja030=5)|(married=0)) then resspouse = 0 ;
if ((G562=1)|(ha030=1)|(ja030=1)) then resspouse = 1 ;
label resspouse= "Living with Spouse/Partner";


/** Number of Household Members

generate hhm = .
 then hhm = sa098 ;if ((ta098>=.) & (ua098>=.))
 then hhm = ta098 ;if ((sa098>=.) & (ua098>=.))
 then hhm = ua098 ;if ((ta098>=.) & (sa098>=.))
label hhm "Number of Household Members"
sum hhm, detail
Cross-Wave Equivalents for:
A098 COUNT OF HHM 
1995 Core D504 
1996 Core E504 
1998 Core F807 
2000 Core G884 
2002 Core HA098 
2002 Exit SA098 
2004 Core JA098 
2004 Exit TA098 
2006 Core KA098 
2006 Exit UA098 
2008 Core LA098 
2008 Exit VA098 

*/
hhm= .;
if ((g884=.) & (ha098 =.))  then hhm= ja098   ;
if (ja098 =.) & (ha098 =.) then hhm= g884 ;
if (ja098 =.) & (g884=.) then hhm= ha098  ;
label hhm="Number of Household Members";

/*Ling,no hospice variable,so we can't generate the above variable
** Living Alone in Community
generate livealone=.
 then livealone=1 ;if ((hhm=0)&(hhm <.)&(nhres!=1)&(hospice!=1))
 then livealone=0 ;if  ((hhm!=0)&(hhm <.))|(nhres=1)|(hospice=1)
label livealone "Live Alone in Community"
label define livealone 0 "No" 1 "Yes", mod;ify
label values livealone livealone
tab livealone, missing
*/

/** Good Friends Nearby from Core Interview, codes missing as 'no' **
generate friend = 0
 then friend = 1 ;if ((g2495=1)|(hf175=1)|(jf175=1))
 then friend = 0 ;if ((g2495=5)|(hf175=5)|(jf175=5))
label friend "Good Friends Nearby"
label define friend 0 "No" 1 "Yes", mod;ify
label values friend friend
tab friend, missing 
Cross-Wave Equivalents for:
F175 GOOD FRIENDS NEAR 
1995 Core N/A 
1996 Core E1737 
1998 Core F2244 
2000 Core G2495 
2002 Core HF175 
2002 Exit N/A 
2004 Core JF175 
2004 Exit N/A 
2006 Core KF175 
2006 Exit N/A 
2008 Core LF175 
2008 Exit N/A 

*/

friend = .;
if ((g2495=5)|(hf175=5)|(jf175=5)) then friend = 0 ;
if ((g2495=1)|(hf175=1)|(jf175=1)) then friend = 1 ;
label friend= "Good Friends Nearby";


/** Relatives Nearby from Core Interview, codes missing as 'no' **
generate rel_nb = 0
 then rel_nb = 1 ;if ((g2494=1)| (hf174=1)|(jf174=1))
 then rel_nb = 0 ;if ((g2494=5)| (hf174=5)|(jf174=5))
label rel_nb "Relatives Nearby"
label define rel_nb 0 "No" 1 "Yes", mod;ify
label values rel_nb rel_nb
tab rel_nb, missing 
Cross-Wave Equivalents for:
F174 RELATIVES NEAR 
1995 Core N/A 
1996 Core E1736 
1998 Core F2243 
2000 Core G2494 
2002 Core HF174 
2002 Exit N/A 
2004 Core JF174 
2004 Exit N/A 
2006 Core KF174 
2006 Exit N/A 
2008 Core LF174 
2008 Exit N/A 

*/

rel_nb = .;
if ((g2494=5)| (hf174=5)|(jf174=5)) then rel_nb = 0 ;
if ((g2494=1)| (hf174=1)|(jf174=1)) then rel_nb = 1 ;
label rel_nb= "Relatives Nearby";


/*start with adl

*******************************************************************************************
** These variables are drawn from the Core interview. In general the questions 
** were framed "Because of a health or memory problem, do you have any difficulty...
** .. Does anyone ever help you...?"
** " Each ADL is coded "Yes- need help" if the 
** response was "Yes"; and "No" if the item was skipped in the interview.  ADL questions 
** were skipped if respondents were able to do all higher level function in the 
** preceding series of questions, such as climb stairs. "Don't Know" "Not Ascertained" 
** and "Refused" responses are coded as missing. 
*******************************************************************************************

*/
** ADLs **
Ling: no bed bounded infor in core,adl_bedbound,so we ignore this variable,if adl_bedbound,
that means all other adl is missing.
so we can genenerate teh bed bounded iadl,
Cross-Wave Equivalents for:
G129 NUMBER DAYS IN BED 
1995 Core N/A 
1996 Core N/A 
1998 Core N/A 
2000 Core N/A 
2002 Core N/A 
2002 Exit SG129 
2004 Core N/A 
2004 Exit TG129 
2006 Core N/A 
2006 Exit UG129 
2008 Core N/A 
2008 Exit VG129 


/**Dressing, g2724 hg015 jg015

generate adl_dr_core = 0
replace adl_dr_core = 1 if ((g2724==1)|(hg015 ==1)|(jg015==1))
replace adl_dr_core = 0 if ((g2724==5)|(hg015 ==5)|(jg015==5))
replace adl_dr_core = . if ((g2724==8)|(hg015 ==8)|(jg015==8)|(g2724==9)|(hg015 ==9)|(jg015==9))
label variable adl_dr_core "Help Dressing"
label define adl_dr_core 0 "No" 1 "Yes", modify
label values adl_dr_core adl_dr_core
tab adl_dr_core, missing 
if the iadl variable are missing,it might because t
hat the previous question “whether they has any difficulty ”=”No” 
and then further ask whether 
4,need to revise the variable for adl as in the above item 3

*/ ;
adl_dr_core = 0;
if ((g2724=1)|(hg015 =1)|(jg015=1)) then adl_dr_core = 1  ;
if ((g2724=5)|(hg015 =5)|(jg015=5)) then adl_dr_core = 0  ;
if ((g2724=8)|(hg015 =8)|(jg015=8)|(g2724=9)|(hg015 =9)|(jg015=9)) then adl_dr_core = .  ;
*if ((g2723=5)|(hg014 =5)|(jg014=5)) then adl_dr_core = 0  ;
label adl_dr_core= "Help Dressing";



/**Walking, g2729 hg020 jg020 
generate adl_wk_core = 0
 then adl_wk_core = 1  ;if ((g2729=1)|(hg020 =1)|(jg020=1))
 then adl_wk_core = 0  ;if ((g2729=5)|(hg020 =5)|(jg020=5))
 then adl_wk_core = .  ;if ((g2729=8)|(hg020 =8)|(jg020=8)|(g2729=9)|(hg020 =9)|(jg020=9))
label adl_wk_core "Help Walking"
label define adl_wk_core 0 "No" 1 "Yes", mod ;ify
label values adl_wk_core adl_wk_core
tab adl_wk_core, missing 
*/
adl_wk_core = 0;
if ((g2729=1)|(hg020 =1)|(jg020=1)) then adl_wk_core = 1  ;
if ((g2729=5)|(hg020 =5)|(jg020=5)) then adl_wk_core = 0  ;
if ((g2729=8)|(hg020 =8)|(jg020=8)|(g2729=9)|(hg020 =9)|(jg020=9)) then adl_wk_core = .  ;
*if ((g2725=5)|(hg016 =5)|(jg016=5)) then adl_wk_core = 0  ;
label adl_wk_core= "Help Walking";




/**Bathing, g2745 hg022 jg022 

generate adl_bh_core = 0
 then adl_bh_core = 1  ;if ((g2745=1)|(hg022 =1)|(jg022=1))
 then adl_bh_core = 0  ;if ((g2745=5)|(hg022 =5)|(jg022=5))
 then adl_bh_core = .  ;if ((g2745=8)|(hg022 =8)|(jg022=8)|(g2745=9)|(hg022 =9)|(jg022=9))
label adl_bh_core "Help Bathing"
label define adl_bh_core 0 "No" 1 "Yes", mod ;ify
label values adl_bh_core adl_bh_core
tab adl_bh_core, missing 
Cross-Wave Equivalents for:
G022 ADL BATHE HELP 
1995 Core D1897 
1996 Core E1921 
1998 Core F2447 
2000 Core G2745 
2002 Core HG022 
2002 Exit SG022 
2004 Core JG022 
2004 Exit TG022 
2006 Core KG022 
2006 Exit UG022 
2008 Core LG022 
2008 Exit VG022 

*/
adl_bh_core = 0;
if ((g2745=1)|(hg022 =1)|(jg022=1)) then adl_bh_core = 1  ;
if ((g2745=5)|(hg022 =5)|(jg022=5)) then adl_bh_core = 0  ;
if ((g2745=8)|(hg022 =8)|(jg022=8)|(g2745=9)|(hg022 =9)|(jg022=9)) then adl_bh_core = .  ;
*if ((g2742=5)|(hg021 =5)|(jg021=5)) then adl_bh_core = 0  ;
label adl_bh_core= "Help Bathing";


/*
**Eating, g2755 hg024 jg024 

generate adl_e_core = 0
 then adl_e_core = 1  ;if ((g2755=1)|(hg024 =1)|(jg024=1))
 then adl_e_core = 0  ;if ((g2755=5)|(hg024 =5)|(jg024=5))
 then adl_e_core = .  ;if ((g2755=8)|(hg024 =8)|(jg024=8)|(g2755=9)|(hg024 =9)|(jg024=9))
label adl_e_core "Help Eating"
label define adl_e_core 0 "No" 1 "Yes", mod ;ify
label values adl_e_core adl_e_core
tab adl_e_core, missing 
Cross-Wave Equivalents for:
G024 ADL EAT HELP 
1995 Core D1907 
1996 Core E1931 
1998 Core F2457 
2000 Core G2755 
2002 Core HG024 
2002 Exit SG024 
2004 Core JG024 
2004 Exit TG024 
2006 Core KG024 
2006 Exit UG024 
2008 Core LG024 
2008 Exit VG024 

*/
adl_e_core = 0;
if ((g2755=1)|(hg024 =1)|(jg024=1)) then adl_e_core = 1  ;
if ((g2755=5)|(hg024 =5)|(jg024=5)) then adl_e_core = 0  ;
if ((g2755=8)|(hg024 =8)|(jg024=8)|(g2755=9)|(hg024 =9)|(jg024=9)) then adl_e_core = .  ;
*if ((g2752=5)|(hg023 =5)|(jg023=5)) then adl_e_core = 0  ;
label adl_e_core= "Help Eating";



/**Transfers to Bed, g2768 hg029 jg029 

generate adl_tx_core = 0
 then adl_tx_core = 1  ;if ((g2768=1)|(hg029 =1)|(jg029=1))
 then adl_tx_core = 0  ;if ((g2768=5)|(hg029 =5)|(jg029=5))
 then adl_tx_core = .  ;if ((g2768=8)|(hg029 =8)|(jg029=8)|(g2768=9)|(hg029 =9)|(jg029=9))
label adl_tx_core "Help with Transfers to Bed"
label define adl_tx_core 0 "No" 1 "Yes", mod ;ify
label values adl_tx_core adl_tx_core
tab adl_tx_core, missing 
*/
adl_tx_core = 0;
if ((g2768=1)|(hg029 =1)|(jg029=1)) then adl_tx_core = 1  ;
if ((g2768=5)|(hg029 =5)|(jg029=5)) then adl_tx_core = 0  ;
if ((g2768=8)|(hg029 =8)|(jg029=8)|(g2768=9)|(hg029 =9)|(jg029=9)) then adl_tx_core = .  ;
*if ((g2762=5)|(hg025 =5)|(jg025=5)) then adl_tx_core = 0  ;
label adl_tx_core= "Help with Transfers to Bed";




/**Toileting, g2778 hg031 jg031 

generate adl_t_core = 0
 then adl_t_core = 1  ;if ((g2778=1)|(hg031 =1)|(jg031=1))
 then adl_t_core = 0  ;if ((g2778=5)|(hg031 =5)|(jg031=5))
 then adl_t_core = .  ;if ((g2778=8)|(hg031 =8)|(jg031=8)|(g2778=9)|(hg031 =9)|(jg031=9))
label adl_t_core "Help Toileting"
label define adl_t_core 0 "No" 1 "Yes", mod ;ify
label values adl_t_core adl_t_core
tab adl_t_core, missing 
*/
adl_t_core = 0;
if ((g2778=1)|(hg031 =1)|(jg031=1)) then adl_t_core = 1  ;
if ((g2778=5)|(hg031 =5)|(jg031=5)) then adl_t_core = 0  ;
if ((g2778=8)|(hg031 =8)|(jg031=8)|(g2778=9)|(hg031 =9)|(jg031=9)) then adl_t_core = .  ;
*if ((g2775=5)|(hg030 =5)|(jg030=5)) then adl_t_core = 0  ;
label adl_t_core= "Help Toileting";



/** Index of ADLs: First step is a simple count
** Then the index is divided by categoies: 
** independent (0 ADL deficiencies), partial dependence (1-3 ),
** severe dependence (>=4).

generate adl_index_core = .
 then adl_index_core = adl_dr_core + adl_wk_core + adl_bh_core + adl_e_core + adl_tx_core + adl_t_core
label adl_index_core "Index of ADLs"
tab adl_index_core, missing 
*/
adl_index_core = .;
adl_index_core = adl_dr_core + adl_wk_core + adl_bh_core + adl_e_core + adl_tx_core + adl_t_core;
label adl_index_core= "Index of ADLs";

 adl_cat_core = .;
if (adl_index_core =0) then adl_cat_core = 0  ;
if (0<adl_index_core<=3) then adl_cat_core = 1  ;
if (3<adl_index_core<=6) then adl_cat_core = 2  ;
label adl_cat_core ="ADLs, Categorical";
format adl_cat_core adl_cat_core.;


**Create dummy variables for ADL Categories;
adl_independent_core = .;
if (adl_cat_core=0) then adl_independent_core = 1  ;
if ((adl_cat_core = 1)| (adl_cat_core = 2)) then adl_independent_core = 0  ;
label adl_independent_core= "Independent for ADLs";


adl_partial_core = .;
if (adl_cat_core=1) then adl_partial_core = 1  ;
if ((adl_cat_core = 0)| (adl_cat_core = 2)) then adl_partial_core = 0  ;
label adl_partial_core= "Partial Dependence for ADLs";

adl_severe_core = .;
if (adl_cat_core=2) then adl_severe_core= 1  ;
if ((adl_cat_core = 0)| (adl_cat_core = 1)) then adl_severe_core = 0  ;
label adl_severe_core ="Severe Dependence for ADLs";

/* iadl
** IADLs

**Meal Prep, r2002 

generate iadl_mp = .
replace iadl_mp = 1 if ((sg043==1)|(tg043==1)|(ug043==1)|(sg043==6)|(tg043==6)|(ug043==6)|(sg043==7)|(tg043==7)|(ug043==7))
replace iadl_mp = 0 if ((sg043==5)|(tg043==5)|(ug043==5))
replace iadl_mp = . if ((sg043==8)|(tg043==8)|(ug043==8)|(sg043==9)|(tg043==9)|(ug043==9))
replace iadl_mp=1 if adl_bedbound==1
label variable iadl_mp  "Help with Meal Prep"
label define iadl_mp 0 "No" 1 "Yes", modify
label values iadl_mp iadl_mp 
tab iadl_mp, missing  

**Grocery Shopping, r2012

generate iadl_gr = .
replace iadl_gr = 1 if ((sg046==1)|(tg046==1)|(ug046==1)|(sg046==6)|(tg046==6)|(ug046==6)|(sg046==7)|(tg046==7)|(ug046==7))
replace iadl_gr = 0 if ((sg046==5)|(tg046==5)|(ug046==5))
replace iadl_gr = . if ((sg046==8)|(tg046==8)|(ug046==8)|(sg046==9)|(tg046==9)|(ug046==9))
replace iadl_gr=1 if adl_bedbound==1
label variable iadl_gr  "Help with Grocery Shopping"
label define iadl_gr 0 "No" 1 "Yes", modify
label values iadl_gr iadl_gr 
tab iadl_gr, missing  

**Phone Calls, r2022

generate iadl_ph = .
replace iadl_ph = 1 if ((sg049==1)|(tg049==1)|(ug049==1)|(sg049==6)|(tg049==6)|(ug049==6)|(sg049==7)|(tg049==7)|(ug049==7))
replace iadl_ph = 0 if ((sg049==5)|(tg049==5)|(ug049==5))
replace iadl_ph = . if ((sg049==8)|(tg049==8)|(ug049==8)|(sg049==9)|(tg049==9)|(ug049==9))
replace iadl_ph=1 if adl_bedbound==1
label variable iadl_ph  "Help with Phone Calls"
label define iadl_ph 0 "No" 1 "Yes", modify
label values iadl_ph iadl_ph 
tab iadl_ph, missing  

**Medications, r2032

generate iadl_rx = .
replace iadl_rx = 1 if ((sg053==1)|(tg053==1)|(ug053==1)|(sg053==6)|(tg053==6)|(ug053==6)|(sg053==7)|(tg053==7)|(ug053==7))
replace iadl_rx = 0 if ((sg053==5)|(tg053==5)|(ug053==5))
replace iadl_rx = . if ((sg053==8)|(tg053==8)|(ug053==8)|(sg053==9)|(tg053==9)|(ug053==9))
replace iadl_rx=1 if adl_bedbound==1
label variable iadl_rx  "Help with Medications"
label define iadl_rx 0 "No" 1 "Yes", modify
label values iadl_rx iadl_rx 
tab iadl_rx, missing 

**Money, r2077

generate iadl_m = .
replace iadl_m = 1 if ((sg061==1)|(tg061==1)|(ug061==1)|(sg061==6)|(tg061==6)|(ug061==6)|(sg061==7)|(tg061==7)|(ug061==7))
replace iadl_m = 0 if ((sg061==5)|(tg061==5)|(ug061==5))
replace iadl_m = . if ((sg061==8)|(tg061==8)|(ug061==8)|(sg061==9)|(tg061==9)|(ug061==9))
replace iadl_m=1 if adl_bedbound==1
label variable iadl_m  "Help with Money"
label define iadl_m 0 "No" 1 "Yes", modify
label values iadl_m iadl_m 
tab iadl_m, missing 

** Index of IADLs: First step is a simple count
** Then the index is divided by categoies: 
** independent (0 IADL deficiencies), partial dependence (1-3 ),
** severe dependence (>4).

generate iadl_ind = .
replace iadl_ind = iadl_mp + iadl_gr + iadl_ph + iadl_rx + iadl_m
label variable iadl_ind "Index of IADLs"
tab iadl_ind, missing 

generate iadl_cat = .
replace iadl_cat = 0 if (iadl_ind ==0)
replace iadl_cat = 1 if (iadl_ind >=1 & iadl_ind<=3)
replace iadl_cat = 2 if (iadl_ind >=4 & iadl_ind<=5)
replace iadl_cat = 3 if ((sg129<94)&(sg129>=85))|((tg129<994)&(tg129>=85))|((ug129<994)&(ug129>=85))
label variable iadl_cat "IADLs, Categorical"
label define iadl_cat 0 "Independent" 1 "Partial Dependence" 2 "Severe Dependence" 3 "Restricted to Bed", modify
label values iadl_cat iadl_cat
tab iadl_cat, missing 

**Create dummy variables for IADL Categories, 'Restricted to bed' defined as '0' in all cases
generate iadl_independent = .
replace iadl_independent = 1 if (iadl_cat==0)
replace iadl_independent = 0 if ((iadl_cat == 1)|(iadl_cat == 2)|(iadl_cat == 3))
label variable iadl_independent "Independent for IADLs"
tab iadl_independent, missing

generate iadl_partial = .
replace iadl_partial = 1 if (iadl_cat==1)
replace iadl_partial = 0 if ((iadl_cat == 0)| (iadl_cat == 2)|(iadl_cat == 3))
label variable iadl_partial "Partial Dependence for IADLs"
tab iadl_partial, missing

generate iadl_severe = .
replace iadl_severe= 1 if (iadl_cat==2)
replace iadl_severe = 0 if ((iadl_cat == 0)| (iadl_cat == 1)|(iadl_cat == 3))
label variable iadl_severe "Severe Dependence for IADLs"
tab iadl_severe, missing


*/


** IADLs

**Meal Prep, r2002 
Cross-Wave Equivalents for:
G043 IADL MEAL PREPARATION HELP 
1995 Core D2024 
1996 Core E2039 
1998 Core F2565 
2000 Core G2863 
2002 Core HG043 
2002 Exit SG043 
2004 Core JG043 
2004 Exit TG043 
2006 Core KG043 
2006 Exit UG043 
2008 Core LG043 
2008 Exit VG043 
generate;
iadl_mp = 0;
if ((G2863=1)|(hg043=1)|(jg043=1)|(G2863=6)|(hg043=6)|(jg043=6)|(G2863=7)|(hg043=7)|(jg043=7)) then iadl_mp = 1 ;
if ((G2863=5)|(hg043=5)|(jg043=5)) then iadl_mp = 0 ;
if ((G2863=8)|(hg043=8)|(jg043=8)|(G2863=9)|(hg043=9)|(jg043=9)) then iadl_mp = . ;
*if ((G2860=5)|(hg041=5)|(jg041=5)) then iadl_mp=0 ;
label iadl_mp=  "Help with Meal Prep";


**Grocery Shopping, r2012
Cross-Wave Equivalents for:
G046 IADL GROC SHOP HELP 
1995 Core D2029 
1996 Core E2044 
1998 Core F2570 
2000 Core G2868 
2002 Core HG046 
2002 Exit SG046 
2004 Core JG046 
2004 Exit TG046 
2006 Core KG046 
2006 Exit UG046 
2008 Core LG046 
2008 Exit VG046 

generate;
iadl_gr = 0;
 if ((G2868=1)|(hg046=1)|(jg046=1)|(G2868=6)|(hg046=6)|(jg046=6)|(G2868=7)|(hg046=7)|(jg046=7)) then iadl_gr = 1 ;
if ((G2868=5)|(hg046=5)|(jg046=5)) then iadl_gr = 0 ;
if ((G2868=8)|(hg046=8)|(jg046=8)|(G2868=9)|(hg046=9)|(jg046=9)) then iadl_gr = . ;
*if ((G2865=5)|(hg044=5)|(jg044=5)) then iadl_gr=0 ;
label iadl_gr  ="Help with Grocery Shopping";


/**Phone Calls, r2022
Cross-Wave Equivalents for:
G049 IADL MAKING PHONE CALLS HELP 
1995 Core D2034 
1996 Core E2049 
1998 Core F2575 
2000 Core G2873 
2002 Core HG049 
2002 Exit SG049 
2004 Core JG049 
2004 Exit TG049 
2006 Core KG049 
2006 Exit UG049 
2008 Core LG049 
2008 Exit VG049 

iadl_ph = .
 then iadl_ph = 1 ;if ((sg049=1)|(tg049=1)|(ug049=1)|(sg049=6)|(tg049=6)|(ug049=6)|(sg049=7)|(tg049=7)|(ug049=7))
 then iadl_ph = 0 ;if ((sg049=5)|(tg049=5)|(ug049=5))
 then iadl_ph = . ;if ((sg049=8)|(tg049=8)|(ug049=8)|(sg049=9)|(tg049=9)|(ug049=9))
 then iadl_ph=1 ;if adl_bedbound=1
label iadl_ph  "Help with Phone Calls"
label define iadl_ph 0 "No" 1 "Yes", mod;ify
label values iadl_ph iadl_ph 
tab iadl_ph, missing  
*/
iadl_ph = 0;
if ((G2873=1)|(hg049=1)|(jg049=1)|(G2873=6)|(hg049=6)|(jg049=6)|(G2873=7)|(hg049=7)|(jg049=7)) then iadl_ph = 1 ;
if ((G2873=5)|(hg049=5)|(jg049=5)) then iadl_ph = 0 ;
if ((G2873=8)|(hg049=8)|(jg049=8)|(G2873=9)|(hg049=9)|(jg049=9)) then iadl_ph = . ;
*if ((G2870=5)|(hg047=5)|(jg047=5)) then iadl_ph=0 ;*if adl_bedbound=1 then iadl_ph=1 ;
label iadl_ph = "Help with Phone Calls";


/**Medications, r2032
Cross-Wave Equivalents for:
G053 IADL TAKING MEDICATIONS HELP 
1995 Core D2039 
1996 Core E2054 
1998 Core F2580 
2000 Core G2878 
2002 Core HG053 
2002 Exit SG053 
2004 Core JG053 
2004 Exit TG053 
2006 Core KG053 
2006 Exit UG053 
2008 Core LG053 
2008 Exit VG053 

generate iadl_rx = .
 then iadl_rx = 1 ;if ((sg053=1)|(tg053=1)|(ug053=1)|(sg053=6)|(tg053=6)|(ug053=6)|(sg053=7)|(tg053=7)|(ug053=7))
 then iadl_rx = 0 ;if ((sg053=5)|(tg053=5)|(ug053=5))
 then iadl_rx = . ;if ((sg053=8)|(tg053=8)|(ug053=8)|(sg053=9)|(tg053=9)|(ug053=9))
 then iadl_rx=1 ;if adl_bedbound=1
label iadl_rx  "Help with Medications"
label define iadl_rx 0 "No" 1 "Yes", mod;ify
label values iadl_rx iadl_rx 
tab iadl_rx, missing 
*/
iadl_rx = 0;
if ((G2878=1)|(hg053=1)|(jg053=1)|(G2878=6)|(hg053=6)|(jg053=6)|(G2878=7)|(hg053=7)|(jg053=7)) then iadl_rx = 1 ;
if ((G2878=5)|(hg053=5)|(jg053=5)) then iadl_rx = 0 ;
if ((G2878=8)|(hg053=8)|(jg053=8)|(G2878=9)|(hg053=9)|(jg053=9)) then iadl_rx = . ;
*if ((G2876=5)|(hg051=5)|(jg051=5)) then iadl_rx=0 ;*if adl_bedbound=1 then iadl_rx=1 ;
label iadl_rx = "Help with Medications";

/**Money, r2077
Cross-Wave Equivalents for:
G061 IADL MANAGING MONEY HELP 
1995 Core D2102 
1996 Core E2096 
1998 Core F2620 
2000 Core G2918 
2002 Core HG061 
2002 Exit SG061 
2004 Core JG061 
2004 Exit TG061 
2006 Core KG061 
2006 Exit UG061 
2008 Core LG061 
2008 Exit VG061 
generate iadl_m = .
 then iadl_m = 1 ;if ((sg061=1)|(tg061=1)|(ug061=1)|(sg061=6)|(tg061=6)|(ug061=6)|(sg061=7)|(tg061=7)|(ug061=7))
 then iadl_m = 0 ;if ((sg061=5)|(tg061=5)|(ug061=5))
 then iadl_m = . ;if ((sg061=8)|(tg061=8)|(ug061=8)|(sg061=9)|(tg061=9)|(ug061=9))
 then iadl_m=1 ;if adl_bedbound=1
label iadl_m  "Help with Money"
label define iadl_m 0 "No" 1 "Yes", mod;ify
label values iadl_m iadl_m 
tab iadl_m, missing 
*/
iadl_m = 0;
if ((G2918=1)|(hg061=1)|(jg061=1)|(G2918=6)|(hg061=6)|(jg061=6)|(G2918=7)|(hg061=7)|(jg061=7)) then iadl_m = 1 ;
if ((G2918=5)|(hg061=5)|(jg061=5)) then iadl_m = 0 ;
if ((G2918=8)|(hg061=8)|(jg061=8)|(G2918=9)|(hg061=9)|(jg061=9)) then iadl_m = . ;
*if ((G2916=5)|(hg059=5)|(jg059=5)) then iadl_m=0 ;*if adl_bedbound=1 then iadl_m=1 ;
label iadl_m = "Help with Money";


/*
** Index of IADLs: First step is a simple count
** Then the index is divided by categoies: 
** independent (0 IADL deficiencies), partial dependence (1-3 ),
** severe dependence (>4).

generate iadl_ind = .
 then iadl_ind = iadl_mp + iadl_gr + iadl_ph + iadl_rx + iadl_m
label iadl_ind "Index of IADLs"
tab iadl_ind, missing 

generate iadl_cat = .
 then iadl_cat = 0 ;if (iadl_ind =0)
 then iadl_cat = 1 ;if (iadl_ind >=1 & iadl_ind<=3)
 then iadl_cat = 2 ;if (iadl_ind >=4 & iadl_ind<=5)
 then iadl_cat = 3 ;if ((sg129<94)&(sg129>=85))|((tg129<994)&(tg129>=85))|((ug129<994)&(ug129>=85))
label iadl_cat "IADLs, Categorical"
label define iadl_cat 0 "Independent" 1 "Partial Dependence" 2 "Severe Dependence" 3 "Restricted to Bed", mod;ify
label values iadl_cat iadl_cat
tab iadl_cat, missing 

**Create dummy variables for IADL Categories, 'Restricted to bed' defined as '0' in all cases
generate iadl_independent = .
 then iadl_independent = 1 ;if (iadl_cat=0)
 then iadl_independent = 0 ;if ((iadl_cat = 1)|(iadl_cat = 2)|(iadl_cat = 3))
label iadl_independent "Independent for IADLs"
tab iadl_independent, missing

generate iadl_partial = .
 then iadl_partial = 1 ;if (iadl_cat=1)
 then iadl_partial = 0 ;if ((iadl_cat = 0)| (iadl_cat = 2)|(iadl_cat = 3))
label iadl_partial "Partial Dependence for IADLs"
tab iadl_partial, missing

generate iadl_severe = .
 then iadl_severe= 1 ;if (iadl_cat=2)
 then iadl_severe = 0 ;if ((iadl_cat = 0)| (iadl_cat = 1)|(iadl_cat = 3))
label iadl_severe "Severe Dependence for IADLs"
tab iadl_severe, missing
*/

iadl_ind = .;
iadl_ind = iadl_mp + iadl_gr + iadl_ph + iadl_rx + iadl_m;
label iadl_ind ="Index of IADLs";
 

 iadl_cat = .;
if (iadl_ind =0) then iadl_cat = 0 ;
if (iadl_ind >=1 & iadl_ind<=3) then iadl_cat = 1 ;
if (iadl_ind >=4 & iadl_ind<=5) then iadl_cat = 2 ;
/*Cross-Wave Equivalents for:
G129 NUMBER DAYS IN BED 
1995 Core N/A 
1996 Core N/A 
1998 Core N/A 
2000 Core N/A 
2002 Core N/A 
2002 Exit SG129 
2004 Core N/A 
2004 Exit TG129 
2006 Core N/A 
2006 Exit UG129 
2008 Core N/A 
2008 Exit VG129 

if ((sg129<94)&(sg129>=85))|((tg129<94)&(tg129>=85))|((ug129<94)&(ug129>=85)) then iadl_cat = 3 ;
*/
label iadl_cat ="IADLs, Categorical";

format iadl_cat iadl_cat.;


 iadl_independent = .;
 if (iadl_cat=0) then iadl_independent = 1 ;
 if ((iadl_cat = 1)|(iadl_cat = 2)|(iadl_cat = 3)) then iadl_independent = 0 ;
label iadl_independent ="Independent for IADLs";
;

; iadl_partial = .;
if (iadl_cat=1) then iadl_partial = 1 ;
if ((iadl_cat = 0)| (iadl_cat = 2)|(iadl_cat = 3)) then iadl_partial = 0 ;
label iadl_partial ="Partial Dependence for IADLs";
;

 iadl_severe = .;
if (iadl_cat=2) then iadl_severe= 1 ;
if ((iadl_cat = 0)| (iadl_cat = 1)|(iadl_cat = 3)) then iadl_severe = 0 ;
label iadl_severe ="Severe Dependence for IADLs";

/*
Cross-Wave Equivalents for:
C018 CANCER OF ANY KIND EXCLUDING SKIN 
1995 Core D801 
1996 Core E801 
1998 Core F1129 
2000 Core G1262 
2002 Core HC018 
2002 Exit SC018 
2004 Core JC018 
2004 Exit TC018 
2006 Core KC018 
2006 Exit UC018 
2008 Core LC018 
2008 Exit VC018 
*/




/**Cancer, r1174
Cross-Wave Equivalents for:
C018 CANCER OF ANY KIND EXCLUDING SKIN 
1995 Core D801 
1996 Core E801 
1998 Core F1129 
2000 Core G1262 
2002 Core HC018 
2002 Exit SC018 
2004 Core JC018 
2004 Exit TC018 
2006 Core KC018 
2006 Exit UC018 
2008 Core LC018 
2008 Exit VC018
generate cancer_hrs = .
 then cancer_hrs = 1 ; if ((sc018=1)|(tc018=1)|(uc018=1)|(sc018=3)|(tc018=3)|(uc018=3))
 then cancer_hrs = 0 ; if ((sc018=5)|(tc018=5)|(uc018=5)|(sc018=4)|(tc018=4)|(uc018=4))
label cancer_hrs "Cancer"
label define cancer_hrs 0 "No" 1 "Yes" 9 "Don't Know/Refused", mod; ify
label values cancer_hrs cancer_hrs
tab cancer_hrs, missing 
*/
cancer_hrs = .;
if ((G1262=1)|(hc018=1)|(jc018=1)|(G1262=3)|(hc018=3)|(jc018=3)) then cancer_hrs = 1 ; 
if ((G1262=5)|(hc018=5)|(jc018=5)|(G1262=4)|(hc018=4)|(jc018=4)) then cancer_hrs = 0 ; 
label cancer_hrs= "Cancer";


/**Lung Disease, r1191
Cross-Wave Equivalents for:
C030 LUNG DISEASE 
1995 Core D818 
1996 Core E818 
1998 Core F1146 
2000 Core G1279 
2002 Core HC030 
2002 Exit SC030 
2004 Core JC030 
2004 Exit TC030 
2006 Core KC030 
2006 Exit UC030 
2008 Core LC030 
2008 Exit VC030 

generate lung_hrs = .
 then lung_hrs = 1 ; if ((sc030=1)|(tc030=1)|(uc030=1)|(sc030=3)|(tc030=3)|(uc030=3))
 then lung_hrs = 0 ; if ((sc030=5)|(tc030=5)|(uc030=5)|(sc030=4)|(tc030=4)|(uc030=4))
label lung_hrs "Lung Disease"
*/
lung_hrs = .;
 if ((G1279=1)|(hc030=1)|(jc030=1)|(G1279=3)|(hc030=3)|(jc030=3)) then lung_hrs = 1 ;
if ((G1279=5)|(hc030=5)|(jc030=5)|(G1279=4)|(hc030=4)|(jc030=4)) then lung_hrs = 0 ; 
label lung_hrs ="Lung Disease";


/**Heart Condition: "heart attack, coronary heart disease, angina, congestive heart failure, or other heart problems?", r1201
Cross-Wave Equivalents for:
C036 HEART CONDITION 
1995 Core D828 
1996 Core E828 
1998 Core F1156 
2000 Core G1289 
2002 Core HC036 
2002 Exit SC036 
2004 Core JC036 
2004 Exit TC036 
2006 Core KC036 
2006 Exit UC036 
2008 Core LC036 
2008 Exit VC036 
generate heart_hrs = .
 then heart_hrs = 1 ; if ((sc036=1)|(tc036=1)|(uc036=1)|(sc036=3)|(tc036=3)|(uc036=3))
 then heart_hrs = 0 ; if ((sc036=5)|(tc036=5)|(uc036=5)|(sc036=4)|(tc036=4)|(uc036=4))
label heart_hrs "Heart Condition"
*/
heart_hrs = .;
if ((G1289=1)|(hc036=1)|(jc036=1)|(G1289=3)|(hc036=3)|(jc036=3)) then heart_hrs = 1 ; 
if ((G1289=5)|(hc036=5)|(jc036=5)|(G1289=4)|(hc036=4)|(jc036=4)) then heart_hrs = 0 ; 
label heart_hrs= "Heart Condition";





/**CHF: Only asked of those who said "YES" to Heart Condition, so those who said "NO" are coded "0" here. r1216
Cross-Wave Equivalents for:
C048 CONGESTIVE HEART FAILURE 
1995 Core D843 
1996 Core E843 
1998 Core F1171 
2000 Core G1304 
2002 Core HC048 
2002 Exit SC048 
2004 Core JC048 
2004 Exit TC048 
2006 Core KC048 
2006 Exit UC048 
2008 Core LC048 
2008 Exit VC048 

generate chf_hrs = .
 then chf_hrs = 1 ; if ((sc048=1)|(tc048=1)|(uc048=1)|(sc048=3)|(tc048=3)|(uc048=3))
 then chf_hrs = 0 ; if ((sc048=5)|(tc048=5)|(uc048=5)|(sc048=4)|(tc048=4)|(uc048=4)|(heart=0))
label chf_hrs "CHF"
label define chf_hrs 0 "No" 1 "Yes" 9 "Don't Know/Refused", mod; ify
label values chf_hrs chf_hrs
tab chf_hrs, missing

for year 2000-2004,if chf=inapplication,then put chf=0,but it won't be for year 2006-2008,

            576         1. YES
           3270         5. NO
             12         8. DK (don't know); NA (not ascertained)
                        9. RF (refused)
          15722     Blank. INAP (Inapplicable); [Q1289:B7] IS (NE 1 AND NE 3); [Q1290:B7a]
                           IS (5) AND [Q1291:B7b] IS (5)


*/
 chf_hrs = 0;
if ((G1304=1)|(hc048=1)|(jc048=1)|(G1304=3)|(hc048=3)|(jc048=3)) then chf_hrs = 1 ; 
if ((G1304=5)|(hc048=5)|(jc048=5)|(G1304=4)|(hc048=4)|(jc048=4)|(heart_hrs=0)) then chf_hrs = 0 ; 
if ((G1304=8)|(hc048=8)|(jc048=8)|(G1304=9)|(hc048=9)|(jc048=9)) then chf_hrs = . ; 
label chf_hrs= "CHF";


/**Stroke, missing r1221

generate stroke_hrs = .
 then stroke_hrs = 1 ; if ((sc053=1)|(tc053=1)|(uc053=1)|(sc053=3)|(tc053=3)|(uc053=3))
 then stroke_hrs = 0 ; if ((sc053=5)|(tc053=5)|(uc053=5)|(sc053=4)|(tc053=4)|(uc053=4))
label stroke_hrs "Stroke"
Cross-Wave Equivalents for:
C053 STROKE 
1995 Core D848 
1996 Core E848 
1998 Core F1176 
2000 Core G1309 
2002 Core HC053 
2002 Exit SC053 
2004 Core JC053 
2004 Exit TC053 
2006 Core KC053 
2006 Exit UC053 
2008 Core LC053 
2008 Exit VC053 

*/
stroke_hrs = .;
 if ((G1309=1)|(hc053=1)|(jc053=1)|(G1309=2)|(hc053=2)|(jc053=2)|(G1309=3)|(hc053=3)|(jc053=3)) then stroke_hrs = 1 ;
if ((G1309=5)|(hc053=5)|(jc053=5)|(G1309=4)|(hc053=4)|(jc053=4)) then stroke_hrs = 0 ; 
label stroke_hrs ="Stroke,TIA";

/**Memory Disease (diagnosed by a doctor, per the proxy report) r1240

generate memory_hrs = .
 then memory_hrs = 1 ; if ((sc069=1)|(tc069=1)|(uc069=1)|(sc069=3)|(tc069=3)|(uc069=3))
 then memory_hrs = 0 ; if ((sc069=5)|(tc069=5)|(uc069=5)|(sc069=4)|(tc069=4)|(uc069=4))
label memory_hrs "Memory Disease"
Cross-Wave Equivalents for:
C069 MEMORY RELATED DISEASE 
1995 Core N/A 
1996 Core N/A 
1998 Core F1193 
2000 Core G1326 
2002 Core HC069 
2002 Exit SC069 
2004 Core JC069 
2004 Exit TC069 
2006 Core KC069 
2006 Exit UC069 
2008 Core LC069 
2008 Exit VC069 


Cross-Wave Equivalents for:
Z117 PREV WAVE R HAS MEMORY DISEASE 
1995 Core N/A 
1996 Core N/A 
1998 Core N/A 
2000 Core N/A 
2002 Core HZ117 
2002 Exit SZ117 
2004 Core JZ117 
2004 Exit TZ117 
2006 Core KZ117 
2006 Exit UZ117 
2008 Core LZ117 
2008 Exit VZ117 

memory,jc069,jz117,if jz117 then memory_hrs=1, which means they will be dis application in jc069

*/
memory_hrs = .;
 if ((G1326=1)|(hc069=1)|(jc069=1)|(G1326=3)|(hc069=3)|(jc069=3)) then memory_hrs = 1 ;
  if ((HZ117=1)|(JZ117=1)) then memory_hrs = 1 ;
if ((G1326=5)|(hc069=5)|(jc069=5)|(G1326=4)|(hc069=4)|(jc069=4)) then memory_hrs = 0 ; 
label memory_hrs ="Memory Disease";


/** Falls r1230

generate falls_hrs = .
 then falls_hrs = 1 ; if ((sc079=1)|(tc079=1)|(uc079=1)|(sc079=3)|(tc079=3)|(uc079=3))
 then falls_hrs = 0 ; if ((sc079=5)|(tc079=5)|(uc079=5)|(sc079=4)|(tc079=4)|(uc079=4))
label falls_hrs "Falls"
Cross-Wave Equivalents for:
C079 FALLEN IN PAST TWO YEARS 
1995 Core D878 
1996 Core E878 
1998 Core F1206 
2000 Core G1339 
2002 Core HC079 
2002 Exit SC079 
2004 Core JC079 
2004 Exit TC079 
2006 Core KC079 
2006 Exit UC079 
2008 Core LC079 
2008 Exit VC079 

*/
falls_hrs = .;
 if ((G1339=1)|(hc079=1)|(jc079=1)|(G1339=3)|(hc079=3)|(jc079=3)) then falls_hrs = 1 ;
 if ((G1339=5)|(hc079=5)|(jc079=5)|(G1339=4)|(hc079=4)|(jc079=4)) then falls_hrs = 0 ;

label falls_hrs ="Falls";


/** Incontinence

Cross-Wave Equivalents for:
Cross-Wave Equivalents for:
C087 INCONTINENCE 
1995 Core D892 
1996 Core E892 
1998 Core F1220 
2000 Core G1353 
2002 Core HC087 
2002 Exit N/A 
2004 Core JC087 
2004 Exit N/A 
2006 Core KC087 
2006 Exit N/A 
2008 Core LC087 
2008 Exit N/A 


generate incont_hrs = .
 then incont_hrs = 1 ; if ((sc208=1)|(tc208=1)|(uc208=1)|(sc208=3)|(tc208=3)|(uc208=3))
 then incont_hrs = 0 ; if ((sc208=5)|(tc208=5)|(uc208=5)|(sc208=4)|(tc208=4)|(uc208=4))
label incont_hrs "Incontinence"
*/
incont_hrs = .;
if ((G1353=1)|(HC087=1)|(JC087=1)|(G1353=3)|(HC087=3)|(JC087=3)) then incont_hrs = 1 ; 
if ((G1353=5)|(HC087=5)|(JC087=5)|(G1353=4)|(HC087=4)|(JC087=4)) then incont_hrs = 0 ; 
label incont_hrs="Incontinence";


/** Pain r1246

generate pain_hrs = .
 then pain_hrs = 1 ; if ((sc104=1)|(tc104=1)|(uc104=1)|(sc104=3)|(tc104=3)|(uc104=3))
 then pain_hrs = 0 ; if ((sc104=5)|(tc104=5)|(uc104=5)|(sc104=4)|(tc104=4)|(uc104=4))
label pain_hrs "Pain"
Cross-Wave Equivalents for:
C104 TROUBLED WITH PAIN 
1995 Core D911 
1996 Core E911 
1998 Core F1239 
2000 Core G1372 
2002 Core HC104 
2002 Exit SC104 
2004 Core JC104 
2004 Exit TC104 
2006 Core KC104 
2006 Exit UC104 
2008 Core LC104 
2008 Exit VC104 

*/
pain_hrs = .;
 if ((G1372=1)|(hc104=1)|(jc104=1)|(G1372=3)|(hc104=3)|(jc104=3)) then pain_hrs = 1 ;
 if ((G1372=5)|(hc104=5)|(jc104=5)|(G1372=4)|(hc104=4)|(jc104=4)) then pain_hrs = 0 ;
label pain_hrs ="Pain";

 

/** HTN
Cross-Wave Equivalents for:
C005 HIGH BLOOD PRESSURE 
1995 Core D781 
1996 Core E781 
1998 Core F1109 
2000 Core G1238 
2002 Core HC005 
2002 Exit N/A 
2004 Core JC005 
2004 Exit N/A 
2006 Core KC005 
2006 Exit N/A 
2008 Core LC005 
2008 Exit N/A 

generate htn_hrs = .
 then htn_hrs = 1 ; if ((sz101=1)|(tz101=1)|(uz101=1))
 then htn_hrs = 0 ; if ((sz101=5)|(tz101=5)|(uz101=5))
label htn_hrs "Hypertension"
*/
htn_hrs = .;
 if ((G1238=1)|(HC005=1)|(JC005=1)|(G1238=3)|(HC005=3)|(JC005=3)) then htn_hrs = 1 ;
 if ((G1238=4)|(HC005=4)|(JC005=4)|(G1238=5)|(HC005=5)|(JC005=5)) then htn_hrs = 0 ;
label htn_hrs ="Hypertension";

/** Diabetes

generate dm_hrs = .
 then dm_hrs = 1 ; if ((sz102=1)|(tz102=1)|(uz102=1))
 then dm_hrs = 0 ; if ((sz102=5)|(tz102=5)|(uz102=5))
label dm_hrs "Diabetes"
Cross-Wave Equivalents for:
C010 DIABETES 
1995 Core D788 
1996 Core E788 
1998 Core F1116 
2000 Core G1245 
2002 Core HC010 
2002 Exit N/A 
2004 Core JC010 
2004 Exit N/A 
2006 Core KC010 
2006 Exit N/A 
2008 Core LC010 
2008 Exit N/A 


*/
 dm_hrs = .;
 if ((G1245 =1)|(HC010=1)|(JC010=1)|(G1245 =3)|(HC010=3)|(JC010=3)) then dm_hrs = 1 ;
 if ((G1245 =4)|(HC010=4)|(JC010=4)|(G1245 =5)|(HC010=5)|(JC010=5)) then dm_hrs = 0 ; 
label dm_hrs ="Diabetes";



/** Psychiatric Condition ("doctor ever told... emotional, nervous or psychiatric problems?")

generate psych_hrs = .
 then psych_hrs = 1 ; if ((sz107=1)|(tz107=1)|(uz107=1))
 then psych_hrs = 0 ; if ((sz107=5)|(tz107=5)|(uz107=5))
label psych_hrs "Psychiatric Condition"
Cross-Wave Equivalents for:
C065 EMOTIONAL/PSYCHIATRIC PROBLEMS 
1995 Core D861 
1996 Core E861 
1998 Core F1189 
2000 Core G1322 
2002 Core HC065 
2002 Exit N/A 
2004 Core JC065 
2004 Exit N/A 
2006 Core KC065 
2006 Exit N/A 
2008 Core LC065 
2008 Exit N/A 


*/
psych_hrs = .;
if ((G1322 =1)|(HC065=1)|(JC065=1)|(G1322 =3)|(HC065=3)|(JC065=3)) then psych_hrs = 1 ; 
if ((G1322 =4)|(HC065=4)|(JC065=4)|(G1322 =5)|(HC065=5)|(JC065=5)) then psych_hrs = 0 ; 
label psych_hrs= "Psychiatric Condition";
 

/** Arthritis

generate arth_hrs = .
 then arth_hrs = 1 ; if ((sz108=1)|(tz108=1)|(uz108=1))
 then arth_hrs = 0 ; if ((sz108=5)|(tz108=5)|(uz108=5))
label arth_hrs "Arthritis"
C070 ARTHRITIS 
1995 Core D866 
1996 Core E866 
1998 Core F1194 
2000 Core G1327 
2002 Core HC070 
2002 Exit N/A 
2004 Core JC070 
2004 Exit N/A 
2006 Core KC070 
2006 Exit N/A 
2008 Core LC070 
2008 Exit N/A 


*/
arth_hrs = .;
if ((G1327=3)|(HC070=3)|(JC070=3)|(G1327=1)|(HC070=1)|(JC070=1)) then arth_hrs = 1 ; 
if ((G1327=4)|(HC070=4)|(JC070=4)|(G1327=5)|(HC070=5)|(JC070=5)) then arth_hrs = 0 ; 
label arth_hrs ="Arthritis";


/** Index of Comorbidities: First step is a simple count
** Then the index is divided by categoies: 
** None (0), Mild (1-3), Moderate (4-6), Severe (>7).

generate comor_in_hrs = .
 then comor_in_hrs = (cancer_hrs + lung_hrs + heart_hrs + chf_hrs + stroke_hrs + memory_hrs + htn_hrs + dm_hrs + psych_hrs)
label comor_in_hrs "Index of Comorbidities"
tab comor_in_hrs, missing  
 
generate comor_c_hrs = .
 then comor_c_hrs = 0 ; if (comor_in_hrs =0)
 then comor_c_hrs = 1 ; if (comor_in_hrs >=1 & comor_in_hrs<=3)
 then comor_c_hrs = 2 ; if (comor_in_hrs >=4 & comor_in_hrs<=6)
 then comor_c_hrs = 3 ; if (comor_in_hrs >=7 & comor_in_hrs<=13)
label comor_c_hrs "Comorbidity Index, Categorical"
label define comor_c_hrs 0 "None (0)" 1 "Mild (1-3)" 2 "Moderate (4-6)" 3 "Severe (>7)", mod; ify
label values comor_c_hrs comor_c_hrs
tab comor_c_hrs, missing 
*/

comor_in_hrs = .;
comor_in_hrs = (cancer_hrs + lung_hrs + heart_hrs + chf_hrs + stroke_hrs + memory_hrs + htn_hrs + dm_hrs + psych_hrs);
label comor_in_hrs= "Index of Comorbidities";
 
 
comor_c_hrs = .;
if (comor_in_hrs =0) then comor_c_hrs = 0 ; 
 if (comor_in_hrs >=1 & comor_in_hrs<=3) then comor_c_hrs = 1 ;
if (comor_in_hrs >=4 & comor_in_hrs<=6) then comor_c_hrs = 2 ; 
if (comor_in_hrs >=7 & comor_in_hrs<=13) then comor_c_hrs = 3 ; 
label comor_c_hrs= "Comorbidity Index, Categorical";
format comor_c_hrs comor_c_hrs.;

/*******************************************************************************************
** Core Interview (up to 2 yr before death) included a measure of self rated health,
so there is not need to seek concordance
*******************************************************************************************/

/**Self Rated Health "Don't Know/Refused" (only 2 cases) included with missing 
Cross-Wave Equivalents for:
C001 RATE HEALTH 
1995 Core D769 
1996 Core E769 
1998 Core F1097 
2000 Core G1226 
2002 Core HC001 
2002 Exit N/A 
2004 Core JC001 
2004 Exit N/A 
2006 Core KC001 
2006 Exit N/A 
2008 Core LC001 
2008 Exit N/A 
*/

 srh = .;
if ((g1226=1)|(hc001=1)|(jc001=1)) then srh = 1 ; 
if ((g1226=2)|(hc001=2)|(jc001=2)) then srh = 2 ; 
if ((g1226=3)|(hc001=3)|(jc001=3)) then srh = 3 ; 
if ((g1226=4)|(hc001=4)|(jc001=4)) then srh = 4 ; 
if ((g1226=5)|(hc001=5)|(jc001=5)) then srh = 5 ; 
label srh ="Self Rated Health";
format srh srh.;

** Dummies for 3 categories: Poor/Fair, Good, Very Good /Excellent**
;
srh_pf = .;
if ((srh=1)|(srh=2)|(srh=3)) then srh_pf = 0 ; 
if ((srh=5)|(srh=4)) then srh_pf = 1 ; 
label srh_pf= "Self Rated Health: Poor/Fair";
;
 srh_g = .;
if ((srh=1)|(srh=2)|(srh=4)|(srh=5)) then srh_g = 0 ; 
 if (srh=3) then srh_g = 1 ;
label srh_g ="Self Rated Health: Good";
;
 srh_ve = .;
 if ((srh=3)|(srh=4)|(srh=5))then srh_ve = 0 ; 
if ((srh=1)|(srh=2)) then srh_ve = 1 ; 
label srh_ve ="Self Rated Health: Very Good /Excellent";
run;

proc means;
var networth;
run;
proc freq;
table marital;
run;











*

keep=( hhid pn id merged_year
 proxy_core female marital married marital_sep marital_div marital_wid
marital_nev marital_sd educ networth medicare medicareb medicaid champus hmo medigap nhres
imprelig child gchil allchil reschil reschil_d resspouse hhm friend rel_nb adl_dr_core
adl_wk_core adl_bh_core adl_e_core adl_tx_core adl_t_core adl_index_core adl_cat_core
adl_independent_core adl_partial_core adl_severe_core iadl_mp iadl_gr iadl_ph iadl_rx iadl_m
cancer_hrs lung_hrs heart_hrs chf_hrs stroke_hrs memory_hrs falls_hrs pain_hrs htn_hrs dm_hrs
psych_hrs arth_hrs comor_in_hrs comor_c_hrs srh srh_pf srh_g srh_ve)
;
run;

/*was married/was living with a partner as if married
2000 Core G543 
2002 Core HA020 
2002 Exit SA020 
2004 Core JA020 
2004 Exit TA020 
2006 Core KA020 
2006 Exit UA020 
2008 Core LA020 
2008 Exit VA020 
wo G543,*/

proc freq data=hrs00.core_00_02_04_sub;
table merged_year*(proxy_core female marital married marital_sep marital_div marital_wid
marital_nev marital_sd educ medicare medicareb medicaid champus hmo medigap nhres
imprelig   reschil_d resspouse  friend rel_nb adl_dr_core
adl_wk_core adl_bh_core adl_e_core adl_tx_core adl_t_core adl_index_core adl_cat_core
adl_independent_core adl_partial_core adl_severe_core iadl_mp iadl_gr iadl_ph iadl_rx iadl_m
cancer_hrs lung_hrs heart_hrs chf_hrs stroke_hrs memory_hrs falls_hrs pain_hrs htn_hrs dm_hrs
psych_hrs arth_hrs comor_in_hrs comor_c_hrs srh srh_pf srh_g srh_ve);* ;
run;

proc means data=hrs00.core_00_02_04_sub;
class merged_year;
var networth child gchil allchil reschil hhm;
run;



proc freq data=hrs00.core_00_02_04_sub(where=(merged_year=2002));
table hg059 hg059*hg061;
run;



/*start from year 2006*/



/*the code book is http://hrsonline.isr.umich.edu/index.php?p=showcbk */


%let year=06;

libname HRS "c:\hrs20&year.\sas\";






proc sort data=HRS.H&year.a_r;
by hhid pn ksubhh;

proc sort data=HRS.H&year.b_r;
by hhid pn ksubhh;
proc sort data=HRS.H&year.c_r;
by hhid pn ksubhh;
proc sort data=HRS.H&year.d_r;
by hhid pn ksubhh;
proc sort data=HRS.H&year.f_r;
by hhid pn ksubhh;
proc sort data=HRS.H&year.g_r;
by hhid pn ksubhh;
proc sort data=HRS.H&year.m1_r;
by hhid pn ksubhh;
proc sort data=HRS.H&year.n_r;
by hhid pn ksubhh;
proc sort data=HRS.H&year.pr_r;
by hhid pn ksubhh;
run;


proc sort data=HRS.H&year.a_h;
by hhid ksubhh;
proc sort data=HRS.H&year.e_h;
by hhid ksubhh;
run;

proc sort data=hrs.incwlth&year.f2a;
by hhid pn ksubhh;
run;



data HRS.Core20&year.sub1;
merge hrs.incwlth&year.f2a HRS.H&year.a_r HRS.H&year.b_r HRS.H&year.c_r HRS.H&year.d_r HRS.H&year.f_r HRS.H&year.g_r HRS.H&year.m1_r HRS.H&year.n_r HRS.H&year.pr_r;
by hhid pn;
run;

proc sort data=HRS.Core20&year.sub1;
by hhid ksubhh;
run;
data HRS.Core20&year.;
merge HRS.Core20&year.sub1  HRS.H&year.a_h  HRS.H&year.e_h;
by hhid ksubhh;
run;
*%let data1=HRS.Core20&year.(obs=100);

options compress=yes;
libname hrs00 "C:\hrs2000\sas";
%let data1=HRS.Core20&year.;

data hrs00.core_06_sub(keep=&keep_var_list2);
set &data1;
merged_year=2006;
if h8atotw~=. then networth=h8atotw;
if 0<=KE046<81 and merged_year=2006 then gchil=KE046;
/*Cross-Wave Equivalents for:
N099 OVERNIGHT STAY IN HOSP-SINCE PREV IW/2YR 
1995 Core D1664 
1996 Core E1770 
1998 Core F2295 
2000 Core G2567 
2002 Core HN099 
2002 Exit SN099 
2004 Core JN099 
2004 Exit TN099 
2006 Core KN099 
2006 Exit UN099 
2008 Core LN099 
2008 Exit VN099 
*/
hosp_last_2yr=.;
if KN099=1 then hosp_last_2yr=1;
if KN099=5 then hosp_last_2yr=0;
/*
** Proxy versus self, Core(1=self, 2=spouse, 3=non-spouse)
generate proxy_core = .
replace  proxy_core = 1 if ((g514==2)|(g514==3)|(ha009==2)|(ha009==3)|(ja009==2)|(ja009==3))
replace  proxy_core = 0 if ((g514==1)|(ha009==1)|(ja009==1))
label variable proxy_core "Proxy Respondent for Core Interview"
label define proxy_core 0 "No" 1 "Proxy", modify
label values proxy_core proxy_core
tab proxy_core, missing 
*/

proxy_core = .;
if ((ka009=2)|(ka009=3)) then  proxy_core = 1; 
if ((ka009=1)) then  proxy_core = 0 ;
label  proxy_core= "Proxy Respondent for Core Interview";

*gender,;
female = .;
 if ( (kX060_R=2)) then  female = 1;
if ( (kX060_R=1)) then  female = 0 ;


*age according dob from restricted file and year(core_date),core_date is also in restricted
they are available on amy's computer;

*race and ethnicity is already in restricted data file;

** Marital status r1134
/*
Cross-Wave Equivalents for:
B063 MARITAL STATUS ASSIGNED 
1995 Core N/A 
1996 Core N/A 
1998 Core N/A 
2000 Core N/A 
2002 Core N/A 
2002 Exit N/A 
2004 Core JB063 
2004 Exit TB063 
2006 Core KB063 
2006 Exit UB063 
2008 Core LB063 
2008 Exit VB063 


Cross-Wave Equivalents for:
B061 MARITAL STATUS IF UNMARRIED 
1995 Core N/A 
1996 Core N/A 
1998 Core F1070 
2000 Core G1157 
2002 Core HB061 
2002 Exit SB061 
2004 Core JB061 
2004 Exit TB061 
2006 Core KB061 
2006 Exit UB061 
2008 Core LB061 
2008 Exit VB061 

Cross-Wave Equivalents for:
 
2000 Core G543 
2002 Core HA020 
2002 Exit SA020 
2004 Core JA020 
2004 Exit TA020 
2006 Core KA020 
2006 Exit UA020 
2008 Core LA020 
2008 Exit VA020 

*/
*change sa020(exit) into G543(core);


marital = .;
if ((kb063=1)) then marital = 1 ;
if ( (kb061=3)|(kb063=3)) then marital = 2 ;
if ((kb061=4)|(kb063=4)) then marital = 3 ;
if ( (kb061=5)|(kb063=5)) then marital = 4 ;
if ((kb061=6)|(kb063=6)) then marital = 5 ;
if ((kb061=7)|(kb061=8)|(kb063=7)) then marital = 6 ;
label marital="Marital Status";
format marital marital.;


married = .;
if (marital=1) then married = 1 ;
if (marital>1) then married = 0 ;
label married= "Married";

marital_sep = .;
if (marital=2) then marital_sep = 1 ;
if (marital~=2 & marital ~=.) then marital_sep = 0 ;
label marital_sep= "Separated";

marital_div = .;
if (marital=3) then marital_div = 1 ;
if (marital~=3 & marital ~=.) then marital_div = 0 ;
label marital_div= "Divorced";

marital_wid = .;
if (marital=4) then marital_wid = 1 ;
if (marital~=4 & marital ~=.) then marital_wid = 0 ;
label marital_wid= "Widowed";

marital_nev = .;
if (marital=5) then marital_nev = 1 ;
if (marital~=5 & marital ~=.) then marital_nev = 0 ;
label marital_nev= "Never Married";

marital_sd = .;
if (marital_sep=1 | marital_div=1) then marital_sd  = 1 ;
if (marital_sep=0 & marital_div=0) then marital_sd  = 0 ;
label marital_sd = "Separated or Divorced";
/*
married = .
 then married = 1 ;if (marital=1)
 then married = 0 ;if (marital!=1 & marital <.)
label married "Married"
label define married 1 "Married" 0 "Not Married", mod;ify
label values married married
tab married, missing 

generate marital_sep = .
 then marital_sep = 1 ;if (marital=2)
 then marital_sep = 0 ;if (marital!=2 & marital <.)
label marital_sep "Separated"
label define marital_sep 1 "Separated" 0 "Not Separated", mod;ify
label values marital_sep marital_sep
tab marital_sep, missing 

generate marital_div = .
 then marital_div = 1 ;if (marital=3)
 then marital_div = 0 ;if (marital!=3 & marital <.)
label marital_div "Divorced"
label define marital_div 1 "Divorced" 0 "Not Divorced", mod;ify
label values marital_div marital_div
tab marital_div, missing 

generate marital_wid = .
 then marital_wid = 1 ;if (marital=4)
 then marital_wid = 0 ;if (marital!=4 & marital <.)
label marital_wid "Widowed"
label define marital_wid 1 "Widowed" 0 "Not Widowed", mod;ify
label values marital_wid marital_wid
tab marital_wid, missing 

generate marital_nev = .
 then marital_nev = 1 ;if (marital=5)
 then marital_nev = 0 ;if (marital!=5 & marital <.)
label marital_nev "Never Married"
label define marital_nev 1 "Never Married" 0 "Not Never Married", mod;ify
label values marital_nev marital_nev
tab marital_nev, missing 

generate marital_sd = .
 then marital_sd = 1 ;if (marital_sep=1 | marital_div=1)
 then marital_sd = 0 ;if (marital_sep=0 & marital_div=0)
label marital_sd "Separated or Divorced"
label define marital_sd 1 "Separated or Divorced" 0 "Not Separated or Divorced", mod;ify
label values marital_sd marital_sd
*/


*education,all related variables are already in the dataset,
not found in year 2006,2008,just use the education from year 2004,
use variable educ format educ. ;



/*net worth wait for amy's confirm*/



medicare = .;
if ( (kn001=1)) then medicare= 1 ;
if ( (kn001=5)) then medicare= 0 ;
** r2587
generate; medicareb = .;
 if ( (kn004=1)) then medicareb= 1;
 if ( (kn004=5)) then medicareb= 0;
 if medicare= 0 then medicareb= 0;

** r2588 r2589
generate; medicaid = 0;
if ( (kn005=1)) then medicaid= 1 ;
if ( (kn005=8)) then medicaid= . ;


 champus = 0;
if ((kn007=1)) then champus= 1 ;
if ((kn007=8)) then champus = . ;


** r2601
generate
Cross-Wave Equivalents for:
N009 MEDICARE/MEDICAID HMO 
1995 Core N/A 
1996 Core E5148 
1998 Core F5881 
2000 Core G6254 
2002 Core HN009 
2002 Exit SN009 
2004 Core kn009 
2004 Exit TN009 
2006 Core KN009 
2006 Exit UN009 
2008 Core LN009 
2008 Exit VN009 
; hmo = 0;
if ((kn009=1)) then hmo= 1 ;
if ((kn009=8)) then hmo = . ;


** r2623
generate 
Cross-Wave Equivalents for:
N023 NUM PRIVATE HEALTH INS PLANS 
1995 Core N/A 
1996 Core N/A 
1998 Core N/A 
2000 Core N/A 
2002 Core HN023 
2002 Exit SN023 
2004 Core kn023 
2004 Exit TN023 
2006 Core KN023 
2006 Exit UN023 
2008 Core LN023 
2008 Exit VN023 
;
medigap = .;
if (  (kn023>=1)) then medigap= 1 ;
if ( (kn023=0)) then medigap= 0 ;
if (  (kn023=98)| (kn023=99)) then medigap= . ;

nhres = .;
if ( (ka028=1)) then nhres = 1 ; 
if ((ka028=5)) then nhres = 0 ;
label nhres="Nursing Home Resident";


imprelig = .;
if ((kb053=1)) then imprelig = 1 ;
if ((kb053=3)) then imprelig = 2 ;
if ((kb053=5)) then imprelig = 3 ;
if ((kb053=8)|(kb053=9)) then imprelig = 4 ;
if ((kb053=.)) then imprelig = 4 ;
label imprelig ="Importance of Religion";
format imprelig imprelig.;

child = .;
child = ka101 ;
label child ="Number of Children, not their children's spouses";

allchil = kA113 ;
label allchil= "Total Number of Children, Children-in-law, and Grandchildren";

reschil= kA099  ;
label reschil="Number of Resident Children";

reschil_d = .;
if ((reschil=0) )|(nhres=1) then reschil_d = 0 ;
if ((reschil>0) )&(nhres~=1) then reschil_d = 1 ;
label reschil_d= "Living with Children";

resspouse = .;
if ((ka030=5)|(married=0)) then resspouse = 0 ;
if ((ka030=1)) then resspouse = 1 ;
label resspouse= "Living with Spouse/Partner";

hhm= ka098  ;
label hhm="Number of Household Members";

friend = .;
if ((kf175=5)) then friend = 0 ;
if ((kf175=1)) then friend = 1 ;
label friend= "Good Friends Nearby";

rel_nb = .;
if ((kf174=5)) then rel_nb = 0 ;
if ((kf174=1)) then rel_nb = 1 ;
label rel_nb= "Relatives Nearby";

adl_dr_core = 0;
if ((kg015=1)) then adl_dr_core = 1  ;
if ((kg015=5)) then adl_dr_core = 0  ;
if ((kg015=8)|(kg015=9)) then adl_dr_core = .  ;
*if ((kg014=5)) then adl_dr_core = 0  ;
label adl_dr_core= "Help Dressing";

adl_wk_core = 0;
if ((kg020=1)) then adl_wk_core = 1  ;
if ((kg020=5)) then adl_wk_core = 0  ;
if ((kg020=8)|(kg020=9)) then adl_wk_core = .  ;
*if ((kg016=5)) then adl_wk_core = 0  ;
label adl_wk_core= "Help Walking";

adl_bh_core = 0;
if ((kg022=1)) then adl_bh_core = 1  ;
if ((kg022=5)) then adl_bh_core = 0  ;
if ((kg022=8)|(kg022=9)) then adl_bh_core = .  ;
*if ((kg021=5)) then adl_bh_core = 0  ;
label adl_bh_core= "Help Bathing";


adl_e_core = 0;
if ((kg024=1)) then adl_e_core = 1  ;
if ((kg024=5)) then adl_e_core = 0  ;
if ((kg024=8)|(kg024=9)) then adl_e_core = .  ;
*if ((kg023=5)) then adl_e_core = 0  ;
label adl_e_core= "Help Eating";


adl_tx_core = 0;
if ((kg029=1)) then adl_tx_core = 1  ;
if ((kg029=5)) then adl_tx_core = 0  ;
if ((kg029=8)|(kg029=9)) then adl_tx_core = .  ;
*if ((kg025=5)) then adl_tx_core = 0  ;
label adl_tx_core= "Help with Transfers to Bed";

adl_t_core = 0;
if ((kg031=1)) then adl_t_core = 1  ;
if ((kg031=5)) then adl_t_core = 0  ;
if ((kg031=8)|(kg031=9)) then adl_t_core = .  ;
*if ((kg030=5)) then adl_t_core = 0  ;
label adl_t_core= "Help Toileting";


adl_index_core = .;
adl_index_core = adl_dr_core + adl_wk_core + adl_bh_core + adl_e_core + adl_tx_core + adl_t_core;
label adl_index_core= "Index of ADLs";

 adl_cat_core = .;
if (adl_index_core =0) then adl_cat_core = 0  ;
if (0<adl_index_core<=3) then adl_cat_core = 1  ;
if (3<adl_index_core<=6) then adl_cat_core = 2  ;
label adl_cat_core ="ADLs, Categorical";
format adl_cat_core adl_cat_core.;


**Create dummy variables for ADL Categories;
adl_independent_core = .;
if (adl_cat_core=0) then adl_independent_core = 1  ;
if ((adl_cat_core = 1)| (adl_cat_core = 2)) then adl_independent_core = 0  ;
label adl_independent_core= "Independent for ADLs";


adl_partial_core = .;
if (adl_cat_core=1) then adl_partial_core = 1  ;
if ((adl_cat_core = 0)| (adl_cat_core = 2)) then adl_partial_core = 0  ;
label adl_partial_core= "Partial Dependence for ADLs";

adl_severe_core = .;
if (adl_cat_core=2) then adl_severe_core= 1  ;
if ((adl_cat_core = 0)| (adl_cat_core = 1)) then adl_severe_core = 0  ;
label adl_severe_core ="Severe Dependence for ADLs";


iadl_mp = 0;
if ((kg043=1)|(kg043=6)|(kg043=7)) then iadl_mp = 1 ;
if ((kg043=5)) then iadl_mp = 0 ;
if ((kg043=8)|(kg043=9)) then iadl_mp = . ;
*if ((kg041=5)) then iadl_mp = 0 ;*if adl_bedbound=1 then iadl_mp=1 ;
label iadl_mp=  "Help with Meal Prep";

iadl_gr = 0;
 if ((kg046=1)|(kg046=6)|(kg046=7)) then iadl_gr = 1 ;
if ((kg046=5)) then iadl_gr = 0 ;
if ((kg046=8)|(kg046=9)) then iadl_gr = . ;
*if ((kg044=5)) then iadl_gr = 0 ;*if adl_bedbound=1 then iadl_gr=1 ;
label iadl_gr  ="Help with Grocery Shopping";

iadl_ph = 0;
if ((kg049=1)|(kg049=6)|(kg049=7)) then iadl_ph = 1 ;
if ((kg049=5)) then iadl_ph = 0 ;
if ((kg049=8)|(kg049=9)) then iadl_ph = . ;
*if ((kg047=5)) then iadl_ph = 0 ;*if adl_bedbound=1 then iadl_ph=1 ;
label iadl_ph = "Help with Phone Calls";

iadl_rx = 0;
if ((kg053=1)|(kg053=6)|(kg053=7)) then iadl_rx = 1 ;
if ((kg053=5)) then iadl_rx = 0 ;
if ((kg053=8)|(kg053=9)) then iadl_rx = . ;
*if ((kg051=5)) then iadl_rx = 0 ;*if adl_bedbound=1 then iadl_rx=1 ;
label iadl_rx = "Help with Medications";

iadl_m = 0;
if ((kg061=1)|(kg061=6)|(kg061=7)) then iadl_m = 1 ;
if ((kg061=5)) then iadl_m = 0 ;
if ((kg061=8)|(kg061=9)) then iadl_m = . ;
*if ((kg059=5)) then iadl_m = 0 ;*if adl_bedbound=1 then iadl_m=1 ;
label iadl_m = "Help with Money";

iadl_ind = .;
iadl_ind = iadl_mp + iadl_gr + iadl_ph + iadl_rx + iadl_m;
label iadl_ind ="Index of IADLs";
 

 iadl_cat = .;
if (iadl_ind =0) then iadl_cat = 0 ;
if (iadl_ind >=1 & iadl_ind<=3) then iadl_cat = 1 ;
if (iadl_ind >=4 & iadl_ind<=5) then iadl_cat = 2 ;
/*Cross-Wave Equivalents for:
G129 NUMBER DAYS IN BED 
1995 Core N/A 
1996 Core N/A 
1998 Core N/A 
2000 Core N/A 
2002 Core N/A 
2002 Exit SG129 
2004 Core N/A 
2004 Exit TG129 
2006 Core N/A 
2006 Exit UG129 
2008 Core N/A 
2008 Exit VG129 

if ((sg129<94)&(sg129>=85))|((tg129<94)&(tg129>=85))|((ug129<94)&(ug129>=85)) then iadl_cat = 3 ;
*/
label iadl_cat ="IADLs, Categorical";

format iadl_cat iadl_cat.;


 iadl_independent = .;
 if (iadl_cat=0) then iadl_independent = 1 ;
 if ((iadl_cat = 1)|(iadl_cat = 2)|(iadl_cat = 3)) then iadl_independent = 0 ;
label iadl_independent ="Independent for IADLs";
;

; iadl_partial = .;
if (iadl_cat=1) then iadl_partial = 1 ;
if ((iadl_cat = 0)| (iadl_cat = 2)|(iadl_cat = 3)) then iadl_partial = 0 ;
label iadl_partial ="Partial Dependence for IADLs";
;

 iadl_severe = .;
if (iadl_cat=2) then iadl_severe= 1 ;
if ((iadl_cat = 0)| (iadl_cat = 1)|(iadl_cat = 3)) then iadl_severe = 0 ;
label iadl_severe ="Severe Dependence for IADLs";


cancer_hrs = .;
if ((kc018=1)|(kc018=3)) then cancer_hrs = 1 ; 
if ((kc018=5)|(kc018=4)) then cancer_hrs = 0 ; 
label cancer_hrs= "Cancer";


/**Lung Disease, r1191
Cross-Wave Equivalents for:
C030 LUNG DISEASE 
1995 Core D818 
1996 Core E818 
1998 Core F1146 
2000 Core G1279 
2002 Core HC030 
2002 Exit SC030 
2004 Core JC030 
2004 Exit TC030 
2006 Core KC030 
2006 Exit UC030 
2008 Core LC030 
2008 Exit VC030 

generate lung_hrs = .
 then lung_hrs = 1 ; if ((sc030=1)|(tc030=1)|(uc030=1)|(sc030=3)|(tc030=3)|(uc030=3))
 then lung_hrs = 0 ; if ((sc030=5)|(tc030=5)|(uc030=5)|(sc030=4)|(tc030=4)|(uc030=4))
label lung_hrs "Lung Disease"
*/
lung_hrs = .;
 if ((kc030=1)|(kc030=3)) then lung_hrs = 1 ;
if ((kc030=5)|(kc030=4)) then lung_hrs = 0 ; 
label lung_hrs ="Lung Disease";


/**Heart Condition: "heart attack, coronary heart disease, angina, congestive heart failure, or other heart problems?", r1201
Cross-Wave Equivalents for:
C036 HEART CONDITION 
1995 Core D828 
1996 Core E828 
1998 Core F1156 
2000 Core G1289 
2002 Core HC036 
2002 Exit SC036 
2004 Core JC036 
2004 Exit TC036 
2006 Core KC036 
2006 Exit UC036 
2008 Core LC036 
2008 Exit VC036 
generate heart_hrs = .
 then heart_hrs = 1 ; if ((sc036=1)|(tc036=1)|(uc036=1)|(sc036=3)|(tc036=3)|(uc036=3))
 then heart_hrs = 0 ; if ((sc036=5)|(tc036=5)|(uc036=5)|(sc036=4)|(tc036=4)|(uc036=4))
label heart_hrs "Heart Condition"
*/
heart_hrs = .;
if ((kc036=1)|(kc036=3)) then heart_hrs = 1 ; 
if ((kc036=5)|(kc036=4)) then heart_hrs = 0 ; 
label heart_hrs= "Heart Condition";





/**CHF: Only asked of those who said "YES" to Heart Condition, so those who said "NO" are coded "0" here. r1216
Cross-Wave Equivalents for:
C048 CONGESTIVE HEART FAILURE 
1995 Core D843 
1996 Core E843 
1998 Core F1171 
2000 Core G1304 
2002 Core HC048 
2002 Exit SC048 
2004 Core JC048 
2004 Exit TC048 
2006 Core KC048 
2006 Exit UC048 
2008 Core LC048 
2008 Exit VC048 

generate chf_hrs = .
 then chf_hrs = 1 ; if ((sc048=1)|(tc048=1)|(uc048=1)|(sc048=3)|(tc048=3)|(uc048=3))
 then chf_hrs = 0 ; if ((sc048=5)|(tc048=5)|(uc048=5)|(sc048=4)|(tc048=4)|(uc048=4)|(heart=0))
label chf_hrs "CHF"
label define chf_hrs 0 "No" 1 "Yes" 9 "Don't Know/Refused", mod; ify
label values chf_hrs chf_hrs
tab chf_hrs, missing
*/
 chf_hrs = .;
if ((kc048=1)|(kc048=3)) then chf_hrs = 1 ; 
if ((kc048=5)|(kc048=4)|(heart_hrs=0)) then chf_hrs = 0 ; 
label chf_hrs= "CHF";


/**Stroke, missing r1221

generate stroke_hrs = .
 then stroke_hrs = 1 ; if ((sc053=1)|(tc053=1)|(uc053=1)|(sc053=3)|(tc053=3)|(uc053=3))
 then stroke_hrs = 0 ; if ((sc053=5)|(tc053=5)|(uc053=5)|(sc053=4)|(tc053=4)|(uc053=4))
label stroke_hrs "Stroke"
Cross-Wave Equivalents for:
C053 STROKE 
1995 Core D848 
1996 Core E848 
1998 Core F1176 
2000 Core G1309 
2002 Core HC053 
2002 Exit SC053 
2004 Core JC053 
2004 Exit TC053 
2006 Core KC053 
2006 Exit UC053 
2008 Core LC053 
2008 Exit VC053 

*/
stroke_hrs = .;
 if ((kc053=1)|(kc053=3)|(kc053=2)) then stroke_hrs = 1 ;
if ((kc053=5)|(kc053=4)) then stroke_hrs = 0 ; 
label stroke_hrs ="Stroke,TIA";



/**Memory Disease (diagnosed by a doctor, per the proxy report) r1240

generate memory_hrs = .
 then memory_hrs = 1 ; if ((sc069=1)|(tc069=1)|(uc069=1)|(sc069=3)|(tc069=3)|(uc069=3))
 then memory_hrs = 0 ; if ((sc069=5)|(tc069=5)|(uc069=5)|(sc069=4)|(tc069=4)|(uc069=4))
label memory_hrs "Memory Disease"
Cross-Wave Equivalents for:
C069 MEMORY RELATED DISEASE 
1995 Core N/A 
1996 Core N/A 
1998 Core F1193 
2000 Core G1326 
2002 Core HC069 
2002 Exit SC069 
2004 Core JC069 
2004 Exit TC069 
2006 Core KC069 
2006 Exit UC069 
2008 Core LC069 
2008 Exit VC069 

Cross-Wave Equivalents for:
Z117 PREV WAVE R HAS MEMORY DISEASE 
1995 Core N/A 
1996 Core N/A 
1998 Core N/A 
2000 Core N/A 
2002 Core HZ117 
2002 Exit SZ117 
2004 Core JZ117 
2004 Exit TZ117 
2006 Core KZ117 
2006 Exit UZ117 
2008 Core LZ117 
2008 Exit VZ117 
memory,jc069,jz117,if jz117 then memory_hrs=1, which means they will be dis application in jc069


*/
memory_hrs = .;
 if ((kc069=1)|(kc069=3)) then memory_hrs = 1 ;
if ((kc069=5)|(kc069=4)) then memory_hrs = 0 ; 
if ((kZ117=1)) then memory_hrs = 1 ;
label memory_hrs ="Memory Disease";


/** Falls r1230

generate falls_hrs = .
 then falls_hrs = 1 ; if ((sc079=1)|(tc079=1)|(uc079=1)|(sc079=3)|(tc079=3)|(uc079=3))
 then falls_hrs = 0 ; if ((sc079=5)|(tc079=5)|(uc079=5)|(sc079=4)|(tc079=4)|(uc079=4))
label falls_hrs "Falls"
Cross-Wave Equivalents for:
C079 FALLEN IN PAST TWO YEARS 
1995 Core D878 
1996 Core E878 
1998 Core F1206 
2000 Core G1339 
2002 Core HC079 
2002 Exit SC079 
2004 Core JC079 
2004 Exit TC079 
2006 Core KC079 
2006 Exit UC079 
2008 Core LC079 
2008 Exit VC079 

*/
falls_hrs = .;
 if ((kc079=1)|(kc079=3)) then falls_hrs = 1 ;
 if ((kc079=5)|(kc079=4)) then falls_hrs = 0 ;
label falls_hrs ="Falls";


/** Incontinence
C087 INCONTINENCE 
1995 Core D892 
1996 Core E892 
1998 Core F1220 
2000 Core G1353 
2002 Core HC087 
2002 Exit N/A 
2004 Core JC087 
2004 Exit N/A 
2006 Core KC087 
2006 Exit N/A 
2008 Core LC087 
2008 Exit N/A 


generate incont_hrs = .
 then incont_hrs = 1 ; if ((sc208=1)|(tc208=1)|(uc208=1)|(sc208=3)|(tc208=3)|(uc208=3))
 then incont_hrs = 0 ; if ((sc208=5)|(tc208=5)|(uc208=5)|(sc208=4)|(tc208=4)|(uc208=4))
label incont_hrs "Incontinence"
*/
incont_hrs = .;
if ((KC087=1)|(KC087=3)) then incont_hrs = 1 ; 
if ((kC087=5)|(KC087=4)) then incont_hrs = 0 ; 
label incont_hrs="Incontinence";

*/



/* 
Pain r1246

generate pain_hrs = .
 then pain_hrs = 1 ;
/*if ((sc104=1)|(tc104=1)|(uc104=1)|(sc104=3)|(tc104=3)|(uc104=3))
 then pain_hrs = 0 ; if ((sc104=5)|(tc104=5)|(uc104=5)|(sc104=4)|(tc104=4)|(uc104=4))
label pain_hrs "Pain"
Cross-Wave Equivalents for:
C104 TROUBLED WITH PAIN 
1995 Core D911 
1996 Core E911 
1998 Core F1239 
2000 Core G1372 
2002 Core HC104 
2002 Exit SC104 
2004 Core JC104 
2004 Exit TC104 
2006 Core KC104 
2006 Exit UC104 
2008 Core LC104 
2008 Exit VC104 

*/
pain_hrs = .;
 if ((kc104=1)|(kc104=3)) then pain_hrs = 1 ;
 if ((kc104=5)|(kc104=4)) then pain_hrs = 0 ;
label pain_hrs ="Pain";

 

/** HTN
Cross-Wave Equivalents for:
Z101 PREV WAVE R HAS HIGH BLOOD PRESSURE 
1995 Core D109 
1996 Core E109 
1998 Core F230 
2000 Core G230 
2002 Core HZ101 
2002 Exit SZ101 
2004 Core JZ101 
2004 Exit TZ101 
2006 Core KZ101 
2006 Exit UZ101 
2008 Core LZ101 
2008 Exit VZ101 

generate htn_hrs = .
 then htn_hrs = 1 ; if ((sz101=1)|(tz101=1)|(uz101=1))
 then htn_hrs = 0 ; if ((sz101=5)|(tz101=5)|(uz101=5))
label htn_hrs "Hypertension"
*/
htn_hrs = .;
 if ((kc005 in (1,3))) then htn_hrs = 1 ;
 if ((kc005 in (4,5))) then htn_hrs = 0 ;
label htn_hrs ="Hypertension";

/** Diabetes

generate dm_hrs = .
 then dm_hrs = 1 ; if ((sz102=1)|(tz102=1)|(uz102=1))
 then dm_hrs = 0 ; if ((sz102=5)|(tz102=5)|(uz102=5))
label dm_hrs "Diabetes"
Cross-Wave Equivalents for:
C010 DIABETES 
1995 Core D788 
1996 Core E788 
1998 Core F1116 
2000 Core G1245 
2002 Core HC010 
2002 Exit N/A 
2004 Core JC010 
2004 Exit N/A 
2006 Core KC010 
2006 Exit N/A 
2008 Core LC010 
2008 Exit N/A 

*/
 dm_hrs = .;
 if ((KC010=1)|(KC010=3)) then dm_hrs = 1 ;
 if ((KC010=5)|(KC010=4)) then dm_hrs = 0 ; 
label dm_hrs ="Diabetes";



/** Psychiatric Condition ("doctor ever told... emotional, nervous or psychiatric problems?")

generate psych_hrs = .
 then psych_hrs = 1 ; if ((sz107=1)|(tz107=1)|(uz107=1))
 then psych_hrs = 0 ; if ((sz107=5)|(tz107=5)|(uz107=5))
label psych_hrs "Psychiatric Condition"
Cross-Wave Equivalents for:
C065 EMOTIONAL/PSYCHIATRIC PROBLEMS 
1995 Core D861 
1996 Core E861 
1998 Core F1189 
2000 Core G1322 
2002 Core HC065 
2002 Exit N/A 
2004 Core JC065 
2004 Exit N/A 
2006 Core KC065 
2006 Exit N/A 
2008 Core LC065 
2008 Exit N/A  

*/
psych_hrs = .;
if ((KC065 =1)|(KC065 =3)) then psych_hrs = 1 ; 
if ((KC065 =4)|(KC065 =5)) then psych_hrs = 0 ; 
label psych_hrs= "Psychiatric Condition";
 

/** Arthritis

generate arth_hrs = .
 then arth_hrs = 1 ; if ((sz108=1)|(tz108=1)|(uz108=1))
 then arth_hrs = 0 ; if ((sz108=5)|(tz108=5)|(uz108=5))
label arth_hrs "Arthritis"
C070 ARTHRITIS 
1995 Core D866 
1996 Core E866 
1998 Core F1194 
2000 Core G1327 
2002 Core HC070 
2002 Exit N/A 
2004 Core JC070 
2004 Exit N/A 
2006 Core KC070 
2006 Exit N/A 
2008 Core LC070 
2008 Exit N/A  

*/
arth_hrs = .;
if ((KC070=1)|(KC070=3)) then arth_hrs = 1 ; 
if ((KC070=4)|(KC070=5)) then arth_hrs = 0 ; 
label arth_hrs ="Arthritis";


/** Index of Comorbidities: First step is a simple count
** Then the index is divided by categoies: 
** None (0), Mild (1-3), Moderate (4-6), Severe (>7).

generate comor_in_hrs = .
 then comor_in_hrs = (cancer_hrs + lung_hrs + heart_hrs + chf_hrs + stroke_hrs + memory_hrs + htn_hrs + dm_hrs + psych_hrs)
label comor_in_hrs "Index of Comorbidities"
tab comor_in_hrs, missing  
 
generate comor_c_hrs = .
 then comor_c_hrs = 0 ; if (comor_in_hrs =0)
 then comor_c_hrs = 1 ; if (comor_in_hrs >=1 & comor_in_hrs<=3)
 then comor_c_hrs = 2 ; if (comor_in_hrs >=4 & comor_in_hrs<=6)
 then comor_c_hrs = 3 ; if (comor_in_hrs >=7 & comor_in_hrs<=13)
label comor_c_hrs "Comorbidity Index, Categorical"
label define comor_c_hrs 0 "None (0)" 1 "Mild (1-3)" 2 "Moderate (4-6)" 3 "Severe (>7)", mod; ify
label values comor_c_hrs comor_c_hrs
tab comor_c_hrs, missing 
*/

comor_in_hrs = .;
comor_in_hrs = (cancer_hrs + lung_hrs + heart_hrs + chf_hrs + stroke_hrs + memory_hrs + htn_hrs + dm_hrs + psych_hrs);
label comor_in_hrs= "Index of Comorbidities";
 
 
comor_c_hrs = .;
if (comor_in_hrs =0) then comor_c_hrs = 0 ; 
 if (comor_in_hrs >=1 & comor_in_hrs<=3) then comor_c_hrs = 1 ;
if (comor_in_hrs >=4 & comor_in_hrs<=6) then comor_c_hrs = 2 ; 
if (comor_in_hrs >=7 & comor_in_hrs<=13) then comor_c_hrs = 3 ; 
label comor_c_hrs= "Comorbidity Index, Categorical";
format comor_c_hrs comor_c_hrs.;

/*******************************************************************************************
** Core Interview (up to 2 yr before death) included a measure of self rated health,
so there is not need to seek concordance
*******************************************************************************************/

/**Self Rated Health "Don't Know/Refused" (only 2 cases) included with missing 
Cross-Wave Equivalents for:
C001 RATE HEALTH 
1995 Core D769 
1996 Core E769 
1998 Core F1097 
2000 Core G1226 
2002 Core HC001 
2002 Exit N/A 
2004 Core JC001 
2004 Exit N/A 
2006 Core KC001 
2006 Exit N/A 
2008 Core LC001 
2008 Exit N/A 
*/

 srh = .;
if ((kc001=1)) then srh = 1 ; 
if ((kc001=2)) then srh = 2 ; 
if ((kc001=3)) then srh = 3 ; 
if ((kc001=4)) then srh = 4 ; 
if ((kc001=5)) then srh = 5 ; 
label srh ="Self Rated Health";
format srh srh.;

** Dummies for 3 categories: Poor/Fair, Good, Very Good /Excellent**
;
srh_pf = .;
if ((srh=1)|(srh=2)|(srh=3)) then srh_pf = 0 ; 
if ((srh=5)|(srh=4)) then srh_pf = 1 ; 
label srh_pf= "Self Rated Health: Poor/Fair";
;
 srh_g = .;
if ((srh=1)|(srh=2)|(srh=4)|(srh=5)) then srh_g = 0 ; 
 if (srh=3) then srh_g = 1 ;
label srh_g ="Self Rated Health: Good";
;
 srh_ve = .;
 if ((srh=3)|(srh=4)|(srh=5))then srh_ve = 0 ; 
if ((srh=1)|(srh=2)) then srh_ve = 1 ; 
label srh_ve ="Self Rated Health: Very Good /Excellent";



run;
proc freq ;
table proxy_core marital;
run;

*****,borrow from year 2004,
educ,educ.

;


/*start from year 2008*/





/*the code book is http://hrsonline.isr.umich.edu/index.php?p=showcbk */

%let type=h;
%let year=08;

libname HRS "c:\hrs20&year.\sas\";




proc sort data=HRS.H&year.a_r;
by hhid pn lsubhh;

proc sort data=HRS.H&year.b_r;
by hhid pn lsubhh;
proc sort data=HRS.H&year.c_r;
by hhid pn lsubhh;
proc sort data=HRS.H&year.d_r;
by hhid pn lsubhh;
proc sort data=HRS.H&year.f_r;
by hhid pn lsubhh;
proc sort data=HRS.H&year.g_r;
by hhid pn lsubhh;
proc sort data=HRS.H&year.m1_r;
by hhid pn lsubhh;
proc sort data=HRS.H&year.n_r;
by hhid pn lsubhh;
proc sort data=HRS.H&year.pr_r;
by hhid pn lsubhh;
run;


proc sort data=HRS.H&year.a_h;
by hhid lsubhh;
proc sort data=HRS.H&year.e_h;
by hhid lsubhh;
run;

proc sort data=hrs.incwlth&year.e1a;
by hhid pn lsubhh;
run;



data HRS.Core20&year.sub1;
merge hrs.incwlth&year.e1a HRS.H&year.a_r HRS.H&year.b_r HRS.H&year.c_r HRS.H&year.d_r HRS.H&year.f_r HRS.H&year.g_r HRS.H&year.m1_r HRS.H&year.n_r HRS.H&year.pr_r;
by hhid pn;
run;

proc sort data=HRS.Core20&year.sub1;
by hhid lsubhh;
run;
data HRS.Core20&year.;
merge HRS.Core20&year.sub1  HRS.H&year.a_h  HRS.H&year.e_h;
by hhid lsubhh;
run;




*%let data1=HRS.Core20&year.(obs=100);
options compress=yes;
libname hrs00 "C:\hrs2000\sas";
%let data1=HRS.Core20&year.;

data hrs00.core_08_sub(keep=&keep_var_list2);
set &data1;
merged_year=2008;
if h9atotw~=. then networth=h9atotw;
if 0<=LE046<81 and merged_year=2008 then gchil=LE046;
/*Cross-Wave Equivalents for:
N099 OVERNIGHT STAY IN HOSP-SINCE PREV IW/2YR 
1995 Core D1664 
1996 Core E1770 
1998 Core F2295 
2000 Core G2567 
2002 Core HN099 
2002 Exit SN099 
2004 Core JN099 
2004 Exit TN099 
2006 Core KN099 
2006 Exit UN099 
2008 Core LN099 
2008 Exit VN099 
*/
hosp_last_2yr=.;
if LN099=1 then hosp_last_2yr=1;
if LN099=5 then hosp_last_2yr=0;

/*
** Proxy versus self, Core(1=self, 2=spouse, 3=non-spouse)
generate proxy_core = .
replace  proxy_core = 1 if ((g514==2)|(g514==3)|(ha009==2)|(ha009==3)|(ja009==2)|(ja009==3))
replace  proxy_core = 0 if ((g514==1)|(ha009==1)|(ja009==1))
label variable proxy_core "Proxy Respondent for Core Interview"
label define proxy_core 0 "No" 1 "Proxy", modify
label values proxy_core proxy_core
tab proxy_core, missing 
*/

proxy_core = .;
if ((la009=2)|(la009=3)) then  proxy_core = 1; 
if ((la009=1)) then  proxy_core = 0 ;
label  proxy_core= "Proxy Respondent for Core Interview";

*gender,year 2000 gender is borrow,(used HX060_R) from year 2002;
female = .;
 if ( (lx060_R=2)) then  female = 1;
if ( (lx060_R=1)) then  female = 0 ;


*age according dob from restricted file and year(core_date),core_date is also in restricted
they are available on amy's computer;

*race and ethnicity is already in restricted data file;

** Marital status r1134
/*
Cross-Wave Equivalents for:
B063 MARITAL STATUS ASSIGNED 
1995 Core N/A 
1996 Core N/A 
1998 Core N/A 
2000 Core N/A 
2002 Core N/A 
2002 Exit N/A 
2004 Core JB063 
2004 Exit TB063 
2006 Core KB063 
2006 Exit UB063 
2008 Core LB063 
2008 Exit VB063 


Cross-Wave Equivalents for:
B061 MARITAL STATUS IF UNMARRIED 
1995 Core N/A 
1996 Core N/A 
1998 Core F1070 
2000 Core G1157 
2002 Core HB061 
2002 Exit SB061 
2004 Core JB061 
2004 Exit TB061 
2006 Core KB061 
2006 Exit UB061 
2008 Core LB061 
2008 Exit VB061 

Cross-Wave Equivalents for:
 
2000 Core G543 
2002 Core HA020 
2002 Exit SA020 
2004 Core JA020 
2004 Exit TA020 
2006 Core KA020 
2006 Exit UA020 
2008 Core LA020 
2008 Exit VA020 

*/
*change sa020(exit) into G543(core);


marital = .;
if ((lb063=1)) then marital = 1 ;
if ( (lB061=3)|(lb063=3)) then marital = 2 ;
if ( (lB061=4)|(lb063=4)) then marital = 3 ;
if ( (lB061=5)|(lb063=5)) then marital = 4 ;
if ((lB061=6)|(lb063=6)) then marital = 5 ;
if ((lB061=7)|(lB061=8)|(lb063=7)) then marital = 6 ;
label marital="Marital Status";
format marital marital.;


married = .;
if (marital=1) then married = 1 ;
if (marital>1) then married = 0 ;
label married= "Married";

marital_sep = .;
if (marital=2) then marital_sep = 1 ;
if (marital~=2 & marital ~=.) then marital_sep = 0 ;
label marital_sep= "Separated";

marital_div = .;
if (marital=3) then marital_div = 1 ;
if (marital~=3 & marital ~=.) then marital_div = 0 ;
label marital_div= "Divorced";

marital_wid = .;
if (marital=4) then marital_wid = 1 ;
if (marital~=4 & marital ~=.) then marital_wid = 0 ;
label marital_wid= "Widowed";

marital_nev = .;
if (marital=5) then marital_nev = 1 ;
if (marital~=5 & marital ~=.) then marital_nev = 0 ;
label marital_nev= "Never Married";

marital_sd = .;
if (marital_sep=1 | marital_div=1) then marital_sd  = 1 ;
if (marital_sep=0 & marital_div=0) then marital_sd  = 0 ;
label marital_sd = "Separated or Divorced";
/*
married = .
 then married = 1 ;if (marital=1)
 then married = 0 ;if (marital!=1 & marital <.)
label married "Married"
label define married 1 "Married" 0 "Not Married", mod;ify
label values married married
tab married, missing 

generate marital_sep = .
 then marital_sep = 1 ;if (marital=2)
 then marital_sep = 0 ;if (marital!=2 & marital <.)
label marital_sep "Separated"
label define marital_sep 1 "Separated" 0 "Not Separated", mod;ify
label values marital_sep marital_sep
tab marital_sep, missing 

generate marital_div = .
 then marital_div = 1 ;if (marital=3)
 then marital_div = 0 ;if (marital!=3 & marital <.)
label marital_div "Divorced"
label define marital_div 1 "Divorced" 0 "Not Divorced", mod;ify
label values marital_div marital_div
tab marital_div, missing 

generate marital_wid = .
 then marital_wid = 1 ;if (marital=4)
 then marital_wid = 0 ;if (marital!=4 & marital <.)
label marital_wid "Widowed"
label define marital_wid 1 "Widowed" 0 "Not Widowed", mod;ify
label values marital_wid marital_wid
tab marital_wid, missing 

generate marital_nev = .
 then marital_nev = 1 ;if (marital=5)
 then marital_nev = 0 ;if (marital!=5 & marital <.)
label marital_nev "Never Married"
label define marital_nev 1 "Never Married" 0 "Not Never Married", mod;ify
label values marital_nev marital_nev
tab marital_nev, missing 

generate marital_sd = .
 then marital_sd = 1 ;if (marital_sep=1 | marital_div=1)
 then marital_sd = 0 ;if (marital_sep=0 & marital_div=0)
label marital_sd "Separated or Divorced"
label define marital_sd 1 "Separated or Divorced" 0 "Not Separated or Divorced", mod;ify
label values marital_sd marital_sd
*/


*education,all related variables are already in the dataset,
not found in year 2006,2008,just use the education from year 2004,
use variable educ format educ. ;



/*net worth wait for amy's confirm*/



medicare = .;
if ( (ln001=1)) then medicare= 1 ;
if ( (ln001=5)) then medicare= 0 ;
** r2587
generate; medicareb = .;
 if ( (ln004=1)) then medicareb= 1;
 if ( (ln004=5)) then medicareb= 0;
 if medicare= 0 then medicareb= 0;

** r2588 r2589
generate; medicaid = 0;
if ( (ln005=1)) then medicaid= 1 ;
if ( (ln005=8)) then medicaid= . ;


 champus = 0;
if ((ln007=1)) then champus= 1 ;
if ((ln007=8)) then champus = . ;


** r2601
generate
Cross-Wave Equivalents for:
N009 MEDICARE/MEDICAID HMO 
1995 Core N/A 
1996 Core E5148 
1998 Core F5881 
2000 Core G6254 
2002 Core HN009 
2002 Exit SN009 
2004 Core ln009 
2004 Exit TN009 
2006 Core ln009 
2006 Exit UN009 
2008 Core LN009 
2008 Exit VN009 
; hmo = 0;
if ((ln009=1)) then hmo= 1 ;
if ((ln009=8)) then hmo = . ;


** r2623
generate 
Cross-Wave Equivalents for:
N023 NUM PRIVATE HEALTH INS PLANS 
1995 Core N/A 
1996 Core N/A 
1998 Core N/A 
2000 Core N/A 
2002 Core HN023 
2002 Exit SN023 
2004 Core kn023 
2004 Exit TN023 
2006 Core KN023 
2006 Exit UN023 
2008 Core LN023 
2008 Exit VN023 
;
medigap = .;
if (  (ln023>=1)) then medigap= 1 ;
if ( (ln023=0)) then medigap= 0 ;
if (  (ln023=98)| (ln023=99)) then medigap= . ;

nhres = .;
if ( (la028=1)) then nhres = 1 ; 
if ((la028=5)) then nhres = 0 ;
label nhres="Nursing Home Resident";


imprelig = .;
if ((lb053=1)) then imprelig = 1 ;
if ((lb053=3)) then imprelig = 2 ;
if ((lb053=5)) then imprelig = 3 ;
if ((lb053=8)|(lb053=9)) then imprelig = 4 ;
if ((lb053=.)) then imprelig = 4 ;
label imprelig ="Importance of Religion";
format imprelig imprelig.;

child = .;
child = la101 ;
label child ="Number of Children, not their children's spouses";

allchil = la113 ;
label allchil= "Total Number of Children, Children-in-law, and Grandchildren";

reschil= la099  ;
label reschil="Number of Resident Children";

reschil_d = .;
if ((reschil=0) )|(nhres=1) then reschil_d = 0 ;
if ((reschil>0) )&(nhres~=1) then reschil_d = 1 ;
label reschil_d= "Living with Children";

resspouse = .;
if ((la030=5)|(married=0)) then resspouse = 0 ;
if ((la030=1)) then resspouse = 1 ;
label resspouse= "Living with Spouse/Partner";

hhm= la098  ;
label hhm="Number of Household Members";

friend = .;
if ((lf175=5)) then friend = 0 ;
if ((lf175=1)) then friend = 1 ;
label friend= "Good Friends Nearby";

rel_nb = .;
if ((lf174=5)) then rel_nb = 0 ;
if ((lf174=1)) then rel_nb = 1 ;
label rel_nb= "Relatives Nearby";

adl_dr_core = 0;
if ((lg015=1)) then adl_dr_core = 1  ;
if ((lg015=5)) then adl_dr_core = 0  ;
if ((lg015=8)|(lg015=9)) then adl_dr_core = .  ;
*if ((lg014=5)) then adl_dr_core = 0  ;
label adl_dr_core= "Help Dressing";

adl_wk_core = 0;
if ((lg020=1)) then adl_wk_core = 1  ;
if ((lg020=5)) then adl_wk_core = 0  ;
if ((lg020=8)|(lg020=9)) then adl_wk_core = .  ;
*if ((lg016=5)) then adl_wk_core = 0  ;
label adl_wk_core= "Help Walking";

adl_bh_core =0;
if ((lg022=1)) then adl_bh_core = 1  ;
if ((lg022=5)) then adl_bh_core = 0  ;
if ((lg022=8)|(lg022=9)) then adl_bh_core = .  ;
*if ((lg021=5)) then adl_bh_core = 0  ;
label adl_bh_core= "Help Bathing";


adl_e_core = 0;
if ((lg024=1)) then adl_e_core = 1  ;
if ((lg024=5)) then adl_e_core = 0  ;
if ((lg024=8)|(lg024=9)) then adl_e_core = .  ;
*if ((lg023=5)) then adl_e_core = 0  ;
label adl_e_core= "Help Eating";


adl_tx_core = 0;
if ((lg029=1)) then adl_tx_core = 1  ;
if ((lg029=5)) then adl_tx_core = 0  ;
if ((lg029=8)|(lg029=9)) then adl_tx_core = .  ;
*if ((lg025=5)) then adl_tx_core = 0  ;
label adl_tx_core= "Help with Transfers to Bed";

adl_t_core =0;
if ((lg031=1)) then adl_t_core = 1  ;
if ((lg031=5)) then adl_t_core = 0  ;
if ((lg031=8)|(lg031=9)) then adl_t_core = .  ;
*if ((lg030=5)) then adl_t_core = 0  ;
label adl_t_core= "Help Toileting";


adl_index_core = .;
adl_index_core = adl_dr_core + adl_wk_core + adl_bh_core + adl_e_core + adl_tx_core + adl_t_core;
label adl_index_core= "Index of ADLs";

 adl_cat_core = .;
if (adl_index_core =0) then adl_cat_core = 0  ;
if (0<adl_index_core<=3) then adl_cat_core = 1  ;
if (3<adl_index_core<=6) then adl_cat_core = 2  ;
label adl_cat_core ="ADLs, Categorical";
format adl_cat_core adl_cat_core.;


**Create dummy variables for ADL Categories;
adl_independent_core = .;
if (adl_cat_core=0) then adl_independent_core = 1  ;
if ((adl_cat_core = 1)| (adl_cat_core = 2)) then adl_independent_core = 0  ;
label adl_independent_core= "Independent for ADLs";


adl_partial_core = .;
if (adl_cat_core=1) then adl_partial_core = 1  ;
if ((adl_cat_core = 0)| (adl_cat_core = 2)) then adl_partial_core = 0  ;
label adl_partial_core= "Partial Dependence for ADLs";

adl_severe_core = .;
if (adl_cat_core=2) then adl_severe_core= 1  ;
if ((adl_cat_core = 0)| (adl_cat_core = 1)) then adl_severe_core = 0  ;
label adl_severe_core ="Severe Dependence for ADLs";


iadl_mp = 0;
if ((lg043=1)|(lg043=6)|(lg043=7)) then iadl_mp = 1 ;
if ((lg043=5)) then iadl_mp = 0 ;
if ((lg043=8)|(lg043=9)) then iadl_mp = . ;
*if ((lg041=5)) then iadl_mp = 0 ;*if adl_bedbound=1 then iadl_mp=1 ;
label iadl_mp=  "Help with Meal Prep";

iadl_gr = 0;
 if ((lg046=1)|(lg046=6)|(lg046=7)) then iadl_gr = 1 ;
if ((lg046=5)) then iadl_gr = 0 ;
if ((lg046=8)|(lg046=9)) then iadl_gr = . ;
*if adl_bedbound=1 then iadl_gr=1 ;
if ((lg044=5)) then iadl_gr = 0 ;
label iadl_gr  ="Help with Grocery Shopping";

iadl_ph = 0;
if ((lg049=1)|(lg049=6)|(lg049=7)) then iadl_ph = 1 ;
if ((lg049=5)) then iadl_ph = 0 ;
if ((lg049=8)|(lg049=9)) then iadl_ph = . ;
*if ((lg047=5)) then iadl_ph = 0 ;*if adl_bedbound=1 then iadl_ph=1 ;
label iadl_ph = "Help with Phone Calls";

iadl_rx = 0;
if ((lg053=1)|(lg053=6)|(lg053=7)) then iadl_rx = 1 ;
if ((lg053=5)) then iadl_rx = 0 ;
if ((lg053=8)|(lg053=9)) then iadl_rx = . ;
*if ((lg051=5)) then iadl_rx = 0 ;*if adl_bedbound=1 then iadl_rx=1 ;
label iadl_rx = "Help with Medications";

iadl_m = 0;
if ((lg061=1)|(lg061=6)|(lg061=7)) then iadl_m = 1 ;
if ((lg061=5)) then iadl_m = 0 ;
if ((lg061=8)|(lg061=9)) then iadl_m = . ;
*if ((lg059=5)) then iadl_m = 0 ;*if adl_bedbound=1 then iadl_m=1 ;
label iadl_m = "Help with Money";

iadl_ind = .;
iadl_ind = iadl_mp + iadl_gr + iadl_ph + iadl_rx + iadl_m;
label iadl_ind ="Index of IADLs";
 

 iadl_cat = .;
if (iadl_ind =0) then iadl_cat = 0 ;
if (iadl_ind >=1 & iadl_ind<=3) then iadl_cat = 1 ;
if (iadl_ind >=4 & iadl_ind<=5) then iadl_cat = 2 ;
/*Cross-Wave Equivalents for:
G129 NUMBER DAYS IN BED 
1995 Core N/A 
1996 Core N/A 
1998 Core N/A 
2000 Core N/A 
2002 Core N/A 
2002 Exit SG129 
2004 Core N/A 
2004 Exit TG129 
2006 Core N/A 
2006 Exit UG129 
2008 Core N/A 
2008 Exit VG129 

if ((sg129<94)&(sg129>=85))|((tg129<94)&(tg129>=85))|((ug129<94)&(ug129>=85)) then iadl_cat = 3 ;
*/
label iadl_cat ="IADLs, Categorical";

format iadl_cat iadl_cat.;


 iadl_independent = .;
 if (iadl_cat=0) then iadl_independent = 1 ;
 if ((iadl_cat = 1)|(iadl_cat = 2)|(iadl_cat = 3)) then iadl_independent = 0 ;
label iadl_independent ="Independent for IADLs";
;

; iadl_partial = .;
if (iadl_cat=1) then iadl_partial = 1 ;
if ((iadl_cat = 0)| (iadl_cat = 2)|(iadl_cat = 3)) then iadl_partial = 0 ;
label iadl_partial ="Partial Dependence for IADLs";
;

 iadl_severe = .;
if (iadl_cat=2) then iadl_severe= 1 ;
if ((iadl_cat = 0)| (iadl_cat = 1)|(iadl_cat = 3)) then iadl_severe = 0 ;
label iadl_severe ="Severe Dependence for IADLs";


cancer_hrs = .;
if ((lc018=1)|(lc018=3)) then cancer_hrs = 1 ; 
if ((lc018=5)|(lc018=4)) then cancer_hrs = 0 ; 
label cancer_hrs= "Cancer";


/**Lung Disease, r1191
Cross-Wave Equivalents for:
C030 LUNG DISEASE 
1995 Core D818 
1996 Core E818 
1998 Core F1146 
2000 Core G1279 
2002 Core HC030 
2002 Exit SC030 
2004 Core JC030 
2004 Exit TC030 
2006 Core lc030 
2006 Exit UC030 
2008 Core LC030 
2008 Exit VC030 

generate lung_hrs = .
 then lung_hrs = 1 ; if ((sc030=1)|(tc030=1)|(uc030=1)|(sc030=3)|(tc030=3)|(uc030=3))
 then lung_hrs = 0 ; if ((sc030=5)|(tc030=5)|(uc030=5)|(sc030=4)|(tc030=4)|(uc030=4))
label lung_hrs "Lung Disease"
*/
lung_hrs = .;
 if ((lc030=1)|(lc030=3)) then lung_hrs = 1 ;
if ((lc030=5)|(lc030=4)) then lung_hrs = 0 ; 
label lung_hrs ="Lung Disease";


/**Heart Condition: "heart attack, coronary heart disease, angina, congestive heart failure, or other heart problems?", r1201
Cross-Wave Equivalents for:
C036 HEART CONDITION 
1995 Core D828 
1996 Core E828 
1998 Core F1156 
2000 Core G1289 
2002 Core HC036 
2002 Exit SC036 
2004 Core JC036 
2004 Exit TC036 
2006 Core lc036 
2006 Exit UC036 
2008 Core LC036 
2008 Exit VC036 
generate heart_hrs = .
 then heart_hrs = 1 ; if ((sc036=1)|(tc036=1)|(uc036=1)|(sc036=3)|(tc036=3)|(uc036=3))
 then heart_hrs = 0 ; if ((sc036=5)|(tc036=5)|(uc036=5)|(sc036=4)|(tc036=4)|(uc036=4))
label heart_hrs "Heart Condition"
*/
heart_hrs = .;
if ((lc036=1)|(lc036=3)) then heart_hrs = 1 ; 
if ((lc036=5)|(lc036=4)) then heart_hrs = 0 ; 
label heart_hrs= "Heart Condition";





/**CHF: Only asked of those who said "YES" to Heart Condition, so those who said "NO" are coded "0" here. r1216
Cross-Wave Equivalents for:
C048 CONGESTIVE HEART FAILURE 
1995 Core D843 
1996 Core E843 
1998 Core F1171 
2000 Core G1304 
2002 Core HC048 
2002 Exit SC048 
2004 Core JC048 
2004 Exit TC048 
2006 Core lc048 
2006 Exit UC048 
2008 Core LC048 
2008 Exit VC048 

generate chf_hrs = .
 then chf_hrs = 1 ; if ((sc048=1)|(tc048=1)|(uc048=1)|(sc048=3)|(tc048=3)|(uc048=3))
 then chf_hrs = 0 ; if ((sc048=5)|(tc048=5)|(uc048=5)|(sc048=4)|(tc048=4)|(uc048=4)|(heart=0))
label chf_hrs "CHF"
label define chf_hrs 0 "No" 1 "Yes" 9 "Don't Know/Refused", mod; ify
label values chf_hrs chf_hrs
tab chf_hrs, missing
*/
 chf_hrs = .;
if ((lc048=1)|(lc048=3)) then chf_hrs = 1 ; 
if ((lc048=5)|(lc048=4)|(heart_hrs=0)) then chf_hrs = 0 ; 
label chf_hrs= "CHF";


/**Stroke, missing r1221

generate stroke_hrs = .
 then stroke_hrs = 1 ; if ((sc053=1)|(tc053=1)|(uc053=1)|(sc053=3)|(tc053=3)|(uc053=3))
 then stroke_hrs = 0 ; if ((sc053=5)|(tc053=5)|(uc053=5)|(sc053=4)|(tc053=4)|(uc053=4))
label stroke_hrs "Stroke"
Cross-Wave Equivalents for:
C053 STROKE 
1995 Core D848 
1996 Core E848 
1998 Core F1176 
2000 Core G1309 
2002 Core HC053 
2002 Exit SC053 
2004 Core JC053 
2004 Exit TC053 
2006 Core lc053 
2006 Exit UC053 
2008 Core LC053 
2008 Exit VC053 

*/
stroke_hrs = .;
 if ((lc053=1)|(lc053=3)|(lc053=2)) then stroke_hrs = 1 ;
if ((lc053=5)|(lc053=4)) then stroke_hrs = 0 ; 
label stroke_hrs ="Stroke,TIA";



/**Memory Disease (diagnosed by a doctor, per the proxy report) r1240

generate memory_hrs = .
 then memory_hrs = 1 ; if ((sc069=1)|(tc069=1)|(uc069=1)|(sc069=3)|(tc069=3)|(uc069=3))
 then memory_hrs = 0 ; if ((sc069=5)|(tc069=5)|(uc069=5)|(sc069=4)|(tc069=4)|(uc069=4))
label memory_hrs "Memory Disease"
Cross-Wave Equivalents for:
C069 MEMORY RELATED DISEASE 
1995 Core N/A 
1996 Core N/A 
1998 Core F1193 
2000 Core G1326 
2002 Core HC069 
2002 Exit SC069 
2004 Core JC069 
2004 Exit TC069 
2006 Core lc069 
2006 Exit UC069 
2008 Core LC069 
2008 Exit VC069 
*/
memory_hrs = .;
 if ((lc069=1)|(lc069=3)) then memory_hrs = 1 ;
if ((lc069=5)|(lc069=4)) then memory_hrs = 0 ; 
if ((lZ117=1)) then memory_hrs = 1 ;
label memory_hrs ="Memory Disease";


/** Falls r1230

generate falls_hrs = .
 then falls_hrs = 1 ; if ((sc079=1)|(tc079=1)|(uc079=1)|(sc079=3)|(tc079=3)|(uc079=3))
 then falls_hrs = 0 ; if ((sc079=5)|(tc079=5)|(uc079=5)|(sc079=4)|(tc079=4)|(uc079=4))
label falls_hrs "Falls"
Cross-Wave Equivalents for:
C079 FALLEN IN PAST TWO YEARS 
1995 Core D878 
1996 Core E878 
1998 Core F1206 
2000 Core G1339 
2002 Core HC079 
2002 Exit SC079 
2004 Core JC079 
2004 Exit TC079 
2006 Core lc079 
2006 Exit UC079 
2008 Core LC079 
2008 Exit VC079 

*/
falls_hrs = .;
 if ((lc079=1)|(lc079=3)) then falls_hrs = 1 ;
 if ((lc079=5)|(lc079=4)) then falls_hrs = 0 ;
label falls_hrs ="Falls";


/** Incontinence
Ling,no such infor avaible in core,
Cross-Wave Equivalents for:
C208 INCONTINENCE 
1995 Core N/A 
1996 Core N/A 
1998 Core N/A 
2000 Core N/A 
2002 Core N/A 
2002 Exit SC208 
2004 Core N/A 
2004 Exit TC208 
2006 Core N/A 
2006 Exit UC208 
2008 Core N/A 
2008 Exit VC208 

generate incont_hrs = .
 then incont_hrs = 1 ; if ((sc208=1)|(tc208=1)|(uc208=1)|(sc208=3)|(tc208=3)|(uc208=3))
 then incont_hrs = 0 ; if ((sc208=5)|(tc208=5)|(uc208=5)|(sc208=4)|(tc208=4)|(uc208=4))
label incont_hrs "Incontinence"
*/
/** Incontinence
C087 INCONTINENCE 
1995 Core D892 
1996 Core E892 
1998 Core F1220 
2000 Core G1353 
2002 Core HC087 
2002 Exit N/A 
2004 Core JC087 
2004 Exit N/A 
2006 Core KC087 
2006 Exit N/A 
2008 Core LC087 
2008 Exit N/A 


generate incont_hrs = .
 then incont_hrs = 1 ; if ((sc208=1)|(tc208=1)|(uc208=1)|(sc208=3)|(tc208=3)|(uc208=3))
 then incont_hrs = 0 ; if ((sc208=5)|(tc208=5)|(uc208=5)|(sc208=4)|(tc208=4)|(uc208=4))
label incont_hrs "Incontinence"
*/
incont_hrs = .;
if ((lC087=1)|(lC087=3)) then incont_hrs = 1 ; 
if ((lC087=5)|(lC087=4)) then incont_hrs = 0 ; 
label incont_hrs="Incontinence";


/** Pain r1246

generate pain_hrs = .
 then pain_hrs = 1 ; if ((sc104=1)|(tc104=1)|(uc104=1)|(sc104=3)|(tc104=3)|(uc104=3))
 then pain_hrs = 0 ; if ((sc104=5)|(tc104=5)|(uc104=5)|(sc104=4)|(tc104=4)|(uc104=4))
label pain_hrs "Pain"
Cross-Wave Equivalents for:
C104 TROUBLED WITH PAIN 
1995 Core D911 
1996 Core E911 
1998 Core F1239 
2000 Core G1372 
2002 Core HC104 
2002 Exit SC104 
2004 Core JC104 
2004 Exit TC104 
2006 Core lc104 
2006 Exit UC104 
2008 Core LC104 
2008 Exit VC104 

*/
pain_hrs = .;
 if ((lc104=1)|(lc104=3)) then pain_hrs = 1 ;
 if ((lc104=5)|(lc104=4)) then pain_hrs = 0 ;
label pain_hrs ="Pain";

 

/** HTN
Cross-Wave Equivalents for:
C005 HIGH BLOOD PRESSURE 
1995 Core D781 
1996 Core E781 
1998 Core F1109 
2000 Core G1238 
2002 Core HC005 
2002 Exit N/A 
2004 Core JC005 
2004 Exit N/A 
2006 Core KC005 
2006 Exit N/A 
2008 Core LC005 
2008 Exit N/A 


generate htn_hrs = .
 then htn_hrs = 1 ; if ((sz101=1)|(tz101=1)|(uz101=1))
 then htn_hrs = 0 ; if ((sz101=5)|(tz101=5)|(uz101=5))
label htn_hrs "Hypertension"
*/
htn_hrs = .;
 if ((lc005 in (3,1) )) then htn_hrs = 1 ;
 if ((lc005 in (4,5))) then htn_hrs = 0 ;
label htn_hrs ="Hypertension";

/** Diabetes

generate dm_hrs = .
 then dm_hrs = 1 ; if ((sz102=1)|(tz102=1)|(uz102=1))
 then dm_hrs = 0 ; if ((sz102=5)|(tz102=5)|(uz102=5))
label dm_hrs "Diabetes"
Cross-Wave Equivalents for:
Z102 PREV WAVE R HAS DIABETES 
1995 Core D110 
1996 Core E110 
1998 Core F231 
2000 Core G231 
2002 Core HZ102 
2002 Exit SZ102 
2004 Core JZ102 
2004 Exit TZ102 
2006 Core lz102 
2006 Exit UZ102 
2008 Core LZ102 
2008 Exit VZ102 

*/
 dm_hrs = .;
 if ((LC010=1)|(LC010=3)) then dm_hrs = 1 ;
 if ((LC010=5)|(LC010=4)) then dm_hrs = 0 ; 
label dm_hrs ="Diabetes";



/** Psychiatric Condition ("doctor ever told... emotional, nervous or psychiatric problems?")

generate psych_hrs = .
 then psych_hrs = 1 ; if ((sz107=1)|(tz107=1)|(uz107=1))
 then psych_hrs = 0 ; if ((sz107=5)|(tz107=5)|(uz107=5))
label psych_hrs "Psychiatric Condition"
Cross-Wave Equivalents for:
C065 EMOTIONAL/PSYCHIATRIC PROBLEMS 
1995 Core D861 
1996 Core E861 
1998 Core F1189 
2000 Core G1322 
2002 Core HC065 
2002 Exit N/A 
2004 Core JC065 
2004 Exit N/A 
2006 Core KC065 
2006 Exit N/A 
2008 Core LC065 
2008 Exit N/A  

*/
psych_hrs = .;
if ((LC065=1)|(LC065=3)) then psych_hrs = 1 ; 
if ((LC065=4)|(LC065=5)) then psych_hrs = 0 ; 
label psych_hrs= "Psychiatric Condition";
 

/** Arthritis

generate arth_hrs = .
 then arth_hrs = 1 ; if ((sz108=1)|(tz108=1)|(uz108=1))
 then arth_hrs = 0 ; if ((sz108=5)|(tz108=5)|(uz108=5))
label arth_hrs "Arthritis"
C070 ARTHRITIS 
1995 Core D866 
1996 Core E866 
1998 Core F1194 
2000 Core G1327 
2002 Core HC070 
2002 Exit N/A 
2004 Core JC070 
2004 Exit N/A 
2006 Core KC070 
2006 Exit N/A 
2008 Core LC070 
2008 Exit N/A  

*/
arth_hrs = .;
if ((LC070=1)|(LC070=3)) then arth_hrs = 1 ; 
if ((LC070=4)|(LC070=5)) then arth_hrs = 0 ; 
label arth_hrs ="Arthritis";


/** Index of Comorbidities: First step is a simple count
** Then the index is divided by categoies: 
** None (0), Mild (1-3), Moderate (4-6), Severe (>7).

generate comor_in_hrs = .
 then comor_in_hrs = (cancer_hrs + lung_hrs + heart_hrs + chf_hrs + stroke_hrs + memory_hrs + htn_hrs + dm_hrs + psych_hrs)
label comor_in_hrs "Index of Comorbidities"
tab comor_in_hrs, missing  
 
generate comor_c_hrs = .
 then comor_c_hrs = 0 ; if (comor_in_hrs =0)
 then comor_c_hrs = 1 ; if (comor_in_hrs >=1 & comor_in_hrs<=3)
 then comor_c_hrs = 2 ; if (comor_in_hrs >=4 & comor_in_hrs<=6)
 then comor_c_hrs = 3 ; if (comor_in_hrs >=7 & comor_in_hrs<=13)
label comor_c_hrs "Comorbidity Index, Categorical"
label define comor_c_hrs 0 "None (0)" 1 "Mild (1-3)" 2 "Moderate (4-6)" 3 "Severe (>7)", mod; ify
label values comor_c_hrs comor_c_hrs
tab comor_c_hrs, missing 
*/

comor_in_hrs = .;
comor_in_hrs = (cancer_hrs + lung_hrs + heart_hrs + chf_hrs + stroke_hrs + memory_hrs + htn_hrs + dm_hrs + psych_hrs);
label comor_in_hrs= "Index of Comorbidities";
 
 
comor_c_hrs = .;
if (comor_in_hrs =0) then comor_c_hrs = 0 ; 
 if (comor_in_hrs >=1 & comor_in_hrs<=3) then comor_c_hrs = 1 ;
if (comor_in_hrs >=4 & comor_in_hrs<=6) then comor_c_hrs = 2 ; 
if (comor_in_hrs >=7 & comor_in_hrs<=13) then comor_c_hrs = 3 ; 
label comor_c_hrs= "Comorbidity Index, Categorical";
format comor_c_hrs comor_c_hrs.;

/*******************************************************************************************
** Core Interview (up to 2 yr before death) included a measure of self rated health,
so there is not need to seek concordance
*******************************************************************************************/

/**Self Rated Health "Don't Know/Refused" (only 2 cases) included with missing 
Cross-Wave Equivalents for:
C001 RATE HEALTH 
1995 Core D769 
1996 Core E769 
1998 Core F1097 
2000 Core G1226 
2002 Core HC001 
2002 Exit N/A 
2004 Core JC001 
2004 Exit N/A 
2006 Core KC001 
2006 Exit N/A 
2008 Core LC001 
2008 Exit N/A 
*/

 srh = .;
if ((lc001=1)) then srh = 1 ; 
if ((lc001=2)) then srh = 2 ; 
if ((lc001=3)) then srh = 3 ; 
if ((lc001=4)) then srh = 4 ; 
if ((lc001=5)) then srh = 5 ; 
label srh ="Self Rated Health";
format srh srh.;

** Dummies for 3 categories: Poor/Fair, Good, Very Good /Excellent**
;
srh_pf = .;
if ((srh=1)|(srh=2)|(srh=3)) then srh_pf = 0 ; 
if ((srh=5)|(srh=4)) then srh_pf = 1 ; 
label srh_pf= "Self Rated Health: Poor/Fair";
;
 srh_g = .;
if ((srh=1)|(srh=2)|(srh=4)|(srh=5)) then srh_g = 0 ; 
 if (srh=3) then srh_g = 1 ;
label srh_g ="Self Rated Health: Good";
;
 srh_ve = .;
 if ((srh=3)|(srh=4)|(srh=5))then srh_ve = 0 ; 
if ((srh=1)|(srh=2)) then srh_ve = 1 ; 
label srh_ve ="Self Rated Health: Very Good /Excellent";



run;

*****,borrow from year 2004,
educ,educ.

;
proc freq;
table marital;
run;






proc sql;
create table hrs00.core_08_sub_2 as select a.*,b.educ
from hrs00.core_08_sub a left join
hrs00.core_00_02_04_sub(where=(merged_year=2004)) b on
a.hhid=b.hhid and a.pn=b.pn;
quit;

proc sql;
create table hrs00.core_06_sub_2 as select a.*,b.educ
from hrs00.core_06_sub a left join
hrs00.core_00_02_04_sub(where=(merged_year=2004)) b on
a.hhid=b.hhid and a.pn=b.pn;
quit;

data hrs00.core_00_to_08_0;
set hrs00.core_00_02_04_sub hrs00.core_06_sub_2 hrs00.core_08_sub_2;
length hhidpn $9.;
hhidpn=hhid||pn;
run;

proc contents data=hrs00.core_00_to_08_0(keep=hhid pn hhidpn);
run;


%let var=female;
proc sql;
create table &var._0 as select hhid,pn,&var
from hrs00.core_00_to_08_0 where &var~=.;
quit;
proc sort data=&var._0 out=&var nodupkey;
by hhid pn;
run;
proc sql;
create table core_00_to_08_1 as select a.*,b.&var
from hrs00.core_00_to_08_0(drop=&var) a
left join
&var b
on a.hhid=b.hhid and a.pn=b.pn;
quit;
proc freq;
table &var;
run;

%let var=educ;
proc sql;
create table &var._0 as select hhid,pn,&var
from hrs00.core_00_to_08_0 where &var~=.;
quit;
proc sort data=&var._0 out=&var nodupkey;
by hhid pn;
run;
proc sql;
create table core_00_to_08_2 as select a.*,b.&var
from core_00_to_08_1(drop=&var) a
left join
&var b
on a.hhid=b.hhid and a.pn=b.pn;
quit;
proc freq;
table &var;
run;




data hrs00.core_00_to_08;
set core_00_to_08_2;
run;




%let file=hrs00.core_00_to_08;

%let report_path=C:\projects\Hospice_impact_on_utilization\report;
ods rtf body="&report_path.\core_freq_04_13_2011.rtf";
proc freq data=&file;
table (proxy_core female marital married marital_sep marital_div marital_wid
marital_nev marital_sd educ medicare medicareb medicaid champus hmo medigap nhres
imprelig   reschil_d resspouse  friend rel_nb adl_dr_core
adl_wk_core adl_bh_core adl_e_core adl_tx_core adl_t_core adl_index_core adl_cat_core
adl_independent_core adl_partial_core adl_severe_core iadl_mp iadl_gr iadl_ph iadl_rx iadl_m
cancer_hrs lung_hrs heart_hrs chf_hrs stroke_hrs memory_hrs falls_hrs pain_hrs htn_hrs dm_hrs
psych_hrs arth_hrs comor_in_hrs comor_c_hrs srh srh_pf srh_g srh_ve hosp_last_2yr)*merged_year;
format educ educ. marital marital. imprelig imprelig. adl_cat_core adl_cat_core.
srh srh. comor_c_hrs comor_c_hrs. iadl_cat iadl_cat.;
run;

proc means data=&file;
class merged_year;
var networth child gchil allchil reschil hhm;
run;

ods rtf close;

proc sql;
select * from &file 
where female=.;
quit;

/*cohort selection criteria*/
/*
if age>65 or (
if age=65 & core_month>month(birth_date) ) then age_ge_65=1;
*
srh_pf
chf_hrs
lung_hrs
dm_hrs
cancer_hrs
hosp_last_2yr
;
*/





proc sql;
title "meet age>=65 at core interview,2000-2006";
select count(distinct hhidpn) from criteria_cohort 
where age_ge_65=1 and merged_year in (2000,2002,2004,2006);
create table age_ge_65 as 
select * from criteria_cohort 
where age_ge_65=1 and merged_year in (2000,2002,2004,2006);

title "those meet age>=65,srf(poor,fair)";
select count(distinct hhidpn) from age_ge_65 
where srh_pf=1 ;

title "those meet age>=65,chf";
select count(distinct hhidpn) from age_ge_65 
where chf_hrs=1 ;

title "those meet age>=65,lung";
select count(distinct hhidpn) from age_ge_65 
where lung_hrs=1 ;

title "those meet age>=65,diabet";
select count(distinct hhidpn) from age_ge_65 
where dm_hrs=1 ;

title "those meet age>=65,cancer";
select count(distinct hhidpn) from age_ge_65 
where cancer_hrs=1 ;

title "those meet age>=65,hosp_last_2yr";
select count(distinct hhidpn) from age_ge_65 
where hosp_last_2yr=1 ;

quit;









proc format;
value educ 
0= "No Formal Education"
1= "Grades 1-11" 
2 ="High School" 
3= "Some College" 
4 ="College" 
5 ="Post College"
;

value marital 1= "Married" 
2= "Separated" 
3= "Divorced" 
4= "Widowed" 
5= "Never Married" 
6= "Other/Don't Know"
;
value imprelig 
1= "Very Important" 
2= "Somewhat Important" 
3= "Not Too Important" 
4 ="Don't Know/Refused/Missing"
;
value adl_cat_core
0= "Independent" 
1 ="Partial Dependence" 
2 ="Severe Dependence"
;
value srh 
1= "Excellent" 
2= "Very Good" 
3= "Good" 
4= "Fair" 
5= "Poor"
;
value comor_c_hrs 
0 ="None (0)" 
1 ="Mild (1-3)" 
2 ="Moderate (4-6)" 
3 ="Severe (>7)"
;
value  
iadl_cat 
0= "Independent" 
1 ="Partial Dependence" 
2 ="Severe Dependence" 
3 ="Restricted to Bed"
;
run;
libname data "C:\data\hrs";
options compress=yes;


options fmterr=no;




/*to get the core interview date*/


libname data "C:\data\hrs";





*note it seems more obs in the core than in the ;
libname temp "c:\data\hrs_2011_v2";
data IVWDATE ;
set temp.IVWDATE;
run;
proc sort data=IVWDATE out=d nodupkey;
by hhid pn;
run;
proc contents data=ivwdate;
run;

/*
data temp;
set data.core_00_to_08(obs=2);
run;
proc freq;
table merged_year;
run;
%let year=2000;
proc sql outobs=10;
create table core_00_date
as select a.hhid,a.pn,a.merged_year,b.GIWMONTH as core_month,b.GIWDAY as core_day,GIWyear as core_year
from temp(where=(merged_year=&year)) a left join
IVWDATE b
on a.hhid=b.hhid and a.pn=b.pn;
quit;
*/


%let year=2000;
proc sql;
create table core_00_date
as select a.hhid,a.pn,a.merged_year,b.GIWMONTH as core_month,b.GIWDAY as core_day,GIWyear as core_year
from data.core_00_to_08(where=(merged_year=&year)) a left join
IVWDATE b
on a.hhid=b.hhid and a.pn=b.pn;
quit;


%let year=2002;
proc sql;
create table core_02_date
as select a.hhid,a.pn,a.merged_year,b.hIWMONTH as core_month,b.hIWDAY as core_day,hIWyear as core_year
from data.core_00_to_08(where=(merged_year=&year)) a left join
IVWDATE b
on a.hhid=b.hhid and a.pn=b.pn;
quit;

%let year=2004;
proc sql;
create table core_04_date
as select a.hhid,a.pn,a.merged_year,b.jIWMONTH as core_month,b.jIWDAY as core_day,jIWyear as core_year
from data.core_00_to_08(where=(merged_year=&year)) a left join
IVWDATE b
on a.hhid=b.hhid and a.pn=b.pn;
quit;

%let year=2006;
proc sql;
create table core_06_date
as select a.hhid,a.pn,a.merged_year,b.kIWMONTH as core_month,b.kIWDAY as core_day,kIWyear as core_year
from data.core_00_to_08(where=(merged_year=&year)) a left join
IVWDATE b
on a.hhid=b.hhid and a.pn=b.pn;
quit;

%let year=2008;
proc sql;
create table core_08_date
as select a.hhid,a.pn,a.merged_year,b.lIWMONTH as core_month,b.lIWDAY as core_day,lIWyear as core_year
from data.core_00_to_08(where=(merged_year=&year)) a left join
IVWDATE b
on a.hhid=b.hhid and a.pn=b.pn;
quit;

data core_date_00_08;
set core_00_date
core_02_date
core_04_date
core_06_date
core_08_date;
run;
proc sort data=data.core_00_to_08 out=temp nodupkey;
by hhid pn merged_year;
run;

proc sort data=core_date_00_08 out=tem_date nodupkey;
by hhid pn merged_year;
run;

proc sql;
create table core_00_to_08_dt as 
select * from 
temp a 
left join 
tem_date b
on a.hhid=b.hhid and a.pn=b.pn and a.merged_year=b.merged_year;
quit;

proc sort data=core_00_to_08_dt out=t2 nodupkey;
by hhid pn merged_year;
run;


/*to merege with restricted dataproc sql;
create table proc contents data=temp.hrs_dod_dob_race;
run;
*/

proc sort data=temp.hrs_dod_dob_race out=t1 nodupkey;
by id;
run;

libname final "C:\projects\Hospice_impact_on_utilization\final_data";
proc sql;
create table final.core_res_00_to_08 as 
select * from 
core_00_to_08_dt a 
left join 
temp.hrs_dod_dob_race b
on a.hhid=b.hhid and a.pn=b.pn;
quit;

/*the data live_up_to is from core 2000 to 2008,*/


/*add the proxy_c1,proxy_c2, from hrs core -1 interviews*/
libname raw "C:\projects\Procedures\raw_data";
libname final "C:\projects\Procedures\final_data";
options fmterr=no;


proc sql;
create table intensive_procedure_1 as select * 
from final.intensive_procedure a 
left join
SAS.ELIX_N6M_N12M_2(rename=(BID_hrs=BID_hrs2)) b
on trim(left(a.BID_hrs))=trim(left(b.BID_hrs2));
quit;

proc sql;
create table intensive_procedure_2 as select * 
from intensive_procedure_1(drop=bid_hrs2) a 
left join
sas.chronic_21_n6_n12(rename=(bid_hrs=bid_hrs2)) b 
on trim(left(a.bid_hrs))=trim(left(b.bid_hrs2));
quit;
proc freq;
table proxy:;
run;




H="Raw data from Medicare"

%let raw_folder=C:\projects\Hospice_impact_on_utilization\raw_data;
%let final_folder=C:\projects\Hospice_impact_on_utilization\final_data;
libname raw_data "&raw_folder";
libname final_data "&final_folder";
/*new hrs cms id cross walk from cms 02/08/2012*/
libname medi "C:\data\CMS\medicare_2008";
proc contents data=medi.hrscms2008;
run;



libname bid_hhid "C:\data\CMS\medicare_2008";

libname exit "&raw_folder";



%let list_2002=
sa009 sa020 sa026 sa028 sa028 sa030 sa065 sa066 sa098 sa099 sa101 sb034 sa101 sb034 
sa113 sa121 sa123 sa124 sa131 sa134 sa136 sa142 sa148 sa500 sa501 sb002 sb014 sb015 
sb016 sb028 sb031m sb050 sb061 sb082 sc018 sc030 sc036 sc048 sc053 sc069 sc079 sc104 
sc117 sc208 sg015 sg020 sg022 sg024 sg029 sg031 sg043 sg046 sg049 sg053 sg061 sg129 
sn001 sn004 sn005 sn006 sn007 sn023 sn009 sn099 sn099 sn100 sn100 sn101 sn147 sn148
sn149 sn221 sn222 sn223 sn301 sn302 sn305 sn306 sn307 sn309 sn310 sn315 sn315 sn316 
sn317 sn319 sn316 sr_age st190 st191 st192 st193 st194 st195 st196 st197 st204 st205
st206 st211 st212 st213 st218 st219m1 st219m2 st219m3 st219m4 st219m5 st223 st223 st224
st225 st226 st227 st230 st231 st232 st233 st234 st235 st236 sx004_r sx060_r sx067_r
sz080 sz101 sz102 sz107 sz108 sz113 sz114 se046 SE100;*add SE100 by ling for [did you have grand children];


%let list_2004=
tx004 ta009 ta019 ta026 ta030 ta065 ta066 ta098 ta099 ta101 tb034 ta101 tb034 ta113 ta121 ta123 ta124 ta131 ta134 ta136 ta142 ta148 ta167 ta500 ta501 tb002 tb014 tb015 tb016 tb028 tb050 tb061 tb063 tb082 tc018 tc030 tc036 tc048 tc053 tc069 tc079 tc104 tc117 tc208 te046 tg015 tg020 tg022 tg024 tg029 tg031 tg043 tg046 tg049 tg053 tg061 tg129 tn001 tn004 tn005 tn006 tn007 tn023 tn009 tn099 tn100 tn100 tn101 tn147 tn148 tn149 tn257 tn301 tn302 tn305 tn306 tn307 tn309 tn310 tn315 tn315 tn316 tn316 tt190 tt191 tt192 tt193 tt194 tt195 tt196 tt197 tt204 tt205 tt206 tt211 tt212 tt213 tt218 tt219m1 tt219m2 tt219m3 tt219m4 tt219m5 tt219m6 tt223 tt223 tt224 tt225 tt226 tt227 tt230 tt231 tt232 tt233 tt234 tt235 tt236 tx060_r tz068_r tz080 tz101 tz102 tz107 tz108 tz113
;




%let list_2006=
ua009 ua019 ua026 ua030 ua065 ua066 ua098 ua099 ua101 ua101 ua113 ua121 ua123 ua124 ua131 ua134 ua136 ua148 ua167 ua500 ua501 ub028 ub082 ub061 ub063 ub086 uc018 uc030 uc036 uc048 uc053 uc069 uc079 uc104 uc117 uc208 ue046 ug015 ug020 ug022 ug024 ug029 ug031 ug043 ug046 ug049 ug053 ug061 ug129 un001 un004 un005 un006 un007 un023 un009 un099 un100 un101 un147 un148 un149 un257 un301 un302 un305 un306 un307 un309 un310 un315 un315 un316 un316 ut190 ut191 ut192 ut193 ut194 ut195 ut197 ut204 ut205 ut206 ut211 ut212 ut213 ut218 ut219m1 ut219m2 ut219m3 ut219m4 ut219m5 ut223 ut223 ut224 ut225 ut226 ut227 ut230 ut231 ut232 ut233 ut234 ut235 ut236 ut196 ux004 ux060_r ux068_r uz080 uz101 uz102 uz107 uz108 uz113;




data raw_data.exit_2002_to_2006;
set raw_data.exit2002(IN=in02 keep=hhid pn &list_2002)
raw_data.exit2004(IN=in04 keep=hhid pn &list_2004)
raw_data.exit2006(IN=in06 keep=hhid pn &list_2006);*
exit.exit2008(IN=in08);
if in02 then merge_year=2002;
if in04 then merge_year=2004;
if in06 then merge_year=2006;
id=hhid*1000+pn;
run;
proc sort data=raw_data.exit_2002_to_2006 nodupkey;
by id;
run;

proc export data=raw_data.exit_2002_to_2006
outfile="&raw_folder.\exit_2002_to_2006.dta" replace;
run;

/*use amy' stata code to read the variables*/


data raw_folder.exit_2002_to_2008_id;
set raw_folder.exit2002(IN=in02)
raw_folder.exit2004(IN=in04)
raw_folder.exit2006(IN=in06)
raw_folder.exit2008(IN=in08);
if in02 then merge_year=2002;
if in04 then merge_year=2004;
if in06 then merge_year=2006;
if in08 then merge_year=2008;
id=hhid*1000+pn;
run;
proc sql;
select count(*) from exit.exit_2002_to_2008_ID
where id>0;
select count(*) from exit.exit_2002_to_2008_ID
where id=.;
quit;
/*note there is no duplicate in exit 2002 to exit*/
proc sort data= raw_folder.exit_2002_to_2008_id nodupkey;
by id;
run;

%let medi=C:\data\CMS\medicare_2008;
/*new hrs cms id cross walk from cms 02/08/2012*/
libname medi "&medi";
proc contents data=medi.hrscms2008;
run;

data BID_MTSI_1;
set medi.hrscms2008 ;
id=hhidpn+0;
*bid_n=BID_HRS_10+0;
run;
proc sql;
select * from BID_MTSI_1
where id=.;
*select * from BID_MTSI_1
where bid_n=.;
quit;

proc sort data=BID_MTSI_1 nodupkey;
by id;
run;

proc sql;
select count(*) from BID_MTSI_1
where id>0;
select count(*) from BID_MTSI_1
where id=.;
quit;

proc sort data=exit.exit_2002_to_2008_id nodupkey;
by id;
run;
/*999 ids doesn't have the correspoinding bid-id cross walk because their age is not qualify<65*/

proc sql;
select count(*) from hrs_dod_dob_race where id_n=.;
quit;
proc sql;
create table test2 as
select * from exit.exit_2002_to_2008_id
where id not in (select id from BID_MTSI_1);
quit;


proc sql;
create table exit_re_0 as
select a.id,b.bid_hrs_10 from 
exit.exit_2002_to_2008_id a
left join 
bid_mtsi_1 b
on a.id=b.id;
quit;


data hrs_dod_dob_race;
set raw_data.hrs_dod_dob_race;
id_n=id+0;
run;
proc sql;
create table exit_re as
select a.*,b.death_date,b.birth_date from 
exit_re_0 a
left join 
hrs_dod_dob_race b
on a.id=b.id_n;
quit;


/*note the death month should be from restricted file since more obs in restricted rather than in DN*/

data medi.dn_2000_2008;
set  medi.dn_2000 medi.dn_2001 medi.dn_2002 medi.dn_2003 
medi.dn_2004 medi.dn_2005 medi.dn_2006 medi.dn_2007 medi.dn_2008;
year=2000+RFRNC_YR;
bid_n=substr(trim(left(BID_HRS)),4,6)+0;
BID=bid_n;



/*note we can't use dob dod fro dn since a lot of the r missing,they should come from restricted fiel*/
if substr(trim(left(DEATH_DT)),1,1)~="0"  then do;
death_year=substr(trim(left(DEATH_DT)),1,4)+0;
death_month=substr(trim(left(DEATH_DT)),5,2)+0;
death_day=substr(trim(left(DEATH_DT)),7,2)+0;
death_date=mdy(death_month,death_day,death_year);
end;
if substr(trim(left(BENE_DOB)),1,1)~="0"  then do;
birth_year=substr(trim(left(BENE_DOB)),1,4)+0;
birth_month=substr(trim(left(BENE_DOB)),5,2)+0;
birth_day=substr(trim(left(BENE_DOB)),7,2)+0;
birth_date=mdy(birth_month,birth_day,birth_year);
end;
run;
proc sort data=medi.dn_2000_2008 out=dn_2000_20082  nodupkey;
by BID_HRS year;
run;


data dn_last_year;
set dn_2000_20082;
by BID_HRS year;
if last.BID_HRS then output;
run;
proc freq data=dn_last_year;
table death_year year;
run;


proc sql;
create table exit_re2 as
select a.*,coalesce(a.death_date,b.death_date) as death_date2 ,coalesce(a.birth_date,b.birth_date) as
birth_date2 from 
exit_re a
left join 
dn_last_year b
on a.bid_hrs_10=b.bid_hrs;
quit;
/*4665 meet the age >=66*/
proc sql;
create table exit_re_age_ge66 as
select * from exit_re2
where (death_date2-birth_date2)/365.25>=66;
quit;
/*4176 ids of 4665 has the cross walk ids.*/
proc sql;
create table exit_age_ge66_in_mc as
select * from exit_re_age_ge66 
where id in 
(select id from BID_MTSI_1);
quit;

proc freq;
table merge_year;
run;
/*inner join because if one don't have the cross work in bid, we won't know whether they met dn's 
parta partb eligibility,then drop those ids*/
 proc sql;
create table hrsid_bid as 
select a.*
 from 
 exit_re_age_ge66 a inner join
 BID_MTSI_1 b
 on a.id=b.id;
 quit;

 proc freq data=hrsid_bid;
 table merge_year;
 run;
/*4350 have the corresponding bid in medicar data*/
 /*get the death date from restricted file and dob to get the age,
 in fact, dn file also has dob and dod*/

 


/*Disregarding Unnecessary Claim Segments

Many RIF applications can be performed using only the information from the first segment of a claim. 
In such instances, 2nd and higher order claim segments can be deleted from created research files to avoid confusion. 
Fewer than one percent of the Hospice, Inpatient, Outpatient, and Skilled Nursing Facility SAFs
claims have two or more segments.
For those claims that do have more than one segment,
only the ***Revenue Center variable**** group 
ever contains new values in the 2nd and higher segments. 
Carrier and Durable Medical Equipment (DME) RIF SAFs never contain claims with more than one segment.  

In short, you can disregard all but the first segment of a claim when:

1. You are working only with Carrier or DME files, or 
2. You are not using information about revenue center codes in your analysis. 
*/
*,
note there is no SGMT_CNT in medpar ;
%let source=mp;
proc sql outobs=10;
select BID_HRS, ADMSNDT,DSCHRGDT,loscnt,SGMT_CNT from medi.&source._2000;
quit;

data medi.&source._2000_2008;
set medi.&source._2000 medi.&source._2001 medi.&source._2002 medi.&source._2003 
medi.&source._2004 medi.&source._2005 medi.&source._2006 medi.&source._2007 medi.&source._2008;

admit_date=datejul(ADMSNDT);
if substr(trim(left(DSCHRGDT)),1,1) in ("1","2") then do;
disch_date=datejul(DSCHRGDT);
end;

admit_year=year(admit_date);

if disch_date=. then disch_date=admit_date+loscnt;
bid_n=substr(trim(left(BID_HRS)),4,6)+0;
disch_year=year(disch_date);

run;



proc sort data=medi.&source._2000_2008 out=temp2  nodupkey;
by BID_n admit_date disch_date;
run;
proc sql;
create table bid as
select BID_n,admit_date, disch_date,count(*)
from medi.&source._2000_2008 group by
BID_n,admit_date, disch_date having count(*)>1
;
select BID_n,admit_date, disch_date from medi.&source._2000_2008
where bid_n in (select bid_n from bid)
;
quit;
*
MSNDT ADMSNDT CHAR Documentation MEDPAR_ADMSN_DT: MEDPAR Admission Date 
DSCHRGDT DSCHRGDT CHAR Documentation MEDPAR_DSCHRG_DT: MEDPAR Discharge Date 
loscnt;
proc sql outobs=10;
select BID_HRS, ADMSNDT,DSCHRGDT,loscnt from medi.&source._2000_2008 where 
disch_year=.;
quit;
proc freq;
table admit_year disch_year;
run;



%let source=op;
proc sql outobs=10;
select BID_HRS, FROM_DT,thru_DT,pmt_amt from medi.&source._2000;
quit;

data medi.&source._2000_2008;
set medi.&source._2000 medi.&source._2001 medi.&source._2002 medi.&source._2003 
medi.&source._2004 medi.&source._2005 medi.&source._2006 medi.&source._2007 medi.&source._2008;

admit_date=mdy(substr(trim(left(FROM_DT)),5,2),substr(trim(left(FROM_DT)),7,2),substr(trim(left(FROM_DT)),1,4));
disch_date=mdy(substr(trim(left(thru_DT)),5,2),substr(trim(left(thru_DT)),7,2),substr(trim(left(thru_DT)),1,4));


admit_year=year(admit_date);


bid_n=substr(trim(left(BID_HRS)),4,6)+0;
if SGMT_NUM=1;

run;



proc sort data=medi.&source._2000_2008 out=temp2  nodupkey;
by BID_HRS admit_date disch_date pmt_amt;
run;

proc sql;
create table bid as
select BID_n,admit_date, disch_date,count(*)
from medi.&source._2000_2008 group by
BID_n,admit_date, disch_date having count(*)>1
;
quit;
proc sql;
create table temp as
select * from medi.&source._2000_2008
where bid_n in (select bid_n from bid) group by bid_n,admit_date having count(*)>1 order by BID_n,admit_date, disch_date
;
quit;

%let source=pb;
proc sql outobs=10;
select BID_HRS, FROM_DT,thru_DT,pmt_amt from medi.&source._2000;
quit;

data medi.&source._2000_2008;
set medi.&source._2000 medi.&source._2001 medi.&source._2002 medi.&source._2003 
medi.&source._2004 medi.&source._2005 medi.&source._2006 medi.&source._2007 medi.&source._2008;

admit_date=mdy(substr(trim(left(FROM_DT)),5,2),substr(trim(left(FROM_DT)),7,2),substr(trim(left(FROM_DT)),1,4));
disch_date=mdy(substr(trim(left(thru_DT)),5,2),substr(trim(left(thru_DT)),7,2),substr(trim(left(thru_DT)),1,4));


admit_year=year(admit_date);


bid_n=substr(trim(left(BID_HRS)),4,6)+0;
if SGMT_NUM=1;
run;

%let source=hh;
proc sql outobs=10;
select BID_HRS, FROM_DT,thru_DT,pmt_amt from medi.&source._2000;
quit;

data medi.&source._2000_2008;
set medi.&source._2000 medi.&source._2001 medi.&source._2002 medi.&source._2003 
medi.&source._2004 medi.&source._2005 medi.&source._2006 medi.&source._2007 medi.&source._2008;

admit_date=mdy(substr(trim(left(FROM_DT)),5,2),substr(trim(left(FROM_DT)),7,2),substr(trim(left(FROM_DT)),1,4));
disch_date=mdy(substr(trim(left(thru_DT)),5,2),substr(trim(left(thru_DT)),7,2),substr(trim(left(thru_DT)),1,4));


admit_year=year(admit_date);


bid_n=substr(trim(left(BID_HRS)),4,6)+0;
if SGMT_NUM=1;
run;
%let source=hs;
proc sql outobs=10;
select BID_HRS, FROM_DT,thru_DT,pmt_amt from medi.&source._2000;
quit;

data medi.&source._2000_2008;
set medi.&source._2000 medi.&source._2001 medi.&source._2002 medi.&source._2003 
medi.&source._2004 medi.&source._2005 medi.&source._2006 medi.&source._2007 medi.&source._2008;

admit_date=mdy(substr(trim(left(FROM_DT)),5,2),substr(trim(left(FROM_DT)),7,2),substr(trim(left(FROM_DT)),1,4));
disch_date=mdy(substr(trim(left(thru_DT)),5,2),substr(trim(left(thru_DT)),7,2),substr(trim(left(thru_DT)),1,4));


admit_year=year(admit_date);


bid_n=substr(trim(left(BID_HRS)),4,6)+0;
if SGMT_NUM=1;
run;

proc sql;
select count(*) from medi.&source._2000_2008
where disch_date=.;
quit;


%let source=dm;
proc sql outobs=10;
select BID_HRS, FROM_DT,thru_DT,pmt_amt from medi.&source._2000;
quit;

data medi.&source._2000_2008;
set medi.&source._2000 medi.&source._2001 medi.&source._2002 medi.&source._2003 
medi.&source._2004 medi.&source._2005 medi.&source._2006 medi.&source._2007 medi.&source._2008;

admit_date=mdy(substr(trim(left(FROM_DT)),5,2),substr(trim(left(FROM_DT)),7,2),substr(trim(left(FROM_DT)),1,4));
disch_date=mdy(substr(trim(left(thru_DT)),5,2),substr(trim(left(thru_DT)),7,2),substr(trim(left(thru_DT)),1,4));


admit_year=year(admit_date);


bid_n=substr(trim(left(BID_HRS)),4,6)+0;
if SGMT_NUM=1;
run;



proc sort data=medi.&source._2000_2008 out=temp2  nodupkey;
by BID_HRS admit_date disch_date pmt_amt;
run;
proc sql outobs=10;
select distinct SGMT_CNT,count(*) from medi.&source._2000_2008 group by SGMT_CNT;
quit;
*SGMT_CNT;




*
MSNDT ADMSNDT CHAR Documentation MEDPAR_ADMSN_DT: MEDPAR Admission Date 
DSCHRGDT DSCHRGDT CHAR Documentation MEDPAR_DSCHRG_DT: MEDPAR Discharge Date 
loscnt;
proc sql outobs=10;
select BID_HRS, ADMSNDT,DSCHRGDT,loscnt from medi.&source._2000_2008 where 
disch_year=.;
quit;
proc freq;
table admit_year disch_year;
run;








proc sql ;
create table test1 as
select hhid,pn,id from hrs_dod_dob_race where id_2=.;
select id from temp.dob20082 where id in 
select id from test1;
quit;

data exitdeathdate2;
set temp.exitdeathdate2;
id_n=id+0;
run;

proc sql;

select count(id) from exit.exit_2002_to_2008_id
where id not in (select id_n from exitdeathdate2);


quit;

/*
proc sql;
create table hrsid_bid2 as select a.*,b.death_date,b.birth_date
from hrsid_bid a 
left join 
hrs_dod_dob_race b
on a.id=b.id_n;
quit;

proc sql;
create table hrsid_bid3 as select a.*,coalesce(a.death_date,b.death_date)
as death_date2,coalesce(a.birth_date,b.birth_date)
as birth_date2
from hrsid_bid2 a 
left join 
dn_last_year b
on trim(left(a.BID_HRS_10))=trim(left(b.BID_HRS));
quit;
*/


proc sql;
select count(*) from hrsid_bid3 where death_date=. and death_date2~=.;
quit;
proc sql;
select count(*) from hrsid_bid2 where birth_date=.;
quit;

proc sql ;
create table test1 as
select id from hrsid_bid where id not in 
(select id_n from hrs_dod_dob_race);
quit;

/*limite those with age>66,*/
 data hrsid_bid4;
 set hrsid_bid;
 death_year=year(death_date2);
  death_month=year(death_date2);
 if (death_date2-birth_date2)/365.25>=66;
 run;
/*only 4073 of 4176 ids have the dn file correspond year,4142 ids in dn file,*/
 proc sql;
 select count(distinct BID_hrs_10) from hrsid_bid4
 where BID_hrs_10 in (select distinct bid_hrs from dn_2000_20082) ;
 quit;

proc sql;
create table dn_death_y as select
a.*,b.buyin12,b.year,b.HMOIND12
from hrsid_bid4 a inner join
dn_2000_20082 b
on trim(left(a.BID_hrs_10))=trim(left(b.BID_hrs))
and a.death_year=b.year
;
quit;
proc freq data=dn_death_y;
table death_year;
run;
proc sql;
select count(distinct bid_n) from dn_death_y;
quit;

/*note death month should from restricted file*/
data dn_death_y2;
set dn_death_y;
death_month=month(death_date2);
if length(trim(left(buyin12)))=12 and death_month>0 then do;
buyin_dy=substr(trim(left(buyin12)),1,death_month);
hmo_dy=substr(trim(left(HMOIND12)),1,death_month);
end;
else do;
buyin_dy=trim(left(buyin12));
hmo_dy=trim(left(HMOIND12));
end;
run;
proc means n;
var  death_month;
run;
/*only 3822 have the -1 year dn file*/
proc sql;
create table dn_death_y_bef as select
a.BID_hrs_10,a.year as death_year,b.year as next_death_year,b.buyin12,b.year,b.HMOIND12
from dn_death_y a inner join
dn_2000_20082 b
on trim(left(a.BID_hrs_10))=trim(left(b.BID_hrs))
and 0<a.year-b.year<=1 order by bid_n,year;
quit;
/*
data dn_death_y2_bef;
set dn_death_y_bef;
by bid_n year;
if first.bid_n then order=0;
order+1;
run;

proc transpose data=dn_death_y2_bef out=wide1 prefix=buyin;
   by bid;
   id order;
   var buyin12;
run;

proc transpose data=dn_death_y2_bef out=wide2 prefix=HMO;
   by bid;
   id order;
   var HMOIND12;
run;

data wide3(keep=bid buyin1-buyin3 hmo1-hmo3);
    merge  wide1(drop=_name_) wide2(drop=_name_);
    by bid;
run;
data wide4(keep=bid buyin_bef hmo_bef);
set wide3;
buyin_bef=trim(left(buyin1))||trim(left(buyin2))||trim(left(buyin3));
hmo_bef=trim(left(hmo1))||trim(left(hmo2))||trim(left(hmo3));
run;

*/
proc sql;
create table all_insurance as select a.*,b.buyin12 as buyin_bef,b.HMOIND12 as hmo_bef from
dn_death_y2 a
left join
dn_death_y_bef b
on trim(left(a.BID_hrs_10))=trim(left(b.BID_hrs_10));
quit;


data all_insurance2;*(drop=buyin_2y buyin_bef buyin_dy hmo_2y hmo_bef hmo_dy id_1 buyin12 HMOIND12 year);
set all_insurance;
buyin_2y=trim(left(buyin_bef))||trim(left(buyin_dy));
hmo_2y=trim(left(hmo_bef))||trim(left(hmo_dy));
if length(trim(left(buyin_2y)))>=12 then do;
if indexc(substr(trim(left(buyin_2y)),(length(trim(left(buyin_2y)))-11),11),"0","1","2","A","B") then part_ab_1y=0;
if indexc(substr(trim(left(buyin_2y)),(length(trim(left(buyin_2y)))-11),11),"0","1","2","A","B")=0 then part_ab_1y=1;
end;
if length(trim(left(hmo_2y)))>=12 then do;
if index(substr(trim(left(hmo_2y)),(length(trim(left(hmo_2y)))-11),11),"00000000000") then hmo_1y=0;
if index(substr(trim(left(hmo_2y)),(length(trim(left(hmo_2y)))-11),11),"00000000000")=0 then hmo_1y=1;
end;
death_year=year(death_date2);
run;
proc freq;
table death_year*hmo_1y;
run;
proc sql outobs=100;
select hmo_2y,buyin_2y,count(*) from all_insurance2
where  part_ab_1y=1 and hmo_1y=1;
quit;

libname sas "C:\projects\Hospice_impact_on_utilization\final_data";


proc freq data=all_insurance2;
table hmo_1y;
run;
proc sql;
select count(*) from all_insurance2 where hmo_1y=1 ;
select count(*) from all_insurance2 where hmo_1y<1 and part_ab_1y<=0  ;
;quit;
/*4073-694=3379 , -285=3094,-25=3069*/
data sas.ids_meet_criteria_1y_0209_2012(drop=death_date2 birth_date2);
set all_insurance2;
if hmo_1y~=1;

if part_ab_1y ;

if death_date2>=mdy(01,01,2001);
if (death_date2-birth_date2)/365.25>=66;
bid_hrs=bid_hrs_10;
death_date_res=death_date;
death_date=death_date2;
birth_date_res=birth_date;
birth_date=birth_date2;
run;
proc contents data=sas.ids_meet_criteria_1y_0209_2012;
run;

ods rtf body ="&report_path.\hospice_impact_N_ids_eligible.rtf";
proc sql;
title "total N from exit 2002 to 2008";
select count(*) from exit.exit_2002_to_2008_id;


title "meet age>=66";
/*4665 meet the age >=66*/



select count(*) from exit_re2
where (death_date2-birth_date2)/365.25>=66;

/*4176 ids of 4665 has the cross walk ids.*/
title "have the corresponding cross walk bid-hrsid";


select count(*) from exit_re_age_ge66 
where id in 
(select id from BID_MTSI_1);



title "have dn information on last years insurance ";
select count(*) from all_insurance2;
title "those with hmo in the last 1 yr";
select count(*) from all_insurance2 where hmo_1y=1 ;
title "those without part a and part b in the whole last 1 year";
select count(*) from all_insurance2 where hmo_1y<1 and part_ab_1y<=0 ;
title "those who died before 01/01/2001 since the earliest available cms data is 2000";
select count(*) from all_insurance2 where hmo_1y<1 and part_ab_1y=1 and death_date2<mdy(01,01,2001);

title "final N, 4073-694-285-25=3069";
select count(*) from sas.ids_meet_criteria_1y_0209_2012; 
quit;
ods rtf close;


proc freq;
table death_year;
run;

/*to get the cost from cms claims data*/
*limit to those with 1 yr partab and no hmo;
* the bid list is in 
data sas.ids_meet_criteria_1y;

%macro mp(month_n=,days_start=,days_bef_death=,source=,equ=);
%let source0=mp;

proc sql;
create table &source._meet as select a.*,b.death_date
from medi.&source0._2000_2008(where=(trim(left(SSLSSNF))&equ.="N")) a inner join
sas.ids_meet_criteria_1y_0209_2012 b
on trim(left(a.bid_hrs))=trim(left(b.BID_hrs))
and &days_start<=b.death_date-a.admit_date<=&days_bef_death;
quit;

proc sql;
create table &source._meet2 as select a.*,b.death_date
from medi.&source0._2000_2008(where=(trim(left(SSLSSNF))&equ.="N")) a inner join
sas.ids_meet_criteria_1y_0209_2012 b
on trim(left(a.bid_hrs))=trim(left(b.BID_hrs))
and b.death_date-a.admit_date>&days_bef_death and b.death_date-a.disch_date<=&days_bef_death;
quit;

data &source._meet3;
set &source._meet2;
pct_6m=(disch_date-(death_date-&days_bef_death))/(disch_date-admit_date);
array list pmt_amt passthru;
do over list;
if list=. then list=0;
list=list*pct_6m;
end;
/*&source._paid_by_mc=(pmt_amt+passthru)*pct_6m;*/
run;

/*
adjust the inflation,
1.502	1999
1.447	2000
1.381	2001
1.314	2002
1.258	2003
1.198	2004
1.143	2005
1.098	2006
1.042	2007
1.000	2008

*/

data &source._cost;
set &source._meet &source._meet3;
array list pmt_amt passthru;
do over list;
if list=. then list=0;
end;
if year(admit_date)>=2008 then rate=1;
if year(admit_date)=2007 then rate=1.042;
if year(admit_date)=2006 then rate=1.098;
if year(admit_date)=2005 then rate=1.143;
if year(admit_date)=2004 then rate=1.198;
if year(admit_date)=2003 then rate=1.258;
if year(admit_date)=2002 then rate=1.314;
if year(admit_date)=2001 then rate=1.381;
if year(admit_date)=2000 then rate=1.447;
if year(admit_date)<=1999 then rate=1.502;


&source._paid_by_mc=rate*(pmt_amt+passthru);
run;

proc sql;
create table &source._pay as select distinct bid_hrs,sum(&source._paid_by_mc) as &source._paid_by_mc
from &source._cost group by bid_hrs;
quit;

proc sql;
create table &source as select
a.bid_hrs,a.id,coalesce(b.&source._paid_by_mc,0) as &source._paid_by_mc_1yr
from sas.ids_meet_criteria_1y_0209_2012 a
left join
 &source._pay b
 on trim(left(a.BID_hrs))=trim(left(b.bid_hrs));
 quit;

  proc sort data=&source ;
 by BID_hrs;
 run;
%mend;
;
%mp(days_start=0,days_bef_death=365,source=snf,equ= );


%mp(days_start=0,days_bef_death=365,source=ip,equ=~ );



%Macro all_other(source=,month_n=,days_start=,days_bef_death=);


proc sql;
create table &source._meet as select a.*
from medi.&source._2000_2008 a inner join
sas.ids_meet_criteria_1y_0209_2012 b
on trim(left(a.BID_hrs))=trim(left(b.BID_hrs))
and &days_start<=b.death_date-a.admit_date<=&days_bef_death;
quit;
data &source._meet2;
set &source._meet;
/*adjust to 2008 dollar*/
if year(admit_date)>=2008 then rate=1;
if year(admit_date)=2007 then rate=1.042;
if year(admit_date)=2006 then rate=1.098;
if year(admit_date)=2005 then rate=1.143;
if year(admit_date)=2004 then rate=1.198;
if year(admit_date)=2003 then rate=1.258;
if year(admit_date)=2002 then rate=1.314;
if year(admit_date)=2001 then rate=1.381;
if year(admit_date)=2000 then rate=1.447;
if year(admit_date)<=1999 then rate=1.502;

&source._paid_by_mc=rate*(pmt_amt);
run;

proc sql;
create table &source._pay as select distinct BID_hrs,sum(&source._paid_by_mc) as &source._paid_by_mc
from &source._meet2 group by BID_hrs;
quit;
proc sql;
create table &source&month_n as select
a.BID_hrs,coalesce(b.&source._paid_by_mc,0) as &source._paid_by_mc&month_n 
from sas.ids_meet_criteria_1y_0209_2012 a
left join
 &source._pay b
 on trim(left(a.BID_hrs))=trim(left(b.BID_hrs));
 quit;

 proc sort data=&source&month_n ;
 by BID_hrs;
 run;
 %mend;


 %all_other(source=hh,month_n=_1yr,days_start=0,days_bef_death=365);
  %all_other(source=hs,month_n=_1yr,days_start=0,days_bef_death=365);
   %all_other(source=dm,month_n=_1yr,days_start=0,days_bef_death=365);
    %all_other(source=op,month_n=_1yr,days_start=0,days_bef_death=365);
	 %all_other(source=pb,month_n=_1yr,days_start=0,days_bef_death=365);

	 data costs_all;
	 merge ip snf hh_1yr hs_1yr pb_1yr op_1yr dm_1yr;
	 by bid_hrs;
	 run;


%mp(days_start=0,days_bef_death=183,source=snf,equ= );
%mp(days_start=0,days_bef_death=183,source=ip,equ=~ );
%all_other(source=hh,month_n=_6m,days_start=0,days_bef_death=183);
  %all_other(source=hs,month_n=_6m,days_start=0,days_bef_death=183);
   %all_other(source=dm,month_n=_6m,days_start=0,days_bef_death=183);
    %all_other(source=op,month_n=_6m,days_start=0,days_bef_death=183);
	 %all_other(source=pb,month_n=_6m,days_start=0,days_bef_death=183);
	 

	 	 data costs_all_6m;
	 merge ip snf hh_6m hs_6m pb_6m op_6m dm_6m;
	 by bid_hrs;
	 run;

	 %mp(days_start=0,days_bef_death=91,source=snf,equ= );
%mp(days_start=0,days_bef_death=91,source=ip,equ=~ );
%all_other(source=hh,month_n=_3m,days_start=0,days_bef_death=91);
  %all_other(source=hs,month_n=_3m,days_start=0,days_bef_death=91);
   %all_other(source=dm,month_n=_3m,days_start=0,days_bef_death=91);
    %all_other(source=op,month_n=_3m,days_start=0,days_bef_death=91);
	 %all_other(source=pb,month_n=_3m,days_start=0,days_bef_death=91);
	 
	 	 data costs_all_3m(rename=(ip_paid_by_mc_1yr=ip_paid_by_mc_3m snf_paid_by_mc_1yr=snf_paid_by_mc_3m));
	 merge ip snf hh_3m hs_3m pb_3m op_3m dm_3m;
	 by bid_hrs;
	 run;
*add the wage index;

 data costs_all_6m2;
 set  costs_all_6m;
 rename ip_paid_by_mc_1yr=ip_paid_by_mc_6m snf_paid_by_mc_1yr=snf_paid_by_mc_6m;
data sas.cost_3m_6m;
merge costs_all_6m2 costs_all_3m;
 by bid_hrs;
	 run;



%macro mp(month_n=,days_start=,days_bef_death=,source=,equ=);
%let source0=mp;

proc sql;
create table &source._meet as select a.*,b.death_date
from medi.&source0._2000_2008(where=(trim(left(SSLSSNF))&equ.="N")) a inner join
sas.ids_meet_criteria_1y_0209_2012 b
on trim(left(a.BID_hrs))=trim(left(b.BID_hrs))
and &days_start<=b.death_date-a.admit_date<=&days_bef_death;
quit;

%mend;



%mp(month_n=12,days_start=0,days_bef_death=183,source=ip,equ=~ );
data ip_2;
set ip_meet;
if icarecnt=. then icarecnt=0;
if CRNRYDAY=. then CRNRYDAY=0;
icu_days=icarecnt+CRNRYDAY;
n_hospd=disch_date-admit_date;
run;


proc sql;
create table ip_3 as select distinct BID_hrs,sum(icu_days) as icu_days_6m label="total icu days in the last 6 mon"
,count(*) as n_ip_admit_6m label="total n of hospital admit in the last 6 mon",
sum(n_hospd) as n_hospd_6m label="total hospital days in the last 6 mon"
 from ip_2 group by BID_hrs;
quit;
proc sql;
create table icu_days_6m as select a.bid_hrs,coalesce(b.icu_days_6m,0) as icu_days_6m
label="total icu+ccu days in the last 6 mon",
case when icu_days_6m>0 then 1
else 0 end as icu_ind_6m 
label="any icu or ccu stay in the last 6 mon",
coalesce(b.n_ip_admit_6m,0) as n_ip_admit_6m label="total n of hospital admit in the last 6 mon",
coalesce(b.n_hospd_6m,0) as n_hospd_6m label="total hospital days in the last 6 mon"

from sas.ids_meet_criteria_1y_0209_2012 a 
left join 
ip_3 b
on trim(left(a.BID_hrs))=trim(left(b.BID_hrs));
quit;


proc freq;
table icu_ind_6m;
run;

/*end of the begin of use sean's code for av disease,icu days,hopital days, n hospital admit in the last 1yr
*/



/*hopice los in the last 1 yr*/


%macro mp(month_n=,days_start=,days_bef_death=,source=,equ=);
%let source0=hs;

proc sql;
create table &source._meet as select a.*,b.death_date
from medi.&source0._2000_2008 a inner join
sas.ids_meet_criteria_1y_0209_2012 b
on trim(left(a.BID_hrs))=trim(left(b.BID_hrs))
and &days_start<=b.death_date-a.admit_date<=&days_bef_death;
quit;

%mend;



%mp(month_n=12,days_start=0,days_bef_death=183,source=hs );
data hs_2;
set hs_meet;

n_hs_day=disch_date-admit_date;
run;
proc sql;
create table hs_3 as select distinct BID_hrs,sum(n_hs_day) as n_hs_day_6m label="total hospice days in the last 6 mon"

 from hs_2 group by BID_hrs;
quit;

proc sql;
create table sas.days_6m_for_hs as select a.*,coalesce(b.n_hs_day_6m,0) as n_hs_days_6m
label="total hospice days in the last 6 mon" from
icu_days_6m a 
left join 
hs_3 b
on trim(left(a.BID_hrs))=trim(left(b.BID_hrs));
quit;





%macro mp(month_n=,days_start=,days_bef_death=,source=,equ=);
%let source0=mp;

proc sql;
create table &source._meet as select a.*,b.death_date
from medi.&source0._2000_2008(where=(trim(left(SSLSSNF))&equ.="N")) a inner join
sas.ids_meet_criteria_1y_0209_2012 b
on trim(left(a.BID_hrs))=trim(left(b.BID_hrs))
and &days_start<=b.death_date-a.admit_date<=&days_bef_death;
quit;

%mend;



%mp(month_n=12,days_start=0,days_bef_death=91,source=ip,equ=~ );
data ip_2;
set ip_meet;
if icarecnt=. then icarecnt=0;
if CRNRYDAY=. then CRNRYDAY=0;
icu_days=icarecnt+CRNRYDAY;
n_hospd=disch_date-admit_date;
run;


proc sql;
create table ip_3 as select distinct BID_hrs,sum(icu_days) as icu_days_3m label="total icu days in the last 3 mon"
,count(*) as n_ip_admit_3m label="total n of hospital admit in the last 3 mon",
sum(n_hospd) as n_hospd_3m label="total hospital days in the last 3 mon"
 from ip_2 group by BID_hrs;
quit;
proc sql;
create table icu_days_3m as select a.bid_hrs,coalesce(b.icu_days_3m,0) as icu_days_3m
label="total icu+ccu days in the last 3 mon",
case when icu_days_3m>0 then 1
else 0 end as icu_ind_3m 
label="any icu or ccu stay in the last 3 mon",
coalesce(b.n_ip_admit_3m,0) as n_ip_admit_3m label="total n of hospital admit in the last 3 mon",
coalesce(b.n_hospd_3m,0) as n_hospd_3m label="total hospital days in the last 3 mon"

from sas.ids_meet_criteria_1y_0209_2012 a 
left join 
ip_3 b
on trim(left(a.BID_hrs))=trim(left(b.BID_hrs));
quit;


proc freq;
table icu_ind_3m;
run;

/*end of the begin of use sean's code for av disease,icu days,hopital days, n hospital admit in the last 1yr
*/



/*hopice los in the last 1 yr*/


%macro mp(month_n=,days_start=,days_bef_death=,source=,equ=);
%let source0=hs;

proc sql;
create table &source._meet as select a.*,b.death_date
from medi.&source0._2000_2008 a inner join
sas.ids_meet_criteria_1y_0209_2012 b
on trim(left(a.BID_hrs))=trim(left(b.BID_hrs))
and &days_start<=b.death_date-a.admit_date<=&days_bef_death;
quit;

%mend;



%mp(month_n=12,days_start=0,days_bef_death=91,source=hs );
data hs_2;
set hs_meet;

n_hs_day=disch_date-admit_date;
run;
proc sql;
create table hs_3 as select distinct BID_hrs,sum(n_hs_day) as n_hs_day_3m label="total hospice days in the last 3 mon"

 from hs_2 group by BID_hrs;
quit;

proc sql;
create table sas.days_3m_for_hs as select a.*,coalesce(b.n_hs_day_3m,0) as n_hs_days_3m
label="total hospice days in the last 3 mon" from
icu_days_3m a 
left join 
hs_3 b
on trim(left(a.BID_hrs))=trim(left(b.BID_hrs));
quit;



/*AFTER THE test,the bid id cross walk is different for 2008 medi care data than 
previous 2007 medi care data, so we need to wait for they send us the new bid-id*/




 *core hrs00.core_00_to_08;

 options fmterr=no;

libname hrs00 "C:\hrs2000\sas";
proc contents data=hrs00.core_00_to_08;
run;


data core1;
set hrs00.core_00_to_08;
id=hhid*1000+pn;
*keep id merged_year &list_raw;
if id>0;
run;
proc sort data=core1 out=core1_1 nodupkey;
by id merged_year;
run;
/*amy mentioned that negative 1 core is always like,
2008 at exit,then negative 1 core=2006 core,
negative 2 core=2004 core,
2002 at exit,negative 1 core is 2000 core,
negative 2 core is 1998 core,
up to 01/30/2012,we didn't organize 1998 core data yet*/
proc sql;
create table merge_core1(drop=id2 merge_year merged_year2) as select a.id,a.merge_year,b.*
from exit.exit_2002_to_2008_id(keep=id merge_year) a left join
core1_1(rename=(id=id2 merged_year=merged_year2)) b on
a.id=b.id2 and a.merge_year=b.merged_year2+2;
quit;

proc sql;
create table merge_core2_0(drop=id2 merged_year2) as select a.id,a.merge_year,b.*
from exit.exit_2002_to_2008_id(keep=id merge_year) a left join
core1_1(rename=(id=id2 merged_year=merged_year2)) b on
a.id=b.id2 and a.merge_year=b.merged_year2+4;
quit;

/*
The RAND HRS Data file (Version L) is based on 1992(wave1, 1993(wave1), 1994(wave2, 1995(wave2, 1996(wave3, 1998(wave4, 2000, 2002, 2004, 2006, 2008, and 2010 early release data of HRS.;
 1998 corresponds to X=4. 
(X=1 is 1992, X=2 is 1994, X=3 is 1996)
*/
libname dd "C:\projects\Hospice_impact_on_utilization\raw_data";
option fmterr=no;
proc sql outobs=10;
select R6ADLA from dd.rndhrs_l;
quit;

data rndhrs_l;*(keep=id adl_cat_core);
set dd.rndhrs_l(keep=hhidpn R4ADLA);
id=hhidpn+0;
if R4ADLA in (0) then adl_cat_core=0;
if R4ADLA in (1,2,3) then adl_cat_core=1;
if R4ADLA>=4 then adl_cat_core=2;
run;
proc contents;
run;
proc freq;
table R6ADLA  adl_cat_core;
run;

proc sql;
create table merge_core2_1 as select a.*,b.adl_cat_core as adl_98
from merge_core2_0 a left join
rndhrs_l b on
a.id=b.id ;
quit;
proc freq;
table merge_year*adl_98;
run;

proc sql outobs=20;
select merge_year,adl_cat_core , adl_98 from merge_core2_1
where merge_year=2002;
quit;

data merge_core2(drop= adl_98);
set merge_core2_1;
if merge_year=2002 then adl_cat_core=adl_98;
run;
proc freq data=merge_core2_1;
table merge_year;
run;
proc freq data=merge_core2_1;
table merge_year*adl_cat_core/missing;
run; 
proc freq data=merge_core2;
table merge_year*adl_cat_core/missing;
run; 


proc import datafile="C:\projects\Hospice_impact_on_utilization\raw_data\exit_02_08_01232012.dta"
out=merge_exit_0 replace;
run;

proc contents data=merge_exit_0 out=vars_exit noprint;
run;

data vars_exit1;
set vars_exit(obs=96);
run;
proc sql;
select name into:var_name separated by " " from vars_exit1;
quit;
%put &var_name;
data merge_exit;
set merge_exit_0;
keep &var_name;
run;


/* Running the renaming macro */
*options macrogen mprint mlogic;
%macro rename(lib,dsn,pre);
options pageno=1 nodate;
proc contents data=&lib..&dsn;
title "Before Renaming All Variables";
run;
proc sql noprint;
select nvar into :num_vars
from dictionary.tables
where libname="&LIB" and
memname="&DSN";
select distinct(name) into :var1-
:var%TRIM(%LEFT(&num_vars))
from dictionary.columns
where libname="&LIB" and
memname="&DSN";
quit;
run;
proc datasets library=&LIB;
modify &DSN;
rename
%do i=1 %to &num_vars;
&&var&i=&&var&i.&&pre.
%end;
;
quit;
run;
options pageno=1 nodate;
proc contents data=&lib..&dsn;
title "After Renaming All Variables";
run;
%mend rename;
%rename(WORK,MERGE_CORE1,_c1);
%rename(WORK,MERGE_CORE2,_c2);

%rename(WORK,MERGE_EXIT,_x);






proc sql;
create table neg_core1_core2 as select 
* from MERGE_CORE1 a
left join
MERGE_CORE2 b
on a.id_c1=b.id_c2;
quit;

proc sql;
create table neg_core1_core2_exit as select 
* from neg_core1_core2 a
left join
MERGE_EXIT b
on a.id_c1=b.id_x;
quit;

proc contents data=merge_core1;
run;




data neg_core1_core2_adl_change(rename=(adl_stable_ind=adl_stable_ind_c1c2
adl_stable_partial =adl_stable_partial_c1c2
adl_stable_severe= adl_stable_severe_c1c2
adl_change_i_m= adl_change_i_m_c1c2
adl_change_i_s=adl_change_i_s_c1c2
adl_change_m_s= adl_change_m_s_c1c2
adl_improved=adl_improved_c1c2));
set neg_core1_core2_exit;

/*generate adl_stable_ind=0
replace adl_stable_ind=1 if ((adl_cat==0) & (adl_cat_core==0))
* to account from those who improved from moderate to independent (overlap with adl_improved)
replace adl_stable_ind=1 if ((adl_cat==0) & (adl_cat_core==1 | adl_cat_core==2))

generate adl_stable_partial=0
replace adl_stable_partial=1 if ((adl_cat==1) & (adl_cat_core==1))
* to account from those who improved from severe to moderate (overlap with adl_improved)
replace adl_stable_partial=1 if ((adl_cat==1) & (adl_cat_core==2))

generate adl_stable_severe=0
replace adl_stable_severe=1 if ((adl_cat==2|adl_cat==3) & (adl_cat_core==2))

generate adl_change_i_m=0
replace adl_change_i_m=1 if ((adl_cat==1) & (adl_cat_core==0))

generate adl_change_i_s=0
replace adl_change_i_s=1 if ((adl_cat==2|adl_cat==3) & (adl_cat_core==0))

generate adl_change_m_s=0
replace adl_change_m_s=1 if ((adl_cat==2|adl_cat==3)& (adl_cat_core==1))

generate adl_improved=0
replace adl_improved=1 if ((adl_cat==1) & (adl_cat_core==2))
replace adl_improved=1 if ((adl_cat==0) & (adl_cat_core==1 | adl_cat_core==2))*/

adl_stable_ind=0;
if ((adl_cat_core_c1=0) & (adl_cat_core_c2=0)) then adl_stable_ind=1 ;
* to account from those who improved from moderate to independent (overlap with adl_improved);
if ((adl_cat_core_c1=0) & (adl_cat_core_c2=1 | adl_cat_core_c2=2)) then adl_stable_ind=1 ;

adl_stable_partial=0;
if ((adl_cat_core_c1=1) & (adl_cat_core_c2=1)) then adl_stable_partial=1 ;;
* to account from those who improved from severe to moderate (overlap with adl_improved);
if ((adl_cat_core_c1=1) & (adl_cat_core_c2=2)) then adl_stable_partial=1 ;

adl_stable_severe=0;
 if ((adl_cat_core_c1=2|adl_cat_core_c1=3) & (adl_cat_core_c2=2)) then adl_stable_severe=1;

adl_change_i_m=0;
if ((adl_cat_core_c1=1) & (adl_cat_core_c2=0)) then adl_change_i_m=1 ;

adl_change_i_s=0;
if ((adl_cat_core_c1=2|adl_cat_core_c1=3) & (adl_cat_core_c2=0)) then adl_change_i_s=1 ;

adl_change_m_s=0;
if ((adl_cat_core_c1=2|adl_cat_core_c1=3)& (adl_cat_core_c2=1)) then adl_change_m_s=1 ;

adl_improved=0;
 if ((adl_cat_core_c1=1) & (adl_cat_core_c2=2)) then adl_improved=1;
if ((adl_cat_core_c1=0) & (adl_cat_core_c2=1 | adl_cat_core_c2=2)) then adl_improved=1 ;
array list adl_stable_ind adl_stable_partial adl_stable_severe adl_change_i_m adl_change_i_s adl_change_m_s adl_improved;
do over list;
if adl_cat_core_c1=. or  adl_cat_core_c2=.  then list=.;
end;



run;

proc freq;
table adl_stable_ind_c1c2;
run;





data neg_core1_core2_exit_adl_change
(rename=( adl_stable_ind=adl_stable_ind_xc1
adl_stable_partial =adl_stable_partial_xc1
adl_stable_severe= adl_stable_severe_xc1
adl_change_i_m= adl_change_i_m_xc1
adl_change_i_s=adl_change_i_s_xc1
adl_change_m_s= adl_change_m_s_xc1
adl_improved=adl_improved_xc1));
set neg_core1_core2_adl_change;

/*generate adl_stable_ind=0
replace adl_stable_ind=1 if ((adl_cat==0) & (adl_cat_core==0))
* to account from those who improved from moderate to independent (overlap with adl_improved)
replace adl_stable_ind=1 if ((adl_cat==0) & (adl_cat_core==1 | adl_cat_core==2))

generate adl_stable_partial=0
replace adl_stable_partial=1 if ((adl_cat==1) & (adl_cat_core==1))
* to account from those who improved from severe to moderate (overlap with adl_improved)
replace adl_stable_partial=1 if ((adl_cat==1) & (adl_cat_core==2))

generate adl_stable_severe=0
replace adl_stable_severe=1 if ((adl_cat==2|adl_cat==3) & (adl_cat_core==2))

generate adl_change_i_m=0
replace adl_change_i_m=1 if ((adl_cat==1) & (adl_cat_core==0))

generate adl_change_i_s=0
replace adl_change_i_s=1 if ((adl_cat==2|adl_cat==3) & (adl_cat_core==0))

generate adl_change_m_s=0
replace adl_change_m_s=1 if ((adl_cat==2|adl_cat==3)& (adl_cat_core==1))

generate adl_improved=0
replace adl_improved=1 if ((adl_cat==1) & (adl_cat_core==2))
replace adl_improved=1 if ((adl_cat==0) & (adl_cat_core==1 | adl_cat_core==2))*/

adl_stable_ind=0;
if ((adl_cat_x=0) & (adl_cat_core_c1=0)) then adl_stable_ind=1 ;
* to account from those who improved from moderate to independent (overlap with adl_improved);
if ((adl_cat_x=0) & (adl_cat_core_c1=1 | adl_cat_core_c1=2)) then adl_stable_ind=1 ;

adl_stable_partial=0;
if ((adl_cat_x=1) & (adl_cat_core_c1=1)) then adl_stable_partial=1 ;;
* to account from those who improved from severe to moderate (overlap with adl_improved);
if ((adl_cat_x=1) & (adl_cat_core_c1=2)) then adl_stable_partial=1 ;

adl_stable_severe=0;
 if ((adl_cat_x=2|adl_cat_x=3) & (adl_cat_core_c1=2)) then adl_stable_severe=1;

adl_change_i_m=0;
if ((adl_cat_x=1) & (adl_cat_core_c1=0)) then adl_change_i_m=1 ;

adl_change_i_s=0;
if ((adl_cat_x=2|adl_cat_x=3) & (adl_cat_core_c1=0)) then adl_change_i_s=1 ;

adl_change_m_s=0;
if ((adl_cat_x=2|adl_cat_x=3)& (adl_cat_core_c1=1)) then adl_change_m_s=1 ;

adl_improved=0;
 if ((adl_cat_x=1) & (adl_cat_core_c1=2)) then adl_improved=1;
if ((adl_cat_x=0) & (adl_cat_core_c1=1 | adl_cat_core_c1=2)) then adl_improved=1 ;
array list adl_stable_ind adl_stable_partial adl_stable_severe adl_change_i_m adl_change_i_s adl_change_m_s adl_improved;
do over list;
if adl_cat_x=. or  adl_cat_core_c1=.  then list=.;
end;




run;

data sas.neg_core1_core2_exit_adl_change;
set neg_core1_core2_exit_adl_change;
run;

*ods rtf body="&report_path.\freq_core1_core2_exit_02012012.rtf";
ods rtf body="&report_path.\freq_core1_core2_exit_02022012.rtf";
proc freq data=sas.neg_core1_core2_exit_adl_change;
table adl_stable_ind_c1c2 adl_stable_ind_xc1
adl_stable_partial_c1c2 adl_stable_partial_xc1
adl_stable_severe_c1c2  adl_stable_severe_xc1
adl_change_i_m_c1c2  adl_change_i_m_xc1
adl_change_i_s_c1c2 adl_change_i_s_xc1
adl_change_m_s_c1c2  adl_change_m_s_xc1
adl_improved_c1c2 adl_improved_xc1;
run;
ods rtf close;

proc freq data=neg_core1_core2_exit_adl_change(where=(adl_change_m_s_c1c2=.));
table merge_year_x;
run;


*get the zipcode from restricted file based on exit year or the one next to exit year;
proc sql;
create table id_zip as select * from
 exit.exit_2002_to_2008_id(keep=id merge_year) a
 left join
 hrs_dod_dob_race(drop=id hhid pn) b
 on a.id=b.id_n;
 quit;

 proc contents data=hrs_dod_dob_race;
 run;

* note only one id is suing the -1 wave exit since the zip at exit year is not available.,
 more geographic informaitn needed, such as state,urban,tract;
 data id_zip2;
 set id_zip;

 zip_exit=vvaluex("zip"||substr(trim(left(merge_year)),3,2) );
if zip_exit="" then zip_exit=vvaluex("zip"||substr(trim(left(merge_year-2)),3,2) );

run;

proc sql;
select zip08,zip02  from id_zip2
 where zip_exit is null;
 quit;
 proc sql outobs=10;
select zip_exit  from id_zip2
;
 quit;
 data id_zip3;
 set id_zip2;
 zip_exit_n=zip_exit+0;
 run;

* 1.use the zip to get cbsa wage index,to get the hrr index,eol intensity,
 hospital beds,or other reatlated information;
*,zipcode07
hrrnum;


 libname x "C:\projects\Hospice_impact_on_utilization\raw_data";
 data zip_cb;
 set x.xtract;
 zip_n=zip5+0;
 cbsa_n=cbsa+0;
 if zip_n~=.;
 state_n=state+0;
 run;

 proc sort data=zip_cb out=zip_cb2 nodupkey;
 by zip5 cbsa;
 run;

proc sql;
select zip5, cbsa from zip_cb2
where cbsa_n in (40380);
quit;
/*
filename inf 'C:\Documents and Settings\duq01\Desktop\du\amy\data\cms\CBSA_ZIP_092010.dbf';

proc dbf db4=inf out=cbsa_zip;
run; 
/*note several zip  have multiple cbsa
proc sort data=cbsa_zip out=cbsa_zip_final nodupkey;
by zip;
run;
proc sort data=cbsa_zip out=temp2 nodupkey;
by zip cbsa;
run;
proc sql;
select zip, cbsa from cbsa_zip_final2
where cbsa_n in (40380);
quit;

data cbsa_zip_final2;
set cbsa_zip ;
cbsa_n=cbsa+0;
zip_n=zip+0;
if zip_n~=.;
run;
*/
proc sql;
select zip,cbsa from cbsa_zip group by zip having count(*)>1 
order by zip,cbsa;
quit;

/*one zipcode can have only one cbsa*/
*to import the wage index from cms.;
 proc import datafile="C:\projects\Hospice_impact_on_utilization\raw_data\wage_index_cbsa_2008.xls"  out=wage_index 
replace;
run;
data wage_index2;
set wage_index;
cbsa_n=cbsa_code+0;
if trim(left(cbsa_code))~="";
wage_index_2008=Full_Wage_Index_;
if index(trim(left(Urban_Area_Title)),", MA")>0 then MA=1;
if index(trim(left(Urban_Area_Title)),", NJ")>0 then NJ=1;
if index(trim(left(Urban_Area_Title)),", RI")>0 then RI=1;
if state_in_wage_index=25 then wage_index_2008=1.0953286; 
if state_in_wage_index=34 then wage_index_2008=1.092057; 
if state_in_wage_index=44 then wage_index_2008=1.0783000
; 
run;
proc freq data=wage_index2(where=(ri=1));
table Urban_Area_Title;
run;
%let var=ri;
proc means data=wage_index2;
class &var;
var wage_index_2008;
run;

proc sql; 
select count(distinct cbsa) from cbsa_zip;
select count(distinct zip_exit_n) from id_zip3
where zip_exit_n not in 
(select zip_n from cbsa_zip_final2);
quit;


proc sql; 

select distinct zip_exit_n from id_zip3
where zip_exit_n not in 
(select zip_n from zip_cb2);
quit;

proc sql;
select count(*) from wage_index2
where cbsa=.;
select count(*) from wage_index2
where cbsa_code is null;
quit;
proc sql;
create table zip_cbsa_wage_index 
as select a.*,b.wage_index_2008
from
 zip_cb2 a
left join
wage_index2 b
on a.cbsa_n=b.cbsa_n;
quit;
proc sort data=zip_cbsa_wage_index out=zip_cbsa_wage_index2 nodupkey;
by zip_n;
run;

proc sql;
create table id_wage_index 
as select a.*,b.wage_index_2008,b.state_n
from
id_zip3 a
left join
zip_cbsa_wage_index2 b
on a.zip_exit_n=b.zip_n;
quit;

proc sort data=wage_index2 out=wage_index3 nodupkey;
by state_in_wage_index;
run;

proc sql;
create table id_wage_index2 
as select a.*,coalesce(a.wage_index_2008,b.wage_index_2008) as wage_index_20082
from
id_wage_index a
left join
wage_index3 b
on a.state_n=b.state_in_wage_index;
quit;
proc means;
var wage_index_2008 wage_index_20082;
run;

proc sql;
select distinct state_n ,count(*) from id_wage_index2
where wage_index_20082=. group by state_n;
quit;
proc sql;
select distinct zip_exit_n ,count(*) from id_wage_index2
where wage_index_20082=. group by zip_exit_n;
quit;


proc contents data=id_wage_index2;
run;
proc sql;
create table id_cost_wage as select a.*,b.wage_index_20082 as wage_index_2008
from costs_all a left join
id_wage_index2 b 
on 
a.id=b.id;
quit;


data sas.id_cost_wage2;
set id_cost_wage;
array list ip_paid_by_mc_1yr op_paid_by_mc_1yr snf_paid_by_mc_1yr
pb_paid_by_mc_1yr hh_paid_by_mc_1yr hs_paid_by_mc_1yr dm_paid_by_mc_1yr
;
do over list;
if wage_index_2008~=. then do;
list=list/wage_index_2008;
end;
end;
tot_paid_by_mc_1yr=sum( of ip_paid_by_mc_1yr op_paid_by_mc_1yr snf_paid_by_mc_1yr
pb_paid_by_mc_1yr hh_paid_by_mc_1yr hs_paid_by_mc_1yr dm_paid_by_mc_1yr)
;
run;

ods rtf body="&report_path.\costs_0210_2012.rtf";
proc means data=sas.id_cost_wage2(drop=bid_hrs id);
var _all_;
run;

ods rtf close;


* to get the dx in the last 1 yr.;


proc means;
var wage_index_2008;
run;

/*19 ids lack wage_index*/

*
select 
* the unfound zip-cbsa can be found on
http://www.zip-codes.com/zip-code/85286/zip-code-85286.asp
   78542         1  32580(cbsa)
                                            85286         1   38060(cbsa)

;


proc means;
var wage_index_2008 wage_index_20082;
run;











 proc import datafile="C:\projects\Hospice_impact_on_utilization\raw_data\ZipHsaHrr07.xls"  out=zip_hrr 
replace;
run;
proc contents data=zip_hrr;
run;
/*44 ids without zipcode from ZipHsaHrr07 ,38 ids with zip=99999 or 0*/
proc sql;
select distinct zip_exit_n ,count(*) from id_zip3 where zip_exit_n not in
(select zipcode07 from zip_hrr ) group by zip_exit_n;
quit;
proc sql;
select count(*) from id_zip3 where zip_exit_n not in
(select zipcode07 from zip_hrr );
quit;
proc sql;
create table id_zip_hrr as
select a.*,b.hrrnum from
id_wage_index2 a left join
zip_hrr b
on a.zip_exit_n=b.zipcode07;
quit;
proc means ;
var hrrnum;
run;
 proc import datafile="C:\projects\Hospice_impact_on_utilization\raw_data\hci_hrr.xls"  out=hrr_hci_index 
replace;
run;

proc sql;
create table id_zip_hrr_hci as select a.*,b.hci_index
from id_zip_hrr a 
left join
hrr_hci_index b
on a.hrrnum=b.geoid;
quit;
proc means ;
var hci_index;
run;
/*to make certain what they represents for per capital,
Acute Care Hospital Beds per 1,000 Residents (2006)
Total Physicians per 100,000 Residents (2006)
Medical Specialists per 100,000 Residents (2006)
Primary Care Physicians per 100,000 Residents (2006)
Total Specialists per 100,000 Residents (2006)
*/
 proc import datafile="C:\projects\Hospice_impact_on_utilization\raw_data\HRR_data_beds_specialist_per_capital.xls"  out=hrr_beds_per_capital 
replace;
run;
proc contents ;
run;
data hrr_beds_per_capital2;
set hrr_beds_per_capital;
label hospital_beds="Acute Care Hospital Beds per 1,000 Residents,2006,at hrr";
label Medical_Specialists="Medical_Specialists per 100,000 Residents,2006,at hrr";
label Physicians
="Physicians per 100,000 Residents,2006,at hrr";
label Primary_Care="Primary_Care per 100,000 Residents,2006,at hrr";
label Specialists="Total Specialists per 100,000 Residents,2006,at hrr";
run;
proc sort data=hrr_beds_per_capital2 out=hrr_beds_per_capital3 nodupkey;
by hrr;
run;

proc sql;
create table id_zip_hrr_hci_bed(drop=hrr) as select *
from id_zip_hrr_hci  a 
left join
hrr_beds_per_capital3 b
on a.hrrnum=b.hrr;
quit;
proc means ;
var hospital_beds;
run;
 proc import datafile="C:\projects\Hospice_impact_on_utilization\raw_data\Hrr_eol_ei_annals_2003.xls"  out=hrr_eol 
replace;
run;
proc sql;
create table id_zip_hrr_hci_bed_eol as select a.*,b.Quintile_of_Intensity as Quintile_of_eol
from id_zip_hrr_hci_bed a 
left join
hrr_eol b
on a.hrrnum=b.hrr_number;
quit;

* 48 pct_pal_hrr        Num    8                   pct of  hospitals with Pal care at HRR level
canypal
 47 pct_teach_hrr      Num    8                   pct of teaching hospitals at HRR level
medsch
canypal
med.no_exclusions2
hrr:hrrcode;
;
libname med "C:\projects\Hospice_impact_on_utilization\raw_data";
proc contents data=med.no_exclusions2;
run;
proc sql outobs=10;
select distinct canypal from med.no_exclusions2;
quit;
proc freq data=med.no_exclusions2;
table canypal uanypal medsch;
run;

data no_exclusions2;
set med.no_exclusions2;
hrrnum=hrrcode+0;
run;
proc sql;
create table pct_pal_hrr as
select distinct hrrnum,sum(canypal)/count(*)*100 as pct_pal_hrr from no_exclusions2
where hrrnum~=. and canypal~=. group by hrrnum;
quit;
proc means;
var pct_pal_hrr;
run;
proc sql;
create table pct_teach_hrr as
select distinct hrrnum,sum(medsch)/count(*)*100 as pct_teach_hrr from no_exclusions2
where hrrnum~=. and medsch~=. group by hrrnum;
quit;
proc means;
var pct_teach_hrr;
run;

proc sql;
create table id_zip_hrr_hci_bed_eol_2 as select a.*,b.pct_pal_hrr
from id_zip_hrr_hci_bed_eol a 
left join
pct_pal_hrr b
on a.hrrnum=b.hrrnum;
quit;
proc sql;
create table sas.id_zip_hrr_hci_bed_eol_3(drop=death_date) as select a.*,b.pct_teach_hrr
from id_zip_hrr_hci_bed_eol_2 a 
left join
pct_teach_hrr b
on a.hrrnum=b.hrrnum;
quit;

proc contents ;
run;




 * use 21 chronic icd9-9 code to get cms conditins
 or use sean's code for av disease;



/*the begin of use sean's code for av disease,icu days,hopital days, n hospital admit in the last 1yr
*/




/*get all dx for all sources;
dm,PDGNS_CD,DGNS_CD1-,Claim Diagnosis Code
where { x } ranges from 1 to 4


hh,PDGNS_CD,DGNSCD01-DGNSCD10,where { x } ranges from 1 to 10

hs,PDGNS_CD,DGNSCD01-DGNSCD10 Claim Diagnosis Code
where { x } ranges from 1 to 10

mp,AD_DGNS,DGNS_CD01-DGNS_CD10{x} MEDPAR Diagnosis Code
where { x } 1:10

op,PDGNS_CD,DGNSCD01-DGNSCD10  NCH Diagnosis Trailer Indicator Code
where { x } ranges from 1 to 10

pb,PDGNS_CD,DGNS_CD1-DGNS_CD4 Claim Diagnosis Code
where { x } ranges from 1 to 4
*/




libname sas "C:\projects\Hospice_impact_on_utilization\final_data";

%let source0=pb;


data temp;
set medi.&source0._2000_2008(obs=20);
keep AD_DGNS PDGNS_CD DGNs:;
run;
proc print ;
run;


%macro other(days_start=,days_bef_death=,source=);

proc sql;
create table &source._meet as select a.*,b.death_date
from medi.&source._2000_2008 a inner join
sas.ids_meet_criteria_1y_0209_2012 b
on trim(left(a.bid_hrs))=trim(left(b.bid_hrs))
and &days_start<=b.death_date-a.admit_date<=&days_bef_death;
quit;

/*&source._paid_by_mc=(pmt_amt+passthru)*pct_6m;*/
run;

%mend;

%macro mp(days_start=,days_bef_death=,source=);
%let source0=mp;

proc sql;
create table &source._meet as select a.*,b.death_date
from medi.&source0._2000_2008 a inner join
sas.ids_meet_criteria_1y_0209_2012 b
on trim(left(a.bid_hrs))=trim(left(b.bid_hrs))
and &days_start<=b.death_date-a.admit_date<=&days_bef_death;
quit;

proc sql;
create table &source._meet2 as select a.*,b.death_date
from medi.&source0._2000_2008 a inner join
sas.ids_meet_criteria_1y_0209_2012 b
on trim(left(a.bid_hrs))=trim(left(b.bid_hrs))
and b.death_date-a.admit_date>&days_bef_death and b.death_date-a.disch_date<=&days_bef_death;
quit;

data &source._meet3;
set &source._meet &source._meet2;
run;

/*&source._paid_by_mc=(pmt_amt+passthru)*pct_6m;*/
run;

%mend;

%mp(days_start=0,days_bef_death=183,source=mp );
%other(days_start=0,days_bef_death=183,source=hh );
%other(days_start=0,days_bef_death=183,source=hs );
%other(days_start=0,days_bef_death=183,source=dm );
%other(days_start=0,days_bef_death=183,source=op );
%other(days_start=0,days_bef_death=183,source=pb );
options compress=yes;
data pb_last_6m_dx(keep=bid_hrs diag);
set pb_meet(keep=bid_hrs PDGNS_CD DGNS_CD1-DGNS_CD4 );
array dx PDGNS_CD DGNS_CD1-DGNS_CD4;
do over dx;
diag=dx ;
output;
end;
run;
proc sort data=pb_last_6m_dx out=pb_last_6m_dx2 nodupkey;
by bid_hrs diag;
run;



data op_last_6m_dx(keep=bid_hrs diag);
set op_meet(keep=bid_hrs PDGNS_CD DGNSCD01-DGNSCD10  );
array dx PDGNS_CD DGNSCD01-DGNSCD10 ;
do over dx;
diag=dx ;
output;
end;
run;
proc sort data=op_last_6m_dx out=op_last_6m_dx2 nodupkey;
by bid_hrs diag;
run;

data mp_last_6m_dx(keep=bid_hrs diag);
set mp_meet3(keep=bid_hrs AD_DGNS DGNS_CD01-DGNS_CD10 );
array dx AD_DGNS DGNS_CD01-DGNS_CD10 ;
do over dx;
diag=dx ;
output;
end;
run;
proc sort data=mp_last_6m_dx out=mp_last_6m_dx2 nodupkey;
by bid_hrs diag;
run;

data dm_last_6m_dx(keep=bid_hrs diag);
set dm_meet(keep=bid_hrs PDGNS_CD DGNS_CD1-DGNS_CD4 );
array dx PDGNS_CD DGNS_CD1-DGNS_CD4 ;
do over dx;
diag=dx ;
output;
end;
run;
proc sort data=dm_last_6m_dx out=dm_last_6m_dx2 nodupkey;
by bid_hrs diag;
run;


data hh_last_6m_dx(keep=bid_hrs diag);
set hh_meet(keep=bid_hrs PDGNS_CD DGNSCD01-DGNSCD10 );
array dx PDGNS_CD DGNSCD01-DGNSCD10 ;
do over dx;
diag=dx ;
output;
end;
run;
proc sort data=hh_last_6m_dx out=hh_last_6m_dx2 nodupkey;
by bid_hrs diag;
run;


data hs_last_6m_dx(keep=bid_hrs diag);
set hs_meet(keep=bid_hrs PDGNS_CD DGNSCD01-DGNSCD10 );
array dx PDGNS_CD DGNSCD01-DGNSCD10 ;
do over dx;
diag=dx ;
output;
end;
run;
proc sort data=hs_last_6m_dx out=hs_last_6m_dx2 nodupkey;
by bid_hrs diag;
run;



data dx_all_last_6m_0106_2011;
set hs_last_6m_dx2
hh_last_6m_dx2
mp_last_6m_dx2
dm_last_6m_dx2
op_last_6m_dx2
pb_last_6m_dx2;
run;
proc sort data=dx_all_last_6m_0106_2011(where=(diag~="")) out=dx_all_last_6m_0106_2011 nodupkey;
by bid_hrs diag;
run;
proc transpose data=dx_all_last_6m_0106_2011 out=wide prefix=dx;
  by bid_hrs;
  var diag;
run;
data wide2(drop=dx1-dx156);
set wide;
  array dxarr  dx1-dx156;

  ** get preliminary disease flags **;
  any_copdchf=0; any_hiv=0; anyhiv_2nd_ds=0; anyhiv_2nd_ca=0; any_copd=0; any_chf=0;
  ca_solid=0; ca_cns=0; any_ca_pancreas=0; any_ca_headneck=0; any_melanoma=0; any_ca_local=0;
ALS=0;  
  cirrhosis=0;

  do over dxarr;
   if trim(left(dxarr))~="" then do;
    if anyalpha( substr( trim(left(dxarr)) ,1,1 ) )=0 then
    do;
       dx3dgt=substr(dxarr,1,3);
       dx4dgt=substr(dxarr,1,4);
	   dx3num=dx3dgt+0;
       if dx3dgt='428' then any_chf=1;
       if dx3dgt in('490','491','492','493','494','495','496')
	     then any_copd=1;
         if any_chf | any_copd then any_copdchf=1;
	   if dx3dgt='196' then any_advca=1;
	   if dx3dgt='042' then any_hiv=1;
	   if 140<= dx3num <=208 or 235<= dx3num <=239 then anyhiv_2nd_ca=1;
	     else if dx4dgt in('5712','5715','5716','7994') then anyhiv_2nd_ds=1;
	   if dx3dgt in('197','198') then ca_solid=1;
	   if dx3dgt='191' then ca_cns=1;
	   if 141<= dx3num <=148 then any_ca_headneck=1;
	   if dx3dgt='172' then any_melanoma=1;
	   if dx3dgt='157' then any_ca_pancreas=1;
       if dx3dgt='196' then any_ca_local=1;  ** locally advanced ca (lymph node involvement) **;
if trim(left(dxarr))="33520" then ALS=1;
if trim(left(dxarr)) in ("5712","5715","5716","5723") then cirrhosis=1;
end;
  end;
  end;

  ** adv disease flags for dx dependent diseases (not copdchf) **;
  ca_mmela=(any_melanoma & any_ca_local);
  ca_hdnck=(any_ca_headneck & any_ca_local);
  ca_pancr=(any_ca_pancreas & any_ca_local);
  hiv_aids=(any_hiv & (anyhiv_2nd_ca | anyhiv_2nd_ds));

  adv_ca=(ca_solid | ca_cns | ca_mmela | ca_hdnck | ca_pancr);
  
  
  /*
(1) metastatic solid tumor,
(2) central nervous system (CNS) malignancies, 
(3) metastatic melanoma, 
(4) locally advanced head and neck cancer, 
(5) locally advanced pancreatic cancer,
(6) human immunodeficiency virus/acquired immune deficiencty syndrome (HIV/AIDS) and at least one of the following secondary diagnoses: hepatoma, cirrhosis, lymphoma, cachexia, or other cancer,
 (7) congestive heart failure (CHF) or chronic obstructive pulmonary disease (COPD) and either two or more hospitalizations in any 6 months of the study period or one or more ICU admissions for CHF or COPD during the study period.

I suspect it's impossible to get ICU use from claims so if you could pull the CHF and COPD group just with 2 or more admissions within the past 6 month, that would be great.

Additionally, could I ask you to add the following additional categories.

(8)  ALS  335.20
(9) Liver disease with cirrhosis  571.2, 571.5, 571.6, 572.3

  (8)  ALS  335.20
(9) Liver disease with cirrhosis  571.2, 571.5, 571.6, 572.3
  */



drop dx3dgt dx4dgt dx3num;
RUN;

proc freq;
table cirrhosis any:;
run;


proc sql;
create table bid_dx_last6m(drop=_name_) as select a.bid_hrs,b.*
from 
sas.ids_meet_criteria_1y_0209_2012 a
left join
wide2 b 
on trim(left(a.bid_hrs))=trim(left(b.bid_hrs));
quit;
data bid_dx_last6m_2;
set bid_dx_last6m;
array dx ALS
                                 adv_ca
                                 any_advca
                                 any_ca_headneck
                                 any_ca_local
                                 any_ca_pancreas
                                 any_chf
                                 any_copd
                                 any_copdchf
                                 any_hiv
                                 any_melanoma
                                 anyhiv_2nd_ca
                                 anyhiv_2nd_ds
                                 ca_cns
                                 ca_hdnck
                                 ca_mmela
                                 ca_pancr
                                 ca_solid
                                 cirrhosis
                                 hiv_aids;
do over dx 
;
if dx=. then dx=0;
end;
run;
proc contents data = bid_dx_last6m
out = vars(keep = varnum name)
noprint;
run;
proc sql;
select  name into:var_name
from vars
;
quit;
%put &var_name;


proc sql ;
select nvar into :num_vars
from dictionary.tables
where libname="WORK" and
memname="TEST";
quit;
/* Running the renaming macro */
*options macrogen mprint mlogic;

%macro rename(lib,dsn,pre);
options pageno=1 nodate;
proc contents data=&lib..&dsn;
title "Before Renaming All Variables";
run;
proc sql noprint;
select nvar into :num_vars
from dictionary.tables
where libname="&LIB" and
memname="&DSN";
select distinct(name) into :var1-
:var%TRIM(%LEFT(&num_vars))
from dictionary.columns
where libname="&LIB" and
memname="&DSN";
quit;
run;
proc datasets library=&LIB;
modify &DSN;
rename
%do i=1 %to &num_vars;
&&var&i=&&var&i.._&pre 
%end;
;
quit;
run;
options pageno=1 nodate;
proc contents data=&lib..&dsn;
title "After Renaming All Variables";
run;
%mend rename;
data test;
set bid_dx_last6m_2;
run;

%rename(WORK,TEST,n6n0);


data bid_ad_disease_n6n0;
set test(rename=(bid_hrs_n6n0=bid_hrs));
run;

/*get all dx for all sources;
dm,PDGNS_CD,DGNS_CD1-,Claim Diagnosis Code
where { x } ranges from 1 to 4


hh,PDGNS_CD,DGNSCD01-DGNSCD10,where { x } ranges from 1 to 10

hs,PDGNS_CD,DGNSCD01-DGNSCD10 Claim Diagnosis Code
where { x } ranges from 1 to 10

mp,AD_DGNS,DGNS_CD01-DGNS_CD10{x} MEDPAR Diagnosis Code
where { x } 1:10

op,PDGNS_CD,DGNSCD01-DGNSCD10  NCH Diagnosis Trailer Indicator Code
where { x } ranges from 1 to 10

pb,PDGNS_CD,DGNS_CD1-DGNS_CD4 Claim Diagnosis Code
where { x } ranges from 1 to 4
*/





/*the below is to start n12 month to n6 months





%mp(days_start=184,days_bef_death=365,source=mp );
%other(days_start=184,days_bef_death=365,source=hh );
%other(days_start=184,days_bef_death=365,source=hs );
%other(days_start=184,days_bef_death=365,source=dm );
%other(days_start=184,days_bef_death=365,source=op );
%other(days_start=184,days_bef_death=365,source=pb );
*/

/*the below is to start n18? month to n6 months*/

%mp(days_start=184,days_bef_death=548,source=mp );
%other(days_start=184,days_bef_death=548,source=hh );
%other(days_start=184,days_bef_death=548,source=hs );
%other(days_start=184,days_bef_death=548,source=dm );
%other(days_start=184,days_bef_death=548,source=op );
%other(days_start=184,days_bef_death=548,source=pb );
data pb_last_12m_dx(keep=BID_hrs diag);
set pb_meet(keep=BID_hrs PDGNS_CD DGNS_CD1-DGNS_CD4 );
array dx PDGNS_CD DGNS_CD1-DGNS_CD4;
do over dx;
diag=dx ;
output;
end;
run;
proc sort data=pb_last_12m_dx out=pb_last_12m_dx2 nodupkey;
by BID_hrs diag;
run;

data op_last_12m_dx(keep=BID_hrs diag);
set op_meet(keep=BID_hrs PDGNS_CD DGNSCD01-DGNSCD10  );
array dx PDGNS_CD DGNSCD01-DGNSCD10 ;
do over dx;
diag=dx ;
output;
end;
run;
proc sort data=op_last_12m_dx out=op_last_12m_dx2 nodupkey;
by BID_hrs diag;
run;

data mp_last_12m_dx(keep=BID_hrs diag);
set mp_meet3(keep=BID_hrs AD_DGNS DGNS_CD01-DGNS_CD10 );
array dx D_DGNS DGNS_CD01-DGNS_CD10 ;
do over dx;
diag=dx ;
output;
end;
run;
proc sort data=mp_last_12m_dx out=mp_last_12m_dx2 nodupkey;
by BID_hrs diag;
run;

data dm_last_12m_dx(keep=BID_hrs diag);
set dm_meet(keep=BID_hrs PDGNS_CD DGNS_CD1-DGNS_CD4 );
array dx PDGNS_CD DGNS_CD1-DGNS_CD4 ;
do over dx;
diag=dx ;
output;
end;
run;
proc sort data=dm_last_12m_dx out=dm_last_12m_dx2 nodupkey;
by BID_hrs diag;
run;

data hh_last_12m_dx(keep=BID_hrs diag);
set hh_meet(keep=BID_hrs PDGNS_CD DGNSCD01-DGNSCD10 );
array dx PDGNS_CD DGNSCD01-DGNSCD10 ;
do over dx;
diag=dx ;
output;
end;
run;
proc sort data=hh_last_12m_dx out=hh_last_12m_dx2 nodupkey;
by BID_hrs diag;
run;



data hs_last_12m_dx(keep=bid_hrs diag);
set hs_meet(keep=bid_hrs PDGNS_CD DGNSCD01-DGNSCD10 );
array dx PDGNS_CD DGNSCD01-DGNSCD10 ;
do over dx;
diag=dx ;
output;
end;
run;
proc sort data=hs_last_12m_dx out=hs_last_12m_dx2 nodupkey;
by bid_hrs diag;
run;


data dx_all_last_n18m_n6m;
set hs_last_12m_dx2
hh_last_12m_dx2
mp_last_12m_dx2
dm_last_12m_dx2
op_last_12m_dx2
pb_last_12m_dx2;
run;



proc sql outobs=10;
select distinct diag from dx_all_last_12m_0106_2011
where substr(trim(left(diag)),1,5) in ('71598');
quit;


proc sort data=dx_all_last_n18m_n6m(where=(diag~="")) out=dx_all_last_n18m_n6m2 nodupkey;
by bid_hrs diag;
run;
proc sql outobs=10;
select diag from dx_all_last_12m_0106_2011;
quit;
proc export data=dx_all_last_n18m_n6m2
outfile="C:\projects\Hospice_impact_on_utilization\raw_data\dx_all_last_n18m_n6m2.dta" replace;
run;

*put the sas data to stata in to dot format;
/*
clear
set memory 500m
use "C:\projects\Hospice_impact_on_utilization\raw_data\dx_all_last_12m_0106_2011.dta",clear

*tostring diag,gen(icd9_c)
gen new=ltrim(diag)
icd9 check new,gen(icd9_c)
 replace new="" if icd9_c>0 
 icd9 clean new,dots 
 

 replace diag=new
drop icd9_c new

save "C:\projects\Hospice_impact_on_utilization\raw_data\dx_all_last_12m_0106_20112.dta",replace
/*the below is to clean procedure rather than icd9 code*/
/*
icd9p check var1,gen(picd9_c)
 replace var1="" if picd9_c>0 
 icd9p clean var1,dots 
  icd9p gen icd9_c_icd=icd9_c,desc 
  */

* to the cms 21 chronic comorbidity;

proc import 
datafile="C:\projects\Hospice_impact_on_utilization\raw_data\dx_all_last_n18m_n6m3.dta" 
out=dx_all_last_n18m_n6m3 replace;
run;


proc import datafile="C:\projects\Hospice_impact_on_utilization\raw_data\chronic_21_condition_icd9.xls" 
out=icd9_21_chronic dbms=xls replace;
run;
data icd9_21_chronic2;
set icd9_21_chronic;
icd9_wo_dot=compress(icd_9,".");
run;
proc contents data=icd9_21_chronic;
run;

proc sql;
select icd_9 into :chronic_desc1-:chronic_desc21 from icd9_21_chronic;
quit;
%put &chronic_desc10;
%put &chronic_desc5;

data n12m_n6m_dx;
set dx_all_last_n18m_n6m3;
array list AMI
ALZH
ALZHDMTA
ATRIALFB
CATARACT
CHRNKIDN
COPD
CHF
DIABETES
GLAUCOMA
HIPFRAC
ISCHMCHT
DEPRESSN
OSTEOPRS
RA_OA
STRKETIA
CNCRBRST
CNCRCLRC
CNCRPRST
CNCRLUNG
CNCREndM
;
do over list ;
list=0;

end;
diag_string=diag;

if anydigit(substr(trim(left(diag_string)),1,1))=1 then do;
diag=diag_string+0;

if diag in (&chronic_desc1) then AMI=1;
if diag in (&chronic_desc2)  then ALZH=1;
if diag in (&chronic_desc3)  then ALZHDMTA=1;
if diag in (&chronic_desc4) then ATRIALFB=1;
if diag in (&chronic_desc5) then CATARACT=1;
if diag in (&chronic_desc6) then CHRNKIDN=1;
if diag in (&chronic_desc7) then COPD=1;
if diag in (&chronic_desc8) then CHF=1;
if diag in (&chronic_desc9) then DIABETES=1;
if diag in (&chronic_desc10) then GLAUCOMA=1;
if diag in (&chronic_desc11) then HIPFRAC=1;
if diag in (&chronic_desc12) then ISCHMCHT=1;
if diag in (&chronic_desc13) then DEPRESSN=1;
if diag in (&chronic_desc14) then OSTEOPRS=1;
if diag in (&chronic_desc15) then RA_OA=1;
if diag in (&chronic_desc16) then STRKETIA=1;
if diag in (&chronic_desc17) then CNCRBRST=1;
if diag in (&chronic_desc18) then CNCRCLRC=1;
if diag in (&chronic_desc19) then CNCRPRST=1;
if diag in (&chronic_desc20) then CNCRLUNG=1;
if diag in (&chronic_desc21) then CNCREndM=1;
end;

if anydigit(substr(trim(left(diag_string)),1,1))=0 then do;
if trim(left(diag_string)) in ("V431") then CATARACT=1;
if trim(left(diag_string)) in ("V801") then GLAUCOMA=1;
end;

run;


proc sql;
create table bid_dx_n18m_n6m(rename=(bid_hrs=bid)) as
select distinct bid_hrs,
sum(AMI) as AMI,
sum(ALZH) as ALZH,
sum(ALZHDMTA) as ALZHDMTA,
sum(ATRIALFB) as ATRIALFB,
sum(CATARACT) as CATARACT,
sum(CHRNKIDN) as CHRNKIDN,
sum(COPD) as COPD,
sum(CHF) as CHF,
sum(DIABETES) as DIABETES,
sum(GLAUCOMA) as GLAUCOMA,
sum(HIPFRAC) as HIPFRAC,
sum(ISCHMCHT) as ISCHMCHT,
sum(DEPRESSN) as DEPRESSN,
sum(OSTEOPRS) as OSTEOPRS,
sum(RA_OA) as RA_OA,
sum(STRKETIA) as STRKETIA,
sum(CNCRBRST) as CNCRBRST,
sum(CNCRCLRC) as CNCRCLRC,
sum(CNCRPRST) as CNCRPRST,
sum(CNCRLUNG) as CNCRLUNG,
sum(CNCREndM) as CNCREndM

from n12m_n6m_dx group by bid_hrs;
quit;

 proc sql;
 create table bid_dx_n18m_n6m2(drop=bid) as select a.bid_hrs,b.*
 from sas.ids_meet_criteria_1y_0209_2012 a
 left join
  bid_dx_n18m_n6m b 
 on trim(left(a.bid_hrs))=trim(left(b.bid));
 quit;

 data bid_dx_n18m_n6m3;
 set bid_dx_n18m_n6m2;
 array list AMI
ALZH
ALZHDMTA
ATRIALFB
CATARACT
CHRNKIDN
COPD
CHF
DIABETES
GLAUCOMA
HIPFRAC
ISCHMCHT
DEPRESSN
OSTEOPRS
RA_OA
STRKETIA
CNCRBRST
CNCRCLRC
CNCRPRST
CNCRLUNG
CNCREndM
;
do over list ;
if list>0 then list=1;
if list<=0 then list=0;
end;
AMI_isch=AMI|ISCHMCHT;
alzheim=ALZH|ALZHDMTA;
cncr_chronic=CNCRBRST|CNCRCLRC|CNCRPRST|CNCRLUNG|CNCREndM;
run;



proc means;
var AMI
ALZH
ALZHDMTA
ATRIALFB
CATARACT
CHRNKIDN
COPD
CHF
DIABETES
GLAUCOMA
HIPFRAC
ISCHMCHT
DEPRESSN
OSTEOPRS
RA_OA
STRKETIA
CNCRBRST
CNCRCLRC
CNCRPRST
CNCRLUNG
CNCREndM;
run;

data test;
set bid_dx_n18m_n6m3;
run;


%rename(WORK,TEST,n18n6);
data sas.chronic_21_n18m_n6m_0;
set test;
bid_hrs=bid_hrs_n18n6;
drop bid_hrs_n18n6;
run;
data test;
set sas.chronic_21_n18m_n6m_0;
run;
data sas.chronic_21_n18m_n6m;
set test;
AMI_isch_n18n6=AMI_n18n6|ISCHMCHT_n18n6;
alzheim_n18n6=ALZH_n18n6|ALZHDMTA_n18n6;
cncr_chronic_n18n6=CNCRBRST_n18n6|CNCRCLRC_n18n6|CNCRPRST_n18n6|CNCRLUNG_n18n6|CNCREndM_n18n6;
run;
proc freq;
table cncr_chronic_n18n6;
run;

proc transpose data=dx_all_last_12m_0106_2011 out=wide prefix=dx;
  by bid_hrs;
  var diag;
run;
data wide2(drop=dx1-dx128);
set wide;
  array dxarr  dx1-dx128;

  ** get preliminary disease flags **;
  any_copdchf=0; any_hiv=0; anyhiv_2nd_ds=0; anyhiv_2nd_ca=0; any_copd=0; any_chf=0;
  ca_solid=0; ca_cns=0; any_ca_pancreas=0; any_ca_headneck=0; any_melanoma=0; any_ca_local=0;
ALS=0;  
  cirrhosis=0;

  do over dxarr;
   if trim(left(dxarr))~="" then do;
    if anyalpha( substr( trim(left(dxarr)) ,1,1 ) )=0 then
    do;
       dx3dgt=substr(dxarr,1,3);
       dx4dgt=substr(dxarr,1,4);
	   dx3num=dx3dgt+0;
       if dx3dgt='428' then any_chf=1;
       if dx3dgt in('490','491','492','493','494','495','496')
	     then any_copd=1;
         if any_chf | any_copd then any_copdchf=1;
	   if dx3dgt='196' then any_advca=1;
	   if dx3dgt='042' then any_hiv=1;
	   if 140<= dx3num <=208 or 235<= dx3num <=239 then anyhiv_2nd_ca=1;
	     else if dx4dgt in('5712','5715','5716','7994') then anyhiv_2nd_ds=1;
	   if dx3dgt in('197','198') then ca_solid=1;
	   if dx3dgt='191' then ca_cns=1;
	   if 141<= dx3num <=148 then any_ca_headneck=1;
	   if dx3dgt='172' then any_melanoma=1;
	   if dx3dgt='157' then any_ca_pancreas=1;
       if dx3dgt='196' then any_ca_local=1;  ** locally advanced ca (lymph node involvement) **;
if trim(left(dxarr))="33520" then ALS=1;
if trim(left(dxarr)) in ("5712","5715","5716","5723") then cirrhosis=1;
end;
  end;
  end;

  ** adv disease flags for dx dependent diseases (not copdchf) **;
  ca_mmela=(any_melanoma & any_ca_local);
  ca_hdnck=(any_ca_headneck & any_ca_local);
  ca_pancr=(any_ca_pancreas & any_ca_local);
  hiv_aids=(any_hiv & (anyhiv_2nd_ca | anyhiv_2nd_ds));

  adv_ca=(ca_solid | ca_cns | ca_mmela | ca_hdnck | ca_pancr);
  
  
  /*
(1) metastatic solid tumor,
(2) central nervous system (CNS) malignancies, 
(3) metastatic melanoma, 
(4) locally advanced head and neck cancer, 
(5) locally advanced pancreatic cancer,
(6) human immunodeficiency virus/acquired immune deficiencty syndrome (HIV/AIDS) and at least one of the following secondary diagnoses: hepatoma, cirrhosis, lymphoma, cachexia, or other cancer,
 (7) congestive heart failure (CHF) or chronic obstructive pulmonary disease (COPD) and either two or more hospitalizations in any 6 months of the study period or one or more ICU admissions for CHF or COPD during the study period.

I suspect it's impossible to get ICU use from claims so if you could pull the CHF and COPD group just with 2 or more admissions within the past 6 month, that would be great.

Additionally, could I ask you to add the following additional categories.

(8)  ALS  335.20
(9) Liver disease with cirrhosis  571.2, 571.5, 571.6, 572.3

  (8)  ALS  335.20
(9) Liver disease with cirrhosis  571.2, 571.5, 571.6, 572.3
  */



drop dx3dgt dx4dgt dx3num;
RUN;

proc freq;
table cirrhosis any:;
run;


proc sql;
create table bid_dx_last12m(drop=_name_) as select a.bid_hrs,b.*
from 
sas.ids_meet_criteria_1y_0209_2012 a
left join
wide2 b 
on trim(left(a.bid_hrs))=trim(left(b.bid_hrs));
quit;
data bid_dx_last12m_2;
set bid_dx_last12m;
array dx ALS
                                 adv_ca
                                 any_advca
                                 any_ca_headneck
                                 any_ca_local
                                 any_ca_pancreas
                                 any_chf
                                 any_copd
                                 any_copdchf
                                 any_hiv
                                 any_melanoma
                                 anyhiv_2nd_ca
                                 anyhiv_2nd_ds
                                 ca_cns
                                 ca_hdnck
                                 ca_mmela
                                 ca_pancr
                                 ca_solid
                                 cirrhosis
                                 hiv_aids;
do over dx 
;
if dx=. then dx=0;
end;
run;






data test;
set bid_dx_last12m_2;
run;
proc contents data=test;
run;

%rename(WORK,TEST,n12n6);


data bid_ad_disease_n12n6;
set test(rename=(bid_hrs_n12n6=bid_hrs));
run;
proc freq data=bid_ad_disease_n12n6;
table any:;
run;
proc freq data=bid_ad_disease_n6n0;
table any:;
run;
proc sql;
create table sas.bid_ad_disease_n12n6_n6n0_022012(drop=bid_hrs2) as 
select * from
bid_ad_disease_n6n0 a
left join
bid_ad_disease_n12n6(rename=(bid_hrs=bid_hrs2)) b
on a.bid_hrs=b.bid_hrs2;
quit;

ods rtf body="&report_path.\ad_disease_n12n6_n6n0_0210_2012.rtf";
proc freq data=sas.bid_ad_disease_n12n6_n6n0_022012(drop=bid_hrs);
table _all_;
run;
ods rtf  close;



*limit to those ;
* the bid list is in 
data sas.bid_list_in_final_model_6m;








%macro mp(month_n=,days_start=,days_bef_death=,source=,equ=);
%let source0=mp;

proc sql;
create table &source._meet as select a.*,b.death_date
from medi.&source0._2000_2008(where=(trim(left(SSLSSNF))&equ.="N")) a inner join
sas.ids_meet_criteria_1y_0209_2012 b
on trim(left(a.BID_hrs))=trim(left(b.BID_hrs))
and &days_start<=b.death_date-a.admit_date<=&days_bef_death;
quit;

%mend;



%mp(month_n=12,days_start=0,days_bef_death=365,source=ip,equ=~ );
data ip_2;
set ip_meet;
if icarecnt=. then icarecnt=0;
if CRNRYDAY=. then CRNRYDAY=0;
icu_days=icarecnt+CRNRYDAY;
n_hospd=disch_date-admit_date;
run;
proc sql;
create table bid_hrs as
select bid_hrs from ip_3 where n_hospd_1yr=233;
select bid_hrs,n_hospd,disch_date,admit_date,sslssnf from ip_2
where bid_hrs in (select * from bid_hrs);
quit;


proc sql;
create table ip_3 as select distinct BID_hrs,sum(icu_days) as icu_days_12m label="total icu days in the last 12 mon"
,count(*) as n_ip_admit_1yr label="total n of hospital admit in the last 12 mon",
sum(n_hospd) as n_hospd_1yr label="total hospital days in the last 12 mon"
 from ip_2 group by BID_hrs;
quit;
proc sql;
create table icu_days_12m as select a.bid_hrs,coalesce(b.icu_days_12m,0) as icu_days_1yr
label="total icu+ccu days in the last 12 mon",
case when icu_days_12m>0 then 1
else 0 end as icu_ind_1yr 
label="any icu or ccu stay in the last 12 mon",
coalesce(b.n_ip_admit_1yr,0) as n_ip_admit_1yr label="total n of hospital admit in the last 12 mon",
coalesce(b.n_hospd_1yr,0) as n_hospd_1yr label="total hospital days in the last 12 mon"

from sas.ids_meet_criteria_1y_0209_2012 a 
left join 
ip_3 b
on trim(left(a.BID_hrs))=trim(left(b.BID_hrs));
quit;


proc freq;
table icu_ind_1yr;
run;

/*end of the begin of use sean's code for av disease,icu days,hopital days, n hospital admit in the last 1yr
*/



/*hopice los in the last 1 yr*/


%macro mp(month_n=,days_start=,days_bef_death=,source=,equ=);
%let source0=hs;

proc sql;
create table &source._meet as select a.*,b.death_date
from medi.&source0._2000_2008 a inner join
sas.ids_meet_criteria_1y_0209_2012 b
on trim(left(a.BID_hrs))=trim(left(b.BID_hrs))
and &days_start<=b.death_date-a.admit_date<=&days_bef_death;
quit;

%mend;



%mp(month_n=12,days_start=0,days_bef_death=365,source=hs );
data hs_2;
set hs_meet;

n_hs_day=disch_date-admit_date;
run;
proc sql;
create table hs_3 as select distinct BID_hrs,sum(n_hs_day) as n_hs_day_1yr label="total hospice days in the last 12 mon"

 from hs_2 group by BID_hrs;
quit;

proc sql;
create table sas.days_12m_for_hs as select a.*,coalesce(b.n_hs_day_1yr,0) as n_hs_days_1yr
label="total hospice days in the last 12 mon" from
icu_days_12m a 
left join 
hs_3 b
on trim(left(a.BID_hrs))=trim(left(b.BID_hrs));
quit;

proc contents data=sas.days_12m_for_hs;
run;

ods rtf body="&report_path.\utilization_days_last_1yr.rtf";
proc means data=sas.days_12m_for_hs(drop=bid_hrs);
var _all_;
run;
ods rtf close;


/*on urban big
urban_big=urban_rural_3=1;
if urban_rural_3=. then urban_big=.;

use "C:\Documents and Settings\Ann Litke\Desktop\du\amy\data\hsr\hrsregion.dta"
drop id
gen long id=HHID*1000+PN


sort id
merge id using "C:\Documents and Settings\Ann Litke\Desktop\du\amy\data\hsr\dateofdeath.dta"

keep if _merge==3


destring(DeathYear),gen (d_y_n)

*gen dy_2=substr(ltrim(DeathYear),3,2)

local var ZIP STCNTY 
foreach varname of local var  {

       foreach year in 92 93 94 95 96 98 00 02 04 {   
       replace `varname'`year'=. if `varname'`year'==0      
                                                   }

 
                                   }

local var URBRUR 
foreach varname of local var  {

       foreach year in 92 93 94 95 96 98 00 02 04 {   
       replace `varname'`year'=. if `varname'`year'==99 
       replace `varname'`year'=1 if `varname'`year'==0      
                                                   }

                                    }
/* prior to year 2004,
1
0
Central counties of metro areas of 1 million population or more.
2
1
Fringe counties of metro areas of 1 million population or more. */
*/
/*hospice los in the last 1yr,
she will also look at the subset of beneficiaries with 3 or more months on hospice in the last 1 yr(
*/

;


data IVWDATE ;
set temp.IVWDATE;
id=hhidpn+0;
run;
proc contents data=IVWDATE ;
run;
proc contents data=hrs00.core_00_to_08 ;
run;



libname hrs00 "C:\hrs2000\sas";


%let year=2002;
proc sql;
create table core_00_date
as select a.id,a.merge_year,b.gIWMONTH as core_month,b.gIWDAY as core_day,gIWyear as core_year
from exit.exit_2002_to_2008_id(where=(merge_year=&year)) a left join
IVWDATE b
on a.id=b.id ;
quit;
proc sql outobs=10;
select core_year from core_00_date;
quit;

%let year=2004;
proc sql;
create table core_02_date
as select a.id,a.merge_year,b.hIWMONTH as core_month,b.hIWDAY as core_day,hIWyear as core_year
from exit.exit_2002_to_2008_id(where=(merge_year=&year)) a left join
IVWDATE b
on a.id=b.id ;
quit;
proc sql outobs=10;
select core_year from core_02_date;
quit;


%let year=2006;
proc sql;
create table core_04_date
as select a.id,a.merge_year,b.jIWMONTH as core_month,b.jIWDAY as core_day,jIWyear as core_year
from exit.exit_2002_to_2008_id(where=(merge_year=&year)) a left join
IVWDATE b
on a.id=b.id ;
quit;
proc sql outobs=10;
select core_year from core_04_date;
quit;


%let year=2008;
proc sql;
create table core_06_date
as select a.id,a.merge_year,b.kIWMONTH as core_month,b.kIWDAY as core_day,kIWyear as core_year
from exit.exit_2002_to_2008_id(where=(merge_year=&year)) a left join
IVWDATE b
on a.id=b.id ;
quit;
proc freq;
table core_year;
run;

data n1_core_date;
set core_00_date core_02_date core_04_date core_06_date;
core_date_n1=mdy(core_month,core_day,core_year);
run;

proc sql;
create table ids_meet_criteria_1y_0215_2012
as select a.*,b.core_date_n1 label="-1 core interview date,one core interview before the exit"
from sas.ids_meet_criteria_1y_0209_2012 a left join
n1_core_date b
on a.id=b.id;
quit;



data sas.ids_meet_criteria_1y_0215_2012;
set ids_meet_criteria_1y_0215_2012;
days_n1_core_dead=death_date-core_date_n1;
if days_n1_core_dead<0 then days_n1_core_dead=.;
run;

proc sql;
select count(*),death_date format=mmddyy8.,core_date_n1 format=mmddyy8. from sas.ids_meet_criteria_1y_0215_2012
where .<days_n1_core_dead<0;
quit;

 
proc means ;
var days_n1_core_dead ;
run;

proc contents data=sas.ids_meet_criteria_1y_0215_2012 noprint out=vars_2;
run;
data sas.ids_meet_criteria_1y_0216_2012;
set sas.ids_meet_criteria_1y_0215_2012;
keep bid: birth: death: merge: hmo: buyin: merge_year days: core: part: days: id;
run;
proc contents data=sas.ids_meet_criteria_1y_0216_2012 noprint out=vars_3;
run;
proc freq;
table merge_year;
run;

proc sql;
create table hospice_impact_1(drop=id2)
as select * from
sas.ids_meet_criteria_1y_0216_2012 a
left join
sas.days_12m_for_hs(rename=(bid_hrs=id2)) b 
on a.bid_hrs=b.id2;
quit;


proc sql;
create table hospice_impact_2(drop=id2)
as select * from
hospice_impact_1 a
left join
sas.chronic_21_n18m_n6m(rename=(bid_hrs=id2)) b 
on a.bid_hrs=b.id2;
quit;
proc sql;
create table hospice_impact_3(drop=id_:)
as select * from
hospice_impact_2 a
inner join
sas.neg_core1_core2_exit_adl_change b 
on a.id=b.id_x;
quit;
proc contents data=sas.days_12m_for_hs;
run;

proc sql;
create table hospice_impact_4(drop=id2)
as select * from
hospice_impact_3 a
left join
sas.id_cost_wage2(rename=(id=id2) drop=bid_hrs) b 
on a.id=b.id2;
quit;
proc sql;
create table hospice_impact_5(drop=id2 )
as select * from
hospice_impact_4 a
left join
sas.id_zip_hrr_hci_bed_eol_3(rename=(id=id2) drop=merge_year
birth_date wage_index_2008
) b 
on a.id=b.id2;
quit;
proc freq;
table female_x;
run;


data sas.hospice_impact;
set hospice_impact_5;
age=year(death_date)-year(birth_date);
female=female_x;
if educ_c1 in (0,1) then hseduc=0;
if educ_c1>1 then hseduc=1;
imprelig_vimp_c1=imprelig_c1<=1;
if imprelig_c1=. then imprelig_vimp_c1=.;
run;

proc means data=sas.hospice_impact;
var wage_index_20082 wage_index_2008;
run;
proc sort data=sas.hospice_impact;
by bid_hrs;
run;
option fmterr=no;
data hospice_impact_0224_2012;
merge sas.hospice_impact sas.cost_3m_6m sas.days_6m_for_hs sas.days_3m_for_hs ;
by bid_hrs;
run;

proc means;
var ip_paid_by_mc_6m op_paid_by_mc_6m snf_paid_by_mc_6m
pb_paid_by_mc_6m hh_paid_by_mc_6m hs_paid_by_mc_6m dm_paid_by_mc_6m
 ip_paid_by_mc_3m op_paid_by_mc_3m snf_paid_by_mc_3m
pb_paid_by_mc_3m hh_paid_by_mc_3m hs_paid_by_mc_3m dm_paid_by_mc_3m
n_:
;
run;

data sas.hospice_impact_0224_2012(drop=wage_index_20082);
set  hospice_impact_0224_2012;
array list ip_paid_by_mc_6m op_paid_by_mc_6m snf_paid_by_mc_6m
pb_paid_by_mc_6m hh_paid_by_mc_6m hs_paid_by_mc_6m dm_paid_by_mc_6m
 ip_paid_by_mc_3m op_paid_by_mc_3m snf_paid_by_mc_3m
pb_paid_by_mc_3m hh_paid_by_mc_3m hs_paid_by_mc_3m dm_paid_by_mc_3m

;
do over list;
if wage_index_2008~=. then do;
list=list/wage_index_2008;
end;
end;
tot_paid_by_mc_6m=sum( of ip_paid_by_mc_6m op_paid_by_mc_6m snf_paid_by_mc_6m
pb_paid_by_mc_6m hh_paid_by_mc_6m hs_paid_by_mc_6m dm_paid_by_mc_6m)
;
tot_paid_by_mc_3m=sum( of ip_paid_by_mc_3m op_paid_by_mc_3m snf_paid_by_mc_3m
pb_paid_by_mc_3m hh_paid_by_mc_3m hs_paid_by_mc_3m dm_paid_by_mc_3m)
;

run;

options fmterr=no;
proc export data=sas.hospice_impact_0224_2012
outfile="C:\projects\Hospice_impact_on_utilization\final_data\hospice_impact.dta" replace;
run;
proc means;
var tot_paid_by_mc_3m;
run;







%let medi=C:\data\CMS\medicare_2008;
/*new hrs cms id cross walk from cms 02/08/2012*/
libname medi "&medi";
libname sas "C:\projects\Hospice_impact_on_utilization\raw_data";


%macro mp(month_n=,days_start=,days_bef_death=,source=,equ=);
%let source0=mp;

proc sql;
create table &source._meet as select a.*,b.death_date
from medi.&source0._2000_2008(where=(trim(left(SSLSSNF))&equ.="N")) a inner join
sas.ids_meet_criteria_1y_0209_2012 b
on trim(left(a.bid_hrs))=trim(left(b.bid_hrs))
and &days_start<=b.death_date-a.admit_date<=&days_bef_death;
quit;

proc sql;
create table &source._meet2 as select a.*,b.death_date
from medi.&source0._2000_2008(where=(trim(left(SSLSSNF))&equ.="N")) a inner join
sas.ids_meet_criteria_1y_0209_2012 b
on trim(left(a.bid_hrs))=trim(left(b.bid_hrs))
and b.death_date-a.admit_date>&days_bef_death and b.death_date-a.disch_date<=&days_bef_death;
quit;

data &source._meet3;
set &source._meet &source._meet2;
run;

/*&source._paid_by_mc=(pmt_amt+passthru)*pct_6m;*/
run;

%mend;



%mp(month_n=12,days_start=0,days_bef_death=183,source=ip,equ=~ );
proc sort data=ip_meet3 ;
by bid_hrs admit_date disch_date;
run;
data ip_meet4;
set ip_meet3 ;
by bid_hrs admit_date disch_date;
if last.admit_date then output;
run;
data ip_meet_30d;
set ip_meet4(keep=bid_hrs admit_date disch_date);
by bid_hrs admit_date;
retain ind_end;

if first.bid_hrs then do;

ind_end=disch_date;
end;

else do;
if (0<=admit_date-ind_end <= 30)  then do;
readmit_30d=1;
output;
end;

ind_end=disch_date;
end;
run;

proc sort data=ip_meet_30d out=ip_re_admit_30d_bid nodupkey;
by bid_hrs;
run;
proc sql;
create table ip_re_admit_30d_6m as select a.bid_hrs,
coalesce(b.readmit_30d,0) as ip_re_admit_30d_6m label="ip re-admit within 30d in the last 6 mon"
from 
sas.ids_meet_criteria_1y_0209_2012 a left join
ip_re_admit_30d_bid b 
on trim(left(a.bid_hrs))=trim(left(b.bid_hrs));
quit;




/*30 day readmission in the last 3month*/

%mp(month_n=12,days_start=0,days_bef_death=91,source=ip,equ=~ );
proc sort data=ip_meet3 ;
by bid_hrs admit_date disch_date;
run;
data ip_meet4;
set ip_meet3 ;
by bid_hrs admit_date disch_date;
if last.admit_date then output;
run;
data ip_meet_30d;
set ip_meet4(keep=bid_hrs admit_date disch_date);
by bid_hrs admit_date;
retain ind_end;

if first.bid_hrs then do;

ind_end=disch_date;
end;

else do;
if (0<=admit_date-ind_end <= 30)  then do;
readmit_30d=1;
output;
end;

ind_end=disch_date;
end;
run;

proc sort data=ip_meet_30d out=ip_re_admit_30d_bid nodupkey;
by bid_hrs;
run;
proc sql;
create table ip_re_admit_30d_3m as select a.bid_hrs,
coalesce(b.readmit_30d,0) as ip_re_admit_30d_3m label="ip re-admit within 30d in the last 3 mon"
from 
sas.ids_meet_criteria_1y_0209_2012 a left join
ip_re_admit_30d_bid b 
on trim(left(a.bid_hrs))=trim(left(b.bid_hrs));
quit;
/*end of 30 day readmission in the last 3month*/

proc sql;
create table hrs.ip_re_admit_30d_6m_0518_11 as select a.*,b.ip_re_admit_30d from
 hrs.imputed_09_28_2010_review_3 a
inner join 
hrs.ip_re_admit_30d_6m b
on trim(left(a.bid_hrs))=trim(left(b.bid_hrs));
quit;

options fmterr=no;
libname final "C:\projects\Hospice_impact_on_utilization\final_data";
data final.hospice_impact_0323_2012;
set final.hospice_impact;
run;

proc sql;
create table hospice_impact_1 as select a.*,b.ip_re_admit_30d_3m
from final.hospice_impact_0323_2012 a 
left join 
ip_re_admit_30d_3m b
on trim(left(a.bid_hrs))=trim(left(b.bid_hrs));
quit;

proc sql;
create table hospice_impact_2 as select a.*,b.ip_re_admit_30d_6m
from hospice_impact_1 a 
left join 
ip_re_admit_30d_6m b
on trim(left(a.bid_hrs))=trim(left(b.bid_hrs));
quit;
data final.hospice_impact;
set hospice_impact_2;
run;

proc export data=final.hospice_impact
outfile="C:\projects\Hospice_impact_on_utilization\final_data\hospice_impact.dta" replace;
run;

proc freq data=hospice_impact_2;
table ip_re_admit_30d_3m ip_re_admit_30d_6m;
run;



/*begin to add intensitve procedure code*/

/*copy and replace the hospice impact data from hospice impact on 05/16/2012*/
libname final "C:\projects\Procedures\final_data";
proc export data=final.hospice_impact
outfile="C:\projects\Hospice_impact_on_utilization\final_data\hospice_impact.dta" replace;
run;



libname temp "c:\data\hrs_2011_v2";
data IVWDATE ;
set temp.IVWDATE;
id=hhidpn+0;
run;
proc contents data=ivwdate;
run;

libname sas "C:\projects\Procedures\raw_data";

libname hrs00 "C:\hrs2000\sas";

%let raw_folder=C:\projects\Hospice_impact_on_utilization\raw_data;
libname exit "&raw_folder";

%let year=2002;
proc sql;
create table core_98_date
as select a.id,a.merge_year,b.fIWMONTH as core_month,b.fIWDAY as core_day,fIWyear as core_year
from exit.exit_2002_to_2008_id(where=(merge_year=&year)) a left join
IVWDATE b
on a.id=b.id ;
quit;
proc sql outobs=10;
select core_year from core_00_date;
quit;

%let year=2004;
proc sql;
create table core_00_date
as select a.id,a.merge_year,b.gIWMONTH as core_month,b.gIWDAY as core_day,gIWyear as core_year
from exit.exit_2002_to_2008_id(where=(merge_year=&year)) a left join
IVWDATE b
on a.id=b.id ;
quit;
proc sql outobs=10;
select core_year from core_00_date;
quit;

%let year=2006;
proc sql;
create table core_02_date
as select a.id,a.merge_year,b.hIWMONTH as core_month,b.hIWDAY as core_day,hIWyear as core_year
from exit.exit_2002_to_2008_id(where=(merge_year=&year)) a left join
IVWDATE b
on a.id=b.id ;
quit;
proc sql outobs=10;
select core_year from core_02_date;
quit;


%let year=2008;
proc sql;
create table core_04_date
as select a.id,a.merge_year,b.jIWMONTH as core_month,b.jIWDAY as core_day,jIWyear as core_year
from exit.exit_2002_to_2008_id(where=(merge_year=&year)) a left join
IVWDATE b
on a.id=b.id ;
quit;
proc sql outobs=10;
select core_year from core_04_date;
quit;


data n2_core_date;
set core_98_date core_00_date core_02_date core_04_date ;
core_date_n2=mdy(core_month,core_day,core_year);
run;

proc sql;
create table ids_meet_criteria_2
as select a.*,b.core_date_n2 label="-2 core interview date,one core interview before the exit"
from sas.ids_meet_criteria_1y_0216_2012 a left join
n2_core_date b
on a.id=b.id;
quit;



data sas.ids_meet_criteria_1y_0830_2012;
set ids_meet_criteria_2;
days_n2_core_dead=death_date-core_date_n2;
if days_n2_core_dead<0 then days_n2_core_dead=.;
run;

proc means;
var days_n2_core_dead days_n1_core_dead;
run;
/*
proc sql;
create table as s
select * from sas.ids_meet_criteria_1y_0830_2012 
where .<days_n1_core_dead<=180;
quit;
*/
libname final "C:\projects\Hospice_impact_on_utilization\final_data";
data final.hospice_impact_08302012;
set final.hospice_impact;
run;

proc sql;
select count(*) from final.hospice_impact
where .<days_n2_core_dead<181;
quit;

proc sql;
create table hospice_impact_9
as select a.*,b.days_n2_core_dead from
final.hospice_impact_08302012 a
left join
sas.ids_meet_criteria_1y_0830_2012(rename=(bid_hrs=bid_hrs2)) b 
on trim(left(a.bid_hrs))=trim(left(b.bid_hrs2));
quit;
data final.hospice_impact;
set hospice_impact_9;
run;

proc contents;
run;
/*end of chronic 21 condirtions*/
/*rename hospice_impact in the final_data as hospice_impact_date*/
options fmterr=no;

proc export data=final.hospice_impact
outfile="C:\projects\Hospice_impact_on_utilization\final_data\hospice_impact.dta" replace ;
run;


libname final "C:\projects\Procedures\final_data";

data final.intensive_procedure_0830_2012;
set final.intensive_procedure;
run;

proc sql;
create table intensive_procedure_2
as select a.*,b.days_n2_core_dead from
final.intensive_procedure_0830_2012 a
left join
sas.ids_meet_criteria_1y_0830_2012(rename=(bid_hrs=bid_hrs2)) b 
on trim(left(a.bid_hrs))=trim(left(b.bid_hrs2));
quit;


data final.intensive_procedure;
set intensive_procedure_2;
run;
proc contents data=final.intensive_procedure;
run;


/*end of chronic 21 condirtions*/
/*rename hospice_impact in the final_data as hospice_impact_date*/
options fmterr=no;

proc export data=final.intensive_procedure
outfile="C:\projects\Procedures\final_data\intensive_procedure.dta" replace;
run;




























H="Raw data from HRS--exit"



*set mem 500m 
use "C:\projects\Hospice_impact_on_utilization\raw_data\exit_2002_to_2006.dta",clear
tab merge_year



*******************************************************************************************
** Code below creates variables for the interview month and year (exact date of core 
** interview avaiable in restricted data files,) and The relationship of the proxy to the 
** reposindent (for the Exit interview).
*******************************************************************************************

** Proxy relationship, Exit(2=spouse, 3=non-spouse)
generate proxy_exit = .
replace  proxy_exit = 1 if ((sa009==2)|(ta009==2)|(ua009==2))
replace  proxy_exit = 0 if ((sa009==3)|(ta009==3)|(ua009==3))
label variable proxy_exit "Proxy Respondent for Exit Interview"
label define proxy_exit 0 "Proxy=Not-spouse" 1 "Proxy=spouse", modify
label values proxy_exit proxy_exit
tab proxy_exit, missing

** Female
tab sx060_r 
tab tx060_r 
tab ux060_r

generate female = .
replace  female = 1 if ((sx060_r==2)| (tx060_r==2)| (ux060_r==2))
replace  female = 0 if ((sx060_r==1)| (tx060_r==1)| (ux060_r==1))
label variable female "Female"
label define female 0 "Male" 1 "Female", modify
label values female female
tab female, missing 

** Marital status r1134

generate marital = .
replace marital = 1 if ((sa020==1) | (tb063==1)| (ub063==1))
replace marital = 2 if ((sb061==3) | (tb063==3)| (ub063==3))
replace marital = 3 if ((sb061==4) | (tb063==4)| (ub063==4))
replace marital = 4 if ((sb061==5) | (tb063==5)| (ub063==5))
replace marital = 5 if ((sb061==6) | (tb063==6)| (ub063==6))
replace marital = 6 if ((sb061==7)|(sb061==8)|(tb063==7)|(ub063==7)|(ub063==8)|(ub063==9)|(ub063==2))
label variable marital "Marital Status"
label define marital 1 "Married" 2 "Separated" 3 "Divorced" 4 "Widowed" 5 "Never Married" 6 "Other/Don't Know", modify
label values marital marital
tab marital, missing 

generate married = .
replace married = 1 if (marital==1)
replace married = 0 if (marital!=1 & marital <.)
label variable married "Married"
label define married 1 "Married" 0 "Not Married", modify
label values married married
tab married, missing 

generate marital_sep = .
replace marital_sep = 1 if (marital==2)
replace marital_sep = 0 if (marital!=2 & marital <.)
label variable marital_sep "Separated"
label define marital_sep 1 "Separated" 0 "Not Separated", modify
label values marital_sep marital_sep
tab marital_sep, missing 

generate marital_div = .
replace marital_div = 1 if (marital==3)
replace marital_div = 0 if (marital!=3 & marital <.)
label variable marital_div "Divorced"
label define marital_div 1 "Divorced" 0 "Not Divorced", modify
label values marital_div marital_div
tab marital_div, missing 

generate marital_wid = .
replace marital_wid = 1 if (marital==4)
replace marital_wid = 0 if (marital!=4 & marital <.)
label variable marital_wid "Widowed"
label define marital_wid 1 "Widowed" 0 "Not Widowed", modify
label values marital_wid marital_wid
tab marital_wid, missing 

generate marital_nev = .
replace marital_nev = 1 if (marital==5)
replace marital_nev = 0 if (marital!=5 & marital <.)
label variable marital_nev "Never Married"
label define marital_nev 1 "Never Married" 0 "Not Never Married", modify
label values marital_nev marital_nev
tab marital_nev, missing 

generate marital_sd = .
replace marital_sd = 1 if (marital_sep==1 | marital_div==1)
replace marital_sd = 0 if (marital_sep==0 & marital_div==0)
label variable marital_sd "Separated or Divorced"
label define marital_sd 1 "Separated or Divorced" 0 "Not Separated or Divorced", modify
label values marital_sd marital_sd
tab marital_sd, missing

generate marital_missing = 0
replace marital_missing = 1 if ((marital >=.)|(marital==6))
label variable marital_missing "Marital Status Missing"
label define marital_missing 1 "Marital Status Missing" 0 "Not Missing", modify
label values marital_missing marital_missing
tab marital_missing, missing

** r2585 
generate medicare = .
replace medicare= 1 if ((sn001==1) | (tn001==1)| (un001==1))
replace medicare= 0 if ((sn001==5) | (tn001==5)| (un001==5))
label variable medicare "Medicare, 1=yes"

** r2587
generate medicareb = .
replace medicareb= 1 if ((sn004==1) | (tn004==1)| (un004==1))
replace medicareb= 1 if ((sn004==5) | (tn004==5)| (un004==5))
replace medicareb= 0 if ((medicare== 0)) 
label variable medicareb "Medicare Part B, 1=yes"

** r2588 r2589
generate medicaid = 0
replace medicaid= 1 if ((sn005==1) | (tn005==1)| (un005==1))
replace medicaid= . if ((sn005==8) | (tn005==8)| (un005==8))
label variable medicaid "Medicaid, 1=yes"

** r2598
generate champus = 0
replace champus= 1 if ((sn007==1) | (tn007==1)| (un007==1))
replace champus = . if ((sn007==8)|(tn007==8)|(un007==8))
label variable champus "CHAMPUS, 1=yes"

** r2601
generate hmo = 0
replace hmo= 1 if ((sn009==1) | (tn009==1)| (un009==1))
replace hmo = . if ((sn009==8)|(tn009==8)|(un009==8))
label variable hmo "HMO, 1=yes"

** r2623
generate medigap = .
replace medigap= 1 if ((sn023>=1) | (tn023>=1)| (un023>=1))
replace medigap= 0 if ((sn023==0) | (tn023==0)| (un023==0))
replace medigap= . if ((sn023==98) | (tn023==98)| (un023==98)|(sn023==99) | (tn023==99)| (un023==99))
label variable medigap "Medigap, 1=yes"

tab medicare, missing
tab medicareb, missing
tab medicaid, missing
tab champus, missing
tab hmo, missing
tab medigap, missing

egen catinsur= concat(medicare medicareb medicaid champus hmo medigap)
tab catinsur


**Nursing Home and Hospice Residence**

generate nhres = .
replace nhres = 1 if ((sa028==1)| (ta167==1)| (ua167==1))
replace nhres = 0 if ((sa028==5)| (ta167==5)| (ua167==5))|((sa028==2)|(ta167==2)|(ua167==2))
label variable nhres "Nursing Home Resident"
label define nhres 0 "No" 1 "Yes", modify
label values nhres nhres
tab nhres, missing 

** "Was R living in a NH or other health care facility at the time he/she died?" answer '2'=hospice, '1'=NH

generate hospice = .
replace hospice = 0 if ((sa028==5)| (ta167==5)| (ua167==5))|((sa028==1)| (ta167==1)| (ua167==1))
replace hospice = 1 if ((sa028==2)|(ta167==2)|(ua167==2))
label variable hospice "Hospice Resident"
label define hospice 0 "No" 1 "Yes", modify
label values hospice hospice
tab hospice, missing 






**Frequency of Religious Services "How often did R attend services in last year of life?".  Core 2004 (jb082) asks directly, but prior cores do not**
generate freqrelg = .
replace freqrelg = 1 if ((sb082==1)|(tb082==1)|(ub082==1))
replace freqrelg = 2 if ((sb082==2)|(tb082==2)|(ub082==2))
replace freqrelg = 3 if ((sb082==3)|(tb082==3)|(ub082==3))
replace freqrelg = 4 if ((sb082==4)|(tb082==4)|(ub082==4))
replace freqrelg = 5 if ((sb082==5)|(tb082==5)|(ub082==5))
replace freqrelg = 6 if ((sb082==8)|(tb082==8)|(ub082==8)|(sb082==9)|(tb082==9)|(ub082==9))
replace freqrelg = 6 if ((sb082>=.)&(tb082>=.)&(ub082>=.))
label variable freqrelg "Frequency of Religious Services per proxy"
label define freqrelg 1 "> Once a Week" 2 "Once a Week" 3 "2-3 Times a Month" 4 "2-3 Times a Year" 5 "Not at All" 6 "Don't Know / Refused/Missing", modify
label values freqrelg freqrelg
tab freqrelg, missing 


** Number of Children

generate child = .
replace child = sa101 if ((ta101>=.) & (ua101>=.))
replace child = ta101 if ((sa101>=.) & (ua101>=.))
replace child = ua101 if ((ta101>=.) & (sa101>=.))
label variable child "Number of Children, not their children's spouses"
sum child, detail

** Number of Grandchildren

generate gchil = .
replace gchil = se046 if ((te046>=.) & (ue046>=.)& (se046!=98))
replace gchil = te046 if ((se046>=.) & (ue046>=.)& (te046!=98))
replace gchil = ue046 if ((te046>=.) & (se046>=.)& (ue046!=998)& (ue046!=999))
*skipped pattern
replace gchil =0 if se100==5
label variable gchil "Number of Grandchildren"
sum gchil, detail

** Total Number of Children, Children-in-law, and Grandchildren

generate allchil = .
replace allchil = sa113 if ((ta113>=.) & (ua113>=.))
replace allchil = ta113 if ((sa113>=.) & (ua113>=.))
replace allchil = ua113 if ((ta113>=.) & (sa113>=.))
label variable allchil "Total Number of Children, Children-in-law, and Grandchildren"
sum allchil, detail

** Number of Resident Children

generate reschil = .
replace reschil = sa099 if ((ta099>=.) & (ua099>=.))
replace reschil = ta099 if ((sa099>=.) & (ua099>=.))
replace reschil = ua099 if ((ta099>=.) & (sa099>=.))
label variable reschil "Number of Resident Children"
sum reschil, detail

** Resident Children as dummy variable

generate reschil_d = .
replace reschil_d = 0 if ((reschil==0) & (reschil<.))|(nhres==1)|(hospice==1)
replace reschil_d = 1 if ((reschil>0) & (reschil<.))&(nhres!=1)&(hospice!=1)
label variable reschil_d "Living with Children"
label define reschil_d 1 "Live with 1 or more Children" 0 "Not Resident Children", modify
tab reschil_d, missing

** Living with spouse (at time of death/before move to hosp)
generate resspouse = .
replace resspouse = 0 if ((sa030==5)|(ta030==5)|(ua030==5)|(married==0))
replace resspouse = 1 if ((sa030==1)|(ta030==1)|(ua030==1))&(nhres!=1)&(hospice!=1)
label variable resspouse "Living with Spouse/Partner"
label define resspouse 1 "Live with Spouse" 0 "No", modify
tab resspouse, missing

** Number of Household Members

generate hhm = .
replace hhm = sa098 if ((ta098>=.) & (ua098>=.))
replace hhm = ta098 if ((sa098>=.) & (ua098>=.))
replace hhm = ua098 if ((ta098>=.) & (sa098>=.))
label variable hhm "Number of Household Members"
sum hhm, detail

** Living Alone in Community
generate livealone=.
replace livealone=1 if ((hhm==0)&(hhm <.)&(nhres!=1)&(hospice!=1))
replace livealone=0 if  ((hhm!=0)&(hhm <.))|(nhres==1)|(hospice==1)
label variable livealone "Live Alone in Community"
label define livealone 0 "No" 1 "Yes", modify
label values livealone livealone
tab livealone, missing



*******************************************************************************************
** These variables are proxies report of the person's ADLs 
** for the last 3 months of life.  In general the question 
** was framed "Because of a health or memory problem, did 
** anyone help him with X during the last 3 months of 
** life?" Each ADL is coded "Yes- needed help" if the 
** proxies' response was "Yes" "Couldn't do it" or "Didn't 
** Do it"; and "No" if the proxies' response was "Needed no help"
** A skip pattern indicated that if the subject had "stayed in bed
** for more than 85 days in the 3 months before death" than all ADL
** and IADL items were skipped and left BLANK.  
*******************************************************************************************

** r1862
generate adl_bedbound = 0
replace adl_bedbound= 1 if ((sg129<94)&(sg129>=85))|((tg129<994)&(tg129>=85))|((ug129<994)&(ug129>=85))
label variable adl_bedbound "Restricted to Bed"
tab adl_bedbound, missing

** ADLs **

**Dressing, r1872

generate adl_dr = .
replace adl_dr = 1 if ((sg015==1)|(tg015==1)|(ug015==1)|(sg015==6)| (tg015==6)|(ug015==6)|(sg015==7)|(tg015==7)|(ug015==7))
replace adl_dr = 0 if ((sg015==5)|(tg015==5)|(ug015==5))
replace adl_dr=1 if adl_bedbound==1
replace adl_dr = . if ((sg015==8)|(tg015==8)|(ug015==8)|(sg015==9)|(tg015==9)|(ug015==9))
label variable adl_dr "Help Dressing"
label define adl_dr 0 "No" 1 "Yes", modify
label values adl_dr adl_dr
tab adl_dr, missing 

**Walking, r1879 

generate adl_wk = .
replace adl_wk = 1 if ((sg020==1)|(tg020==1)|(ug020==1)|(sg020==6)| (tg020==6)|(ug020==6)|(sg020==7)|(tg020==7)|(ug020==7))
replace adl_wk=1 if adl_bedbound==1
replace adl_wk = 0 if ((sg020==5)|(tg020==5)|(ug020==5))
replace adl_wk = . if ((sg020==8)|(tg020==8)|(ug020==8)|(sg020==9)|(tg020==9)|(ug020==9))
label variable adl_wk "Help Walking"
label define adl_wk 0 "No" 1 "Yes", modify
label values adl_wk adl_wk
tab adl_wk, missing 

**Bathing, r1894

generate adl_bh = .
replace adl_bh = 1 if ((sg022==1)|(tg022==1)|(ug022==1)|(sg022==6)|(tg022==6)|(ug022==6)|(sg022==7)|(tg022==7)|(ug022==7))
replace adl_bh=1 if adl_bedbound==1
replace adl_bh = 0 if ((sg022==5)|(tg022==5)|(ug022==5))
replace adl_bh = . if ((sg022==8)|(tg022==8)|(ug022==8)|(sg022==9)|(tg022==9)|(ug022==9))
label variable adl_bh "Help Bathing"
label define adl_bh 0 "No" 1 "Yes", modify
label values adl_bh adl_bh
tab adl_bh, missing 

**Eating, r1909

generate adl_e = .
replace adl_e = 1 if ((sg024==1)|(tg024==1)|(ug024==1)|(sg024==6)|(tg024==6)|(ug024==6)|(sg024==7)|(tg024==7)|(ug024==7))
replace adl_e=1 if adl_bedbound==1
replace adl_e = 0 if ((sg024==5)|(tg024==5)|(ug024==5))
replace adl_e = . if ((sg024==8)|(tg024==8)|(ug024==8)|(sg024==9)|(tg024==9)|(ug024==9))
label variable adl_e "Help Eating"
label define adl_e 0 "No" 1 "Yes", modify
label values adl_e adl_e
tab adl_e, missing 

**Transfers to Bed, r1924 

generate adl_tx = .
replace adl_tx = 1 if ((sg029==1)|(tg029==1)|(ug029==1)|(sg029==6)|(tg029==6)|(ug029==6)|(sg029==7)|(tg029==7)|(ug029==7))
replace adl_tx=1 if adl_bedbound==1
replace adl_tx = 0 if ((sg029==5)|(tg029==5)|(ug029==5))
replace adl_tx = . if ((sg029==8)|(tg029==8)|(ug029==8)|(sg029==9)|(tg029==9)|(ug029==9))
label variable adl_tx "Help with Transfers to Bed"
label define adl_tx 0 "No" 1 "Yes", modify
label values adl_tx adl_tx
tab adl_tx, missing 

**Toileting, r1942

generate adl_t = .
replace adl_t = 1 if ((sg031==1)|(tg031==1)|(ug031==1)|(sg031==6)|(tg031==6)|(ug031==6)|(sg031==7)|(tg031==7)|(ug031==7))
replace adl_t=1 if adl_bedbound==1
replace adl_t = 0 if ((sg031==5)|(tg031==5)|(ug031==5))
replace adl_t = . if ((sg031==8)|(tg031==8)|(ug031==8)|(sg031==9)|(tg031==9)|(ug031==9))
label variable adl_t "Help Toileting"
label define adl_t 0 "No" 1 "Yes", modify
label values adl_t adl_t
tab adl_t, missing 

** Index of ADLs: First step is a simple count
** Then the index is divided by categoies: 
** independent (0 ADL deficiencies), partial dependence (1-3 ),
** severe dependence (>4).

generate adl_index = .
replace adl_index = adl_dr + adl_wk + adl_bh + adl_e + adl_tx + adl_t
label variable adl_index "Index of ADLs"
tab adl_index, missing 

generate adl_cat = .
replace adl_cat = 0 if (adl_index ==0)
replace adl_cat = 1 if (adl_index >=1 & adl_index<=3)
replace adl_cat = 2 if (adl_index >=4 & adl_index<=6)
replace adl_cat = 3 if ((sg129<94)&(sg129>=85))|((tg129<994)&(tg129>=85))|((ug129<994)&(ug129>=85))
label variable adl_cat "ADLs, Categorical"
label define adl_cat 0 "Independent" 1 "Partial Dependence" 2 "Severe Dependence" 3 "Restricted to Bed", modify
label values adl_cat adl_cat
tab adl_cat, missing 

**Create dummy variables for ADL Categories
generate adl_independent = .
replace adl_independent = 1 if (adl_cat==0)
replace adl_independent = 0 if ((adl_cat == 1)| (adl_cat == 2))
replace adl_independent=0 if adl_bedbound==1
label variable adl_independent "Independent for ADLs"
tab adl_independent, missing

generate adl_partial = .
replace adl_partial = 1 if (adl_cat==1)
replace adl_partial = 0 if ((adl_cat == 0)| (adl_cat == 2))
replace adl_partial=0 if adl_bedbound==1
label variable adl_partial "Partial Dependence for ADLs"
tab adl_partial, missing

generate adl_severe = .
replace adl_severe= 1 if (adl_cat==2)
replace adl_severe = 0 if ((adl_cat == 0)| (adl_cat == 1))
replace adl_severe=1 if adl_bedbound==1
label variable adl_severe "Severe Dependence for ADLs"
tab adl_severe, missing


tab adl_dr, missing
tab adl_wk, missing
tab adl_bh, missing
tab adl_e, missing
tab adl_tx, missing
tab adl_t, missing
tab adl_index, missing
tab adl_cat, missing
tab adl_independent, missing
tab adl_partial, missing
tab adl_severe, missing


** IADLs

**Meal Prep, r2002 

generate iadl_mp = .
replace iadl_mp = 1 if ((sg043==1)|(tg043==1)|(ug043==1)|(sg043==6)|(tg043==6)|(ug043==6)|(sg043==7)|(tg043==7)|(ug043==7))
replace iadl_mp = 0 if ((sg043==5)|(tg043==5)|(ug043==5))
replace iadl_mp = . if ((sg043==8)|(tg043==8)|(ug043==8)|(sg043==9)|(tg043==9)|(ug043==9))
replace iadl_mp=1 if adl_bedbound==1
label variable iadl_mp  "Help with Meal Prep"
label define iadl_mp 0 "No" 1 "Yes", modify
label values iadl_mp iadl_mp 
tab iadl_mp, missing  

**Grocery Shopping, r2012

generate iadl_gr = .
replace iadl_gr = 1 if ((sg046==1)|(tg046==1)|(ug046==1)|(sg046==6)|(tg046==6)|(ug046==6)|(sg046==7)|(tg046==7)|(ug046==7))
replace iadl_gr = 0 if ((sg046==5)|(tg046==5)|(ug046==5))
replace iadl_gr = . if ((sg046==8)|(tg046==8)|(ug046==8)|(sg046==9)|(tg046==9)|(ug046==9))
replace iadl_gr=1 if adl_bedbound==1
label variable iadl_gr  "Help with Grocery Shopping"
label define iadl_gr 0 "No" 1 "Yes", modify
label values iadl_gr iadl_gr 
tab iadl_gr, missing  

**Phone Calls, r2022

generate iadl_ph = .
replace iadl_ph = 1 if ((sg049==1)|(tg049==1)|(ug049==1)|(sg049==6)|(tg049==6)|(ug049==6)|(sg049==7)|(tg049==7)|(ug049==7))
replace iadl_ph = 0 if ((sg049==5)|(tg049==5)|(ug049==5))
replace iadl_ph = . if ((sg049==8)|(tg049==8)|(ug049==8)|(sg049==9)|(tg049==9)|(ug049==9))
replace iadl_ph=1 if adl_bedbound==1
label variable iadl_ph  "Help with Phone Calls"
label define iadl_ph 0 "No" 1 "Yes", modify
label values iadl_ph iadl_ph 
tab iadl_ph, missing  

**Medications, r2032

generate iadl_rx = .
replace iadl_rx = 1 if ((sg053==1)|(tg053==1)|(ug053==1)|(sg053==6)|(tg053==6)|(ug053==6)|(sg053==7)|(tg053==7)|(ug053==7))
replace iadl_rx = 0 if ((sg053==5)|(tg053==5)|(ug053==5))
replace iadl_rx = . if ((sg053==8)|(tg053==8)|(ug053==8)|(sg053==9)|(tg053==9)|(ug053==9))
replace iadl_rx=1 if adl_bedbound==1
label variable iadl_rx  "Help with Medications"
label define iadl_rx 0 "No" 1 "Yes", modify
label values iadl_rx iadl_rx 
tab iadl_rx, missing 

**Money, r2077

generate iadl_m = .
replace iadl_m = 1 if ((sg061==1)|(tg061==1)|(ug061==1)|(sg061==6)|(tg061==6)|(ug061==6)|(sg061==7)|(tg061==7)|(ug061==7))
replace iadl_m = 0 if ((sg061==5)|(tg061==5)|(ug061==5))
replace iadl_m = . if ((sg061==8)|(tg061==8)|(ug061==8)|(sg061==9)|(tg061==9)|(ug061==9))
replace iadl_m=1 if adl_bedbound==1
label variable iadl_m  "Help with Money"
label define iadl_m 0 "No" 1 "Yes", modify
label values iadl_m iadl_m 
tab iadl_m, missing 

** Index of IADLs: First step is a simple count
** Then the index is divided by categoies: 
** independent (0 IADL deficiencies), partial dependence (1-3 ),
** severe dependence (>4).

generate iadl_ind = .
replace iadl_ind = iadl_mp + iadl_gr + iadl_ph + iadl_rx + iadl_m
label variable iadl_ind "Index of IADLs"
tab iadl_ind, missing 

generate iadl_cat = .
replace iadl_cat = 0 if (iadl_ind ==0)
replace iadl_cat = 1 if (iadl_ind >=1 & iadl_ind<=3)
replace iadl_cat = 2 if (iadl_ind >=4 & iadl_ind<=5)
replace iadl_cat = 3 if ((sg129<94)&(sg129>=85))|((tg129<994)&(tg129>=85))|((ug129<994)&(ug129>=85))
label variable iadl_cat "IADLs, Categorical"
label define iadl_cat 0 "Independent" 1 "Partial Dependence" 2 "Severe Dependence" 3 "Restricted to Bed", modify
label values iadl_cat iadl_cat
tab iadl_cat, missing 

**Create dummy variables for IADL Categories, 'Restricted to bed' defined as '0' in all cases
generate iadl_independent = .
replace iadl_independent = 1 if (iadl_cat==0)
replace iadl_independent = 0 if ((iadl_cat == 1)|(iadl_cat == 2)|(iadl_cat == 3))
label variable iadl_independent "Independent for IADLs"
tab iadl_independent, missing

generate iadl_partial = .
replace iadl_partial = 1 if (iadl_cat==1)
replace iadl_partial = 0 if ((iadl_cat == 0)| (iadl_cat == 2)|(iadl_cat == 3))
label variable iadl_partial "Partial Dependence for IADLs"
tab iadl_partial, missing

generate iadl_severe = .
replace iadl_severe= 1 if (iadl_cat==2)
replace iadl_severe = 0 if ((iadl_cat == 0)| (iadl_cat == 1)|(iadl_cat == 3))
label variable iadl_severe "Severe Dependence for IADLs"
tab iadl_severe, missing


******************************************************************************************
** Each comorbidity variable is by proxy report of the person's health in the past two years.
** In each case the question states, "Had a doctor ever told NAME that s/he had X?"
** The interviewer also referenced the answer from the last interview: "Our records show that
** NAME had X?  If the proxy disputed that record (VERY few cases) this coding scheme
** favors the proxy report.  So, "Yes" includes "Yes" and "Disputes past record, 
** person did have the condition"; and "No" includes "No" and "Disputes past record,
** person did NOT have the condition"; "don't know" "not ascertained" and "refused" were left as missing.
**
** The Exit interview did not ask directly about HTN, DM, Psychiatric conditions, or Arthritis.
** These comorbidities are reported in the exit interview by pulling in information from the prior wave (Core interview)
*********************************************************************************************

**Cancer, r1174

generate cancer_hrs = .
replace cancer_hrs = 1 if ((sc018==1)|(tc018==1)|(uc018==1)|(sc018==3)|(tc018==3)|(uc018==3))
replace cancer_hrs = 0 if ((sc018==5)|(tc018==5)|(uc018==5)|(sc018==4)|(tc018==4)|(uc018==4))
label variable cancer_hrs "Cancer"
label define cancer_hrs 0 "No" 1 "Yes" 9 "Don't Know/Refused", modify
label values cancer_hrs cancer_hrs
tab cancer_hrs, missing 

**Lung Disease, r1191

generate lung_hrs = .
replace lung_hrs = 1 if ((sc030==1)|(tc030==1)|(uc030==1)|(sc030==3)|(tc030==3)|(uc030==3))
replace lung_hrs = 0 if ((sc030==5)|(tc030==5)|(uc030==5)|(sc030==4)|(tc030==4)|(uc030==4))
label variable lung_hrs "Lung Disease"
label define lung_hrs 0 "No" 1 "Yes" 9 "Don't Know/Refused", modify
label values lung_hrs lung_hrs
tab lung_hrs, missing 

**Heart Condition: "heart attack, coronary heart disease, angina, congestive heart failure, or other heart problems?", r1201
generate heart_hrs = .
replace heart_hrs = 1 if ((sc036==1)|(tc036==1)|(uc036==1)|(sc036==3)|(tc036==3)|(uc036==3))
replace heart_hrs = 0 if ((sc036==5)|(tc036==5)|(uc036==5)|(sc036==4)|(tc036==4)|(uc036==4))
label variable heart_hrs "Heart Condition"
label define heart_hrs 0 "No" 1 "Yes" 9 "Don't Know/Refused", modify
label values heart_hrs heart_hrs
tab heart_hrs, missing 

**CHF: Only asked of those who said "YES" to Heart Condition, so those who said "NO" are coded "0" here. r1216

generate chf_hrs = .
replace chf_hrs = 1 if ((sc048==1)|(tc048==1)|(uc048==1)|(sc048==3)|(tc048==3)|(uc048==3))
replace chf_hrs = 0 if ((sc048==5)|(tc048==5)|(uc048==5)|(sc048==4)|(tc048==4)|(uc048==4)|(heart_hrs==0))
label variable chf_hrs "CHF"
label define chf_hrs 0 "No" 1 "Yes" 9 "Don't Know/Refused", modify
label values chf_hrs chf_hrs
tab chf_hrs, missing

**Stroke, missing r1221

generate stroke_hrs = .
replace stroke_hrs = 1 if ((sc053==1)|(tc053==1)|(uc053==1)|(sc053==3)|(tc053==3)|(uc053==3))
replace stroke_hrs = 0 if ((sc053==5)|(tc053==5)|(uc053==5)|(sc053==4)|(tc053==4)|(uc053==4))
label variable stroke_hrs "Stroke"
label define stroke_hrs 0 "No" 1 "Yes" 9 "Don't Know/Refused", modify
label values stroke_hrs stroke_hrs
tab stroke_hrs, missing 

**Memory Disease (diagnosed by a doctor, per the proxy report) r1240

generate memory_hrs = .
replace memory_hrs = 1 if ((sc069==1)|(tc069==1)|(uc069==1)|(sc069==3)|(tc069==3)|(uc069==3))
replace memory_hrs = 0 if ((sc069==5)|(tc069==5)|(uc069==5)|(sc069==4)|(tc069==4)|(uc069==4))
label variable memory_hrs "Memory Disease"
label define memory_hrs 0 "No" 1 "Yes" 9 "Don't Know/Refused", modify
label values memory_hrs memory_hrs
tab memory_hrs, missing 

** Falls r1230

generate falls_hrs = .
replace falls_hrs = 1 if ((sc079==1)|(tc079==1)|(uc079==1)|(sc079==3)|(tc079==3)|(uc079==3))
replace falls_hrs = 0 if ((sc079==5)|(tc079==5)|(uc079==5)|(sc079==4)|(tc079==4)|(uc079==4))
label variable falls_hrs "Falls"
label define falls_hrs 0 "No" 1 "Yes" 9 "Don't Know/Refused", modify
label values falls_hrs falls_hrs
tab falls_hrs, missing 

** Incontinence

generate incont_hrs = .
replace incont_hrs = 1 if ((sc208==1)|(tc208==1)|(uc208==1)|(sc208==3)|(tc208==3)|(uc208==3))
replace incont_hrs = 0 if ((sc208==5)|(tc208==5)|(uc208==5)|(sc208==4)|(tc208==4)|(uc208==4))
label variable incont_hrs "Incontinence"
label define incont_hrs 0 "No" 1 "Yes" 9 "Don't Know/Refused", modify
label values incont_hrs incont_hrs
tab incont_hrs, missing 

** Pain r1246

generate pain_hrs = .
replace pain_hrs = 1 if ((sc104==1)|(tc104==1)|(uc104==1)|(sc104==3)|(tc104==3)|(uc104==3))
replace pain_hrs = 0 if ((sc104==5)|(tc104==5)|(uc104==5)|(sc104==4)|(tc104==4)|(uc104==4))
label variable pain_hrs "Pain"
label define pain_hrs 0 "No" 1 "Yes" 9 "Don't Know/Refused", modify
label values pain_hrs pain_hrs
tab pain_hrs, missing 

** HTN

generate htn_hrs = .
replace htn_hrs = 1 if ((sz101==1)|(tz101==1)|(uz101==1))
replace htn_hrs = 0 if ((sz101==5)|(tz101==5)|(uz101==5))
label variable htn_hrs "Hypertension"
label define htn_hrs 0 "No" 1 "Yes", modify
label values htn_hrs htn_hrs
tab htn_hrs, missing 

** Diabetes

generate dm_hrs = .
replace dm_hrs = 1 if ((sz102==1)|(tz102==1)|(uz102==1))
replace dm_hrs = 0 if ((sz102==5)|(tz102==5)|(uz102==5))
label variable dm_hrs "Diabetes"
label define dm_hrs 0 "No" 1 "Yes", modify
label values dm_hrs dm_hrs
tab dm_hrs, missing 

** Psychiatric Condition ("doctor ever told... emotional, nervous or psychiatric problems?")

generate psych_hrs = .
replace psych_hrs = 1 if ((sz107==1)|(tz107==1)|(uz107==1))
replace psych_hrs = 0 if ((sz107==5)|(tz107==5)|(uz107==5))
label variable psych_hrs "Psychiatric Condition"
label define psych_hrs 0 "No" 1 "Yes", modify
label values psych_hrs psych_hrs
tab psych_hrs, missing 

** Arthritis

generate arth_hrs = .
replace arth_hrs = 1 if ((sz108==1)|(tz108==1)|(uz108==1))
replace arth_hrs = 0 if ((sz108==5)|(tz108==5)|(uz108==5))
label variable arth_hrs "Arthritis"
label define arth_hrs 0 "No" 1 "Yes", modify
label values arth_hrs arth_hrs
tab arth_hrs, missing 

** Index of Comorbidities: First step is a simple count
** Then the index is divided by categoies: 
** None (0), Mild (1-3), Moderate (4-6), Severe (>7).

generate comor_in_hrs = .
replace comor_in_hrs = (cancer_hrs + lung_hrs + heart_hrs + chf_hrs + stroke_hrs + memory_hrs + htn_hrs + dm_hrs + psych_hrs)
label variable comor_in_hrs "Index of Comorbidities"
tab comor_in_hrs, missing  
 
generate comor_c_hrs = .
replace comor_c_hrs = 0 if (comor_in_hrs ==0)
replace comor_c_hrs = 1 if (comor_in_hrs >=1 & comor_in_hrs<=3)
replace comor_c_hrs = 2 if (comor_in_hrs >=4 & comor_in_hrs<=6)
replace comor_c_hrs = 3 if (comor_in_hrs >=7 & comor_in_hrs<=13)
label variable comor_c_hrs "Comorbidity Index, Categorical"
label define comor_c_hrs 0 "None (0)" 1 "Mild (1-3)" 2 "Moderate (4-6)" 3 "Severe (>7)", modify
label values comor_c_hrs comor_c_hrs
tab comor_c_hrs, missing 


** Location of Death



** The exit interview only asked about ICU admissions, Life Support
** & Dialysis for those who reported a hospital admission and there were 
** no missing responses.  For that reason, I coded "yes" as "yes" and all 
** others "no".  Also, this question was framed "During any of
** those admissions..." not necessarily the terminal admission.

** ICU Admission in 2yrs
generate icu = 0
replace icu = 1 if ((sn305==1)|(tn305==1)|(un305==1))
label variable icu "ICU Admission in 2yrs"
label define icu 0 "No" 1 "Yes", modify
label values icu icu
tab icu, missing 

** Life Support
generate vent = 0
replace vent = 1 if ((sn306==1)|(tn306==1)|(un306==1))
label variable vent "Life Support"
label define vent 0 "No" 1 "Yes", modify
label values vent vent
tab vent, missing 

** Dialysis
generate dialysis = 0
replace dialysis = 1 if ((sn307==1)|(tn307==1)|(un307==1))
label variable dialysis "Dialysis"
label define dialysis 0 "No" 1 "Yes", modify
label values dialysis dialysis
tab dialysis, missing 


*******************************************************************************************
** The Exit interview asks the proxy about what decisions were made
** regarding intensity of care at the EOL.  This question was only
** asked of those who reported that EOL decisions had to be made 
** (st218, tt218, ut218).  Therefore, those for whom no decisions were
** necessary are coded "No" for each of the following items.
*******************************************************************************************

** Decision to Give All Care Possible
generate dec_all = 0
replace dec_all = 1 if ((st230==1)|(tt230==1)|(ut230==1))
label variable dec_all "Decision to Give All Care Possible"
label define dec_all 0 "No" 1 "Yes", modify
label values dec_all dec_all
tab dec_all, missing 

** Decision to Limit Some Care 
generate dec_lim = 0
replace dec_lim = 1 if ((st231==1)|(tt231==1)|(ut231==1))
label variable dec_lim "Decision to Limit Some Care"
label define dec_lim 0 "No" 1 "Yes", modify
label values dec_lim dec_lim
tab dec_lim, missing 

** Decision to Withhold Some Care 
generate dec_whld = 0
replace dec_whld = 1 if ((st232==1)|(tt232==1)|(ut232==1))
label variable dec_whld "Decision to Withhold Some Care"
label define dec_whld 0 "No" 1 "Yes", modify
label values dec_whld dec_whld
tab dec_whld, missing 

** Decision to Focus on Comfort
generate dec_comf = 0
replace dec_comf = 1 if ((st233==1)|(tt233==1)|(ut233==1))
label variable dec_comf "Decision to Focus on Comfort"
label define dec_comf 0 "No" 1 "Yes", modify
label values dec_comf dec_comf 
tab dec_comf, missing  

** EOL Decisions, Categorical
generate dec_cat = 0
replace dec_cat = 4 if (dec_all ==1)
replace dec_cat = 3 if (dec_lim ==1)
replace dec_cat = 2 if (dec_whld ==1)
replace dec_cat = 1 if (dec_comf ==1)
label variable dec_cat "EOL Decisions, Categorical"
label define dec_cat 0 "Not Applicable" 1 "Comfort" 2 "Withhold" 3 "Limit" 4 "All Possible", modify
label values dec_cat dec_cat
tab dec_cat, missing 

*******************************************************************************************
** The following variables capture elements of the context surrounding 
** the EOL.  All per proxy report from the Exit interviews.
*******************************************************************************************

** Death Expected: "Other/Don't Know/Refused" were coded missing by removing:
** replace dexp = 9 if ((sa131==97)|(ta131==97)|(ua131==97)|(sa131==98)|(ta131==98)|(ua131==98)|(sa131==99)|(ta131==99)|(ua131==99))
generate dexp = .
replace dexp = 1 if ((sa131==1)|(ta131==1)|(ua131==1))
replace dexp = 0 if ((sa131==2)|(ta131==2)|(ua131==2))
label variable dexp "Death Expected by Family"
label define dexp 0 "No" 1 "Yes", modify
label values dexp dexp 
tab dexp, missing 

** EOL care Decisions Had to be Made: "Other/Don't Know/Refused" were coded missing by removing:
** replace eoldec = 9 if ((st218==8)|(tt218==8)|(ut218==8)|(st218==9)|(tt218==9)|(ut218==9))
generate eoldec = .
replace eoldec = 1 if ((st218==1)|(tt218==1)|(ut218==1))
replace eoldec = 0 if ((st218==5)|(tt218==5)|(ut218==5))
label variable eoldec "EOL care Decisions Had to be Made"
label define eoldec 0 "No" 1 "Yes", modify
label values eoldec eoldec
tab eoldec, missing  

** Pt Able to Participate in Decision Making: "Other/Don't Know/Refused" were coded missing by removing:
** replace capacity = 9 if ((st223==8)|(tt223==8)|(ut223==8)|(st223==9)|(tt223==9)|(ut223==9)) 
** This variable was asked of those who said no EOL decisions had to be made
generate capacity = .
replace capacity = 1 if ((st223==1)|(tt223==1)|(ut223==1))
replace capacity = 0 if ((st223==5)|(tt223==5)|(ut223==5))
label variable capacity "Pt Able to Particpate in Decision Making"
label define capacity 0 "No" 1 "Yes", modify
label values capacity capacity
replace capacity=0 if eoldec==0
tab capacity, missing  

** Duration of Final Illness
generate duration = .
replace duration = 1 if ((sa134==1) | (ta134==1)| (ua134==1))
replace duration = 2 if ((sa134==2) | (ta134==2)| (ua134==2))
replace duration = 3 if ((sa134==3) | (ta134==3)| (ua134==3))
replace duration = 4 if ((sa134==4) | (ta134==4)| (ua134==4))
replace duration = 5 if ((sa134==5) | (ta134==5)| (ua134==5))
replace duration = 6 if ((sa134==6) | (ta134==6)| (ua134==6))
replace duration = 9 if ((sa134==8) | (ta134==8)| (ua134==8)|(sa134==9) | (ta134==9)| (ua134==9))
label variable duration "Duration of Final Illness"
label define duration 1 "Sudden" 2 "<1 day" 3 "<1 week" 4 "<1 month" 5 "<1 year" 6 ">1 year" 9 "Don't Know/Refused", modify
label values duration duration
tab duration, missing 

** Advance Directive was Applicable
generate adapp = .
replace adapp = 1 if ((st197==1)|(tt197==1)|(ut197==1))
replace adapp = 0 if ((st197==5)|(tt197==5)|(ut197==5))
replace adapp = 9 if ((st197==8)|(tt197==8)|(ut197==8)|(st197==9)|(tt197==9)|(ut197==9))
label variable adapp "Advance Directive was Applicable"
label define adapp 0 "No" 1 "Yes" 9 "Other/Don't Know/Refused", modify
label values adapp adapp
replace adapp=0 if eoldec==0
tab adapp, missing  

** Trouble Following Advance Directive
generate adprob = .
replace adprob = 1 if ((st204==1)|(tt204==1)|(ut204==1))
replace adprob = 0 if ((st204==5)|(tt204==5)|(ut204==5))
replace adprob = 9 if ((st204==8)|(tt204==8)|(ut204==8)|(st204==9)|(tt204==9)|(ut204==9))
label variable adprob "Trouble Follwing Advance Directive"
label define adprob 0 "No" 1 "Yes" 9 "Other/Don't Know/Refused", modify
label values adprob adprob
replace adprob=0 if eoldec==0
tab adprob, missing  

** Main EOL Decision Maker
generate decmaker = .
replace decmaker = 1 if ((st227==1) | (tt227==1)| (ut227==1))
replace decmaker = 2 if ((st227==2) | (tt227==2)| (ut227==2)|(st227==3) | (tt227==3)| (ut227==3))
replace decmaker = 3 if ((st227==4) | (tt227==4)| (ut227==4))
replace decmaker = 4 if ((st227==5) | (tt227==5)| (ut227==5))
replace decmaker = 5 if ((st227==6) | (tt227==6)| (ut227==6))
replace decmaker = 6 if ((st227==7) | (tt227==7)| (ut227==7))
replace decmaker = 7 if ((st227==8) | (tt227==8)| (ut227==8))
replace decmaker = 8 if ((st227==9) | (tt227==9)| (ut227==9)|(st227==10)| (tt227==10)| (ut227==10)|(st227==97) | (tt227==97)| (ut227==97))
replace decmaker = 9 if ((st227==98) | (tt227==98)| (ut227==98)|(st227==99) | (tt227==99)| (ut227==99))
label variable decmaker "Main EOL Decision Maker"
label define decmaker 1 "Patient" 2 "Spouse or Partner" 3 "Child/Child-in-law/Grandchild" 4 "Other Relative" 5 "Friend" 6 "Physician/Health Care Provider" 7 "Minister/Rabbi/Priest" 8 "Other" 9 "Don't Know/Refused", modify
label values decmaker decmaker
replace decmaker=0 if eoldec==0
tab decmaker, missing 



*******************************************************************************************
** The following variables capture the EOL care planning including Advance directives and
** discussion of wishes (all per proxy report) from the Exit interview.
*******************************************************************************************

** Living Will
generate lwill = .
replace lwill = 1 if ((st190==1)|(tt190==1)|(ut190==1))
replace lwill = 0 if ((st190==5)|(tt190==5)|(ut190==5))
replace lwill = 9 if ((st190==8)|(tt190==8)|(ut190==8)|(st190==9)|(tt190==9)|(ut190==9))
label variable lwill "Living Will"
label define lwill 0 "No" 1 "Yes" 9 "Don't Know / Refused", modify
label values lwill lwill 
tab lwill, missing  

** Living Will Said: Give All Care Possible
generate lw_all = .
replace lw_all = 1 if ((st193==1)|(tt193==1)|(ut193==1))
replace lw_all = 0 if ((st193==5)|(tt193==5)|(ut193==5))
label variable lw_all "Living Will Said: Give All Care Possible"
label define lw_all 0 "No" 1 "Yes", modify
label values lw_all lw_all
replace lw_all=0 if lwill==0
tab lw_all, missing 

** Living Will Said: Limit Some Care 
generate lw_lim = .
replace lw_lim = 1 if ((st194==1)|(tt194==1)|(ut194==1))
replace lw_lim = 0 if ((st194==5)|(tt194==5)|(ut194==5))
label variable lw_lim "Living Will Said: Limit Some Care"
label define lw_lim 0 "No" 1 "Yes", modify
label values lw_lim lw_lim
replace lw_lim=0 if lwill==0
tab lw_lim, missing 

** Living Will Said: Withhold Some Care 
generate lw_whld = .
replace lw_whld = 1 if ((st195==1)|(tt195==1)|(ut195==1))
replace lw_whld = 0 if ((st195==5)|(tt195==5)|(ut195==5))
label variable lw_whld "Living Will Said: Withhold Some Care"
label define lw_whld 0 "No" 1 "Yes", modify
label values lw_whld lw_whld
replace lw_whld=0 if lwill==0
tab lw_whld, missing 

** Living Will Said: Focus on Comfort
generate lw_comf = .
replace lw_comf = 1 if ((st196==1)|(tt196==1)|(ut196==1))
replace lw_comf = 0 if ((st196==5)|(tt196==5)|(ut196==5))
label variable lw_comf "Living Will Said: Focus on Comfort"
label define lw_comf 0 "No" 1 "Yes", modify
label values lw_comf lw_comf 
replace lw_comf=0 if lwill==0
tab lw_comf, missing  

** Living Will Said, Categorical
generate lw_cat = .
replace lw_cat = 4 if (lw_all ==1)
replace lw_cat = 3 if (lw_lim ==1)
replace lw_cat = 2 if (lw_whld ==1)
replace lw_cat = 1 if (lw_comf ==1)
replace lw_cat = 0 if (lwill == 0)
label variable lw_cat "Living Will Said, Categorical"
label define lw_cat 0 "Not Applicable" 1 "Comfort" 2 "Withhold" 3 "Limit" 4 "All Possible", modify
label values lw_cat lw_cat
tab lw_cat, missing 

** Durable Power of Attorney for Health Care
generate hcp = .
replace hcp = 1 if ((st206==1)|(tt206==1)|(ut206==1))
replace hcp = 0 if ((st206==5)|(tt206==5)|(ut206==5))
replace hcp = 9 if ((st206==8)|(tt206==8)|(ut206==8)|(st206==9)|(tt206==9)|(ut206==9))
label variable hcp "Durable Power of Attorney for Health Care"
label define hcp 0 "No" 1 "Yes" 9 "Don't Know / Refused", modify
label values hcp hcp
tab hcp, missing  

** Discussion of EOL Care Preferences
generate discuss = .
replace discuss = 1 if ((st213==1)|(tt213==1)|(ut213==1))
replace discuss = 0 if ((st213==5)|(tt213==5)|(ut213==5))
replace discuss = 9 if ((st213==8)|(tt213==8)|(ut213==8)|(st213==9)|(tt213==9)|(ut213==9))
label variable discuss "Discussion of EOL Care Preferences"
label define discuss 0 "No" 1 "Yes" 9 "Don't Know / Refused", modify
label values discuss discuss
tab discuss, missing  

** Advance Directive
generate advdir = .
replace advdir = 1 if ((hcp==1)|(lwill==1))
replace advdir = 0 if ((hcp==0)&(lwill==0))
label variable advdir "Advance Directive"
label define advdir 0 "No" 1 "Yes", modify
label values advdir advdir
tab advdir, missing 

** Any EOL care Planning
generate eolplan = .
replace eolplan = 1 if ((hcp==1)|(lwill==1)|(discuss==1))
replace eolplan = 0 if ((hcp==0)&(lwill==0)&(discuss==0))
label variable eolplan "Any EOL care Planning"
label define eolplan 0 "No" 1 "Yes", modify
label values eolplan eolplan
tab eolplan, missing  


** Location of Death

generate location = .
replace location = 1 if ((sa124==1) | (ta124==1)| (ua124==1))
replace location = 2 if ((sa124==2) | (ta124==2)| (ua124==2))
replace location = 3 if ((sa124==3) | (ta124==3)| (ua124==3))
replace location = 4 if ((sa124==4) | (ta124==4)| (ua124==4))
replace location = 5 if ((sa124==5) | (ta124==5)| (ua124==5))
replace location = 6 if ((sa124==7) | (ta124==7)| (ua124==7)|(sa124==8) | (ta124==8)| (ua124==8))
label variable location "Location of Death"
label define location 1  "Hospital" 2 "Nursing Home" 3 "Home" 4 "Hospice" 5 "Assisted Living/Retirement Home" 6 "Other/Don't Know"
label values location location
tab location, missing 

generate loc_hosp = .
replace loc_hosp = 1 if (location==1)
replace loc_hosp = 0 if ((location==2) | (location==3)| (location==4)|(location==5) | (location==6))
label variable loc_hosp  "Death in the Hospital"
label define loc_hosp  1 "Yes" 0 "No", modify
label values loc_hosp  loc_hosp 
tab loc_hosp , missing 

%let raw_data_path=C:\projects\Hospice_impact_on_utilization\raw_data;

save "&raw_data_path.\exit_2002_to_2006_01232012.dta",replace




/*end of exit 2002 to 2006 stata data*/


















/*start of exit  2008 stata data*/


*set mem 200m
use "C:\x2008\Exit2008_v2.dta",clear

gen merge_year=2008
** Proxy relationship, Exit(2=spouse, 3=non-spouse)
generate proxy_exit = .
replace  proxy_exit = 1 if ((va009==2))
replace  proxy_exit = 0 if ((va009==3))
label variable proxy_exit "Proxy Respondent for Exit Interview"
label define proxy_exit 0 "Proxy=Not-spouse" 1 "Proxy=spouse", modify
label values proxy_exit proxy_exit
tab proxy_exit, missing

generate female = .
replace  female = 1 if ((vx060_r==2))
replace  female = 0 if ((vx060_r==1))
label variable female "Female"
label define female 0 "Male" 1 "Female", modify
label values female female
tab female, missing 



/*VB063               MARITAL STATUS ASSIGNED
         Section: B     Level: Respondent      Type: Numeric    Width: 1   Decimals: 0
         Ref: SecB.B063_MarStatAssign

         *

         User Note: VB063 is assigned using values from the following variables:  X065,
         A007, A023, A026, A034, B058, and B061.

         .................................................................................
           514           1.  MARRIED (VOL)
                         2.  ANULLED (VOL)
            15           3.  SEPARATED
           132           4.  DIVORCED
           604           5.  WIDOWED
            58           6.  NEVER MARRIED
                         7.  OTHER (SPECIFY)
             5           8.  DK (Don't Know); NA (Not Ascertained)
                         9.  RF (Refused)
             2       Blank.  INAP (Inapplicable); Partial Interview; Data Missing
*/
** Marital status r1134

generate marital = .
replace marital = 1 if ((vb063==1))
replace marital = 2 if ((vb063==3))
replace marital = 3 if ((vb063==4))
replace marital = 4 if ((vb063==5))
replace marital = 5 if ((vb063==6))
replace marital = 6 if ((vb063==7)|(vb063==8)|(vb063==9)|(vb063==2))
label variable marital "Marital Status"
label define marital 1 "Married" 2 "Separated" 3 "Divorced" 4 "Widowed" 5 "Never Married" 6 "Other/Don't Know", modify
label values marital marital
tab marital, missing 

generate married = .
replace married = 1 if (marital==1)
replace married = 0 if (marital!=1 & marital <.)
label variable married "Married"
label define married 1 "Married" 0 "Not Married", modify
label values married married
tab married, missing 

generate marital_sep = .
replace marital_sep = 1 if (marital==2)
replace marital_sep = 0 if (marital!=2 & marital <.)
label variable marital_sep "Separated"
label define marital_sep 1 "Separated" 0 "Not Separated", modify
label values marital_sep marital_sep
tab marital_sep, missing 

generate marital_div = .
replace marital_div = 1 if (marital==3)
replace marital_div = 0 if (marital!=3 & marital <.)
label variable marital_div "Divorced"
label define marital_div 1 "Divorced" 0 "Not Divorced", modify
label values marital_div marital_div
tab marital_div, missing 

generate marital_wid = .
replace marital_wid = 1 if (marital==4)
replace marital_wid = 0 if (marital!=4 & marital <.)
label variable marital_wid "Widowed"
label define marital_wid 1 "Widowed" 0 "Not Widowed", modify
label values marital_wid marital_wid
tab marital_wid, missing 

generate marital_nev = .
replace marital_nev = 1 if (marital==5)
replace marital_nev = 0 if (marital!=5 & marital <.)
label variable marital_nev "Never Married"
label define marital_nev 1 "Never Married" 0 "Not Never Married", modify
label values marital_nev marital_nev
tab marital_nev, missing 

generate marital_sd = .
replace marital_sd = 1 if (marital_sep==1 | marital_div==1)
replace marital_sd = 0 if (marital_sep==0 & marital_div==0)
label variable marital_sd "Separated or Divorced"
label define marital_sd 1 "Separated or Divorced" 0 "Not Separated or Divorced", modify
label values marital_sd marital_sd
tab marital_sd, missing

generate marital_missing = 0
replace marital_missing = 1 if ((marital >=.)|(marital==6))
label variable marital_missing "Marital Status Missing"
label define marital_missing 1 "Marital Status Missing" 0 "Not Missing", modify
label values marital_missing marital_missing
tab marital_missing, missing


*to get the insurance

** r2585 
generate medicare = .
replace medicare= 1 if ((vn001==1))
replace medicare= 0 if ((vn001==5))
label variable medicare "Medicare, 1=yes"

** r2587
generate medicareb = .
replace medicareb= 1 if ((vn004==1) )
replace medicareb= 0 if ((vn004==5) )
replace medicareb= 0 if ((medicare== 0) )
label variable medicareb "Medicare Part B, 1=yes"

** r2588 r2589
generate medicaid = 0
replace medicaid= 1 if ((vn005==1) )
replace medicaid= . if ((vn005==8) )
label variable medicaid "Medicaid, 1=yes"

** r2598
generate champus = 0
replace champus= 1 if ((vn007==1) )
replace champus = . if ((vn007==8))
label variable champus "CHAMPUS, 1=yes"

** r2601
generate hmo = 0
replace hmo= 1 if ((vn009==1) )
replace hmo = . if ((vn009==8))
label variable hmo "HMO, 1=yes"

** r2623
generate medigap = .
replace medigap= 1 if ((vn023>=1) )
replace medigap= 0 if ((vn023==0) )
replace medigap= . if ((vn023==98) |(vn023==99) )
label variable medigap "Medigap, 1=yes"

tab medicare, missing
tab medicareb, missing
tab medicaid, missing
tab champus, missing
tab hmo, missing
tab medigap, missing

egen catinsur= concat(medicare medicareb medicaid champus hmo medigap)
tab catinsur





**Nursing Home and Hospice Residence**

generate nhres = .
replace nhres = 1 if ((va167==1))
replace nhres = 0 if ((va167==5))|((va167==2))
label variable nhres "Nursing Home Resident"
label define nhres 0 "No" 1 "Yes", modify
label values nhres nhres
tab nhres, missing 
** "Was R living in a NH or other health care facility at the time he/she died?" answer '2'=hospice, '1'=NH

generate hospice = .
replace hospice = 0 if ((va167==5|va167==1))
replace hospice = 1 if ((va167==2))
label variable hospice "Hospice Resident"
label define hospice 0 "No" 1 "Yes", modify
label values hospice hospice
tab hospice, missing 



**Frequency of Religious Services "How often did R attend services in last year of life?".  Core 2004 (jb082) asks directly, but prior cores do not**
generate freqrelg = .
replace freqrelg = 1 if ((vb082==1))
replace freqrelg = 2 if ((vb082==2))
replace freqrelg = 3 if ((vb082==3))
replace freqrelg = 4 if ((vb082==4))
replace freqrelg = 5 if ((vb082==5))
replace freqrelg = 6 if ((vb082==8)|(vb082==9))
replace freqrelg = 6 if ((vb082>=.))
label variable freqrelg "Frequency of Religious Services per proxy"
label define freqrelg 1 "> Once a Week" 2 "Once a Week" 3 "2-3 Times a Month" 4 "2-3 Times a Year" 5 "Not at All" 6 "Don't Know / Refused/Missing", modify
label values freqrelg freqrelg
tab freqrelg, missing 

** Number of Children

generate child = .
replace child = va101 

label variable child "Number of Children, not their children's spouses"
sum child, detail

** Number of Grandchildren

generate gchil = .
replace gchil = ve046 if ((ve046>=0)& (ve046<81))
replace gchil = 0 if ((ve046==95))
label variable gchil "Number of Grandchildren"
sum gchil, detail

** Total Number of Children, Children-in-law, and Grandchildren

generate allchil = .
replace allchil = va113 

label variable allchil "Total Number of Children, Children-in-law, and Grandchildren"
sum allchil, detail

** Number of Resident Children

generate reschil = .
replace reschil = va099 

label variable reschil "Number of Resident Children"
sum reschil, detail

** Resident Children as dummy variable

generate reschil_d = .
replace reschil_d = 0 if ((reschil==0) & (reschil<.))|(nhres==1)|(hospice==1)
replace reschil_d = 1 if ((reschil>0) & (reschil<.))&(nhres!=1)&(hospice!=1)
label variable reschil_d "Living with Children"
label define reschil_d 1 "Live with 1 or more Children" 0 "Not Resident Children", modify
tab reschil_d, missing

** Living with spouse (at time of death/before move to hosp)
generate resspouse = .
replace resspouse = 0 if ((va030==5)|(married==0))
replace resspouse = 1 if ((va030==1))&(nhres!=1)&(hospice!=1)
label variable resspouse "Living with Spouse/Partner"
label define resspouse 1 "Live with Spouse" 0 "No", modify
tab resspouse, missing

** Number of Household Members

generate hhm = .
replace hhm = va098 
label variable hhm "Number of Household Members"
sum hhm, detail

** Living Alone in Community
generate livealone=.
replace livealone=1 if ((hhm==0)&(hhm <.)&(nhres!=1)&(hospice!=1))
replace livealone=0 if  ((hhm!=0)&(hhm <.))|(nhres==1)|(hospice==1)
label variable livealone "Live Alone in Community"
label define livealone 0 "No" 1 "Yes", modify
label values livealone livealone
tab livealone, missing
















** Location of Death

generate location = .
replace location = 1 if ((va124==1))
replace location = 2 if ((va124==2))
replace location = 3 if ((va124==3))
replace location = 4 if ((va124==4))
replace location = 5 if ((va124==5))
replace location = 6 if ((va124==7)|(va124==8))
label variable location "Location of Death"
label define location 1  "Hospital" 2 "Nursing Home" 3 "Home" 4 "Hospice" 5 "Assisted Living/Retirement Home" 6 "Other/Don't Know"
label values location location
tab location, missing 

generate loc_hosp = .
replace loc_hosp = 1 if (location==1)
replace loc_hosp = 0 if ((location==2) | (location==3)| (location==4)|(location==5) | (location==6))
label variable loc_hosp  "Death in the Hospital"
label define loc_hosp  1 "Yes" 0 "No", modify
label values loc_hosp  loc_hosp 
tab loc_hosp , missing 


** The exit interview only asked about ICU admissions, Life Support
** & Dialysis for those who reported a hospital admission and there were 
** no missing responses.  For that reason, I coded "yes" as "yes" and all 
** others "no".  Also, this question was framed "During any of
** those admissions..." not necessarily the terminal admission.

** ICU Admission in 2yrs
generate icu = 0
replace icu = 1 if ((vn305==1))
label variable icu "ICU Admission in 2yrs"
label define icu 0 "No" 1 "Yes", modify
label values icu icu
tab icu, missing 

** Life Support
generate vent = 0
replace vent = 1 if ((vn306==1))
label variable vent "Life Support"
label define vent 0 "No" 1 "Yes", modify
label values vent vent
tab vent, missing 

** Dialysis
generate dialysis = 0
replace dialysis = 1 if ((vn307==1))
label variable dialysis "Dialysis"
label define dialysis 0 "No" 1 "Yes", modify
label values dialysis dialysis
tab dialysis, missing 


*******************************************************************************************
** The Exit interview asks the proxy about what decisions were made
** regarding intensity of care at the EOL.  This question was only
** asked of those who reported that EOL decisions had to be made 
** (st218, tt218, ut218).  Therefore, those for whom no decisions were
** necessary are coded "No" for each of the following items.
*******************************************************************************************

** Decision to Give All Care Possible
generate dec_all = 0
replace dec_all = 1 if ((vt230==1))
label variable dec_all "Decision to Give All Care Possible"
label define dec_all 0 "No" 1 "Yes", modify
label values dec_all dec_all
tab dec_all, missing 

** Decision to Limit Some Care 
generate dec_lim = 0
replace dec_lim = 1 if ((vt231==1))
label variable dec_lim "Decision to Limit Some Care"
label define dec_lim 0 "No" 1 "Yes", modify
label values dec_lim dec_lim
tab dec_lim, missing 

** Decision to Withhold Some Care 
generate dec_whld = 0
replace dec_whld = 1 if ((vt232==1))
label variable dec_whld "Decision to Withhold Some Care"
label define dec_whld 0 "No" 1 "Yes", modify
label values dec_whld dec_whld
tab dec_whld, missing 

** Decision to Focus on Comfort
generate dec_comf = 0
replace dec_comf = 1 if ((vt233==1))
label variable dec_comf "Decision to Focus on Comfort"
label define dec_comf 0 "No" 1 "Yes", modify
label values dec_comf dec_comf 
tab dec_comf, missing  

** EOL Decisions, Categorical
generate dec_cat = 0
replace dec_cat = 4 if (dec_all ==1)
replace dec_cat = 3 if (dec_lim ==1)
replace dec_cat = 2 if (dec_whld ==1)
replace dec_cat = 1 if (dec_comf ==1)
label variable dec_cat "EOL Decisions, Categorical"
label define dec_cat 0 "Not Applicable" 1 "Comfort" 2 "Withhold" 3 "Limit" 4 "All Possible", modify
label values dec_cat dec_cat
tab dec_cat, missing 




*******************************************************************************************
** The following variables capture elements of the context surrounding 
** the EOL.  All per proxy report from the Exit interviews.
*******************************************************************************************

** Death Expected: "Other/Don't Know/Refused" were coded missing by removing:
** replace dexp = 9 if ((sa131==97)|(ta131==97)|(ua131==97)|(sa131==98)|(ta131==98)|(ua131==98)|(sa131==99)|(ta131==99)|(ua131==99))
generate dexp = .
replace dexp = 1 if ((va131==1))
replace dexp = 0 if ((va131==2))
label variable dexp "Death Expected by Family"
label define dexp 0 "No" 1 "Yes", modify
label values dexp dexp 
tab dexp, missing 

** EOL care Decisions Had to be Made: "Other/Don't Know/Refused" were coded missing by removing:
** replace eoldec = 9 if ((st218==8)|(tt218==8)|(ut218==8)|(st218==9)|(tt218==9)|(ut218==9))
generate eoldec = .
replace eoldec = 1 if ((vt218==1))
replace eoldec = 0 if ((vt218==5))
label variable eoldec "EOL care Decisions Had to be Made"
label define eoldec 0 "No" 1 "Yes", modify
label values eoldec eoldec
tab eoldec, missing  

** Pt Able to Participate in Decision Making: "Other/Don't Know/Refused" were coded missing by removing:
** replace capacity = 9 if ((st223==8)|(tt223==8)|(ut223==8)|(st223==9)|(tt223==9)|(ut223==9)) 
** This variable was asked of those who said no EOL decisions had to be made
generate capacity = .
replace capacity = 1 if ((vt223==1))
replace capacity = 0 if ((vt223==5))
label variable capacity "Pt Able to Particpate in Decision Making"
label define capacity 0 "No" 1 "Yes", modify
label values capacity capacity
replace capacity=0 if eoldec==0
tab capacity, missing  

** Duration of Final Illness
generate duration = .
replace duration = 1 if ((va134==1))
replace duration = 2 if ((va134==2))
replace duration = 3 if ((va134==3))
replace duration = 4 if ((va134==4))
replace duration = 5 if ((va134==5))
replace duration = 6 if ((va134==6))
replace duration = 9 if ((va134==8)|(va134==9))
label variable duration "Duration of Final Illness"
label define duration 1 "Sudden" 2 "<1 day" 3 "<1 week" 4 "<1 month" 5 "<1 year" 6 ">1 year" 9 "Don't Know/Refused", modify
label values duration duration
tab duration, missing 

** Advance Directive was Applicable
generate adapp = .
replace adapp = 1 if ((vt197==1))
replace adapp = 0 if ((vt197==5))
replace adapp = 9 if ((vt197==8)|(vt197==9))
label variable adapp "Advance Directive was Applicable"
label define adapp 0 "No" 1 "Yes" 9 "Other/Don't Know/Refused", modify
label values adapp adapp
replace adapp=0 if eoldec==0
tab adapp, missing  

** Trouble Following Advance Directive
generate adprob = .
replace adprob = 1 if ((vt204==1))
replace adprob = 0 if ((vt204==5))
replace adprob = 9 if ((vt204==8)|(vt204==9))
label variable adprob "Trouble Follwing Advance Directive"
label define adprob 0 "No" 1 "Yes" 9 "Other/Don't Know/Refused", modify
label values adprob adprob
replace adprob=0 if eoldec==0
tab adprob, missing  

** Main EOL Decision Maker
generate decmaker = .
replace decmaker = 1 if ((vt227==1))
replace decmaker = 2 if ((vt227==2)|(vt227==3))
replace decmaker = 3 if ((vt227==4))
replace decmaker = 4 if ((vt227==5))
replace decmaker = 5 if ((vt227==6))
replace decmaker = 6 if ((vt227==7))
replace decmaker = 7 if ((vt227==8))
replace decmaker = 8 if ((vt227==9)|(vt227==10)|(vt227==97))
replace decmaker = 9 if ((vt227==98)|(vt227==99))
label variable decmaker "Main EOL Decision Maker"
label define decmaker 1 "Patient" 2 "Spouse or Partner" 3 "Child/Child-in-law/Grandchild" 4 "Other Relative" 5 "Friend" 6 "Physician/Health Care Provider" 7 "Minister/Rabbi/Priest" 8 "Other" 9 "Don't Know/Refused", modify
label values decmaker decmaker
replace decmaker=0 if eoldec==0
tab decmaker, missing 




*******************************************************************************************
** The following variables capture the EOL care planning including Advance directives and
** discussion of wishes (all per proxy report) from the Exit interview.
*******************************************************************************************

** Living Will
generate lwill = .
replace lwill = 1 if ((vt190==1))
replace lwill = 0 if ((vt190==5))
replace lwill = 9 if ((vt190==8)|(vt190==9))
label variable lwill "Living Will"
label define lwill 0 "No" 1 "Yes" 9 "Don't Know / Refused", modify
label values lwill lwill 
tab lwill, missing  

** Living Will Said: Give All Care Possible
generate lw_all = .
replace lw_all = 1 if ((vt193==1))
replace lw_all = 0 if ((vt193==5))
label variable lw_all "Living Will Said: Give All Care Possible"
label define lw_all 0 "No" 1 "Yes", modify
label values lw_all lw_all
replace lw_all=0 if lwill==0
tab lw_all, missing 

** Living Will Said: Limit Some Care 
generate lw_lim = .
replace lw_lim = 1 if ((vt194==1))
replace lw_lim = 0 if ((vt194==5))
label variable lw_lim "Living Will Said: Limit Some Care"
label define lw_lim 0 "No" 1 "Yes", modify
label values lw_lim lw_lim
replace lw_lim=0 if lwill==0
tab lw_lim, missing 

** Living Will Said: Withhold Some Care 
generate lw_whld = .
replace lw_whld = 1 if ((vt195==1))
replace lw_whld = 0 if ((vt195==5))
label variable lw_whld "Living Will Said: Withhold Some Care"
label define lw_whld 0 "No" 1 "Yes", modify
replace lw_whld=0 if lwill==0
label values lw_whld lw_whld
tab lw_whld, missing 

** Living Will Said: Focus on Comfort
generate lw_comf = .
replace lw_comf = 1 if ((vt196==1))
replace lw_comf = 0 if ((vt196==5))
label variable lw_comf "Living Will Said: Focus on Comfort"
label define lw_comf 0 "No" 1 "Yes", modify
label values lw_comf lw_comf 
replace lw_comf=0 if lwill==0
tab lw_comf, missing  

** Living Will Said, Categorical
generate lw_cat = .
replace lw_cat = 4 if (lw_all ==1)
replace lw_cat = 3 if (lw_lim ==1)
replace lw_cat = 2 if (lw_whld ==1)
replace lw_cat = 1 if (lw_comf ==1)
replace lw_cat = 0 if (lwill == 0)
label variable lw_cat "Living Will Said, Categorical"
label define lw_cat 0 "Not Applicable" 1 "Comfort" 2 "Withhold" 3 "Limit" 4 "All Possible", modify
label values lw_cat lw_cat
tab lw_cat, missing 

** Durable Power of Attorney for Health Care
generate hcp = .
replace hcp = 1 if ((vt206==1))
replace hcp = 0 if ((vt206==5))
replace hcp = 9 if ((vt206==8)|(vt206==9))
label variable hcp "Durable Power of Attorney for Health Care"
label define hcp 0 "No" 1 "Yes" 9 "Don't Know / Refused", modify
label values hcp hcp
tab hcp, missing  

** Discussion of EOL Care Preferences
generate discuss = .
replace discuss = 1 if ((vt213==1))
replace discuss = 0 if ((vt213==5))
replace discuss = 9 if ((vt213==8)|(vt213==9))
label variable discuss "Discussion of EOL Care Preferences"
label define discuss 0 "No" 1 "Yes" 9 "Don't Know / Refused", modify
label values discuss discuss
tab discuss, missing  

** Advance Directive
generate advdir = .
replace advdir = 1 if ((hcp==1)|(lwill==1))
replace advdir = 0 if ((hcp==0)&(lwill==0))
label variable advdir "Advance Directive"
label define advdir 0 "No" 1 "Yes", modify
label values advdir advdir
tab advdir, missing 

** Any EOL care Planning
generate eolplan = .
replace eolplan = 1 if ((hcp==1)|(lwill==1)|(discuss==1))
replace eolplan = 0 if ((hcp==0)&(lwill==0)&(discuss==0))
label variable eolplan "Any EOL care Planning"
label define eolplan 0 "No" 1 "Yes", modify
label values eolplan eolplan
tab eolplan, missing 





 ** new variables:  hhuse hhoop hhoop2 hhcovered omeduse omedoop omedoop2 nmeduse nmedoop nmedoop2



*adl
*******************************************************************************************
** These variables are proxies report of the person's ADLs 
** for the last 3 months of life.  In general the question 
** was framed "Because of a health or memory problem, did 
** anyone help him with X during the last 3 months of 
** life?" Each ADL is coded "Yes- needed help" if the 
** proxies' response was "Yes" "Couldn't do it" or "Didn't 
** Do it"; and "No" if the proxies' response was "Needed no help"
** A skip pattern indicated that if the subject had "stayed in bed
** for more than 85 days in the 3 months before death" than all ADL
** and IADL items were skipped and left BLANK.  
*******************************************************************************************

** r1862
generate adl_bedbound = 0
replace adl_bedbound= 1 if ((vg129<994)&(vg129>=85))
label variable adl_bedbound "Restricted to Bed"
tab adl_bedbound, missing

** ADLs **

**Dressing, r1872

generate adl_dr = .
replace adl_dr = 1 if ((vg015==1)|(vg015==6)|(vg015==7))
replace adl_dr = 0 if ((vg015==5))
replace adl_dr=1 if adl_bedbound==1
replace adl_dr = . if ((vg015==8)|(vg015==9))
label variable adl_dr "Help Dressing"
label define adl_dr 0 "No" 1 "Yes", modify
label values adl_dr adl_dr
tab adl_dr, missing 

**Walking, r1879 

generate adl_wk = .
replace adl_wk = 1 if ((vg020==1)|(vg020==6)|(vg020==7))
replace adl_wk=1 if adl_bedbound==1
replace adl_wk = 0 if ((vg020==5))
replace adl_wk = . if ((vg020==8)|(vg020==9))
label variable adl_wk "Help Walking"
label define adl_wk 0 "No" 1 "Yes", modify
label values adl_wk adl_wk
tab adl_wk, missing 

**Bathing, r1894

generate adl_bh = .
replace adl_bh = 1 if ((vg022==1)|(vg022==6)|(vg022==7))
replace adl_bh=1 if adl_bedbound==1
replace adl_bh = 0 if ((vg022==5))
replace adl_bh = . if ((vg022==8)|(vg022==9))
label variable adl_bh "Help Bathing"
label define adl_bh 0 "No" 1 "Yes", modify
label values adl_bh adl_bh
tab adl_bh, missing 

**Eating, r1909

generate adl_e = .
replace adl_e = 1 if ((vg024==1)|(vg024==6)|(vg024==7))
replace adl_e=1 if adl_bedbound==1
replace adl_e = 0 if ((vg024==5))
replace adl_e = . if ((vg024==8)|(vg024==9))
label variable adl_e "Help Eating"
label define adl_e 0 "No" 1 "Yes", modify
label values adl_e adl_e
tab adl_e, missing 

**Transfers to Bed, r1924 

generate adl_tx = .
replace adl_tx = 1 if ((vg029==1)|(vg029==6)|(vg029==7))
replace adl_tx=1 if adl_bedbound==1
replace adl_tx = 0 if ((vg029==5))
replace adl_tx = . if ((vg029==8)|(vg029==9))
label variable adl_tx "Help with Transfers to Bed"
label define adl_tx 0 "No" 1 "Yes", modify
label values adl_tx adl_tx
tab adl_tx, missing 

**Toileting, r1942

generate adl_t = .
replace adl_t = 1 if ((vg031==1)|(vg031==6)|(vg031==7))
replace adl_t=1 if adl_bedbound==1
replace adl_t = 0 if ((vg031==5))
replace adl_t = . if ((vg031==8)|(vg031==9))
label variable adl_t "Help Toileting"
label define adl_t 0 "No" 1 "Yes", modify
label values adl_t adl_t
tab adl_t, missing 

** Index of ADLs: First step is a simple count
** Then the index is divided by categoies: 
** independent (0 ADL deficiencies), partial dependence (1-3 ),
** severe dependence (>4).

generate adl_index = .
replace adl_index = adl_dr + adl_wk + adl_bh + adl_e + adl_tx + adl_t
label variable adl_index "Index of ADLs"
tab adl_index, missing 

generate adl_cat = .
replace adl_cat = 0 if (adl_index ==0)
replace adl_cat = 1 if (adl_index >=1 & adl_index<=3)
replace adl_cat = 2 if (adl_index >=4 & adl_index<=6)
replace adl_cat = 3 if ((vg129<994)&(vg129>=85))
label variable adl_cat "ADLs, Categorical"
label define adl_cat 0 "Independent" 1 "Partial Dependence" 2 "Severe Dependence" 3 "Restricted to Bed", modify
label values adl_cat adl_cat
tab adl_cat, missing 

**Create dummy variables for ADL Categories
generate adl_independent = .
replace adl_independent = 1 if (adl_cat==0)
replace adl_independent = 0 if ((adl_cat == 1)| (adl_cat == 2))
replace adl_independent=0 if adl_bedbound==1
label variable adl_independent "Independent for ADLs"
tab adl_independent, missing

generate adl_partial = .
replace adl_partial = 1 if (adl_cat==1)
replace adl_partial = 0 if ((adl_cat == 0)| (adl_cat == 2))
replace adl_partial=0 if adl_bedbound==1
label variable adl_partial "Partial Dependence for ADLs"
tab adl_partial, missing

generate adl_severe = .
replace adl_severe= 1 if (adl_cat==2)
replace adl_severe = 0 if ((adl_cat == 0)| (adl_cat == 1))
replace adl_severe=1 if adl_bedbound==1
label variable adl_severe "Severe Dependence for ADLs"
tab adl_severe, missing




** IADLs

**Meal Prep, r2002 

generate iadl_mp = .
replace iadl_mp = 1 if ((vg043==1)|(vg043==6)|(vg043==7))
replace iadl_mp = 0 if ((vg043==5))
replace iadl_mp = . if ((vg043==8)|(vg043==9))
replace iadl_mp=1 if adl_bedbound==1
label variable iadl_mp  "Help with Meal Prep"
label define iadl_mp 0 "No" 1 "Yes", modify
label values iadl_mp iadl_mp 
tab iadl_mp, missing  

**Grocery Shopping, r2012

generate iadl_gr = .
replace iadl_gr = 1 if ((vg046==1)|(vg046==6)|(vg046==7))
replace iadl_gr = 0 if ((vg046==5))
replace iadl_gr = . if ((vg046==8)|(vg046==9))
replace iadl_gr=1 if adl_bedbound==1
label variable iadl_gr  "Help with Grocery Shopping"
label define iadl_gr 0 "No" 1 "Yes", modify
label values iadl_gr iadl_gr 
tab iadl_gr, missing  

**Phone Calls, r2022

generate iadl_ph = .
replace iadl_ph = 1 if ((vg049==1)|(vg049==6)|(vg049==7))
replace iadl_ph = 0 if ((vg049==5))
replace iadl_ph = . if ((vg049==8)|(vg049==9))
replace iadl_ph=1 if adl_bedbound==1
label variable iadl_ph  "Help with Phone Calls"
label define iadl_ph 0 "No" 1 "Yes", modify
label values iadl_ph iadl_ph 
tab iadl_ph, missing  

**Medications, r2032

generate iadl_rx = .
replace iadl_rx = 1 if ((vg053==1)|(vg053==6)|(vg053==7))
replace iadl_rx = 0 if ((vg053==5))
replace iadl_rx = . if ((vg053==8)|(vg053==9))
replace iadl_rx=1 if adl_bedbound==1
label variable iadl_rx  "Help with Medications"
label define iadl_rx 0 "No" 1 "Yes", modify
label values iadl_rx iadl_rx 
tab iadl_rx, missing 

**Money, r2077

generate iadl_m = .
replace iadl_m = 1 if ((vg061==1)|(vg061==6)|(vg061==7))
replace iadl_m = 0 if ((vg061==5))
replace iadl_m = . if ((vg061==8)|(vg061==9))
replace iadl_m=1 if adl_bedbound==1
label variable iadl_m  "Help with Money"
label define iadl_m 0 "No" 1 "Yes", modify
label values iadl_m iadl_m 
tab iadl_m, missing 

** Index of IADLs: First step is a simple count
** Then the index is divided by categoies: 
** independent (0 IADL deficiencies), partial dependence (1-3 ),
** severe dependence (>4).

generate iadl_ind = .
replace iadl_ind = iadl_mp + iadl_gr + iadl_ph + iadl_rx + iadl_m
label variable iadl_ind "Index of IADLs"
tab iadl_ind, missing 

generate iadl_cat = .
replace iadl_cat = 0 if (iadl_ind ==0)
replace iadl_cat = 1 if (iadl_ind >=1 & iadl_ind<=3)
replace iadl_cat = 2 if (iadl_ind >=4 & iadl_ind<=5)
replace iadl_cat = 3 if ((vg129<994)&(vg129>=85))
label variable iadl_cat "IADLs, Categorical"
label define iadl_cat 0 "Independent" 1 "Partial Dependence" 2 "Severe Dependence" 3 "Restricted to Bed", modify
label values iadl_cat iadl_cat
tab iadl_cat, missing 

**Create dummy variables for IADL Categories, 'Restricted to bed' defined as '0' in all cases
generate iadl_independent = .
replace iadl_independent = 1 if (iadl_cat==0)
replace iadl_independent = 0 if ((iadl_cat == 1)|(iadl_cat == 2)|(iadl_cat == 3))
label variable iadl_independent "Independent for IADLs"
tab iadl_independent, missing

generate iadl_partial = .
replace iadl_partial = 1 if (iadl_cat==1)
replace iadl_partial = 0 if ((iadl_cat == 0)| (iadl_cat == 2)|(iadl_cat == 3))
label variable iadl_partial "Partial Dependence for IADLs"
tab iadl_partial, missing

generate iadl_severe = .
replace iadl_severe= 1 if (iadl_cat==2)
replace iadl_severe = 0 if ((iadl_cat == 0)| (iadl_cat == 1)|(iadl_cat == 3))
label variable iadl_severe "Severe Dependence for IADLs"
tab iadl_severe, missing














*add the comorbidity

*******************************************************************************************
** Each comorbidity variable is by proxy report of the person's health in the past two years.
** In each case the question states, "Had a doctor ever told NAME that s/he had X?"
** The interviewer also referenced the answer from the last interview: "Our records show that
** NAME had X?  If the proxy disputed that record (VERY few cases) this coding scheme
** favors the proxy report.  So, "Yes" includes "Yes" and "Disputes past record, 
** person did have the condition"; and "No" includes "No" and "Disputes past record,
** person did NOT have the condition"; "don't know" "not ascertained" and "refused" were left as missing.
**
** The Exit interview did not ask directly about HTN, DM, Psychiatric conditions, or Arthritis.
** These comorbidities are reported in the exit interview by pulling in information from the prior wave (Core interview)
*********************************************************************************************

**Cancer, r1174

generate cancer_hrs = .
replace cancer_hrs = 1 if ((vc018==1)|(vc018==3))
replace cancer_hrs = 0 if ((vc018==5)|(vc018==4))
label variable cancer_hrs "Cancer"
label define cancer_hrs 0 "No" 1 "Yes" 9 "Don't Know/Refused", modify
label values cancer_hrs cancer_hrs
tab cancer_hrs, missing 

**Lung Disease, r1191

generate lung_hrs = .
replace lung_hrs = 1 if ((vc030==1)|(vc030==3))
replace lung_hrs = 0 if ((vc030==5)|(vc030==4))
label variable lung_hrs "Lung Disease"
label define lung_hrs 0 "No" 1 "Yes" 9 "Don't Know/Refused", modify
label values lung_hrs lung_hrs
tab lung_hrs, missing 

**Heart Condition: "heart attack, coronary heart disease, angina, congestive heart failure, or other heart problems?", r1201
generate heart_hrs = .
replace heart_hrs = 1 if ((vc036==1)|(vc036==3))
replace heart_hrs = 0 if ((vc036==5)|(vc036==4))
label variable heart_hrs "Heart Condition"
label define heart_hrs 0 "No" 1 "Yes" 9 "Don't Know/Refused", modify
label values heart_hrs heart_hrs
tab heart_hrs, missing 

**CHF: Only asked of those who said "YES" to Heart Condition, so those who said "NO" are coded "0" here. r1216

generate chf_hrs = .
replace chf_hrs = 1 if ((vc048==1)|(vc048==3))
replace chf_hrs = 0 if ((vc048==5)|(vc048==4)|(heart_hrs==0))
label variable chf_hrs "CHF"
label define chf_hrs 0 "No" 1 "Yes" 9 "Don't Know/Refused", modify
label values chf_hrs chf_hrs
tab chf_hrs, missing

**Stroke, missing r1221

generate stroke_hrs = .
replace stroke_hrs = 1 if ((vc053==1)|(vc053==3))
replace stroke_hrs = 0 if ((vc053==5)|(vc053==4))
label variable stroke_hrs "Stroke"
label define stroke_hrs 0 "No" 1 "Yes" 9 "Don't Know/Refused", modify
label values stroke_hrs stroke_hrs
tab stroke_hrs, missing 

**Memory Disease (diagnosed by a doctor, per the proxy report) r1240

generate memory_hrs = .
replace memory_hrs = 1 if ((vc069==1)|(vc069==3))
replace memory_hrs = 0 if ((vc069==5)|(vc069==4))
label variable memory_hrs "Memory Disease"
label define memory_hrs 0 "No" 1 "Yes" 9 "Don't Know/Refused", modify
label values memory_hrs memory_hrs
tab memory_hrs, missing 

** Falls r1230

generate falls_hrs = .
replace falls_hrs = 1 if ((vc079==1)|(vc079==3))
replace falls_hrs = 0 if ((vc079==5)|(vc079==4))
label variable falls_hrs "Falls"
label define falls_hrs 0 "No" 1 "Yes" 9 "Don't Know/Refused", modify
label values falls_hrs falls_hrs
tab falls_hrs, missing 

** Incontinence

generate incont_hrs = .
replace incont_hrs = 1 if ((vc208==1)|(vc208==3))
replace incont_hrs = 0 if ((vc208==5)|(vc208==4))
label variable incont_hrs "Incontinence"
label define incont_hrs 0 "No" 1 "Yes" 9 "Don't Know/Refused", modify
label values incont_hrs incont_hrs
tab incont_hrs, missing 

** Pain r1246

generate pain_hrs = .
replace pain_hrs = 1 if ((vc104==1)|(vc104==3))
replace pain_hrs = 0 if ((vc104==5)|(vc104==4))
label variable pain_hrs "Pain"
label define pain_hrs 0 "No" 1 "Yes" 9 "Don't Know/Refused", modify
label values pain_hrs pain_hrs
tab pain_hrs, missing 

** HTN

generate htn_hrs = .
replace htn_hrs = 1 if ((vz101==1))
replace htn_hrs = 0 if ((vz101==5))
label variable htn_hrs "Hypertension"
label define htn_hrs 0 "No" 1 "Yes", modify
label values htn_hrs htn_hrs
tab htn_hrs, missing 

** Diabetes

generate dm_hrs = .
replace dm_hrs = 1 if ((vz102==1))
replace dm_hrs = 0 if ((vz102==5))
label variable dm_hrs "Diabetes"
label define dm_hrs 0 "No" 1 "Yes", modify
label values dm_hrs dm_hrs
tab dm_hrs, missing 

** Psychiatric Condition ("doctor ever told... emotional, nervous or psychiatric problems?")

generate psych_hrs = .
replace psych_hrs = 1 if ((vz107==1))
replace psych_hrs = 0 if ((vz107==5))
label variable psych_hrs "Psychiatric Condition"
label define psych_hrs 0 "No" 1 "Yes", modify
label values psych_hrs psych_hrs
tab psych_hrs, missing 

** Arthritis

generate arth_hrs = .
replace arth_hrs = 1 if ((vz108==1))
replace arth_hrs = 0 if ((vz108==5))
label variable arth_hrs "Arthritis"
label define arth_hrs 0 "No" 1 "Yes", modify
label values arth_hrs arth_hrs
tab arth_hrs, missing 

** Index of Comorbidities: First step is a simple count
** Then the index is divided by categoies: 
** None (0), Mild (1-3), Moderate (4-6), Severe (>7).

generate comor_in_hrs = .
replace comor_in_hrs = (cancer_hrs + lung_hrs + heart_hrs + chf_hrs + stroke_hrs + memory_hrs + htn_hrs + dm_hrs + psych_hrs)
label variable comor_in_hrs "Index of Comorbidities"
tab comor_in_hrs, missing  
 
generate comor_c_hrs = .
replace comor_c_hrs = 0 if (comor_in_hrs ==0)
replace comor_c_hrs = 1 if (comor_in_hrs >=1 & comor_in_hrs<=3)
replace comor_c_hrs = 2 if (comor_in_hrs >=4 & comor_in_hrs<=6)
replace comor_c_hrs = 3 if (comor_in_hrs >=7 & comor_in_hrs<=13)
label variable comor_c_hrs "Comorbidity Index, Categorical"
label define comor_c_hrs 0 "None (0)" 1 "Mild (1-3)" 2 "Moderate (4-6)" 3 "Severe (>7)", modify
label values comor_c_hrs comor_c_hrs
tab comor_c_hrs, missing 






save "C:\projects\Hospice_impact_on_utilization\raw_data\exit_2008_01232012.dta",replace
use "C:\projects\Hospice_impact_on_utilization\raw_data\exit_2008_01232012.dta",clear
sort id
append using "C:\projects\Hospice_impact_on_utilization\raw_data\exit_2002_to_2006_01232012.dta"
sort id
quietly by id: gen dup = cond(_N==1,0,_n)
drop if dup>1

save "C:\projects\Hospice_impact_on_utilization\raw_data\exit_02_08_01232012.dta",replace

tab female,missing
tab adl_index merge_year,missing


log using "report_path.\exit_2002_to_2008_freq.log", replace




tab merge_year female, missing

tab merge_year marital, missing
tab merge_year married, missing
tab merge_year marital_sep, missing 
tab merge_year marital_div, missing 
tab merge_year marital_wid, missing 
tab merge_year marital_nev, missing



tab merge_year medicare, missing
tab merge_year medicareb, missing
tab merge_year medicaid, missing
tab merge_year champus, missing
tab merge_year hmo, missing
tab merge_year medigap, missing



tab merge_year freqrelg, missing

tab merge_year adl_dr, missing
tab merge_year adl_wk, missing
tab merge_year adl_bh, missing
tab merge_year adl_e, missing
tab merge_year adl_tx, missing
tab merge_year adl_t, missing
tab merge_year adl_index, missing
tab merge_year adl_cat, missing
tab merge_year adl_independent, missing
tab merge_year adl_partial, missing
tab merge_year adl_severe, missing
tab merge_year adl_bedbound, missing
tab merge_year iadl_mp, missing
tab merge_year iadl_gr, missing
tab merge_year iadl_ph, missing
tab merge_year iadl_rx, missing
tab merge_year iadl_m , missing
tab merge_year iadl_ind, missing
tab merge_year iadl_cat, missing
tab merge_year iadl_independent, missing
tab merge_year iadl_partial, missing
tab merge_year iadl_severe, missing

mean child,over(merge_year)
mean gchil,over(merge_year)
mean allchil,over(merge_year)
mean reschil,over(merge_year)
tab merge_year reschil_d, missing
tab  merge_year resspouse, missing
mean hhm,over(merge_year)



tab merge_year livealone, missing
tab merge_year nhres, missing
tab merge_year hospice, missing

tab merge_year cancer_hrs, missing
tab merge_year lung_hrs, missing
tab merge_year heart_hrs, missing
tab merge_year chf_hrs, missing
tab merge_year stroke_hrs, missing
tab merge_year memory_hrs, missing
tab merge_year falls_hrs, missing
tab merge_year incont_hrs, missing
tab merge_year pain_hrs, missing
tab merge_year htn_hrs, missing
tab merge_year dm_hrs, missing
tab merge_year psych_hrs, missing
tab merge_year arth_hrs, missing
tab merge_year comor_in_hrs, missing
tab merge_year comor_c_hrs, missing
tab merge_year advdir, missing
tab merge_year eolplan, missing
tab merge_year discuss, missing
tab merge_year hcp, missing
tab merge_year lwill, missing
tab merge_year lw_all, missing
tab merge_year lw_lim, missing
tab merge_year lw_whld, missing
tab merge_year lw_comf, missing
tab merge_year dexp, missing
tab merge_year eoldec, missing
tab merge_year duration, missing
tab merge_year capacity, missing
tab merge_year decmaker, missing
tab merge_year dec_all, missing
tab merge_year dec_lim, missing
tab merge_year dec_whld, missing
tab merge_year dec_comf, missing
tab merge_year dec_cat, missing
tab merge_year adapp, missing
tab merge_year adprob, missing
tab merge_year location
tab merge_year icu, missing
tab merge_year vent, missing
tab merge_year dialysis, missing

log close













H="Clean..."


/*4073-694=3379 , -285=3094,-25=3069*/
data sas.ids_meet_criteria_1y_0209_2012(drop=death_date2 birth_date2);
set all_insurance2;
if hmo_1y~=1;

if part_ab_1y ;

if death_date2>=mdy(01,01,2001);
if (death_date2-birth_date2)/365.25>=66;
bid_hrs=bid_hrs_10;
death_date_res=death_date;
death_date=death_date2;
birth_date_res=birth_date;
birth_date=birth_date2;
run;



ods rtf body ="&report_path.\hospice_impact_N_ids_eligible.rtf";
proc sql;
title "total N from exit 2002 to 2008";
select count(*) from exit.exit_2002_to_2008_id;


title "meet age>=66";
/*4665 meet the age >=66*/



select count(*) from exit_re2
where (death_date2-birth_date2)/365.25>=66;

/*4176 ids of 4665 has the cross walk ids.*/
title "have the corresponding cross walk bid-hrsid";


select count(*) from exit_re_age_ge66 
where id in 
(select id from BID_MTSI_1);



title "have dn information on last years insurance ";
select count(*) from all_insurance2;
title "those with hmo in the last 1 yr";
select count(*) from all_insurance2 where hmo_1y=1 ;
title "those without part a and part b in the whole last 1 year";
select count(*) from all_insurance2 where hmo_1y<1 and part_ab_1y<=0 ;
title "those who died before 01/01/2001 since the earliest available cms data is 2000";
select count(*) from all_insurance2 where hmo_1y<1 and part_ab_1y=1 and death_date2<mdy(01,01,2001);

title "final N, 4073-694-285-25=3069";
select count(*) from sas.ids_meet_criteria_1y_0209_2012; 
quit;
ods rtf close;

H="intensive procedure"




libname medi "C:\data\CMS\medicare_2008";
libname sas "C:\projects\Procedures\raw_data";
proc contents data=sas.bid_list_in_final_model_6m2;
run;


%macro mp(month_n=,days_start=,days_bef_death=,source=,equ=);
%let source0=mp;

proc sql;
create table &source._meet as select a.BID_hrs,
a.PRCDR_CD1,a.PRCDR_CD2,
a.PRCDR_CD3,a.PRCDR_CD4,
a.PRCDR_CD5,a.PRCDR_CD6,
a.icarecnt,b.death_date
from medi.&source0._2000_2008(where=(trim(left(SSLSSNF))&equ.="N")) a inner join
sas.ids_meet_criteria_1y_0216_2012 b
on trim(left(a.BID_hrs))=trim(left(b.BID_hrs))
and &days_start<=b.death_date-a.admit_date<=&days_bef_death;
quit;

%mend;



%mp(month_n=6,days_start=0,days_bef_death=183,source=ip,equ=~ );
proc contents data=ip_meet(keep=PRCDR_CD1);
run;

data proc_long(keep=BID_hrs procedure pro);
set ip_meet;
array list PRCDR_CD1-PRCDR_CD6;
do over list;
if list~="" then do;
pro=list;
procedure=list+0;
output;
end;
end;
run;
*import the data file;
proc import datafile="C:\projects\Procedures\raw_data\procedure_ccs_231.xlsx"
out=proc_ccs replace;
run;

proc sql;
create table proc_long_2 as 
select a.*,b.CCS_CATEGORY
from proc_long a
left join 
proc_ccs b
on a.procedure=b.ICD_9_CM_CODE;
quit;
proc freq;
table CCS_CATEGORY;
run;
data proc_long_3;
set proc_long_2;
array list int_trach int_ptca int_cath int_icd int_hemodia int_bmt int_feedtube  int_intubat;
do over list;
list=0;
end;
if CCS_CATEGORY=34 then int_trach =1;
if CCS_CATEGORY=45 then  int_ptca=1;
if CCS_CATEGORY=47 then  int_cath =1;
if CCS_CATEGORY=48 then  int_icd=1;
if CCS_CATEGORY=58 then  int_hemodia=1;
if CCS_CATEGORY=64 then  int_bmt=1;
if CCS_CATEGORY=71 then  int_feedtube=1;
if CCS_CATEGORY=216 then  int_intubat=1;
run;

proc sql;
create table proc_sum as
select distinct BID_hrs,sum(int_trach) as int_trach,
sum(int_ptca) as int_ptca,
sum(int_cath) as int_cath,
sum(int_icd) as int_icd,
sum(int_hemodia) as int_hemodia,
sum(int_bmt) as int_bmt,
sum(int_feedtube) as int_feedtube,
sum(int_intubat) as int_intubat
from proc_long_3 group by BID_hrs;
quit;
data proc_intensive;
set proc_sum;
array list int_trach int_ptca int_cath int_icd int_hemodia int_bmt int_feedtube  int_intubat;
do over list;
if list>0 then list=1;
end;
label int_trach="Tracheostomy; temporary and permanent";
label int_ptca="Percutaneous transluminal coronary angioplasty";
label int_cath="Diagnostic cardiac catheterization; coronary arteriography";
label int_icd="Insertion; revision; replacement; removal of cardiac pacemaker or cardioverter/defibrillator";
label int_hemodia="Hemodialysis";
label int_bmt=" Bone marrow transplant";
label int_feedtube='Gastrostomy; temporary and permanent';
label int_intubat='Respiratory intubation and mechanical ventilation';
run;
   

      
/*
proc import datafile="C:\Documents and Settings\duq01\Desktop\du\amy\data\ccs_ahrq\ccs_231_label.xlsx"
out=ccs_label replace;
run;
proc sql;
select * from ccs_label where intensive is not null;
quit;
*/
proc sql;
create table proc_intensive_6m(drop=BID_hrs2) as select a.bid_hrs,b.*
from sas.ids_meet_criteria_1y_0216_2012 a 
left join 
proc_intensive(rename=(bid_hrs=bid_hrs2)) b
on trim(left(a.BID_hrs))=trim(left(b.BID_hrs2));
quit;
data sas.proc_intensive_6m_old_def;
set proc_intensive_6m;
array list int_trach int_ptca int_cath int_icd int_hemodia int_bmt int_feedtube  int_intubat;
do over list;
if list=. then list=0;
end;
run;

/*end of old definiton,according to ccs 233 categories,*/


/*new definiton according to Barnato 's paper,6 intensive presedure
int_intubation_2
int_trach_2
int_gastro_tude_2
int_hemodia_2
int_enteral_nut_2
int_cpr_2


*/

data proc_long_ba;
set proc_long;
array list 
int_intubation_2
int_trach_2
int_gastro_tude_2
int_hemodia_2
int_enteral_nut_2
int_cpr_2;
do over list;
list=0;
end;

if length(trim(left(pro)))>=3 then do;

if  substr(trim(left(pro)),1,3) in ("967")  then int_intubation_2 =1;
if  substr(trim(left(pro)),1,3) in ("311") then  int_trach_2=1;
if  substr(trim(left(pro)),1,3) in ("432") then  int_gastro_tude_2=1;

if substr(trim(left(pro)),1,3) in ("966") then  int_enteral_nut_2=1;


if length(trim(left(pro)))>3 then do;
if substr(trim(left(pro)),1,4) in ("9604","9605") or substr(trim(left(pro)),1,3) in ("967")  then int_intubation_2 =1;
if substr(trim(left(pro)),1,4) in ("3121","3129") or substr(trim(left(pro)),1,3) in ("311") then  int_trach_2=1;
if substr(trim(left(pro)),1,4) in ("4311","4319","4432")  or substr(trim(left(pro)),1,3) in ("432") then  int_gastro_tude_2=1;
if substr(trim(left(pro)),1,4) in ("3995") then  int_hemodia_2=1;
if substr(trim(left(pro)),1,4) in ("9915")  or substr(trim(left(pro)),1,3) in ("966") then  int_enteral_nut_2=1;
if substr(trim(left(pro)),1,4) in ("9960","9963") then  int_cpr_2=1;
end;

end;
run;
*




;
proc sql;
create table proc_sum_new as
select distinct BID_hrs,
sum(int_intubation_2) as int_intubation_2,
sum(int_trach_2) as int_trach_2,
sum(int_gastro_tude_2) as int_gastro_tude_2,
sum(int_hemodia_2) as int_hemodia_2,
sum(int_enteral_nut_2) as int_enteral_nut_2,
sum(int_cpr_2) as int_cpr_2
from proc_long_ba group by BID_hrs;
quit;




data proc_intensive_new;
set proc_sum_new;
array list int_intubation_2
int_trach_2
int_gastro_tude_2
int_hemodia_2
int_enteral_nut_2
int_cpr_2;
do over list;
if list>0 then list=1;
end;
label int_intubation_2="intubation/mechanic ventilation,Barnato";
label int_trach_2="trachostomy,Barnato";
label int_gastro_tude_2="gastrostomy tube,Barnato";
label int_hemodia_2="hemodialysis,Barnato";
label int_enteral_nut_2="enteral/parenteral nutrition,Barnato";
label int_cpr_2="CPR,Barnato";

run;
   

      
/*
proc import datafile="C:\Documents and Settings\duq01\Desktop\du\amy\data\ccs_ahrq\ccs_231_label.xlsx"
out=ccs_label replace;
run;
proc sql;
select * from ccs_label where intensive is not null;
quit;
*/
proc sql;
create table proc_intensive_6m2(drop=bid_hrs2) as select a.bid_hrs,b.*
from sas.ids_meet_criteria_1y_0216_2012 a 
left join 
proc_intensive_new(rename=(bid_hrs=bid_hrs2)) b
on trim(left(a.BID_hrs))=trim(left(b.BID_hrs2));
quit;
data sas.proc_intensive_6m_new_def;
set proc_intensive_6m2;
array list int_intubation_2
int_trach_2
int_gastro_tude_2
int_hemodia_2
int_enteral_nut_2
int_cpr_2;
do over list;
if list=. then list=0;
end;

run;


*
data sas.proc_intensive_6m_old_def;

proc sql;
create table  proc_intensive_new_old as select * 
from 
 sas.proc_intensive_6m_new_def a
 inner join
sas.proc_intensive_6m_old_def b
on trim(left(a.BID_hrs))=trim(left(b.BID_hrs));
quit;

ods rtf body="C:\projects\Procedures\report\freq_intensive_procedures.rtf";
title "intensive procedure";
proc freq data=proc_intensive_new_old(drop=BID_hrs);
table _all_;
run;

proc freq data=proc_intensive_new_old(drop=BID_hrs);
table int_intubation_2*int_intubat 
int_trach_2*int_trach 
int_gastro_tude_2*int_feedtube
int_hemodia_2*int_hemodia

;*int_enteral_nut_2 int_cpr_2;

run;

ods rtf close;



libname final "C:\projects\Procedures\final_data";
/*the hospice_impact data is from 05/16/2012 version*/
proc sql;
create table final.intensive_procedure(drop=BID_hrs2) as select 
a.*,
b.*
from final.hospice_impact a
left join
proc_intensive_new_old(rename=(BID_hrs=BID_hrs2)) b
on trim(left(a.BID_hrs))=trim(left(b.BID_hrs2));
quit;



/*add the live up to,such as lp029 from hrs core -1 interviews*/
libname raw "C:\projects\Procedures\raw_data";
libname final "C:\projects\Procedures\final_data";
data final.intensive_procedure_07032012;
set  final.intensive_procedure;
run;

proc sql;
create table final.intensive_procedure as select a.*,b.live_up_to as 
live_up_to_c1 label="live up to,such as lp029,in the negative 1 core"
from final.intensive_procedure_07032012 a 
left join
raw.live_2000_to_2008 b 
on a.id=b.id and a.merge_year-2=b.year;
quit;
proc freq data=temp;
table live_up_to_1c;
run;

proc contents data=final.intensive_procedure;
run;

proc freq data=final.intensive_procedure;
table merge_year;
run;





libname medi "C:\data\CMS\medicare_2008";
libname sas "C:\projects\Procedures\raw_data";
proc contents data=sas.bid_list_in_final_model_6m2;
run;

proc contents data=medi.mp_2000_2008(keep=p:);
run;
proc sql outobs=10;
select PRCDR_DT1
 from medi.mp_2000_2008;
 quit;



%macro mp(month_n=,days_start=,days_bef_death=,source=,equ=);
%let source0=mp;

proc sql;
create table &source._meet as select a.*,b.death_date
from medi.&source0._2000_2008(where=(trim(left(SSLSSNF))&equ.="N")) a inner join
sas.ids_meet_criteria_1y_0216_2012 b
on trim(left(a.BID_hrs))=trim(left(b.BID_hrs))
and &days_start<=b.death_date-a.admit_date<=&days_bef_death;
quit;

%mend;



%mp(month_n=6,days_start=0,days_bef_death=183,source=ip,equ=~ );


data proc_long(keep=BID_hrs pro procedure_date);
set ip_meet;
array list PRCDR_CD1-PRCDR_CD6;
array date PRCDR_dt1-PRCDR_dt6;
do over list;
if list~="" then do;
pro=list+0;
procedure_date=datejul(date);
output;
end;
end;
format procedure_date date10.;
run;


*import the data file;
/*not to use the old definitions
proc import datafile="C:\Documents and Settings\duq01\Desktop\du\amy\data\ccs_ahrq\procedure_ccs_231.xlsx"
out=proc_ccs replace;
run;

proc sql;
create table proc_long_2 as 
select a.*,b.CCS_CATEGORY
from proc_long a
left join 
proc_ccs b
on a.procedure=b.ICD_9_CM_CODE;
quit;
proc freq;
table CCS_CATEGORY;
run;
data proc_long_3;
set proc_long_2;
array list int_trach int_ptca int_cath int_icd int_hemodia int_bmt int_feedtube  int_intubat;
do over list;
list=0;
end;
if CCS_CATEGORY=34 then do ;
date_proc=procedure_date;
int_trach =1;
end;
if CCS_CATEGORY=45 then do ;
date_proc=procedure_date;
int_ptca=1;
end;
if CCS_CATEGORY=47 then do ;
date_proc=procedure_date;  int_cath =1;
end;

if CCS_CATEGORY=48 then do ;
date_proc=procedure_date;  int_icd=1;
end;


if CCS_CATEGORY=58 then do ;
date_proc=procedure_date;  int_hemodia=1;
end;
if CCS_CATEGORY=64 then do ;
date_proc=procedure_date; int_bmt=1;
end;
if CCS_CATEGORY=71 then do ;
date_proc=procedure_date;  int_feedtube=1;
end;
if CCS_CATEGORY=216 then do ;
date_proc=procedure_date;  int_intubat=1;
end;
run;

proc sql;
create table proc_sum as
select distinct BID_MTSI_1,sum(int_trach) as int_trach,min(date_proc) as first_proc_date_6m format=date10.,
sum(int_ptca) as int_ptca,
sum(int_cath) as int_cath,
sum(int_icd) as int_icd,
sum(int_hemodia) as int_hemodia,
sum(int_bmt) as int_bmt,
sum(int_feedtube) as int_feedtube,
sum(int_intubat) as int_intubat
from proc_long_3 group by BID_MTSI_1;
quit;
data proc_intensive;
set proc_sum;
array list int_trach int_ptca int_cath int_icd int_hemodia int_bmt int_feedtube  int_intubat;
do over list;
if list>0 then list=1;
end;
label int_trach="Tracheostomy; temporary and permanent";
label int_ptca="Percutaneous transluminal coronary angioplasty";
label int_cath="Diagnostic cardiac catheterization; coronary arteriography";
label int_icd="Insertion; revision; replacement; removal of cardiac pacemaker or cardioverter/defibrillator";
label int_hemodia="Hemodialysis";
label int_bmt=" Bone marrow transplant";
label int_feedtube='Gastrostomy; temporary and permanent';
label int_intubat='Respiratory intubation and mechanical ventilation';
run;
   
*/





/*new definiton according to Barnato 's paper,6 intensive presedure
int_intubation_2
int_trach_2
int_gastro_tude_2
int_hemodia_2
int_enteral_nut_2
int_cpr_2


*/

data proc_long_ba;
set proc_long;
array list 
int_intubation_2
int_trach_2
int_gastro_tude_2
int_hemodia_2
int_enteral_nut_2
int_cpr_2;
do over list;
list=0;
end;

if length(trim(left(pro)))>=3 then do;

if  substr(trim(left(pro)),1,3) in ("967")  then int_intubation_2 =1;
if  substr(trim(left(pro)),1,3) in ("311") then  int_trach_2=1;
if  substr(trim(left(pro)),1,3) in ("432") then  int_gastro_tude_2=1;

if substr(trim(left(pro)),1,3) in ("966") then  int_enteral_nut_2=1;


if length(trim(left(pro)))>3 then do;
if substr(trim(left(pro)),1,4) in ("9604","9605") or substr(trim(left(pro)),1,3) in ("967")  then int_intubation_2 =1;
if substr(trim(left(pro)),1,4) in ("3121","3129") or substr(trim(left(pro)),1,3) in ("311") then  int_trach_2=1;
if substr(trim(left(pro)),1,4) in ("4311","4319","4432")  or substr(trim(left(pro)),1,3) in ("432") then  int_gastro_tude_2=1;
if substr(trim(left(pro)),1,4) in ("3995") then  int_hemodia_2=1;
if substr(trim(left(pro)),1,4) in ("9915")  or substr(trim(left(pro)),1,3) in ("966") then  int_enteral_nut_2=1;
if substr(trim(left(pro)),1,4) in ("9960","9963") then  int_cpr_2=1;
end;

end;

if int_intubation_2|
int_trach_2|
int_gastro_tude_2|
int_hemodia_2|
int_enteral_nut_2|
int_cpr_2 then date_proc=procedure_date;
run;
*




;
proc sql;
create table proc_sum_new as
select distinct BID_hrs,
min(date_proc) as first_proc_date_6m format=date10.
label="first intensive procedure date in the last 6m,Barnato",
sum(int_intubation_2) as int_intubation_2,
sum(int_trach_2) as int_trach_2,
sum(int_gastro_tude_2) as int_gastro_tude_2,
sum(int_hemodia_2) as int_hemodia_2,
sum(int_enteral_nut_2) as int_enteral_nut_2,
sum(int_cpr_2) as int_cpr_2
from proc_long_ba group by BID_hrs;
quit;




data proc_intensive_new;
set proc_sum_new;
array list int_intubation_2
int_trach_2
int_gastro_tude_2
int_hemodia_2
int_enteral_nut_2
int_cpr_2;
do over list;
if list>0 then list=1;
end;
label int_intubation_2="intubation/mechanic ventilation,Barnato";
label int_trach_2="trachostomy,Barnato";
label int_gastro_tude_2="gastrostomy tube,Barnato";
label int_hemodia_2="hemodialysis,Barnato";
label int_enteral_nut_2="enteral/parenteral nutrition,Barnato";
label int_cpr_2="CPR,Barnato";

run;
   
proc sql;
select count(*),count(first_proc_date_6m)
from proc_intensive_new where (int_intubation_2
+int_trach_2
+int_gastro_tude_2
+int_hemodia_2
+int_enteral_nut_2
+int_cpr_2)>0;
quit;

proc freq;
table int:;
run;
proc sql;
create table proc_intensive_6m2(drop=bid_hrs2) as select a.bid_hrs,a.death_date,b.*
from sas.ids_meet_criteria_1y_0216_2012 a 
left join 
proc_intensive_new(rename=(bid_hrs=bid_hrs2)) b
on trim(left(a.BID_hrs))=trim(left(b.BID_hrs2));
quit;
data proc_intensive_6m_new_def;
set proc_intensive_6m2;
array list int_intubation_2
int_trach_2
int_gastro_tude_2
int_hemodia_2
int_enteral_nut_2
int_cpr_2;
do over list;
if list=. then list=0;
end;
days_1st_proc_death=death_date-first_proc_date_6m;
if .<days_1st_proc_death<0 then days_1st_proc_death=0;
label days_1st_proc_death="the days from the first procedure date in the last 6m to death";
run;


/*add the live up to,such as lp029 from hrs core -1 interviews*/
libname raw "C:\projects\Procedures\raw_data";
libname final "C:\projects\Procedures\final_data";
data final.intensive_procedure_07122012;
set  final.intensive_procedure;
run;

proc sql;
create table final.intensive_procedure_temp as select a.*,
b.days_1st_proc_death
from final.intensive_procedure_07122012 a 
left join
 proc_intensive_6m_new_def b 
on trim(left(a.bid_hrs))=trim(left(b.bid_hrs)) ;
quit;

proc contents data=final.intensive_procedure;
run;
proc sql;
create table intensive_procedure_1(drop=bid_hrs2)
as select * from
final.intensive_procedure_temp a
left join
sas.chronic_21_n12m_n0(rename=(bid_hrs=bid_hrs2)) b 
on trim(left(a.bid_hrs))=trim(left(b.bid_hrs2));
quit;
proc sql;
create table intensive_procedure_2(drop=BID_hrs2) as select a.*,
b.*
from 
intensive_procedure_1 a left join
sas.elix_0d_n12m_2(rename=(BID_hrs=BID_hrs2)) b
on trim(left(a.BID_hrs))=trim(left(b.BID_hrs2));
quit;

/*end of addinting [0m,-12m], the follow is to add elixhauser[-18m,6m]*/

proc sql;
create table intensive_procedure_2(drop=BID_hrs2) as select a.*,
b.*
from 
intensive_procedure_1 a left join
sas.elix_0d_n12m_2(rename=(BID_hrs=BID_hrs2)) b
on trim(left(a.BID_hrs))=trim(left(b.BID_hrs2));
quit;

libname final "C:\projects\Procedures\final_data";

proc sql;
create table final.intensive_procedure(drop=BID_hrs2) as select a.*,
b.*
from 
intensive_procedure_2 a left join
sas.elix_184d_n18m_2(rename=(BID_hrs=BID_hrs2)) b
on trim(left(a.BID_hrs))=trim(left(b.BID_hrs2));
quit;




H="intensive procedure add elixhauser,chronic,[-6m,-12m]"

libname final "C:\projects\Hospice_impact_on_utilization\final_data";


options compress=yes;
libname sas "C:\projects\Hospice_impact_on_utilization\raw_data";

%let medi=C:\data\CMS\medicare_2008;
/*new hrs cms id cross walk from cms 02/08/2012*/
libname medi "&medi";


%macro other(days_start=,days_bef_death=,source=);

proc sql;
create table &source._meet as select a.*,b.death_date
from medi.&source._2000_2008 a inner join
sas.ids_meet_criteria_1y_0209_2012 b
on trim(left(a.bid_hrs))=trim(left(b.bid_hrs))
and &days_start<=b.death_date-a.admit_date<=&days_bef_death;
quit;

/*&source._paid_by_mc=(pmt_amt+passthru)*pct_6m;*/
run;

%mend;

%macro mp(days_start=,days_bef_death=,source=);
%let source0=mp;

proc sql;
create table &source._meet as select a.*,b.death_date
from medi.&source0._2000_2008 a inner join
sas.ids_meet_criteria_1y_0209_2012 b
on trim(left(a.bid_hrs))=trim(left(b.bid_hrs))
and &days_start<=b.death_date-a.admit_date<=&days_bef_death;
quit;

proc sql;
create table &source._meet2 as select a.*,b.death_date
from medi.&source0._2000_2008 a inner join
sas.ids_meet_criteria_1y_0209_2012 b
on trim(left(a.bid_hrs))=trim(left(b.bid_hrs))
and b.death_date-a.admit_date>&days_bef_death and b.death_date-a.disch_date<=&days_bef_death;
quit;

data &source._meet3;
set &source._meet &source._meet2;
run;

/*&source._paid_by_mc=(pmt_amt+passthru)*pct_6m;*/
run;

%mend;



%macro dx_time_range(range1=, range2=);
data pb_last_6m_dx(keep=bid_hrs diag);
set pb_meet(keep=bid_hrs PDGNS_CD DGNS_CD1-DGNS_CD4 );
array dx PDGNS_CD DGNS_CD1-DGNS_CD4;
do over dx;
diag=dx ;
output;
end;
run;
proc sort data=pb_last_6m_dx out=pb_last_6m_dx2 nodupkey;
by bid_hrs diag;
run;



data op_last_6m_dx(keep=bid_hrs diag);
set op_meet(keep=bid_hrs PDGNS_CD DGNSCD01-DGNSCD10  );
array dx PDGNS_CD DGNSCD01-DGNSCD10 ;
do over dx;
diag=dx ;
output;
end;
run;
proc sort data=op_last_6m_dx out=op_last_6m_dx2 nodupkey;
by bid_hrs diag;
run;

data mp_last_6m_dx(keep=bid_hrs diag);
set mp_meet3(keep=bid_hrs AD_DGNS DGNS_CD01-DGNS_CD10 );
array dx AD_DGNS DGNS_CD01-DGNS_CD10 ;
do over dx;
diag=dx ;
output;
end;
run;
proc sort data=mp_last_6m_dx out=mp_last_6m_dx2 nodupkey;
by bid_hrs diag;
run;

data dm_last_6m_dx(keep=bid_hrs diag);
set dm_meet(keep=bid_hrs PDGNS_CD DGNS_CD1-DGNS_CD4 );
array dx PDGNS_CD DGNS_CD1-DGNS_CD4 ;
do over dx;
diag=dx ;
output;
end;
run;
proc sort data=dm_last_6m_dx out=dm_last_6m_dx2 nodupkey;
by bid_hrs diag;
run;


data hh_last_6m_dx(keep=bid_hrs diag);
set hh_meet(keep=bid_hrs PDGNS_CD DGNSCD01-DGNSCD10 );
array dx PDGNS_CD DGNSCD01-DGNSCD10 ;
do over dx;
diag=dx ;
output;
end;
run;
proc sort data=hh_last_6m_dx out=hh_last_6m_dx2 nodupkey;
by bid_hrs diag;
run;


data hs_last_6m_dx(keep=bid_hrs diag);
set hs_meet(keep=bid_hrs PDGNS_CD DGNSCD01-DGNSCD10 );
array dx PDGNS_CD DGNSCD01-DGNSCD10 ;
do over dx;
diag=dx ;
output;
end;
run;
proc sort data=hs_last_6m_dx out=hs_last_6m_dx2 nodupkey;
by bid_hrs diag;
run;



data dx_all_last_6m_0106_2011;
set hs_last_6m_dx2
hh_last_6m_dx2
mp_last_6m_dx2
dm_last_6m_dx2
op_last_6m_dx2
pb_last_6m_dx2;
run;
proc sort data=dx_all_last_6m_0106_2011(where=(diag~="")) out=sas.dx_&range1._&range2 nodupkey;
by bid_hrs diag;
run;

%mend;



%macro rename(lib,dsn,pre);
options pageno=1 nodate;
proc contents data=&lib..&dsn;
title "Before Renaming All Variables";
run;
proc sql noprint;
select nvar into :num_vars
from dictionary.tables
where libname="&LIB" and
memname="&DSN";
select distinct(name) into :var1-
:var%TRIM(%LEFT(&num_vars))
from dictionary.columns
where libname="&LIB" and
memname="&DSN";
quit;
run;
proc datasets library=&LIB;
modify &DSN;
rename
%do i=1 %to &num_vars;
&&var&i=&&var&i.._&pre 
%end;
;
quit;
run;
options pageno=1 nodate;
proc contents data=&lib..&dsn;
title "After Renaming All Variables";
run;
%mend rename;




%macro elixhauser(range1=, range2=);




data dx_31_comor;
set sas.dx_&range1._&range2(rename=(diag=dx_0));
dx=trim(left(dx_0));

if dx~="" then do;

comorbi_1=0;
comorbi_2=0;
comorbi_3=0;
comorbi_4=0;
comorbi_5=0;
comorbi_6=0;
comorbi_7=0;
comorbi_8=0;
comorbi_9=0;
comorbi_10=0;
comorbi_11=0;
comorbi_12=0;
comorbi_13=0;
comorbi_14=0;
comorbi_15=0;
comorbi_16=0;
comorbi_17=0;
comorbi_18=0;
comorbi_19=0;
comorbi_20=0;
comorbi_21=0;
comorbi_22=0;
comorbi_23=0;
comorbi_24=0;
comorbi_25=0;
comorbi_26=0;
comorbi_27=0;
comorbi_28=0;
comorbi_29=0;
comorbi_30=0;
*end of intialize of 30 binary variables;
*add dementia;
dementia=0;

*do over dx;
	*Congestive Heart Failure;
	if (substr(dx,1,5)='39891' or
		substr(dx,1,5)='40211' or
		substr(dx,1,5)='40291' or
		substr(dx,1,5)='40411' or
		substr(dx,1,5)='40413' or
		substr(dx,1,5)='40491' or
		substr(dx,1,5)='40493' or
		substr(dx,1,3)='428') 
		and comorbi_1=0 
		then comorbi_1=1;*add one binary variables here.;
	*Cariac Arrhythmias;
	if (substr(dx,1,5)='42610' or
		substr(dx,1,5)='42611' or
		substr(dx,1,5)='42613' or
		substr(dx,1,4)='4262' or
		substr(dx,1,4)='4263' or
		substr(dx,1,4)='4264' or
		substr(dx,1,5)='42650' or
		substr(dx,1,5)='42651' or
		substr(dx,1,5)='42652' or
		substr(dx,1,5)='42653' or
		substr(dx,1,4)='4266' or
		substr(dx,1,4)='4267' or
		substr(dx,1,4)='4268' or
		substr(dx,1,4)='4270' or
		substr(dx,1,4)='4272' or
		substr(dx,1,5)='42731' or
		substr(dx,1,5)='42760' or
		substr(dx,1,4)='4279' or
		substr(dx,1,4)='7850' or
		substr(dx,1,4)='V450' or
		substr(dx,1,4)='V533')
			and comorbi_2=0 
		then comorbi_2=1;
	* ;
	if (substr(dx,1,5)='09320' or
		substr(dx,1,5)='09321' or
		substr(dx,1,5)='09322' or
		substr(dx,1,5)='09323' or
		substr(dx,1,5)='09324' or
		substr(dx,1,3)='394' or
		substr(dx,1,3)='395' or
		substr(dx,1,3)='396' or
		substr(dx,1,4)='3970' or
		substr(dx,1,4)='3971' or
		substr(dx,1,4)='4240' or
		substr(dx,1,4)='4241' or
		substr(dx,1,4)='4242' or
		substr(dx,1,4)='4243' or
		substr(dx,1,4)='4244' or
		substr(dx,1,4)='4245' or
		substr(dx,1,4)='4246' or
		substr(dx,1,4)='4247' or
		substr(dx,1,4)='4248' or
		substr(dx,1,5)='42490' or
		substr(dx,1,5)='42491' or
		substr(dx,1,4)='7463' or
		substr(dx,1,4)='7464' or
		substr(dx,1,4)='7465' or
		substr(dx,1,4)='7466' or
		substr(dx,1,4)='V422' or
		substr(dx,1,5)='V433')
			and comorbi_3=0 
		then comorbi_3=1;
	*Pulmonary Circulation Disorders;
	if (substr(dx,1,3)='416' or
		substr(dx,1,4)='4179')
			and comorbi_4=0 
		then comorbi_4=1;
	*Peripheral Vascular Disorders;
	if (substr(dx,1,3)='440' or
		substr(dx,1,4)='4412' or
		substr(dx,1,4)='4414' or
		substr(dx,1,4)='4417' or
		substr(dx,1,4)='4419' or
		substr(dx,1,4)='4431' or
		substr(dx,1,4)='4432' or
		substr(dx,1,4)='4438' or
		substr(dx,1,4)='4439' or
		substr(dx,1,4)='4471' or
		substr(dx,1,4)='5571' or
		substr(dx,1,4)='5579' or
		substr(dx,1,4)='V434')
			and comorbi_5=0 
		then comorbi_5=1;
	*Hypertension;
	if ((substr(dx,1,4)='4011' or
		substr(dx,1,4)='4019')) or
	   ((substr(dx,1,5)='40210' or
		substr(dx,1,5)='40290' or
		substr(dx,1,5)='40410' or
		substr(dx,1,5)='40490' or
		substr(dx,1,5)='40511' or
		substr(dx,1,5)='40519' or
		substr(dx,1,5)='40591' or
		substr(dx,1,5)='40599')) 
			and comorbi_6=0 
		then comorbi_6=1;
	*Paralysis;	
	if (substr(dx,1,4)='3420' or
		substr(dx,1,5)='34210' or
		substr(dx,1,5)='34211' or
		substr(dx,1,5)='34212' or
		substr(dx,1,4)='3429' or
		substr(dx,1,3)='343' or
		substr(dx,1,3)='344')
			and comorbi_7=0 
		then comorbi_7=1;
	*Other Neurological Disorders;
	if (substr(dx,1,4)='3319' or
		substr(dx,1,4)='3320' or
		substr(dx,1,4)='3334' or
		substr(dx,1,4)='3335' or
		substr(dx,1,3)='334' or
		substr(dx,1,3)='335' or
		substr(dx,1,3)='340' or
		substr(dx,1,4)='3411' or
		substr(dx,1,4)='3418' or
		substr(dx,1,4)='3419' or
		substr(dx,1,5)='34500' or
		substr(dx,1,5)='34501' or
		substr(dx,1,5)='34510' or
		substr(dx,1,5)='34511' or
		substr(dx,1,4)='3454' or
		substr(dx,1,5)='34550' or
		substr(dx,1,5)='34551' or
		substr(dx,1,4)='3458' or
		substr(dx,1,5)='34590' or
		substr(dx,1,5)='34591' or
		substr(dx,1,4)='3481' or
		substr(dx,1,4)='3483' or
		substr(dx,1,4)='7803' or
		substr(dx,1,4)='7843') 
			and comorbi_8=0 
		then comorbi_8=1;	
	*Chronic Pulmonary Disease;
	if (substr(dx,1,3)='490' or
		substr(dx,1,3)='491' or
		substr(dx,1,3)='492' or
		substr(dx,1,4)='4930' or
		substr(dx,1,4)='4931' or
		substr(dx,1,4)='4932' or
		substr(dx,1,4)='4938' or
		substr(dx,1,5)='49390' or
		substr(dx,1,5)='49391' or
		substr(dx,1,3)='494' or
		substr(dx,1,3)='495' or
		substr(dx,1,3)='496' or
		substr(dx,1,3)='497' or
		substr(dx,1,3)='498' or
		substr(dx,1,3)='499' or
		substr(dx,1,3)='500' or
		substr(dx,1,3)='501' or
		substr(dx,1,3)='502' or
		substr(dx,1,3)='503' or
		substr(dx,1,3)='504' or
		substr(dx,1,3)='505' or
		substr(dx,1,4)='5064') 
			and comorbi_9=0 
		then comorbi_9=1;	
	*Diabetes, uncomplicated;
	if (substr(dx,1,4)='2500' or
		substr(dx,1,4)='2501' or
		substr(dx,1,4)='2502' or
		substr(dx,1,4)='2503') 
			and comorbi_10=0 
		then comorbi_10=1;
	*Diabetes, complicated;
	if (substr(dx,1,4)='2504' or
		substr(dx,1,4)='2505' or
		substr(dx,1,4)='2506' or
		substr(dx,1,4)='2507' or
		substr(dx,1,4)='2509') 
			and comorbi_11=0 
		then comorbi_11=1;
	*Hypothyroidism;
	if (substr(dx,1,3)='243' or
		substr(dx,1,4)='2440' or
		substr(dx,1,4)='2441' or
		substr(dx,1,4)='2442' or
		substr(dx,1,4)='2448' or
		substr(dx,1,4)='2449') 	
			and comorbi_12=0 
		then comorbi_12=1;
	*Renal Failure;
	if (substr(dx,1,5)='40311' or
		substr(dx,1,5)='40391' or
		substr(dx,1,5)='40412' or
		substr(dx,1,5)='40492' or
		substr(dx,1,3)='585' or
		substr(dx,1,3)='586' or
		substr(dx,1,4)='V420' or
		substr(dx,1,4)='V451' or
		substr(dx,1,4)='V560' or
		substr(dx,1,4)='V568') 
			and comorbi_13=0 
		then comorbi_13=1;
	*Liver Disease;
	if (substr(dx,1,5)='07032' or
		substr(dx,1,5)='07033' or
		substr(dx,1,5)='07054' or
		substr(dx,1,4)='4560' or
		substr(dx,1,4)='4561' or
		substr(dx,1,5)='45620' or
		substr(dx,1,5)='45621' or
		substr(dx,1,4)='5710' or
		substr(dx,1,4)='5712' or
		substr(dx,1,4)='5713' or
		substr(dx,1,4)='5714' or
		substr(dx,1,4)='5715' or
		substr(dx,1,4)='5716' or
		substr(dx,1,4)='5718' or
		substr(dx,1,4)='5719' or
		substr(dx,1,4)='5723' or
		substr(dx,1,4)='5728' or
		substr(dx,1,4)='V427') 
			and comorbi_14=0 
		then comorbi_14=1;
	*Peptic Ulcer Disease excluding bleeding;
	if (substr(dx,1,5)='53170' or
		substr(dx,1,5)='53190' or
		substr(dx,1,5)='53270' or
		substr(dx,1,5)='53290' or
		substr(dx,1,5)='53370' or
		substr(dx,1,5)='53390' or
		substr(dx,1,5)='53470' or
		substr(dx,1,5)='53490' or
		substr(dx,1,5)='V1271') 
			and comorbi_15=0 
		then comorbi_15=1;
	*AIDS;
	if (substr(dx,1,3)='042' or
		substr(dx,1,3)='043' or
		substr(dx,1,3)='044') 
			and comorbi_16=0 
		then comorbi_16=1;
	*Lymphoma;
	if (substr(dx,1,3)='200' or
		substr(dx,1,4)='201' or
		substr(dx,1,4)='2020' or
		substr(dx,1,4)='2021' or
		substr(dx,1,4)='2022' or
		substr(dx,1,4)='2023' or
		substr(dx,1,4)='2025' or
		substr(dx,1,4)='2026' or
		substr(dx,1,4)='2027' or
		substr(dx,1,4)='2028' or
		substr(dx,1,4)='2029' or
		substr(dx,1,4)='2030' or
		substr(dx,1,4)='2038' or
		substr(dx,1,4)='2386' or
		substr(dx,1,4)='2733' or
		substr(dx,1,4)='V1071' or
		substr(dx,1,4)='V1072' or
		substr(dx,1,4)='V1079')
			and comorbi_17=0 
		then comorbi_17=1;
	*Metastatic Cancer;
	if (substr(dx,1,3)='196' or
		substr(dx,1,3)='197' or
		substr(dx,1,3)='198' or
		substr(dx,1,4)='199') 
			and comorbi_18=0 
		then comorbi_18=1;	
	*Solid Tumor without Metastisis;
	if (substr(dx,1,2)='14' or
		substr(dx,1,2)='15' or
		substr(dx,1,2)='16' or
		substr(dx,1,3)='170' or
		substr(dx,1,3)='171' or
		substr(dx,1,3)='172' or
		substr(dx,1,3)='174' or
		substr(dx,1,3)='175' or
		substr(dx,1,3)='179' or
		substr(dx,1,2)='18' or
		substr(dx,1,3)='190' or
		substr(dx,1,3)='191' or
		substr(dx,1,3)='192' or
		substr(dx,1,3)='193' or
		substr(dx,1,3)='194' or
		substr(dx,1,3)='195' or
		substr(dx,1,3)='V10')
			and comorbi_19=0 
		then comorbi_19=1;
	*Rheumatoid Arthritis/Collagen Vascular Diseases;
	if (substr(dx,1,4)='7010' or
		substr(dx,1,3)='710' or
		substr(dx,1,3)='714' or
		substr(dx,1,3)='720' or
		substr(dx,1,3)='725') 
			and comorbi_20=0 
		then comorbi_20=1;
	*Coagulopathy;
	if (substr(dx,1,3)='286' or
		substr(dx,1,4)='2871' or
		substr(dx,1,4)='2873' or
		substr(dx,1,4)='2874' or
		substr(dx,1,4)='2875') 
			and comorbi_21=0 
		then comorbi_21=1;
	*Obesity;
	if (substr(dx,1,4)='2780')  
			and comorbi_22=0 
		then comorbi_22=1;
	*Weight Loss;
	if (substr(dx,1,3)='260' or
		substr(dx,1,3)='261' or
		substr(dx,1,3)='262' or
		substr(dx,1,3)='263') 
			and comorbi_23=0 
		then comorbi_23=1;	
	*Fluid and Electrolyte Disorders;
	if (substr(dx,1,3)='276') 
			and comorbi_24=0 
		then comorbi_24=1;
	*Blood Loss Anemia;
	if (substr(dx,1,4)='2800') 
			and comorbi_25=0 
		then comorbi_25=1;
	*Deficiency Anemias;
	if (substr(dx,1,4)='2801' or
		substr(dx,1,4)='2808' or
		substr(dx,1,4)='2809' or
		substr(dx,1,4)='2859') 
			and comorbi_26=0 
		then comorbi_26=1;
	*Alcohol Abuse;
	if (substr(dx,1,4)='2911' or
		substr(dx,1,4)='2912' or
		substr(dx,1,4)='2915' or
		substr(dx,1,4)='2918' or
		substr(dx,1,4)='2919' or
		substr(dx,1,4)='3039' or
		substr(dx,1,4)='3050' or
		substr(dx,1,4)='V113') 
			and comorbi_27=0 
		then comorbi_27=1;
	*Drug Abuse;
	if (substr(dx,1,4)='2920' or
		substr(dx,1,5)='29282' or
		substr(dx,1,5)='29283' or
		substr(dx,1,5)='29284' or
		substr(dx,1,5)='29289' or
		substr(dx,1,4)='2929' or
		substr(dx,1,3)='304' or
		substr(dx,1,4)='3052' or
		substr(dx,1,4)='3053' or
		substr(dx,1,4)='3054' or
		substr(dx,1,4)='3055' or
		substr(dx,1,4)='3056' or
		substr(dx,1,4)='3057' or
		substr(dx,1,4)='3058' or
		substr(dx,1,4)='3059')
			and comorbi_28=0 
		then comorbi_28=1;	
	*Psychoses;
	if (substr(dx,1,3)='295' or
		substr(dx,1,3)='296' or
		substr(dx,1,3)='297' or
		substr(dx,1,3)='298' or
		substr(dx,1,4)='2991') 
			and comorbi_29=0 
		then comorbi_29=1;
	*Depression;
	if (substr(dx,1,4)='3004' or
		substr(dx,1,5)='30112' or
		substr(dx,1,4)='3090' or
		substr(dx,1,4)='3091' or
		substr(dx,1,3)='311')
			and comorbi_30=0 
		then comorbi_30=1;


		*add dementia;
		if (substr(dx,1,4) in ('3310','3311','3312','2900','2901',
             '2902','2903','2912','2948','2949') or
		substr(dx,1,5) in ('29410','29411','29040','29041','29042','29043')) 
		and dementia=0 
          then dementia=1;
end;

run;
*comorbi_all=comorbi_1+comorbi_2+comorbi_3+comorbi_4+comorbi_5+comorbi_6+comorbi_7+comorbi_8+comorbi_9+comorbi_10
+comorbi_11+comorbi_12+comorbi_13+comorbi_14+comorbi_15+comorbi_16+comorbi_17+comorbi_18+comorbi_19+comorbi_20
+comorbi_21+comorbi_22+comorbi_23+comorbi_24+comorbi_25+comorbi_26+comorbi_27+comorbi_28+comorbi_29+comorbi_30;
*run;

*331.0

331.1

331.2

290.0

290.1

290.2

290.3

290.4 (includes 290.40 - 290.43)

291.2

294.1 (includes 294.10 and 294.11)

294.8

294.9
;
 



proc sql;
create table com_test1 as
select distinct BID_hrs,
sum(comorbi_1) as com_1,
sum(comorbi_2) as com_2,
sum(comorbi_3) as com_3,
sum(comorbi_4) as com_4,
sum(comorbi_5) as com_5,
sum(comorbi_6) as com_6,
sum(comorbi_7) as com_7,
sum(comorbi_8) as com_8,
sum(comorbi_9) as com_9,
sum(comorbi_10) as com_10,
sum(comorbi_11) as com_11,
sum(comorbi_12) as com_12,
sum(comorbi_13) as com_13,
sum(comorbi_14) as com_14,
sum(comorbi_15) as com_15,
sum(comorbi_16) as com_16,
sum(comorbi_17) as com_17,
sum(comorbi_18) as com_18,
sum(comorbi_19) as com_19,
sum(comorbi_20) as com_20,
sum(comorbi_21) as com_21,
sum(comorbi_22) as com_22,
sum(comorbi_23) as com_23,
sum(comorbi_24) as com_24,
sum(comorbi_25) as com_25,
sum(comorbi_26) as com_26,
sum(comorbi_27) as com_27,
sum(comorbi_28) as com_28,
sum(comorbi_29) as com_29,
sum(comorbi_30) as com_30,
sum(dementia) as dementia
from dx_31_comor
group by BID_hrs;
quit;

data comorbidity_6m(keep=BID_hrs comorb_1-comorb_31 comorb_all);
set com_test1;
array list_com com_1-com_30 dementia;
array list_com_bin comorb_1-comorb_30 comorb_31;

do over list_com;
  list_com_bin=0;

  if list_com>0 then do;
    list_com_bin=1;
   end;

end;
comorb_all=comorb_1+comorb_2+comorb_3+comorb_4+comorb_5+comorb_6+comorb_7+comorb_8+comorb_9+comorb_10
+comorb_11+comorb_12+comorb_13+comorb_14+comorb_15+comorb_16+comorb_17+comorb_18+comorb_19+comorb_20
+comorb_21+comorb_22+comorb_23+comorb_24+comorb_25+comorb_26+comorb_27+comorb_28+comorb_29+comorb_30
+comorb_31;

run;
proc sort data=comorbidity_6m nodupkey;
by BID_hrs;
run;
proc sql;
create table ids_meet_criteria_6m13 as
select a.*,b.*
from sas.ids_meet_criteria_1y_0209_2012
a left join
comorbidity_6m b
on trim(left(a.BID_hrs))=trim(left(b.BID_hrs));
quit;

data sas.elix_&range1._&range2;
set ids_meet_criteria_6m13;
array list comorb_1-comorb_31 comorb_all;
do over list;
if list=. then list=0;
end;

label comorb_1 ="Congestive Heart Failure";
label comorb_2 ="Cariac Arrhythmias";
label comorb_3 ="Valvular Disease";
label comorb_4 ="Pulmonary Circulation Disorders";
label comorb_5 ="Peripheral Vascular Disorders";
label comorb_6 ="Hypertension";
label comorb_7 ="Paralysis";
label comorb_8 ="Other Neurological Disorders";
label comorb_9 ="Chronic Pulmonary Disease";
label comorb_10 ="Diabetes, uncomplicated";
label comorb_11 ="Diabetes, complicated";
label comorb_12 ="Hypothyroidism";
label comorb_13 ="Renal Failure";
label comorb_14 ="Liver Disease";
label comorb_15 ="Peptic Ulcer Disease excluding bleeding";
label comorb_16 ="AIDS";
label comorb_17 ="Lymphoma";
label comorb_18 ="Metastatic Cancer";
label comorb_19 ="Solid Tumor without Metastisis";
label comorb_20 ="Rheumatoid Arthritis/Collagen Vascular Diseases";
label comorb_21 ="Coagulopathy";
label comorb_22 ="Obesity";
label comorb_23 ="Weight Loss";
label comorb_24 ="Fluid and Electrolyte Disorders";
label comorb_25 ="Blood Loss Anemia";
label comorb_26 ="Deficiency Anemias";
label comorb_27 ="Alcohol Abuse";
label comorb_28 ="Drug Abuse";
label comorb_29 ="Psychoses";
label comorb_30 ="Depression";
label comorb_31 ="Dementia";
run;


data test;
set sas.elix_&range1._&range2;
run;

%rename(WORK,TEST,&range1._&range2);

data sas.elix_&range1._&range2._2(rename =(bid_hrs_&range1._&range2=bid_hrs));
set test;
*rename bid_hrs_&range1._&range2=bid_hrs;
keep bid_hrs_&range1._&range2 comorb:;
run;
proc sort data=sas.elix_&range1._&range2._2;
by bid_hrs;
run;

%mend;




%mp(days_start=183,days_bef_death=365,source=mp );
%other(days_start=183,days_bef_death=365,source=hh );
%other(days_start=183,days_bef_death=365,source=hs );
%other(days_start=183,days_bef_death=365,source=dm );
%other(days_start=183,days_bef_death=365,source=op );
%other(days_start=183,days_bef_death=365,source=pb );
%dx_time_range(range1=n6m, range2=n12m);
%elixhauser(range1=n6m, range2=n12m);




proc freq;
table comorb:;
run;
proc contents data=SAS.ELIX_N6M_N12M_2
;
run;



proc sql;
create table hospice_impact_2(drop=BID_hrs2) as select a.*,
b.*
from 
final.hospice_impact a left join
SAS.ELIX_N6M_N12M_2(rename=(BID_hrs=BID_hrs2)) b
on trim(left(a.BID_hrs))=trim(left(b.BID_hrs2));
quit;

/*add the  days*/
















/*begin of chronic 21 conditions.*/
proc export data=sas.dx_n6m_n12m
outfile="C:\projects\Hospice_impact_on_utilization\raw_data\dx_n6m_n12m.dta" replace;
run;

*put the sas data to stata in to dot format;
/*
clear
set memory 500m
use "C:\projects\Hospice_impact_on_utilization\raw_data\dx_n6m_n12m.dta",clear

*tostring diag,gen(icd9_c)
gen new=ltrim(diag)
icd9 check new,gen(icd9_c)
 replace new="" if icd9_c>0 
 icd9 clean new,dots 
 

 replace diag=new
drop icd9_c new

save "C:\projects\Hospice_impact_on_utilization\raw_data\dx_n6m_n12m_2.dta",replace
/*the below is to clean procedure rather than icd9 code*/
/*
icd9p check var1,gen(picd9_c)
 replace var1="" if picd9_c>0 
 icd9p clean var1,dots 
  icd9p gen icd9_c_icd=icd9_c,desc 
  */

* to the cms 21 chronic comorbidity;

proc import 
datafile="C:\projects\Hospice_impact_on_utilization\raw_data\dx_n6m_n12m_2.dta" 
out=dx_n6m_n12m_2 replace;
run;


proc import datafile="C:\projects\Hospice_impact_on_utilization\raw_data\chronic_21_condition_icd9.xls" 
out=icd9_21_chronic dbms=xls replace;
run;
data icd9_21_chronic2;
set icd9_21_chronic;
icd9_wo_dot=compress(icd_9,".");
run;
proc contents data=icd9_21_chronic;
run;

proc sql;
select icd_9 into :chronic_desc1-:chronic_desc21 from icd9_21_chronic;
quit;
%put &chronic_desc10;
%put &chronic_desc5;

data n12m_n6m_dx;
set dx_n6m_n12m_2;
array list AMI
ALZH
ALZHDMTA
ATRIALFB
CATARACT
CHRNKIDN
COPD
CHF
DIABETES
GLAUCOMA
HIPFRAC
ISCHMCHT
DEPRESSN
OSTEOPRS
RA_OA
STRKETIA
CNCRBRST
CNCRCLRC
CNCRPRST
CNCRLUNG
CNCREndM
;
do over list ;
list=0;

end;
diag_string=diag;

if anydigit(substr(trim(left(diag_string)),1,1))=1 then do;
diag=diag_string+0;

if diag in (&chronic_desc1) then AMI=1;
if diag in (&chronic_desc2)  then ALZH=1;
if diag in (&chronic_desc3)  then ALZHDMTA=1;
if diag in (&chronic_desc4) then ATRIALFB=1;
if diag in (&chronic_desc5) then CATARACT=1;
if diag in (&chronic_desc6) then CHRNKIDN=1;
if diag in (&chronic_desc7) then COPD=1;
if diag in (&chronic_desc8) then CHF=1;
if diag in (&chronic_desc9) then DIABETES=1;
if diag in (&chronic_desc10) then GLAUCOMA=1;
if diag in (&chronic_desc11) then HIPFRAC=1;
if diag in (&chronic_desc12) then ISCHMCHT=1;
if diag in (&chronic_desc13) then DEPRESSN=1;
if diag in (&chronic_desc14) then OSTEOPRS=1;
if diag in (&chronic_desc15) then RA_OA=1;
if diag in (&chronic_desc16) then STRKETIA=1;
if diag in (&chronic_desc17) then CNCRBRST=1;
if diag in (&chronic_desc18) then CNCRCLRC=1;
if diag in (&chronic_desc19) then CNCRPRST=1;
if diag in (&chronic_desc20) then CNCRLUNG=1;
if diag in (&chronic_desc21) then CNCREndM=1;
end;

if anydigit(substr(trim(left(diag_string)),1,1))=0 then do;
if trim(left(diag_string)) in ("V431") then CATARACT=1;
if trim(left(diag_string)) in ("V801") then GLAUCOMA=1;
end;

run;


proc sql;
create table bid_dx_n18m_n6m(rename=(bid_hrs=bid)) as
select distinct bid_hrs,
sum(AMI) as AMI,
sum(ALZH) as ALZH,
sum(ALZHDMTA) as ALZHDMTA,
sum(ATRIALFB) as ATRIALFB,
sum(CATARACT) as CATARACT,
sum(CHRNKIDN) as CHRNKIDN,
sum(COPD) as COPD,
sum(CHF) as CHF,
sum(DIABETES) as DIABETES,
sum(GLAUCOMA) as GLAUCOMA,
sum(HIPFRAC) as HIPFRAC,
sum(ISCHMCHT) as ISCHMCHT,
sum(DEPRESSN) as DEPRESSN,
sum(OSTEOPRS) as OSTEOPRS,
sum(RA_OA) as RA_OA,
sum(STRKETIA) as STRKETIA,
sum(CNCRBRST) as CNCRBRST,
sum(CNCRCLRC) as CNCRCLRC,
sum(CNCRPRST) as CNCRPRST,
sum(CNCRLUNG) as CNCRLUNG,
sum(CNCREndM) as CNCREndM

from n12m_n6m_dx group by bid_hrs;
quit;

 proc sql;
 create table bid_dx_n18m_n6m2(drop=bid) as select a.bid_hrs,b.*
 from sas.ids_meet_criteria_1y_0209_2012 a
 left join
  bid_dx_n18m_n6m b 
 on trim(left(a.bid_hrs))=trim(left(b.bid));
 quit;

 data bid_dx_n18m_n6m3;
 set bid_dx_n18m_n6m2;
 array list AMI
ALZH
ALZHDMTA
ATRIALFB
CATARACT
CHRNKIDN
COPD
CHF
DIABETES
GLAUCOMA
HIPFRAC
ISCHMCHT
DEPRESSN
OSTEOPRS
RA_OA
STRKETIA
CNCRBRST
CNCRCLRC
CNCRPRST
CNCRLUNG
CNCREndM
;
do over list ;
if list>0 then list=1;
if list<=0 then list=0;
end;
AMI_isch=AMI|ISCHMCHT;
alzheim=ALZH|ALZHDMTA;
cncr_chronic=CNCRBRST|CNCRCLRC|CNCRPRST|CNCRLUNG|CNCREndM;
run;



proc means;
var AMI
ALZH
ALZHDMTA
ATRIALFB
CATARACT
CHRNKIDN
COPD
CHF
DIABETES
GLAUCOMA
HIPFRAC
ISCHMCHT
DEPRESSN
OSTEOPRS
RA_OA
STRKETIA
CNCRBRST
CNCRCLRC
CNCRPRST
CNCRLUNG
CNCREndM;
run;

data test;
set bid_dx_n18m_n6m3;
run;


%rename(WORK,TEST,n6n12);
data sas.chronic_21_n6n12_0;
set test;
bid_hrs=bid_hrs_n6n12;
drop bid_hrs_n6n12;
run;
data test;
set sas.chronic_21_n6n12_0;
run;
data sas.chronic_21_n6_n12;
set test;
AMI_isch_n6n12=AMI_n6n12|ISCHMCHT_n6n12;
alzheim_n6n12=ALZH_n6n12|ALZHDMTA_n6n12;
cncr_chronic_n6n12=CNCRBRST_n6n12|CNCRCLRC_n6n12|CNCRPRST_n6n12|CNCRLUNG_n6n12|CNCREndM_n6n12;
run;
proc freq;
table alzheim_n6mn0 cncr_chronic_n6mn0;
run;
proc contents;
run;


libname final "C:\projects\Hospice_impact_on_utilization\final_data";
proc sql;
create table hospice_impact_2(drop=BID_hrs2) as select a.*,
b.*
from 
final.hospice_impact a left join
SAS.ELIX_N6M_N12M_2(rename=(BID_hrs=BID_hrs2)) b
on trim(left(a.BID_hrs))=trim(left(b.BID_hrs2));
quit;

proc sql;
create table hospice_impact_3(drop=bid_hrs2)
as select * from
hospice_impact_2 a
left join
sas.chronic_21_n6_n12(rename=(bid_hrs=bid_hrs2)) b 
on trim(left(a.bid_hrs))=trim(left(b.bid_hrs2));
quit;
data final.hospice_impact_0718_2012;
set final.hospice_impact;
run;

data final.hospice_impact;
set hospice_impact_3;
run;
/*end of chronic 21 condirtions*/
/*rename hospice_impact in the final_data as hospice_impact_date*/
options fmterr=no;

proc export data=final.hospice_impact
outfile="C:\projects\Hospice_impact_on_utilization\final_data\hospice_impact.dta" replace;
run;


/*add the proxy_c1,proxy_c2,such as lp029 from hrs core -1 interviews*/
libname raw "C:\projects\Procedures\raw_data";
libname final "C:\projects\Procedures\final_data";
options fmterr=no;


proc sql;
create table intensive_procedure_1 as select * 
from final.intensive_procedure a 
left join
SAS.ELIX_N6M_N12M_2(rename=(BID_hrs=BID_hrs2)) b
on trim(left(a.BID_hrs))=trim(left(b.BID_hrs2));
quit;

proc sql;
create table intensive_procedure_2 as select * 
from intensive_procedure_1(drop=bid_hrs2) a 
left join
sas.chronic_21_n6_n12(rename=(bid_hrs=bid_hrs2)) b 
on trim(left(a.bid_hrs))=trim(left(b.bid_hrs2));
quit;
proc freq;
table proxy:;
run;



data final.intensive_procedure_0718_2012;
set final.intensive_procedure;
run;

data final.intensive_procedure;
set intensive_procedure_2;
run;
proc contents data=final.intensive_procedure;
run;


/*end of chronic 21 condirtions*/
/*rename hospice_impact in the final_data as hospice_impact_date*/
options fmterr=no;

proc export data=final.intensive_procedure
outfile="C:\projects\Procedures\final_data\intensive_procedure.dta" replace;
run;

proc contents data=final.intensive_procedure;
run;









H="notes"


/*
07/18
add elix,chronic in the [-12m,-6m],
add proxy_c1,proxy_c2

07/13/2012

add days_1st_proc_death


added 07/03/2012
live_up_to_c1 label="live up to,such as lp029,in the negative 1 core"

the procedure code includes the chronic comorbidity,
and elixhauser's comorbodities  in different time range,
such as the last 6m,last 12m, the [18m,-6m],etc
updated on 05/16/2012

the other 
 
the intensive procedures using Barnato's method end with *_2

label int_intubation_2="intubation/mechanic ventilation,Barnato";
label int_trach_2="trachostomy,Barnato";
label int_gastro_tude_2="gastrostomy tube,Barnato";
label int_hemodia_2="hemodialysis,Barnato";
label int_enteral_nut_2="enteral/parenteral nutrition,Barnato";
label int_cpr_2="CPR,Barnato";
*/

/*
the old definition of intensive procedures :
label int_trach="Tracheostomy; temporary and permanent";
label int_ptca="Percutaneous transluminal coronary angioplasty";
label int_cath="Diagnostic cardiac catheterization; coronary arteriography";
label int_icd="Insertion; revision; replacement; removal of cardiac pacemaker or cardioverter/defibrillator";
label int_hemodia="Hemodialysis";
label int_bmt=" Bone marrow transplant";
label int_feedtube='Gastrostomy; temporary and permanent';
label int_intubat='Respiratory intubation and mechanical ventilation';
*/

H="Ling 071312"



*limit to those ;
* the bid list is in 
data sas.bid_list_in_final_model_6m,
combined ccu and icu into icu
CRNRYDAY;

libname medi 'C:\Documents and Settings\duq01\Desktop\du\amy\data\medicare\HRS- Mt Sinai School of Medicine_1';
libname sas "C:\Documents and Settings\duq01\Desktop\du\amy\data\sas_generated";



%macro mp(month_n=,days_start=,days_bef_death=,source=,equ=);
%let source0=mp;

proc sql;
create table &source._meet as select a.*
from medi.&source0._1998_2007(where=(trim(left(SSLSSNF))&equ.="N")) a inner join
sas.bid_list_in_final_model_6m2 b
on trim(left(a.BID_MTSI_1))=trim(left(b.BID))
and &days_start<=b.death_date-a.admit_date<=&days_bef_death;
quit;

%mend;



%mp(month_n=6,days_start=0,days_bef_death=183,source=ip,equ=~ );
proc contents data=medi.mp_1998_2007(keep=pr:);
run;

data proc_long(keep=BID_MTSI_1 procedure procedure_date);
set ip_meet;
array list PRCDR_CD1-PRCDR_CD6;
array date PRCDR_dt1-PRCDR_dt6;
do over list;
if list~="" then do;
procedure=list+0;
procedure_date=datejul(date);
output;
end;
end;
format procedure_date date10.;
run;


*import the data file;
proc import datafile="C:\Documents and Settings\duq01\Desktop\du\amy\data\ccs_ahrq\procedure_ccs_231.xlsx"
out=proc_ccs replace;
run;

proc sql;
create table proc_long_2 as 
select a.*,b.CCS_CATEGORY
from proc_long a
left join 
proc_ccs b
on a.procedure=b.ICD_9_CM_CODE;
quit;
proc freq;
table CCS_CATEGORY;
run;
data proc_long_3;
set proc_long_2;
array list int_trach int_ptca int_cath int_icd int_hemodia int_bmt int_feedtube  int_intubat;
do over list;
list=0;
end;
if CCS_CATEGORY=34 then do ;
date_proc=procedure_date;
int_trach =1;
end;
if CCS_CATEGORY=45 then do ;
date_proc=procedure_date;
int_ptca=1;
end;
if CCS_CATEGORY=47 then do ;
date_proc=procedure_date;  int_cath =1;
end;

if CCS_CATEGORY=48 then do ;
date_proc=procedure_date;  int_icd=1;
end;


if CCS_CATEGORY=58 then do ;
date_proc=procedure_date;  int_hemodia=1;
end;
if CCS_CATEGORY=64 then do ;
date_proc=procedure_date; int_bmt=1;
end;
if CCS_CATEGORY=71 then do ;
date_proc=procedure_date;  int_feedtube=1;
end;
if CCS_CATEGORY=216 then do ;
date_proc=procedure_date;  int_intubat=1;
end;
run;

proc sql;
create table proc_sum as
select distinct BID_MTSI_1,sum(int_trach) as int_trach,min(date_proc) as first_proc_date_6m format=date10.,
sum(int_ptca) as int_ptca,
sum(int_cath) as int_cath,
sum(int_icd) as int_icd,
sum(int_hemodia) as int_hemodia,
sum(int_bmt) as int_bmt,
sum(int_feedtube) as int_feedtube,
sum(int_intubat) as int_intubat
from proc_long_3 group by BID_MTSI_1;
quit;
data proc_intensive;
set proc_sum;
array list int_trach int_ptca int_cath int_icd int_hemodia int_bmt int_feedtube  int_intubat;
do over list;
if list>0 then list=1;
end;
label int_trach="Tracheostomy; temporary and permanent";
label int_ptca="Percutaneous transluminal coronary angioplasty";
label int_cath="Diagnostic cardiac catheterization; coronary arteriography";
label int_icd="Insertion; revision; replacement; removal of cardiac pacemaker or cardioverter/defibrillator";
label int_hemodia="Hemodialysis";
label int_bmt=" Bone marrow transplant";
label int_feedtube='Gastrostomy; temporary and permanent';
label int_intubat='Respiratory intubation and mechanical ventilation';
run;
   
clear
use C:\projects\Procedures\final_data\intensive_procedure_07132012


clear
use C:\projects\Serious_Illness_Cohort\Final_data\core_res_oop_00_to_08

H="Evan's Code 071712"
clear
use C:\projects\Procedures\final_data\intensive_procedure_07132012

**MERGE DATA SETS (IF NECESSARY):

** Add frequency of religious services
use Evan_6_25_12, clear
sort id
use Evan 6_6_12, clear
sort id
merge id using Evan_6_25_12

** Add information from C2 interview
use Evan_7_9_12, clear
sort id
use Evan_6_6_12, clear
sort id
merge id using Evan_7_9_12


**DATA CLEANUP:

** Label education level
label define educ 0 "No Formal Education" 1 "Grades 1-11" 2 "High School" 3 "Some College" 4 "College" 5 "Post College"
label values educ_c1 educ

** Label marital status
label define mari 1 "Married" 2 "Separated" 3 "Divorced" 4 "Widowed" 5 "Never Married" 6 "Other/Don't Know"
label values marital_c1 mari

** Label importance of religion
label define reli 1 "Very Important" 2 "Somewhat Important" 3 "Not Too Important" 4 "Don't Know/Refused/Missing"
label values imprelig_c1 reli

** Create variable to indicate married / not married
gen married = marital_c1==1
replace married = . if marital_c1==.

** Create index of intensive procedures (count of total)
gen int_proc_index =  int_intubation_2 +  int_trach_2 +  int_gastro_tude_2 +  int_hemodia_2 +  int_enteral_nut_2 +  int_cpr_2

** Create indicator of at least one intensive procedure
gen int_proc_atleast1 = int_proc_index>=1

** Convert continuous age variable into three groups (65-75, 75-85, 85+)
egen age_group_3 = cut(age), at(65,75,85,113)

** Label age_group_3
label define agegroup 65 "65-74" 75 "75-84" 85 "85+"
label values age_group_3 agegroup

** Create variable to indicate whether patient completed high school or not
gen educ_completed_HS = 0
replace educ_completed_HS = 1 if educ_c1==2|educ_c1==3|educ_c1==4|educ_c1==5
replace educ_completed_HS = . if educ_c1==.

** Create comorbidity categories
gen comorb_cancer = (cncrclrc_n12n6+cncrclrc_n12n6+cncrprst_n12n6+cncrlung_n12n6+cncrendm_n12n6)>=1
gen comorb_eye = (cataract_n12n6+glaucoma_n12n6)>=1

** Create updated adl_index to account for timing issue (grab info from C2 if C1 is less than 6 months before death)
gen adl_index_c1_or_c2 = adl_index_core_c1
replace adl_index_c1_or_c2 = adl_index_core_c2 if days_n1_core_dead<=180

** Create updated nhres to account for timing issue (grab info from C2 if C1 is less than 6 months before death)
gen nhres_c1_or_c2 = nhres_c1
replace nhres_c1_or_c2 = nhres_c2 if days_n1_core_dead<=180

** Create updated rel_nb to account for timing issue (grab info from C2 if C1 is less than 6 months before death)
gen rel_nb_c1_or_c2 = rel_nb_c1
replace rel_nb_c1_or_c2 = rel_nb_c2 if days_n1_core_dead<=180

** Label variables
label var int_proc_index "count of intensive procedure types"
label var int_proc_atleast1 "at least one intensive procedure"
label var married "1 if married, 0 all others"
label var comorb_cancer "1 or more cancer diagnoses during n12n6"
label var comorb_eye "cataracts or glaucoma during n12n6"
label var days_n1_core_dead "days between c1 and death"
label var adl_index_c1_or_c2 "c2 ADL if c1<=180 days"
label var nhres_c1_or_c2 "c2 nhres if c1<=180 days"
label var rel_nb_c1_or_c2 "c2 rel_nb if c1<=180 days"


H="Ling_fix_the_MI"
/*the ice can't not find the "not perfect prediction so we 
we have to work on mi impute mvn,
which used mcmc's method t0 draw the sample for the missing values 
from multiple variable normal distribution.
whice ice is to use the other covariate to predict the missing values.
"*/


use C:\projects\Procedures\final_data\procedures_clean_07182012, replace

mi set mlong
mi register imputed age_74 age_75_84 age_85 white black hisp_eth other_na_api_race  married female networth_c1 medicaid_c1 medigap_c1 relig_vimp_c1  ///
adl_index_c1_or_c2 educ_completed_HS nhres_c1_or_c2 rel_nb_c1_or_c2 hci_index hospital_beds specialists

mi register regular atrialfb_n6n12 chrnkidn_n6n12 copd_n6n12 ///
chf_n6n12 diabetes_n6n12 hipfrac_n6n12 depressn_n6n12 osteoprs_n6n12 strketia_n6n12 ra_oa_n6n12 ami_isch_n6n12 ///
alzheim_n6n12 comorb_cancer comorb_eye comorb_all_n6m_n12m int_proc_atleast1


* Set number of imputations to be used at 10 (may want to use 5 instead)
mi set M = 2


/*get rid of the collinearity,drop age_74, other_na_api_race*/

mi impute mvn  age_75_84 age_85 white black hisp_eth   married female networth_c1 medicaid_c1 medigap_c1 relig_vimp_c1  ///
adl_index_c1_or_c2 educ_completed_HS nhres_c1_or_c2 rel_nb_c1_or_c2 hci_index hospital_beds specialists, replace rseed(1234)


mi estimate: logit int_proc_atleast1  age_75_84 age_85 white black hisp_eth   married female networth_c1 medicaid_c1 medigap_c1 relig_vimp_c1  ///
adl_index_c1_or_c2 educ_completed_HS nhres_c1_or_c2 rel_nb_c1_or_c2 atrialfb_n6n12 chrnkidn_n6n12 copd_n6n12 ///
chf_n6n12 diabetes_n6n12 hipfrac_n6n12 depressn_n6n12 osteoprs_n6n12 strketia_n6n12 ra_oa_n6n12 ami_isch_n6n12 ///
alzheim_n6n12 comorb_cancer comorb_eye comorb_all_n6m_n12m hci_index hospital_beds specialists,







/*try many different ice,still get the perfect prediction,*/

ice  age_75_84 age_85 white black hisp_eth   married female networth_c1 medicaid_c1 medigap_c1 relig_vimp_c1  ///
adl_index_c1_or_c2 educ_completed_HS nhres_c1_or_c2 rel_nb_c1_or_c2 atrialfb_n6n12 chrnkidn_n6n12 copd_n6n12 ///
chf_n6n12 diabetes_n6n12 hipfrac_n6n12 depressn_n6n12 osteoprs_n6n12 strketia_n6n12 ra_oa_n6n12 ami_isch_n6n12 ///
alzheim_n6n12 comorb_cancer comorb_eye comorb_all_n6m_n12m hci_index hospital_beds specialists, dryrun 



* Run multiple imputations, saving to file impdata.dta, with 10 imputations.  Code below assumes we don't want to use "passive command".
use C:\projects\Procedures\final_data\procedures_clean_07182012, replace


ice  age_75_84  white  married female networth_c1   relig_vimp_c1  ///
adl_index_c1_or_c2 educ_completed_HS  rel_nb_c1_or_c2   hci_index hospital_beds specialists using temp3 , m(2) nopp









H="MI 080212"


use C:\projects\Procedures\final_data\procedures_clean_07182012, replace

misstable
mi set mlong
mi register imputed age_74 age_75_84 age_85 white black hisp_eth other_na_api_race  married female networth_c1 medicaid_c1 medigap_c1 relig_vimp_c1  ///
adl_index_c1_or_c2 educ_completed_HS nhres_c1_or_c2 rel_nb_c1_or_c2 hci_index hospital_beds specialists

mi register regular atrialfb_n6n12 chrnkidn_n6n12 copd_n6n12 ///
chf_n6n12 diabetes_n6n12 hipfrac_n6n12 depressn_n6n12 osteoprs_n6n12 strketia_n6n12 ra_oa_n6n12 ami_isch_n6n12 ///
alzheim_n6n12 comorb_cancer comorb_eye comorb_all_n6m_n12m int_proc_atleast1


* Set number of imputations to be used at 10 (may want to use 5 instead)
mi set M = 2


/*get rid of the collinearity,drop age_74, other_na_api_race*/

mi impute mvn  age_75_84 age_85 white black hisp_eth   married female networth_c1 medicaid_c1 medigap_c1 relig_vimp_c1  ///
adl_index_c1_or_c2 educ_completed_HS nhres_c1_or_c2 rel_nb_c1_or_c2 hci_index hospital_beds specialists, replace rseed(1234)


mi estimate: logit int_proc_atleast1  age_75_84 age_85 white black hisp_eth   married female networth_c1 medicaid_c1 medigap_c1 relig_vimp_c1  ///
adl_index_c1_or_c2 educ_completed_HS nhres_c1_or_c2 rel_nb_c1_or_c2 atrialfb_n6n12 chrnkidn_n6n12 copd_n6n12 ///
chf_n6n12 diabetes_n6n12 hipfrac_n6n12 depressn_n6n12 osteoprs_n6n12 strketia_n6n12 ra_oa_n6n12 ami_isch_n6n12 ///
alzheim_n6n12 comorb_cancer comorb_eye comorb_all_n6m_n12m hci_index hospital_beds specialists,




H="Margin_effects_HCI_index_mean_1sd"



use C:\projects\Procedures\final_data\procedures_clean_07182012, replace


mi set mlong
mi register imputed age_74 age_75_84 age_85 white black hisp_eth other_na_api_race  married female networth_c1 medicaid_c1 medigap_c1 relig_vimp_c1  ///
adl_index_c1_or_c2 educ_completed_HS nhres_c1_or_c2 rel_nb_c1_or_c2 hci_index hospital_beds specialists

mi register regular atrialfb_n6n12 chrnkidn_n6n12 copd_n6n12 ///
chf_n6n12 diabetes_n6n12 hipfrac_n6n12 depressn_n6n12 osteoprs_n6n12 strketia_n6n12 ra_oa_n6n12 ami_isch_n6n12 ///
alzheim_n6n12 comorb_cancer comorb_eye comorb_all_n6m_n12m int_proc_atleast1


* Set number of imputations to be 1 to calculate the marginal effects for HCI_index
mi set M = 1


/*get rid of the collinearity,drop age_74, other_na_api_race*/

mi impute mvn  age_75_84 age_85 white black hisp_eth   married female networth_c1 medicaid_c1 medigap_c1 relig_vimp_c1  ///
adl_index_c1_or_c2 educ_completed_HS nhres_c1_or_c2 rel_nb_c1_or_c2 hci_index hospital_beds specialists, replace rseed(1234)






logit int_proc_atleast1  age_75_84 age_85 white black hisp_eth   married female networth_c1 medicaid_c1 medigap_c1 relig_vimp_c1  ///
adl_index_c1_or_c2 educ_completed_HS nhres_c1_or_c2 rel_nb_c1_or_c2 atrialfb_n6n12 chrnkidn_n6n12 copd_n6n12 ///
chf_n6n12 diabetes_n6n12 hipfrac_n6n12 depressn_n6n12 osteoprs_n6n12 strketia_n6n12 ra_oa_n6n12 ami_isch_n6n12 ///
alzheim_n6n12 comorb_cancer comorb_eye comorb_all_n6m_n12m hci_index hospital_beds specialists,

egen mean_hci_index = mean(hci_index)
egen sd_hci_index = sd(hci_index)

display "mean hci index" mean_hci_index
display "mean+1standard deviation of hci_index" mean_hci_index+sd_hci_index
display "marginal effect at hci_index=mean"
margins,at(hci_index=1.027856) 
display "marginal effect at hci_index=mean+1sd"
margins,at(hci_index=1.3207597) 

H="notes 4/8/13"
/* to find the average time from core 1 to death:
sum days_n1_core_dead

242 ids missing c1
20 missing date of death,

checked the N of miss  for variables in c1 and c2 such as networth medigap, they are reasonable.

revised the discuss_x=9 as discuss=0

*/
use C:\projects\Procedures\final_data\procedures_clean_07182012, replace
save "C:\projects\Procedures\final_data\procedures_clean_07182012_old.dta"

replace discuss_x=0 if discuss_x==9

save "C:\projects\Procedures\final_data\procedures_clean_07182012.dta",replace




H="HCI effect 041113"

set mem 500m
use C:\projects\Procedures\final_data\procedures_clean_04102013, replace
log using "C:\projects\Procedures\report\HCI effec_04112013", replace


mi set mlong
mi register imputed age_74 age_75_84 age_85 white black hisp_eth other_na_api_race  married female networth_c1 medicaid_c1 medigap_c1 relig_vimp_c1  ///
adl_index_c1_or_c2 educ_completed_HS nhres_c1_or_c2 rel_nb_c1_or_c2 hci_index hospital_beds specialists

mi register regular atrialfb_n6n12 chrnkidn_n6n12 copd_n6n12 ///
chf_n6n12 diabetes_n6n12 hipfrac_n6n12 depressn_n6n12 osteoprs_n6n12 strketia_n6n12 ra_oa_n6n12 ami_isch_n6n12 ///
alzheim_n6n12 comorb_cancer comorb_eye comorb_all_n6m_n12m int_proc_atleast1


* Set number of imputations to be 1 to calculate the marginal effects for HCI_index
mi set M = 1


/*get rid of the collinearity,drop age_74, other_na_api_race*/

mi impute mvn  age_75_84 age_85 white black hisp_eth   married female networth_c1 medicaid_c1 medigap_c1 relig_vimp_c1  ///
adl_index_c1_or_c2 educ_completed_HS nhres_c1_or_c2 rel_nb_c1_or_c2 hci_index hospital_beds specialists, replace rseed(1234)






logit  int_proc_atleast1_ex_hemodia  age_75_84 age_85 white black hisp_eth   married female networth_c1 medicaid_c1 medigap_c1 relig_vimp_c1  ///
adl_index_c1_or_c2 educ_completed_HS nhres_c1_or_c2 rel_nb_c1_or_c2 atrialfb_n6n12 chrnkidn_n6n12 copd_n6n12 ///
chf_n6n12 diabetes_n6n12 hipfrac_n6n12 depressn_n6n12 osteoprs_n6n12 strketia_n6n12 ra_oa_n6n12 ami_isch_n6n12 ///
alzheim_n6n12 comorb_cancer comorb_eye comorb_all_n6m_n12m hci_index hospital_beds specialists,

egen mean_hci_index = mean(hci_index)
egen sd_hci_index = sd(hci_index)

display "mean hci index" mean_hci_index
display "mean+1standard deviation of hci_index" mean_hci_index+sd_hci_index
display "marginal effect at hci_index=mean"
margins,at(hci_index=1.0235206) 
display "marginal effect at hci_index=mean+1sd"
margins,at(hci_index=1.3139258) 


log close