= V4 Outline MultiLine NoSorting TabWidth=30

H="Setup Overview"
/*This is an attempt to set up a fairly generic, fairly comprehensive starter dataset.  It will include information from the denominator file, HRS core interviews, the Rand Net worth, Dartmouth, Karen's death file, and common medicare questions based on time of core interview.*/

/*hrs cleaned path*/
libname hrs_fnl 'E:\data\hrs_cleaned';

/*medicare xwalk and claims path*/
libname medi 'E:\data\cms_DUA_24548_2012';

/*project data paths*/
libname int 'E:\data\Evan_SAS_practice';




H="add restricted to core"
/***********************************************************************/
/*Core interview dataset, merge variables from restricted              */
/***********************************************************************/

data core;
set hrs_fnl.core_00_to_12;
label c_ivw_year="Core interview year";
run;

proc sort data=core nodupkey;
by id core_year;
run;


data death(rename=(death_all=death_date));
set hrs_fnl.death_date_2012;
keep id death_all;
run;

proc sort data=death nodupkey;
by id;
run;

data restr(rename=(ZIP10_2000=ZIP10 death_date=death_tracker));
set hrs_fnl.restr_tracker_v2012(keep=hhid pn id birth_date death_date white black hisp_eth native_amer 
asian_pi other_race other_na_api_race zip: stateusps: cause_death_12_n degree gender);
id_c=trim(hhid)||trim(pn);
drop id;
rename id_c=id;
restr_yes=1;
run;

proc sort data=restr nodupkey;
by id;
run;

proc contents data=restr; run;

proc sql;
create table core_dob(drop=id2) as select * from core a left join
restr(rename=(id=id2) drop=hhid pn) b 
on a.id=b.id2;
quit;

*6 obs have no match in the restricted dataset;
*These obs each only have 1 inteview, so can't use them anyway;
proc freq data=core_dob; table restr_yes /missprint; run;

data restr_test;
set core_dob;
if restr_yes=.;
run;

proc sql;
create table core_dob1(drop=id2) as select * from core_dob a left join
death(rename=(id=id2)) b 
on a.id=b.id2;
quit;

data core_age_1;
set core_dob1;
format death_date date9.;
age_at_core=floor((c_ivw_date-birth_date)/365.25);
label age_at_core="Age at core interview";
if age_at_core>=65 then age_ge_65=1;
if age_at_core<65 then age_ge_65=0;
label age_ge_65="Age at core interview > 65";

core_to_death=(death_date-c_ivw_date)/365.25;
label core_to_death="Time from core ivw to death, years";
if core_to_death<=1 and core_to_death~=. then core_to_dod_1yr=1;
if core_to_death>1 or core_to_death=. then core_to_dod_1yr=0;
label core_to_dod_1yr="Died within 1 year of core interview";

if core_to_death<=0.5 and core_to_death~=. then core_to_dod_6m=1;
if core_to_death>0.5 or core_to_death=. then core_to_dod_6m=0;
label core_to_dod_6m="Died within 6 months of core interview";

run;

proc freq data=core_age_1;
table age_at_core*age_ge_65 core_to_dod_1yr*core_to_dod_6m /missprint;
run;


****************************************************************;
*get clean zip code variable by wave;
proc sort data=core_age_1; by id core_year; run;

/*get list of first and last interview years*/
data ivw_years_1;
set core_age_1;
by id; 
if first.id then first_ivw_year=core_year;
if last.id then last_ivw_year=core_year;
run;

data ivw_years_1a;
set ivw_years_1;
if first_ivw_year~=.;
run;

data ivw_years_1b;
set ivw_years_1;
if last_ivw_year~=.;
run;

proc sql;
create table ivw_years_2 as select a.id,a.first_ivw_year,b.last_ivw_year
from ivw_years_1a a left join
ivw_years_1b b
on a.id=b.id;
quit;

proc freq; table first_ivw_year last_ivw_year; run;

*merge into overall dataset;
proc sql;
create table core_age_zip_1 as select
a.*, b.first_ivw_year,b.last_ivw_year from
core_age_1 a left join
ivw_years_2 b
on a.id=b.id;
quit;

proc freq; table first_ivw_year last_ivw_year; run;

/*clean up missing zip variables
1. if missing, use interview prior
2. if still missing, use interview after
3. if still missing, use interview 2x prior...*/

data core_age_zip_2 ;
set core_age_zip_1 ;
/*1998 updates, use 2000 zip
1 obs only has one interview in our dataset for 1998 and is missing zip that year, won't be
in the final sample so leave as missing now*/
if zip98='' & first_ivw_year<=1998<=last_ivw_year then do;
	zip_98_imp_yes=1;
	zip98=zip00;
	end;
/*2000 updates, use 1998 zip
2 obs only have one interview in the dataset for 2000, missing zip that year, again not
in final sample so leave missing here*/
if zip00='' & first_ivw_year<=2000<=last_ivw_year then do;
	zip_00_imp_yes=1;
	zip00=zip98;
	end;
/*2002 updates, use 2000 or 2004 zip
1 obs has only the 2002 interview, leave zip missing for that person*/
if zip02='' & first_ivw_year<=2002<=last_ivw_year then do;
	zip_02_imp_yes=1;
	zip02=zip00;
		if zip02='' then do;
		zip02=zip04;
		end;
	end;
/*2004 updates, use 2002 or 2006 zip
13 obs has only the 2004 interview, leave zip missing for those observations*/
if zip04='' & first_ivw_year<=2004<=last_ivw_year then do;
	zip_04_imp_yes=1;
	zip04=zip02;
		if zip04='' then do;
		zip04=zip06;
		end; /*1 obs still missing, use 1998 zip for this person*/
				if zip04='' then do;
				zip04=zip98;
				end; 
	end;
/*2006 updates, use 2004 or 2008 zip
no observations missing*/
if zip06='' & first_ivw_year<=2006<=last_ivw_year then do;
	zip_06_imp_yes=1;
	zip06=zip04;
		if zip06='' then do;
		zip06=zip08;
		end; 
	end;
/*2008 updates, use 2006 zip
no observations missing*/
if zip08='' & first_ivw_year<=2008<=last_ivw_year then do;
	zip_08_imp_yes=1;
	zip08=zip06;
	end;
/*2010 updates, use 2008 zip
1 obs has only 2010 interview and missing zip that year, so leave missing*/
if zip10='' & first_ivw_year<=2010<=last_ivw_year then do;
	zip_10_imp_yes=1;
	zip10=zip08;
	end;
/*2012 12 observations missing, use 2010*/
if zip12='' & first_ivw_year<=2012<=last_ivw_year then do;
	zip_12_imp_yes=1;
	zip12=ZIP10_2010;
	end;
run;

****************************************************************;
*get clean state code variable by wave;
data core_age_zip_state;
set core_age_zip_2;
/*1998 state - n=1 obs only has one interview with missing zip,state, leave blank*/
if stateusps98='' & first_ivw_year<=1998<=last_ivw_year then do;
	st_98_imp_yes=1;
	stateusps98=stateusps00;
	end;
/*2000 state - n=2 obs only single interview so leave missing*/ 
if stateusps00='' & first_ivw_year<=2000<=last_ivw_year then do;
	st_00_imp_yes=1;
	stateusps00=stateusps98;
	end;
/*2002 state - n=1 obs only single interview so leave missing*/ 
if stateusps02='' & first_ivw_year<=2002<=last_ivw_year then do;
	st_02_imp_yes=1;
	stateusps02=stateusps00;
	if stateusps02='' then do;
		stateusps02=stateusps04;
		end;
	end;
/*2004 updates, use 2002 or 2006 state
13 obs has only the 2004 interview, leave state missing for those observations*/
if stateusps04='' & first_ivw_year<=2004<=last_ivw_year then do;
	st_04_imp_yes=1;
	stateusps04=stateusps02;
		if stateusps04='' then do;
		stateusps04=stateusps06;
		end; /*1 obs still missing, use 1998 state for this person*/
				if stateusps04='' then do;
				stateusps04=stateusps98;
				end; 
	end;
/*2006 updates, use 2004 or 2008 state
no observations missing*/
if stateusps06='' & first_ivw_year<=2006<=last_ivw_year then do;
	st_06_imp_yes=1;
	stateusps06=stateusps04;
		if stateusps06='' then do;
		stateusps06=stateusps08;
		end; 
	end;
/*2008 updates, use 2006 state
no observations missing*/
if stateusps08='' & first_ivw_year<=2008<=last_ivw_year then do;
	st_08_imp_yes=1;
	stateusps08=stateusps06;
	end;
/*2010 updates, use 2008 state
1 obs has only 2010 interview and missing state that year, so leave missing*/
if stateusps10='' & first_ivw_year<=2010<=last_ivw_year then do;
	st_10_imp_yes=1;
	stateusps10=stateusps08;
	end;
/*2012 updates, use 2010 state
no observations missing*/
if stateusps12='' & first_ivw_year<=2012<=last_ivw_year then do;
	st_12_imp_yes=1;
	stateusps12=stateusps10;
	end;
run;

proc sort data=core_age_zip_state; by id core_year; run;

*save dataset and drop raw zip code variables;
data int.core_age_zip;
set core_age_zip_state;
zip_wave=vvaluex("zip"||substr(trim(left(core_year)),3,2) );
zip_imputed=vvaluex("zip_"||substr(trim(left(core_year)),3,2)||"_imp_yes" );
drop zip9: zip0: zip1: ;
label zip_wave="ZIP code, residence at time of interview";
label zip_imputed="ZIP code imputed";

state_wave=vvaluex("stateusps"||substr(trim(left(core_year)),3,2) );
state_imputed=vvaluex("st_"||substr(trim(left(core_year)),3,2)||"_imp_yes" );
drop stateusps: ;
label state_wave="State, residence at time of interview";
label state_imputed="State imputed";
run;

proc freq data=int.core_age_zip; table zip_wave state_wave  /missprint ; run;

proc freq; table zip_imputed state_imputed /missprint ; run;

****************************************************************;
/*bring in BMI from rand dataset*/
libname rand 'E:\data\hrs_public_2012\rand2012\main';
/*pull each wave bmi variable from rand xwave data file
wave 5 = 2000
wave 6 = 2002 ... wave 10 = 2010
*/
options fmterr=no;
data bmi_rand;
set rand.rndhrs_n(keep=hhid pn R4BMI R5BMI R6BMI R7BMI R8BMI R9BMI R10BMI R11BMI);
id = hhid||pn;
run;

%macro getBMI(w=,year=);

data bmi_rand1_&w;
set bmi_rand;
keep id core_year R&w.BMI;
core_year=&year;
run;

data bmi_rand2_&w;
set bmi_rand1_&w;
rename R&w.BMI=BMI;
%mend;

%getBMI(w=4,year=1998);
%getBMI(w=5,year=2000);
%getBMI(w=6,year=2002);
%getBMI(w=7,year=2004);
%getBMI(w=8,year=2006);
%getBMI(w=9,year=2008);
%getBMI(w=10,year=2010);
%getBMI(w=11,year=2012);

data bmi_9812;
set bmi_rand2_4 bmi_rand2_5 bmi_rand2_6 bmi_rand2_7 bmi_rand2_8 bmi_rand2_9 bmi_rand2_10 bmi_rand2_11;
label BMI='Body Mass Index';
label id='HRS ID';
run;

proc means; var BMI; run;

proc sort nodupkey; by id core_year ; run;

/*merge into dataset by id,core year*/
proc sql;
create table int.core_age_zip_bmi as select a.*,b.BMI as BMI_rand from
int.core_age_zip a
left join
bmi_9812 b 
on a.id=b.id and a.core_year=b.core_year;
quit;

****************************************************************;
ods rtf body=" E:\data\serious_ill\logs\core_00_to_10_meet_criteria.rtf" ;
proc sql;
title "serious illness cohort, initial core interview criteria";
title "meet age>=65 at core interview,2000-2010";
select count(distinct id) from int.core_age_zip_bmi 
where age_ge_65=1 and core_year in (2000,2002,2004,2006,2008,2010);
create table age_ge_65 as 
select * from int.core_age_zip_bmi 
where age_ge_65=1 and core_year in (2000,2002,2004,2006,2008,2010);

title "those meet age>=65,srf(poor,fair)";
select count(distinct id) from age_ge_65 
where srh_pf=1 ;

title "those meet age>=65,chf";
select count(distinct id) from age_ge_65 
where chf_hrs=1 ;

title "those meet age>=65,lung";
select count(distinct id) from age_ge_65 
where lung_hrs=1 ;

title "those meet age>=65,diabetes";
select count(distinct id) from age_ge_65 
where dm_hrs=1 ;

title "those meet age>=65,cancer";
select count(distinct id) from age_ge_65 
where cancer_hrs=1 ;

title "those meet age>=65,chf or lung or diabetes or cancer";
select count(distinct id) from age_ge_65 
where  chf_hrs=1 or lung_hrs=1 or dm_hrs=1 or cancer_hrs=1 ;

title "those meet age>=65,hosp_last_2yr,since last interview";
select count(distinct id) from age_ge_65 
where hosp_last_2yr=1 ;

title "those meet age>=65,meet at least one,fair or poor self report/chf/lung/diabet/cancer/hosp_last_2yr";
select count(distinct id) from age_ge_65 
where  srh_pf=1 or chf_hrs=1 or lung_hrs=1 or dm_hrs=1 or cancer_hrs=1 or hosp_last_2yr=1 ;

title "age>=65,meet at least one,fair or poor self report/chf/lung/diabet/cancer/hosp_last_2yr/1 adl";
select count(distinct id) from age_ge_65 
where  srh_pf=1 or chf_hrs=1 or lung_hrs=1 or dm_hrs=1 or cancer_hrs=1 or hosp_last_2yr=1 
or adl_independent_core=0;

quit;
ods rtf close;

H="Add in Dartmouth & wage index"
/*Brings in wage index by ZIP or state

Also gets HRR, Dartmouth EOL spending by ZIP

Note that the raw data with the regional data is saved in the out of pocket
(OOP) spending project folders rather than duplicating it for this project

Final dataset is int.core_age_zip_wi_da*/

/******************************************************************/
/* Adjust subtotals for wage index */
/******************************************************************/

/******************************************************************/
/* Link CBSA codes and zip codes from the WI file*/
/******************************************************************/
/*Bring in xwalk file between CBSA codes and zip codes
Note only keep variables needed from xwalk file because formats 
are missing for some of the other text variables
2012 WI/CBSA - based on 2000 census so no change in the xwalk*/

libname oop_ref "E:\data\Dartmouth_misc";

data zip_cb;
set oop_ref.xtract(keep=zip5 cbsa state);
zip_n=zip5+0;
cbsa_n=cbsa+0;
/*If zip code is not missing, add state code*/
if zip_n~=.;
state_n=state+0;
run;

*Remove duplicate entries for zip5 and cbsa from xwalk file;
*Goes from 399045 to 49289 rows;
proc sort data=zip_cb out=zip_cb2 nodupkey;
by zip_n cbsa_n;
run;

*Check to see zip codes in a cbsa code for Rochester, NY;
proc sql;
select zip5, cbsa from zip_cb2
where cbsa_n in (40380);
quit;

/*note several zip codes have multiple cbsa*/
/*create dataset with just one entry for each zip code
8029 zip codes have more than one cbsa code
Just use the first one when sort*/
proc sort data=zip_cb2 out=cbsa_zip_final nodupkey;
by zip_n;
run;

*Check to see zip codes in a cbsa code for Rochester, NY;
proc sql;
select zip_n, cbsa from cbsa_zip_final
where cbsa_n in (40380);
quit;

/******************************************************************/
/* Create dataset with cbsa, state, wage index and zip code */
/******************************************************************/
/******************************************************************/
/* Pull in wage index, set up with wage_index_setup.txt code 
in the general HRS processing directory*/
/******************************************************************/
/*bring in 2012 wage index file*/
libname misc 'E:\data\Dartmouth_misc\Wage Index';

data int.wage_index;
set misc.wage_index_2012;
run;

proc means;
var wage_index_2012;
run;

/*for zip codes with no cbsa, wage index is left missing
there are also many cbsas with missing wage index*/
proc sql;
create table zip_cbsa_wage_index as
select a.*,b.wage_index_2012 from
cbsa_zip_final a
left join
int.wage_index b
on a.cbsa_n=b.cbsa_n;
quit;

/*Check for and remove duplicates by zip, keep first entry*/
proc sort data=zip_cbsa_wage_index out=zip_cbsa_wage_index2 nodupkey;
by zip_n;
run;

/******************************************************************/
/* Merge the wage index into the interview dataset by the cleaned zip */
/******************************************************************/

/*change zip in interview dataset to a number*/
data core_age_zip_1 ;
set int.core_age_zip_bmi ;
zip_wave_n=zip_wave+0;
run;

proc contents; run;

proc sql;
create table core_age_zip_wi as select a.*,b.wage_index_2012 from
core_age_zip_1 a
left join
zip_cbsa_wage_index2 b
on a.zip_wave_n=b.zip_n;
quit;

/*n=76792 ivws are missing the wage index when matched just by zip*/
data miss_wi;
set core_age_zip_wi;
if wage_index_2012 =.;
run;

/******************************************************************/
/* Bring in  WI by state if missing by zip (b/c not in a metro area) */
/******************************************************************/
proc sort data=int.wage_index out=wage_index3 nodupkey;
by state_in_wage_index;
run;

data wage_index4; set wage_index3; if state_in_wage_index~='';
run;

proc freq data=wage_index4; table ST; run;

/*Merges in wage index if there's one for the state but was missing for the zip*/
proc sql;
create table int.core_age_zip_wi_2
as select a.*,coalesce(a.wage_index_2012,b.wage_index_2012) as wage_index_2012_2
from
core_age_zip_wi a
left join
wage_index4 b
on a.state_wave=b.ST;
quit;

/*check for missing values*/
proc means;
var wage_index_2012 wage_index_2012_2;
run;

proc sql;
select distinct state_wave ,count(*) from int.core_age_zip_wi_2
where wage_index_2012_2=. group by state_wave;
quit;

proc sql;
select distinct zip_wave_n ,count(*) from int.core_age_zip_wi_2
where wage_index_2012_2=. group by zip_wave_n;
quit;

proc freq data=int.core_age_zip_wi_2; table  state_wave  /missprint ; run;

data int.core_age_zip_wi_3;
set int.core_age_zip_wi_2;
/* create census regions */
if state_wave in ('CT','ME','MA','NH','RI','VT','NJ','NY','PA') then REGION=1;
   else if state_wave in ('IN','IL','MI','OH','WI','IA','KS','MN','MO','NE','ND','SD') then REGION=2;
   else if state_wave in ('DE','DC','FL','GA','MD','NC','SC','VA','WV','AL','KY','MS','TN',
        'AR','LA','OK','TX' ) then REGION=3;
   else if state_wave in ('AZ','CO','ID','NM','MT','UT','NV','WY','AK','CA','HI','OR','WA') then REGION=4;
/*create census divisions */
if state_wave in ('CT','ME','MA','NH','RI','VT') then DIVISION=1;
   else if state_wave in ('NJ','NY','PA') then DIVISION=2;
   else if state_wave in ('IN','IL','MI','OH','WI') then DIVISION=3;
   else if state_wave in ('IA','KS','MN','MO','NE','ND','SD') then DIVISION=4;
   else if state_wave in ('DE','DC','FL','GA','MD','NC','SC','VA','WV') then DIVISION=5;
   else if state_wave in ('AL','KY','MS','TN') then DIVISION=6;
   else if state_wave in ('AR','LA','OK','TX' ) then DIVISION=7;
   else if state_wave in ('AZ','CO','ID','NM','MT','UT','NV','WY') then DIVISION=8;
   else if state_wave in ('AK','CA','HI','OR','WA') then DIVISION=9;

/* create medicaid eligibility groupings: =>138% or <138% */
if state_wave in ('AL','AK','FL','GA','ID','KS','LA','ME','MS','MO','MT','NE','NC',
        'OK','SC','SD','TN','TX','UT','VA','WI','WY') then MEDICAID_138=0;
   else if state_wave in ('AR','AZ','CA','CO','CT','DE','DC','HI','IN','IL','IA',
        'KY','MA','MI','MN','MD','NH','ND','NM','NV','NJ','NY','OH','OR','PA',
        'RI','VT','WV','WA') then MEDICAID_138=1;
label region='Census Region: 1=NE,2=MW,3=S,4=W';
label division='Census Division';
label medicaid_138='Medicaid eligibility GE 138% FPL';
run;

proc freq data=int.core_age_zip_wi_3; table state_wave region division medicaid_138; run;

/******************************************************************/
/******************************************************************/
/* Bring in Dartmouth spending data by HRR/zip xwalk  */
/******************************************************************/
/******************************************************************/

/*first get HRR - ZIP crosswalk, 2007 since using the 2003-2007 eol spending data*/
proc import
datafile="E:\data\Dartmouth_misc\Dartmouth HRR_ZIP_xwalk\ziphsahrr07.xls"
out=ziphsahrr07 dbms=xls replace;	
run;

data ziphsahrr07_1;
set ziphsahrr07(rename=(zipcode07=zip));
*zip_n = put(zip,z5.);
zip_n=zip;
label zip_n="Zip code for HRR xwalk";
drop zip;
run;

proc freq; table hrrnum; run;

/*merge in Dartmouth eol spending and HCI (2003-2007) to HRR-zip xwalk*/
proc import
datafile="E:\data\Dartmouth_misc\EOL_mc_2yrs_HRR\DAP_HRR_03_07_to_merge.xls"
out=EOL_dartmouth dbms=xls replace;
run;

data EOL_dartmouth_1;
set EOL_dartmouth;
rename HRR = HRR_number; /*note this is not the right HRR number, not sure what it is*/
rename TOTAL_MEDICARE_SPENDING=tot_eol_spending_hrr;
label TOTAL_MEDICARE_SPENDING="EOL MC spend last 2 yr of life HRR level";
run;

proc freq; table HRR_number; run;

/*merge in additional Dartmouth data for number hospital beds, specialists, physicians
This is 2006 data by HRR from Dartmouth*/
/*capacity data per capita - number beds/physicians/specialists*/
proc import datafile="E:\data\Dartmouth_misc\Dartmouth archive_ref\HRR_data_beds_specialist_per_capital.xls"
out=hrr_beds_per_capita dbms=xls
replace;
run;
proc contents ;
run;

proc freq; table HRR; run;

/*merge the two DA datasets together by hrr*/
proc sql; 
create table da_full as select
a.HRR_number, a.HRR_Name, a.HRR_State, a.tot_eol_spending_hrr, a.Hospital_care_intensity_index__s,
b.Physicians, b.Specialists, b.hospital_beds
from 
EOL_dartmouth_1 a
left join
hrr_beds_per_capita b
on a.HRR_number=b.HRR;
quit;

/*merge the DA data into the zip code/hrr list*/
proc sql;
create table zip_eol_2 as select *
from ziphsahrr07_1 a left join
da_full b
on a.hrrnum=b.HRR_number;
quit;

/*all matched using hrr number to link*/
proc means; var tot_eol_spending_hrr; run;

/*merge into the overall dataset by zip code*/
proc sql;
create table hrs_add_da as select
a.*,b.* from
int.core_age_zip_wi_2 a left join
zip_eol_2 b
on a.zip_wave_n=b.zip_n;
quit;

/*check for missing da data*/
data int.core_age_zip_wi_da;
set hrs_add_da ;
miss_hrr=0;
if hrr_number=. then miss_hrr=1;
label miss_hrr = "Missing HRR - zip link";
run;

proc freq; table miss_hrr; run;

/*who is missing the hrr - zip link??
64% don't have valid zip code = 99999
Rest have zip codes that aren't in the hrr-zip crosswalk file*/
data zzzz_misshrr;
set int.core_age_zip_wi_da;
if miss_hrr=1;
run;

proc freq;
table zip_wave_n state_wave core_year; run;

H="Get claims relative to core"
/*Get claims 1 year and 2 year before each core interview*/

/*Step 1: Bring in mc xwalk id
int.core_xwalk_1 has core interviews, age and claims xwalk id */

/*prepare core dataset to merge*/
proc sort data=int.core_age_zip_wi_da out=core_id nodupkey;
by id c_ivw_date;
run;

/*prepare xwalk id file to merge*/
data crosswalk_1;
set medi.cmsxref2012;
keep bid_hrs_21 hhid pn;
run;

/*get 2 variables bid_hrs = claims id, id=HRS id*/
data crosswalk_2;
set crosswalk_1;
bid_hrs=bid_hrs_21;
id=trim(hhid)||trim(pn);
drop hhid pn;
drop bid_hrs_21;
run;

proc sort data= crosswalk_2;
by id;
run;

/*bring in xwalk id to core interview dataset*/
proc sql;
create table core_xwalk as select
a.*,b.bid_hrs from
core_id a
left join
crosswalk_2 b
on a.id=b.id;
quit;

/*check for missing xwalk ids
47839 of 157534 interviews are missing xwalk ids*/
data check1;
set core_xwalk ;
if bid_hrs ='';
run;

/*create indicator for having xwalk id*/
data core_xwalk_1;
set core_xwalk;
xwalk_yes=.;
if bid_hrs ='' then xwalk_yes=0;
if bid_hrs~='' then xwalk_yes=1;
run;

/*most that are missing are <65 years old*/
proc freq;
table xwalk_yes*core_year /missprint;
table age_at_core*xwalk_yes; 
run;

/*just get information needed to grab claims, drop rest of interview data
So pulls all interviews for r's with the mc linkage
91386 interviews have linkage*/
data int.core_lmt_xwalk_2;
set core_xwalk_1(keep=id core_year c_ivw_date c_ivw_year c_ivw_month age_at_core bid_hrs xwalk_yes wage_index_2012_2);
if xwalk_yes=1;
run;

/********************************************************************/
/* Get claims death date, from denominator file as a check
where dod from interview is imputed or after exit interview date */
/********************************************************************/
proc sort data=medi.dn_2000_2012 out=dn_dod_1  nodupkey;
by BID_HRS_21 year;
run;

/*just keep dod from last year*/
data dn_dod_2;
set dn_dod_1;
by BID_HRS_21 year;
if last.BID_HRS_21;
run;

proc freq;
table death_dt /missprint;
run;

/*add to the core dataset with xwalk id*/
proc sort data=core_xwalk_1; by bid_hrs; run;

proc sql;
create table int.core_xwalk_2 as select a.*,b.death_dt as dod_claims
from core_xwalk_1 a left join
dn_dod_2 b
on a.bid_hrs=b.BID_HRS_21;
quit;


H="Identify FFS before Core"
/*Use denominator file to determine which interviews / r's have ffs mc
during the full 12 months preceeding the core interview

2 sets of variables created, 1 for 12 month lookback,
one for 6 month lookback to see what the difference in sample
size would be with the more relaxed requirement*/

proc sort data=medi.dn_2000_2012 out=dn_2000_20122  nodupkey;
by BID_HRS_21 year;
run;

proc sort data=int.core_lmt_xwalk_2 out=core_mc_ids nodupkey;
by bid_hrs c_ivw_year;
run;

proc freq;
table c_ivw_year;
run;

*8 obs have missing core year;
proc freq data=core_mc_ids; table c_ivw_year /missprint; run;

data core_year_test; set core_mc_ids; if c_ivw_year=.; run;

/*pull medicare and hmo status variables from dn file
for the core interview years
interviews are dropped if they don't have a matching dn entry that year*/
proc sql;
create table dn_core_y as select
a.*,b.buyin12,b.year,b.HMOIND12
from core_mc_ids a inner join
dn_2000_20122 b
on trim(left(a.BID_hrs))=trim(left(b.BID_hrs_21))
and a.c_ivw_year=b.year;
quit;

proc freq data=dn_core_y ;
table c_ivw_year c_ivw_month age_at_core;
run;

/*18127 r's have at least 1 interview with a denominator file linked*/
proc sql;
select count(distinct BID_hrs) from dn_core_y ;
quit;

data dn_core_y2;
set dn_core_y;
if length(trim(left(buyin12)))=12 and c_ivw_month>0 then do;
buyin_dy=substr(trim(left(buyin12)),1,c_ivw_month);
hmo_dy=substr(trim(left(HMOIND12)),1,c_ivw_month);
end;
else do;
buyin_dy=trim(left(buyin12));
hmo_dy=trim(left(HMOIND12));
end;
format c_ivw_date date9.;
run;
proc means n;
var  c_ivw_month;
run;

/*Check year prior to core interview to backfill for interview dates
in the first half of the year (since doing 12 mo look back)*/
/* 62565 have the -1 year dn file*/
proc sql;
create table dn_core_y_bef as select
a.BID_hrs,a.c_ivw_year ,
b.year as c_ivw_year_bef,
b.year,b.buyin12,b.HMOIND12
from dn_core_y a inner join
dn_2000_20122 b
on trim(left(a.BID_hrs))=trim(left(b.BID_hrs_21))
and 0<a.c_ivw_year-b.year<=1 order by bid_hrs,c_ivw_year;
quit;

proc sql;
create table all_insurance as select a.*,b.year as year_bef_civw, 
b.buyin12 as buyin_bef,b.HMOIND12 as hmo_bef from
dn_core_y2 a
left join
dn_core_y_bef b
on trim(left(a.BID_hrs))=trim(left(b.BID_hrs)) 
and a.c_ivw_year=b.c_ivw_year;
quit;

proc freq data=all_insurance;
table c_ivw_year*year_bef_civw /missprint;
run;

/*merge interview year and year before interview buy-in and hmo variables
Trim so the final variable _12m is 12 months pre-interview
Note: indicator variables for parts a and b and hmo are null if don't
have information for full 12 months pre-interview*/
data all_insurance2;
set all_insurance;
buyin_2y=trim(left(buyin_bef))||trim(left(buyin_dy));
hmo_2y=trim(left(hmo_bef))||trim(left(hmo_dy));

buyin_2y_r=reverse(trim(buyin_2y));
hmo_2y_r=reverse(trim(hmo_2y));

*************************************************;
** 12 month variables                          **;
*************************************************;
if length(buyin_2y_r)>11 then buyin_12m_r=substr(trim(left(buyin_2y_r)),1,12);
if length(hmo_2y_r)>11 then hmo_12m_r=substr(trim(left(hmo_2y_r)),1,12);

if length(buyin_2y_r)<12 then buyin_12m_r="";
if length(hmo_2y_r)<12 then hmo_12m_r="";

buyin_12m=reverse(trim(buyin_12m_r));
hmo_12m=reverse(trim(hmo_12m_r));

/*create indicator variable for mc coverage 12 mo. 0=no, 1=yes*/
if length(buyin_12m)=12 then do;
if indexc(buyin_12m,"0","1","2","A","B") then part_ab_12m=0;
if indexc(buyin_12m,"0","1","2","A","B")=0 then part_ab_12m=1;
end;
if length(hmo_12m)=12 then do;
if index(hmo_12m,"00000000000") then hmo_d_12m=0;
if index(hmo_12m,"00000000000")=0 then hmo_d_12m=1;
end;

*************************************************;
** 6 month variables                          **;
*************************************************;
if length(buyin_2y_r)>5 then buyin_6m_r=substr(trim(left(buyin_2y_r)),1,6);
if length(hmo_2y_r)>5 then hmo_6m_r=substr(trim(left(hmo_2y_r)),1,6);

if length(buyin_2y_r)<6 then buyin_6m_r="";
if length(hmo_2y_r)<6 then hmo_6m_r="";

buyin_6m=reverse(trim(buyin_6m_r));
hmo_6m=reverse(trim(hmo_6m_r));

/*create indicator variable for mc coverage 6 mo. 0=no, 1=yes*/
if length(buyin_6m)=6 then do;
if indexc(buyin_6m,"0","1","2","A","B") then part_ab_6m=0;
if indexc(buyin_6m,"0","1","2","A","B")=0 then part_ab_6m=1;
end;
if length(hmo_6m)=6 then do;
if index(hmo_6m,"000000") then hmo_d_6m=0;
if index(hmo_6m,"000000")=0 then hmo_d_6m=1;
end;

if part_ab_12m=1 & hmo_d_12m=0 then ffs_yes_12m=1;
if part_ab_12m=0 | hmo_d_12m=1 then ffs_yes_12m=0;
if part_ab_6m=1 & hmo_d_6m=0 then ffs_yes_6m=1;
if part_ab_6m=0 | hmo_d_6m=1 then ffs_yes_6m=0;
 
run;

/*13875 observations don't have full denominator data re insurance status
either interview Before Jan 2001 (11386 ivws) or are missing year -1 dn file
*/
proc freq;
table part_ab_12m hmo_d_12m part_ab_12m*age_at_core part_ab_6m hmo_d_6m;
run;

proc freq;
table ffs_yes_12m ffs_yes_6m ;
run; 

data missdn;
set all_insurance2;
if ffs_yes_12m=.;
run;

proc freq; table c_ivw_year; run;

/*bring indicators into full interview dataset*/
proc sql;
create table int.core_xwalk_ins as select a.*,b.part_ab_12m,b.hmo_d_12m,b.part_ab_6m,b.hmo_d_6m
 from
int.core_xwalk_2 a left join
all_insurance2 b
on a.bid_hrs=b.bid_hrs and a.c_ivw_year=b.c_ivw_year;
quit;



H="Determine FFS after core"
/*This section checks for ffs medicare the 2 years after each
core interview or until death if that is within 2 years. 
This will be a check when looking at the 2 year
outcomes to make sure we have full claims datasets 
in the 2 years post-interview
*/

/*get list of beneficiaries that meet the sample criteria 1yr pre interview*/
proc sql;
create table meet_pre(keep=id bid_hrs c_ivw_year c_ivw_month 
	c_ivw_date core_year death_date core_to_death) as 
select * from int.core_xwalk_ins;
quit;

/*get months from core until death date where relevant*/
data meet_pre2;
set meet_pre;
*core_to_death is years so convert to months;
if death_date~=. then do;
	death_mo = month(death_date);
	death_yr = year(death_date);
	if death_yr=c_ivw_year then core_to_death_mos=death_mo-c_ivw_month+1;
	if death_yr=1+c_ivw_year then core_to_death_mos=death_mo+(13-c_ivw_month);
	if death_yr=2+c_ivw_year then core_to_death_mos=death_mo+(25-c_ivw_month);
end; 
*if core_to_death<=(1 + 1/12) & core_to_death~=. then core_to_death_mos = floor((death_date-c_ivw_date) / 30.5);
*if core_to_death_mos<0 & core_to_death_mos~=. then core_to_death_mos=0;
run;

proc freq; table core_to_death_mos; run;

proc sort data=medi.dn_2000_2012 out=dn_2000_20122  nodupkey;
by BID_HRS_21 year;
run;

/*get medicare and hmo status variables from the dn file
for the year of the core interview*/
proc sql;
create table dn_core_y as select
a.*,b.buyin12,b.year,b.HMOIND12
from meet_pre2 a inner join
dn_2000_20122 b
on trim(left(a.BID_hrs))=trim(left(b.BID_hrs_21))
and a.c_ivw_year=b.year;
quit;

proc freq data=dn_core_y ;
table c_ivw_year c_ivw_month ;
run;

/*11982 r's have at least 1 interview with a denominator file linked*/
proc sql;
select count(distinct BID_hrs) from dn_core_y ;
quit;

/*trim variables to show status month of interview and later
these are all interviews with full info 12m before, so don't 
have to check for missing months in the variable*/
data dn_core_y2;
set dn_core_y;
if length(trim(left(buyin12)))=12 and c_ivw_month>0 then do;
buyin_dy=substr(trim(left(buyin12)),c_ivw_month,(13-c_ivw_month));
hmo_dy=substr(trim(left(HMOIND12)),c_ivw_month,(13-c_ivw_month));
end;
else do;
buyin_dy=trim(left(buyin12));
hmo_dy=trim(left(HMOIND12));
end;
format c_ivw_date date9.;
run;
proc means n;
var  c_ivw_month;
run;
/*Get info for year after interview to fill in remainder of the 12m period*/
/*n=34320 have +1 year dn file*/
proc sql;
create table dn_core_y_aft as select
a.BID_hrs,a.c_ivw_year ,
b.year as c_ivw_year_aft,
b.year,b.buyin12,b.HMOIND12
from dn_core_y a inner join
dn_2000_20122 b
on trim(left(a.BID_hrs))=trim(left(b.BID_hrs_21))
and -1<=a.c_ivw_year-b.year<0 order by bid_hrs,c_ivw_year;
quit;


/*Get info for years after interview to fill in remainder of the 24m period*/
/*n=31055 have +2 year dn file*/
proc sql;
create table dn_core_2y_aft as select
a.BID_hrs,a.c_ivw_year ,
b.year as c_ivw_year_2aft,
b.year,b.buyin12,b.HMOIND12
from dn_core_y a inner join
dn_2000_20122 b
on trim(left(a.BID_hrs))=trim(left(b.BID_hrs_21))
and -2<=a.c_ivw_year-b.year<-1 order by bid_hrs,c_ivw_year;
quit;

proc sql;
create table all_insurance as select a.*,b.year as year_aft_civw, 
b.buyin12 as buyin_aft,b.HMOIND12 as hmo_aft from
dn_core_y2 a
left join
dn_core_y_aft b
on trim(left(a.BID_hrs))=trim(left(b.BID_hrs)) 
and a.c_ivw_year=b.c_ivw_year;
quit;

proc sql;
create table all_insurance1 as select a.*,b.year as year_2aft_civw, 
b.buyin12 as buyin_2aft,b.HMOIND12 as hmo_2aft from
all_insurance a
left join
dn_core_2y_aft b
on trim(left(a.BID_hrs))=trim(left(b.BID_hrs)) 
and a.c_ivw_year=b.c_ivw_year;
quit;

proc freq data=all_insurance1;
table c_ivw_year*year_2aft_civw /missprint;
run;

proc freq data=all_insurance;
table c_ivw_year*year_aft_civw /missprint;
run;

/*trim 2years after if its the death year---I don't understand this right now*/
data data all_insurance2;
set all_insurance1;
if year_aft_civw=death_yr & year_aft_civw~=. then do;
	buyin_aft=substr(trim(left(buyin_aft)),1,death_mo);
	hmo_aft=substr(trim(left(hmo_aft)),1,death_mo);
end;
if year_2aft_civw=death_yr & year_2aft_civw~=. then do;
	buyin_2aft=substr(trim(left(buyin_2aft)),1,death_mo);
	hmo_2aft=substr(trim(left(hmo_2aft)),1,death_mo);
end;
run;

/*merge interview year and year after interview buy-in and hmo variables
Trim so the final variable _24m is 24 months post-interview
Note: indicator variables for parts a and b and hmo are null if don't
have information for full 24 months post-interview*/
data all_insurance3;
set all_insurance2;
buyin_2y=trim(left(buyin_dy))||trim(left(buyin_aft))||trim(left(buyin_2aft));
hmo_2y=trim(left(hmo_dy))||trim(left(hmo_aft))||trim(left(hmo_2aft));

*************************************************;
** 12 month variables                          **;
*************************************************;
if length(buyin_2y)>24 then buyin_24m=substr(trim(left(buyin_2y)),1,25);
if length(hmo_2y)>24 then hmo_24m=substr(trim(left(hmo_2y)),1,25);

if length(buyin_2y)>12 then buyin_12m=substr(trim(left(buyin_2y)),1,13);
if length(hmo_2y)>12 then hmo_12m=substr(trim(left(hmo_2y)),1,13);

if length(buyin_2y)<25 & core_to_death_mos>=25 & core_to_death_mos~=. then buyin_24m="";
if length(hmo_2y)<25 & core_to_death_mos>=25 & core_to_death_mos~=. then hmo_24m="";

if length(buyin_2y)<13 & core_to_death_mos>=13 & core_to_death_mos~=. then buyin_12m="";
if length(hmo_2y)<13 & core_to_death_mos>=13 & core_to_death_mos~=. then hmo_12m="";

if length(buyin_2y)<25 & 0<core_to_death_mos<25 & core_to_death_mos~=. & length(buyin_2y)>=core_to_death_mos  then 
	buyin_24m=substr(trim(left(buyin_2y)),1,core_to_death_mos);
if length(hmo_2y)<25 & 0<core_to_death_mos<25 & core_to_death_mos~=. & length(hmo_2y)>=core_to_death_mos then 
	hmo_24m=substr(trim(left(hmo_2y)),1,core_to_death_mos);

if length(buyin_2y)<13 & 0<core_to_death_mos<13 & core_to_death_mos~=. & length(buyin_2y)>=core_to_death_mos  then 
	buyin_12m=substr(trim(left(buyin_2y)),1,core_to_death_mos);
if length(hmo_2y)<13 & 0<core_to_death_mos<13 & core_to_death_mos~=. & length(hmo_2y)>=core_to_death_mos then 
	hmo_12m=substr(trim(left(hmo_2y)),1,core_to_death_mos);

/*create indicator variable for mc coverage 12 mo. 0=no, 1=yes*/
	/*for obs that dont die within 2 years*/
if length(buyin_24m)=25 then do;
	if indexc(buyin_24m,"0","1","2","A","B") then part_ab_24m_aft=0;
	if indexc(buyin_24m,"0","1","2","A","B")=0 then part_ab_24m_aft=1;
end;
	/*for obs that do die within 2 years*/
else if 0<length(buyin_24m)<=25 & length(buyin_24m)=core_to_death_mos & core_to_death_mos~=. then do;
	if indexc(buyin_24m,"0","1","2","A","B") then part_ab_24m_aft=0;
	if indexc(buyin_24m,"0","1","2","A","B")=0 then part_ab_24m_aft=1;
end;


if length(hmo_24m)=25 then do;
	if indexc(hmo_24m,"1","2","A","B","C") then hmo_d_24m_aft=1;
	if indexc(hmo_24m,"1","2","A","B","C")=0 then hmo_d_24m_aft=0;
end;

else if 0<length(hmo_24m)<=25 & length(hmo_24m)=core_to_death_mos & core_to_death_mos~=. then do;
	if indexc(hmo_24m,"1","2","A","B","C") then hmo_d_24m_aft=1;
	if indexc(hmo_24m,"1","2","A","B","C")=0 then hmo_d_24m_aft=0;
end;

if length(buyin_12m)=13 then do;
	if indexc(buyin_12m,"0","1","2","A","B") then part_ab_12m_aft=0;
	if indexc(buyin_12m,"0","1","2","A","B")=0 then part_ab_12m_aft=1;
end;
	/*for obs that do die within the year*/
else if 0<length(buyin_12m)<=13 & length(buyin_12m)=core_to_death_mos & core_to_death_mos~=. then do;
	if indexc(buyin_12m,"0","1","2","A","B") then part_ab_12m_aft=0;
	if indexc(buyin_12m,"0","1","2","A","B")=0 then part_ab_12m_aft=1;
end;


if length(hmo_12m)=13 then do;
	if indexc(hmo_12m,"1","2","A","B","C") then hmo_d_12m_aft=1;
	if indexc(hmo_12m,"1","2","A","B","C")=0 then hmo_d_12m_aft=0;
end;

else if 0<length(hmo_12m)<=13 & length(hmo_12m)=core_to_death_mos & core_to_death_mos~=. then do;
	if indexc(hmo_12m,"1","2","A","B","C") then hmo_d_12m_aft=1;
	if indexc(hmo_12m,"1","2","A","B","C")=0 then hmo_d_12m_aft=0;
end;

run;

proc freq data=all_insurance3;
table part_ab_12m_aft hmo_d_12m_aft part_ab_24m_aft hmo_d_24m_aft; 
run;

/*part ab, hmo status, all don't have denominator files the year after the interview*/
data miss_12maft;
set all_insurance3;
if hmo_d_12m_aft=.;
run;

data miss_24maft;
set all_insurance3;
if hmo_d_24m_aft=.;
run;

proc freq; table c_ivw_year year_aft_civw /missprint; run;

/*bring indicators into the main dataset*/
proc sql;
create table int.core_ids_1yr as select a.*,b.part_ab_12m_aft,b.hmo_d_12m_aft,
b.part_ab_24m_aft,b.hmo_d_24m_aft
 from
int.core_xwalk_ins a left join
all_insurance3 b
on a.bid_hrs=b.bid_hrs and a.c_ivw_year=b.c_ivw_year;
quit;

proc freq data=int.core_ids_1yr;
table part_ab_12m_aft*part_ab_12m hmo_d_12m_aft*hmo_d_12m 
part_ab_24m_aft*part_ab_12m hmo_d_24m_aft*hmo_d_12m /missprint;
run;



H="Determine outcomes 2yrs after"
/*While still determining criteria, create variables looking at the 1 year, 2 years
after and 6 months after interview for all interviews (regardless of when meet criteria)

Outcomes are:
1. Urgent or emergency hospital admissions 1 year after meet critera
2. Hospice enrollment 1 year after meet criteria
3. Total Medicare payments 1 year after meet criteria

Note: Final dataset is set of interviews that meet ffs mc 1 year and age 65+
with outcomes added
*/

/*ids of those interviews with ffs medicare year preceding interview and 65+*/

proc sql;
create table age_ge_65_mc as 
select * from int.core_ids_1yr 
where age_ge_65=1 and xwalk_yes=1 and part_ab_12m=1 and hmo_d_12m=0 
and core_year in (2000,2002,2004,2006,2008,2010,2012);
quit;

proc freq; table core_to_dod_1yr  core_to_dod_6m; run;

data age_ge_65_mc_ltd;
set age_ge_65_mc(keep=bid_hrs c_ivw_date core_year);
run;

/**********************************************************************/
/**********************************************************************/
*get claims 2 years after interview, all claim types;
/**********************************************************************/
/**********************************************************************/
/*medpar claims
List of claims with some time within 1 year of interview*/
%macro mp(days_start=,days_after_core=,source=,time_label=);

proc sql;
create table &source._meet_post as select a.*,b.c_ivw_date,b.core_year
from medi.&source._2000_2012 a inner join
age_ge_65_mc_ltd b
on trim(left(a.bid_hrs_21))=trim(left(b.bid_hrs))
and &days_start<=a.disch_date-b.c_ivw_date<=&days_after_core;
quit;

proc sql;
create table &source._meet2_post as select a.*,b.c_ivw_date,b.core_year
from medi.&source._2000_2012 a inner join
age_ge_65_mc_ltd b
on trim(left(a.bid_hrs_21))=trim(left(b.bid_hrs))
and a.disch_date-b.c_ivw_date>&days_after_core and a.admit_date-b.c_ivw_date<=&days_after_core;
quit;

data int.&source._meet3_post_&days_after_core.;
set &source._meet_post &source._meet2_post;
format admit_date date9. disch_date date9.;
run;

%mend;

/*otherclaims, Just keep payment info to limit size of dataset
Pull list of any claims with admission date within 1 year of the interview*/
%macro other(days_start=,days_after_core=,source= );

proc sql;
create table int.&source._meet_post_&days_after_core. as select 
a.*,b.c_ivw_date,b.core_year
from medi.&source._2000_2012(keep=admit_date BID_hrs_21 pmt_amt) a inner join
age_ge_65_mc_ltd b
on trim(left(a.bid_hrs_21))=trim(left(b.bid_hrs))
and &days_start<=a.admit_date-b.c_ivw_date<=&days_after_core;
quit;

%mend;

/*2 year claims lists*/
%mp(days_start=0,days_after_core=730,source=mp );
%other(days_start=0,days_after_core=730,source=op );
%other(days_start=0,days_after_core=730,source=pb );
%other(days_start=0,days_after_core=730,source=hh );
%other(days_start=0,days_after_core=730,source=hs );
%other(days_start=0,days_after_core=730,source=dm );


/*1 year claims lists*/
%mp(days_start=0,days_after_core=365,source=mp );
%other(days_start=0,days_after_core=365,source=op );
%other(days_start=0,days_after_core=365,source=pb );
%other(days_start=0,days_after_core=365,source=hh );
%other(days_start=0,days_after_core=365,source=hs );
%other(days_start=0,days_after_core=365,source=dm );

/*6 months claims lists*/
%mp(days_start=0,days_after_core=183,source=mp );
%other(days_start=0,days_after_core=183,source=op );
%other(days_start=0,days_after_core=183,source=pb );
%other(days_start=0,days_after_core=183,source=hh );
%other(days_start=0,days_after_core=183,source=hs );
%other(days_start=0,days_after_core=183,source=dm );

/**********************************************************************/
/**********************************************************************/
/*Count of hospital admissions 1 year after interview
Use suffix p24m to indicate post interview*/
/**********************************************************************/
/**********************************************************************/
%macro admissions(days=,suffix=);
/*pull list of ip claims from all medpar claims x days after interview*/
data ip_meet_post_&days.;
set int.mp_meet3_post_&days.(where=(trim(left(SSLSSNF))~="N"));
*if admit_date>=c_ivw_date;
run;

data ip_post_&days._2;
set ip_meet_post_&days.;
em_urgent_admit=0; /*Urgent , emergent admissions from admission type*/
if type_adm in (1,2) then em_urgent_admit=1;
em_admit=0;
if type_adm=1 then em_admit=1;
urgent_admit=0;
if type_adm=2 then urgent_admit=1;
elect_admit=0;
if type_adm=3 then elect_admit=1;
ind_ed_charge=0; /*ED charges as another indicator of ED use*/
if ER_AMT>0 & ER_AMT~=. then ind_ed_charge=1;
if ER_AMT=0 | ER_AMT=. then ind_ed_charge=0;

*truncate admit and discharge dates to get all days within the window;
admit_trunc=0;
disch_trunc=0;
if admit_date<c_ivw_date then do;
	admit_date=c_ivw_date;
	admit_trunc=1;
end;
if disch_date-c_ivw_date>&days. then do;
	disch_date=c_ivw_date+&days.;
	disch_trunc=1;
end;
adj_los=disch_date-admit_date;
if disch_date-admit_date=0 then adj_los=1;
run;

proc sort data=ip_post_&days._2;
by BID_hrs_21 core_year;
run;

proc sql;
create table ip_post_&days._3 as select distinct BID_hrs_21,core_year,
/*count of IP admissions, all types*/
count(*) as n_ip_admit_&suffix. label="total n of hospital admit &suffix. after core ivw",
/*count of nights in hospital*/
sum(adj_los) as n_hospd_&suffix. label="total n of hospital nights &suffix. after core ivw",
/*count urgent or emergency admissions*/
count(case when em_urgent_admit=1 then em_urgent_admit else . end) as n_em_urgent_admit_&suffix. 
	label="total n of urgent/emergent hospital admit &suffix. after core ivw",
/*count of emergency admissions, from admission type code*/
count(case when em_admit=1 then em_admit else . end) as n_em_admit_&suffix. 
	label="total n of emergent hospital admit &suffix. after core ivw",
/*count of urgent admissions, from admission type code*/
count(case when urgent_admit=1 then urgent_admit else . end) as n_urgent_admit_&suffix. 
	label="total n of urgent hospital admit &suffix. after core ivw",
/*count of elective admissions, from admission type code*/
count(case when elect_admit=1 then elect_admit else . end) as n_elect_admit_&suffix. 
	label="total n of elective hospital admit &suffix. after core ivw",
/*count of admissions with any ED charges*/
count(case when ind_ed_charge=1 then ind_ed_charge else . end) as n_ED_ip_&suffix. 
	label="total n of ED visits with subsequent admit &suffix. after core ivw",
sum(admit_trunc) as adm_trunc_ind_&suffix.
	label="admit before interview indicator, counted as both pre and post admit"

 from ip_post_&days._2 group by BID_hrs_21,core_year;
quit;

data ip_post_&days._4;
set ip_post_&days._3;
if adm_trunc_ind_&suffix.>1 then adm_trunc_ind_&suffix.=1;
run;

%mend;

%admissions(days=730,suffix=p24m); /*1 year admisions details*/
%admissions(days=365,suffix=p12m); /*1 year admisions details*/
%admissions(days=183,suffix=p6m); /*6 months admisions details*/

/*merge in new variables to full variable list*/
proc sql;
create table core_ids_admit_post_1 as select a.*,
b.n_ip_admit_p24m,b.adm_trunc_ind_p24m,b.n_hospd_p24m,
b.n_em_urgent_admit_p24m,b.n_em_admit_p24m,
b.n_urgent_admit_p24m,b.n_elect_admit_p24m,b.n_ED_ip_p24m
from age_ge_65_mc_ltd(drop=c_ivw_date) a
left join
ip_post_730_4 b 
on trim(left(a.bid_hrs))=trim(left(b.bid_hrs_21)) and a.core_year=b.core_year;
quit;

proc sql;
create table core_ids_admit_post_2 as select a.*,
b.n_ip_admit_p12m,b.adm_trunc_ind_p12m,b.n_hospd_p12m,
b.n_em_urgent_admit_p12m,b.n_em_admit_p12m,
b.n_urgent_admit_p12m,b.n_elect_admit_p12m,b.n_ED_ip_p12m
from age_ge_65_mc_ltd(drop=c_ivw_date) a
left join
ip_post_365_4 b 
on trim(left(a.bid_hrs))=trim(left(b.bid_hrs_21)) and a.core_year=b.core_year;
quit;

proc sql;
create table core_ids_admit_post_3 as select a.*,
b.n_ip_admit_p6m,b.adm_trunc_ind_p6m,b.n_hospd_p6m,
b.n_em_urgent_admit_p6m,b.n_em_admit_p6m,
b.n_urgent_admit_p6m,b.n_elect_admit_p6m,b.n_ED_ip_p6m
from core_ids_admit_post_2 a
left join
ip_post_183_4 b 
on trim(left(a.bid_hrs))=trim(left(b.bid_hrs_21)) and a.core_year=b.core_year;
quit;


/*Since dataset is just those with ffs mc 1 year preceeding the
core interview, replace admit info with 0 if missing b/c there were no ip claims*/
 data core_ids_admit_post_3;
 set core_ids_admit_post_2;
 array list 
 	n_ip_admit_p24m n_hospd_p24m n_em_urgent_admit_p24m
	n_em_admit_p24m n_urgent_admit_p24m n_elect_admit_p24m n_ED_ip_p24m
	n_ip_admit_p12m n_hospd_p12m n_em_urgent_admit_p12m
	n_em_admit_p12m n_urgent_admit_p12m n_elect_admit_p12m n_ED_ip_p12m
	n_ip_admit_p6m n_hospd_p6m n_em_urgent_admit_p6m
	n_em_admit_p6m n_urgent_admit_p6m n_elect_admit_p6m n_ED_ip_p6m;
 do over list;
 if list=. then list=0;
 end;

 if n_ip_admit_p24m=0 then ind_hosp_adm_p24m=0;
 if n_ip_admit_p24m>0 & n_ip_admit_p24m~=. then ind_hosp_adm_p24m=1;
 label ind_hosp_adm_p24m="Indicator for any hospital admission 24m after core";

 if n_ip_admit_p12m=0 then ind_hosp_adm_p12m=0;
 if n_ip_admit_p12m>0 & n_ip_admit_p12m~=. then ind_hosp_adm_p12m=1;
 label ind_hosp_adm_p12m="Indicator for any hospital admission 12m after core";

 if n_ip_admit_p6m=0 then ind_hosp_adm_p6m=0;
 if n_ip_admit_p6m>0 & n_ip_admit_p6m~=. then ind_hosp_adm_p6m=1;
 label ind_hosp_adm_p6m="Indicator for any hospital admission 6m after core";

 if n_em_urgent_admit_p24m=0 then ind_em_ur_adm_p24m=0;
 if n_em_urgent_admit_p24m>0 & n_em_urgent_admit_p24m~=. then ind_em_ur_adm_p24m=1;
 label ind_em_ur_adm_p24m="Ind any urgent or emergent hospital admission 24m after core";

 if n_em_urgent_admit_p12m=0 then ind_em_ur_adm_p12m=0;
 if n_em_urgent_admit_p12m>0 & n_em_urgent_admit_p12m~=. then ind_em_ur_adm_p12m=1;
 label ind_em_ur_adm_p12m="Ind any urgent or emergent hospital admission 12m after core";

 if n_em_urgent_admit_p6m=0 then ind_em_ur_adm_p6m=0;
 if n_em_urgent_admit_p6m>0 & n_em_urgent_admit_p6m~=. then ind_em_ur_adm_p6m=1;
 label ind_em_ur_adm_p6m="Ind any urgent or emergent hospital admission 6m after core";

 if n_em_admit_p24m=0 then ind_em_adm_p24m=0;
 if n_em_admit_p24m>0 & n_em_admit_p24m~=. then ind_em_adm_p24m=1;
 label ind_em_adm_p24m="Ind any emergency hospital admission 24m after core";

 if n_em_admit_p12m=0 then ind_em_adm_p12m=0;
 if n_em_admit_p12m>0 & n_em_admit_p12m~=. then ind_em_adm_p12m=1;
 label ind_em_adm_p12m="Ind any emergency hospital admission 12m after core";

 if n_em_admit_p6m=0 then ind_em_adm_p6m=0;
 if n_em_admit_p6m>0 & n_em_admit_p6m~=. then ind_em_adm_p6m=1;
 label ind_em_adm_p6m="Ind any emergency hospital admission 6m after core";

 if n_urgent_admit_p24m=0 then ind_ur_adm_p24m=0;
 if n_urgent_admit_p24m>0 & n_urgent_admit_p24m~=. then ind_ur_adm_p24m=1;
 label ind_ur_adm_p24m="Ind any urgent hospital admission 24m after core";

 if n_urgent_admit_p12m=0 then ind_ur_adm_p12m=0;
 if n_urgent_admit_p12m>0 & n_urgent_admit_p12m~=. then ind_ur_adm_p12m=1;
 label ind_ur_adm_p12m="Ind any urgent hospital admission 12m after core";

 if n_urgent_admit_p6m=0 then ind_ur_adm_p6m=0;
 if n_urgent_admit_p6m>0 & n_urgent_admit_p6m~=. then ind_ur_adm_p6m=1;
 label ind_ur_adm_p6m="Ind any urgent hospital admission 6m after core";

 if n_elect_admit_p24m =0 then ind_elect_adm_p24m=0;
 if n_elect_admit_p24m >0 & n_elect_admit_p24m ~=. then ind_elect_adm_p24m=1;
 label ind_elect_adm_p24m="Ind any elective hospital admission 24m after core";


 if n_elect_admit_p12m =0 then ind_elect_adm_p12m=0;
 if n_elect_admit_p12m >0 & n_elect_admit_p12m ~=. then ind_elect_adm_p12m=1;
 label ind_elect_adm_p12m="Ind any elective hospital admission 12m after core";

 if n_elect_admit_p6m =0 then ind_elect_adm_p6m=0;
 if n_elect_admit_p6m >0 & n_elect_admit_p6m ~=. then ind_elect_adm_p6m=1;
 label ind_elect_adm_p6m="Ind any elective hospital admission 6m after core";

 if (n_ip_admit_p24m - n_elect_admit_p24m)=0 then ind_nonelect_adm_p24m=0;
 if (n_ip_admit_p24m - n_elect_admit_p24m)>0 & n_elect_admit_p24m~=. then ind_nonelect_adm_p24m=1;
 label ind_nonelect_adm_p24m="Ind any non-elective hospital admission 24m after core";

 if (n_ip_admit_p12m - n_elect_admit_p12m)=0 then ind_nonelect_adm_p12m=0;
 if (n_ip_admit_p12m - n_elect_admit_p12m)>0 & n_elect_admit_p12m~=. then ind_nonelect_adm_p12m=1;
 label ind_nonelect_adm_p12m="Ind any non-elective hospital admission 12m after core";

 if (n_ip_admit_p6m - n_elect_admit_p6m)=0 then ind_nonelect_adm_p6m=0;
 if (n_ip_admit_p6m - n_elect_admit_p6m)>0 & n_elect_admit_p6m~=. then ind_nonelect_adm_p6m=1;
 label ind_nonelect_adm_p6m="Ind any non-elective hospital admission 6m after core";

 n_nonelect_adm_p24m=(n_ip_admit_p24m - n_elect_admit_p24m);
 label n_nonelect_adm_p24m="total n non-elective ip admit 24m after core";

 n_nonelect_adm_p12m=(n_ip_admit_p12m - n_elect_admit_p12m);
 label n_nonelect_adm_p12m="total n non-elective ip admit 12m after core";

 n_nonelect_adm_p6m=(n_ip_admit_p6m - n_elect_admit_p6m);
 label n_nonelect_adm_p6m="total n non-elective ip admit 6m after core";

 if n_ED_ip_p24m=0 then ind_ED_adm_p24m=0;
 if n_ED_ip_p24m>0 & n_ED_ip_p24m~=. then ind_ED_adm_p24m=1;
 label ind_ED_adm_p24m="Ind ED use with hospital admission 24m after core, from charges";

 if n_ED_ip_p12m=0 then ind_ED_adm_p12m=0;
 if n_ED_ip_p12m>0 & n_ED_ip_p12m~=. then ind_ED_adm_p12m=1;
 label ind_ED_adm_p12m="Ind ED use with hospital admission 12m after core, from charges";

 if n_ED_ip_p6m=0 then ind_ED_adm_p6m=0;
 if n_ED_ip_p6m>0 & n_ED_ip_p6m~=. then ind_ED_adm_p6m=1;
 label ind_ED_adm_p6m="Ind ED use with hospital admission 6m after core, from charges";

run;

proc freq;
table n_ip_admit_p: adm_trunc_ind_p: n_hospd_p: ind_hosp_adm_p: n_em_urgent_admit_p: ind_em_ur_adm_p:
	ind_em_adm_p: ind_ur_adm_p: ind_nonelect_adm_p: n_nonelect_adm_p: n_ED_ip_p: ind_ED_adm_p: 
	ind_em_adm_p24m*ind_ED_adm_p24m ind_em_adm_p12m*ind_ED_adm_p12m ind_em_adm_p6m*ind_ED_adm_p6m /missprint;
run;

/**********************************************************************/
/**********************************************************************/
/*Indicator of any hospice enrollment after interview
Use suffix p24m to indicate post interview*/
/**********************************************************************/
/**********************************************************************/
/*check of hospice claim list*/
data hospice_check1;
set int.hs_meet_post_730;
ivw_to_admit=admit_date-c_ivw_date;
run;
proc means; var ivw_to_admit;run;

data hospice_check;
set int.hs_meet_post_365;
ivw_to_admit=admit_date-c_ivw_date;
run;
proc means; var ivw_to_admit;run;

data hospice_check2;
set int.hs_meet_post_183;
ivw_to_admit=admit_date-c_ivw_date;
run;
proc means; var ivw_to_admit;run;


%macro hospice(days=,suffix=);

proc sort data=int.hs_meet_post_&days.;
by bid_hrs_21 c_ivw_date admit_date;
run;

/*just keep 1 claim per beneficiary-interview since only need indicator of hospice use*/
data hs_meet_post_2_&days.;
set int.hs_meet_post_&days.;
by bid_hrs_21 c_ivw_date;
if first.c_ivw_date;
hs_admit_&suffix.=1;
label hs_admit_&suffix.="Hospice admission &suffix. after interview";
format admit_date date9.;
run;

%mend;

%hospice(days=730,suffix=p24m);
%hospice(days=365,suffix=p12m);
%hospice(days=183,suffix=p6m);

*merge hospice indicators with full dataset;
proc sql;
create table core_ids_admit_hs_post_2 as select a.*,b.hs_admit_p12m from
core_ids_admit_post_3 a left join
hs_meet_post_2_365 b
on trim(left(a.bid_hrs))=trim(left(b.bid_hrs_21)) and a.core_year=b.core_year;
quit;

proc sql;
create table core_ids_admit_hs_post_3 as select a.*,b.hs_admit_p6m from
core_ids_admit_hs_post_2 a left join
hs_meet_post_2_183 b
on trim(left(a.bid_hrs))=trim(left(b.bid_hrs_21)) and a.core_year=b.core_year;
quit;

proc sql;
create table core_ids_admit_hs_post_4 as select a.*,b.hs_admit_p24m from
core_ids_admit_hs_post_3 a left join
hs_meet_post_2_730 b
on trim(left(a.bid_hrs))=trim(left(b.bid_hrs_21)) and a.core_year=b.core_year;
quit;


proc freq; table hs_admit_p6m*hs_admit_p12m /missprint; run;

/*replace with 0 when have full info but no hospice claims
core interview*/
data core_ids_admit_hs_post_5 ;
set core_ids_admit_hs_post_4 ;
if hs_admit_p24m=. then hs_admit_p24m=0;
if hs_admit_p12m=. then hs_admit_p12m=0;
if hs_admit_p6m=. then hs_admit_p6m=0;
run;
proc freq; table hs_admit_p6m*hs_admit_p12m; run;

/*bring new outcomes variables into full interview dataset for those with ffs medicare */
proc sql;
create table int.core_ids_init_outcomes(drop=bid_hrs2 core_year2)
as select * from
age_ge_65_mc a left join
core_ids_admit_hs_post_5(rename=(bid_hrs=bid_hrs2) rename=(core_year=core_year2)) b
on a.bid_hrs=b.bid_hrs2 and a.core_year=b.core_year2;
quit;

proc contents; run;

proc freq; table core_year; run;

proc freq; table hs_admit_p6m*hs_admit_p12m; run;

proc freq;
table n_ip_admit_p12m adm_trunc_ind_p12m n_hospd_p12m ind_hosp_adm_p12m n_em_urgent_admit_p12m ind_em_ur_adm_p12m
	ind_em_adm_p12m ind_ur_adm_p12m ind_nonelect_adm_p12m n_nonelect_adm_p12m n_ED_ip_p12m ind_ED_adm_p12m 
	ind_em_adm_p12m*ind_ED_adm_p12m /missprint;
run;



H="MC payments 2yrs after"
/*Add total Medicare payments from claims 1 year after interview, 2 yrs after
and 6m after interview*/

/*Claims files from 2000-2012, claims pulled in previous section
to get just claims that are within 1 year of the interview dates
for those interviews were r>65 and ffs medicare 1 yr prior to ivw*/

/**********************************************************/
/**********************************************************/
/*totals from mp file*/
/*Note: variable SSLSSNF from mp claims is N=Skilled nursing facility*/
/*Two totals are calculated - one for skilled nursing facility claims
and one for all other claims in the mp file (inpatient claims)*/
/**********************************************************/
/**********************************************************/

/*get count of snf vs ip claims from claim list */
data snf_all;
set int.mp_meet3_post_730(where=(trim(left(SSLSSNF))="N")) ;
ivw_to_admit=admit_date-c_ivw_date;
ivw_to_disch=disch_date-c_ivw_date;
run;

proc means; var ivw_to_admit ivw_to_disch; run;

data ip_all;
set int.mp_meet3_post_730(where=(trim(left(SSLSSNF))~="N")) ;
run;


%macro mp(month_n=,days_start=,days_after_core=,source=,equ=,name=);
%let source0=mp;

/*Case 1 - no adjustment needed - claims where entire claim is within the x months after the interview*/
proc sql;
create table &source._meet_post_1 as select *
from int.&source0._meet3_post_&days_after_core.(where=(trim(left(SSLSSNF))&equ.="N")) 
where &days_start<=disch_date-c_ivw_date<=&days_after_core and
&days_start<=admit_date-c_ivw_date<=&days_after_core;
quit;

data zz_&source._meet_post_1;
set &source._meet_post_1;
ivw_to_admit=admit_date-c_ivw_date;
ivw_to_disch=disch_date-c_ivw_date;
run;
proc means; var ivw_to_admit ivw_to_disch; run;

/*Case 2 - adjustment needed because part of stay is in the window but part is after the window has ended
Claims with admission date within start of x months but discharge date is after the x month window*/
proc sql;
create table &source._meet2_post as select *
from int.&source0._meet3_post_&days_after_core.(where=(trim(left(SSLSSNF))&equ.="N")) 
where disch_date-c_ivw_date>&days_after_core and 0<=admit_date-c_ivw_date<=&days_after_core;
quit;

data zz_&source._meet2_post;
set &source._meet2_post;
ivw_to_admit=admit_date-c_ivw_date;
ivw_to_disch=disch_date-c_ivw_date;
run;
proc means; var ivw_to_admit ivw_to_disch; run;


/*identify fraction of claims that span x month period that should be 
attributed to the x month period
by just using the fraction of time that was included in the span*/
data &source._meet3_post;
set &source._meet2_post;
pct_xm=((c_ivw_date+&days_after_core)-admit_date)/(disch_date-admit_date);
array list pmt_amt passthru;
do over list;
if list=. then list=0;
/*scale the partial claims by the time within the x month period*/
list=list*pct_xm;
end;

run;

/*Case 3 - adjustment needed because part of stay is in the window but part is before the window started
Claims with discharge date within start of x months but admit date is before the interview date*/
proc sql;
create table &source._meet4_post as select *
from int.&source0._meet3_post_&days_after_core.(where=(trim(left(SSLSSNF))&equ.="N")) 
where disch_date-c_ivw_date<=&days_after_core and admit_date-c_ivw_date<&days_start;
quit;

data zz_&source._meet4_post;
set &source._meet4_post;
ivw_to_admit=admit_date-c_ivw_date;
ivw_to_disch=disch_date-c_ivw_date;
run;
proc means; var ivw_to_admit ivw_to_disch; run;


data &source._meet5_post;
set &source._meet4_post;
pct_xm=(disch_date-c_ivw_date)/(disch_date-admit_date);
array list pmt_amt passthru;
do over list;
if list=. then list=0;
/*scale the partial claims by the time within the x month period*/
list=list*pct_xm;
end;

run;

/*adjust for inflation, Uses CPI for Medical Services from 
BLS website, accessed 5/4/2015*/

/*create table merging both the claims fully in the 2 year period 
and those partially in that time
adjust for inflation here also*/
data &source._cost_post;
set &source._meet_post_1 &source._meet3_post &source._meet5_post;
array list pmt_amt passthru;
do over list;
if list=. then list=0;
end;

if year(admit_date)>=2012 then rate=1;
if year(admit_date)=2011 then rate=1.03902;
if year(admit_date)=2010 then rate=1.07086;
if year(admit_date)=2009 then rate=1.10835;
if year(admit_date)=2008 then rate=1.1439;
if year(admit_date)=2007 then rate=1.1923;
if year(admit_date)=2006 then rate=1.25586;
if year(admit_date)=2005 then rate=1.30783;
if year(admit_date)=2004 then rate=1.37027;
if year(admit_date)=2003 then rate=1.43908;
if year(admit_date)=2002 then rate=1.50337;
if year(admit_date)=2001 then rate=1.57963;
if year(admit_date)=2000 then rate=1.65519;
if year(admit_date)<=1999 then rate=1.72641;


&source._paid_by_mc=rate*(pmt_amt+passthru);
run;

*calculates total of mc charges for the claim type by hrs bid;
proc sql;
create table &source._pay_post as select distinct bid_hrs_21,core_year,
sum(&source._paid_by_mc) as &source._paid_by_mc 
from &source._cost_post group by BID_HRS_21,core_year;
quit;

*merges the totals above with the full interview list;
proc sql;
create table &source._&name. as select
a.BID_hrs,a.id,a.core_year,coalesce(b.&source._paid_by_mc,0) as &source._paid_by_mc_&name.
from int.core_ids_init_outcomes a
left join
 &source._pay_post b
 on trim(left(a.BID_hrs))=trim(left(b.bid_hrs_21)) and a.core_year=b.core_year;
 quit;

 proc sort data=&source._&name. ;
 by BID_hrs core_year;
 run;
%mend;

/*Runs macro to get total for the SNF claims*/
%mp(days_start=0,days_after_core=730,source=snf,equ=,name=24m );
%mp(days_start=0,days_after_core=365,source=snf,equ=,name=12m );
%mp(days_start=0,days_after_core=183,source=snf,equ=,name=6m );
/*Runs macro to get total for the inpatient (not SNF) claims*/
%mp(days_start=0,days_after_core=730,source=ip,equ=~,name=24m );
%mp(days_start=0,days_after_core=365,source=ip,equ=~,name=12m );
%mp(days_start=0,days_after_core=183,source=ip,equ=~,name=6m );

/**********************************************************/
/**********************************************************/
/*totals from other claim types*/
/**********************************************************/
/**********************************************************/
/*macro to calculate totals for the claims that are not in medpar files*/
%macro all_other(source=,month_n=,days_start=,days_after_core=);

/*Adjust for inflation*/
data &source._meet2_post;
set int.&source._meet_post_&days_after_core.;
/*adjust to 2012 dollars*/
if year(admit_date)>=2012 then rate=1;
if year(admit_date)=2011 then rate=1.03902;
if year(admit_date)=2010 then rate=1.07086;
if year(admit_date)=2009 then rate=1.10835;
if year(admit_date)=2008 then rate=1.1439;
if year(admit_date)=2007 then rate=1.1923;
if year(admit_date)=2006 then rate=1.25586;
if year(admit_date)=2005 then rate=1.30783;
if year(admit_date)=2004 then rate=1.37027;
if year(admit_date)=2003 then rate=1.43908;
if year(admit_date)=2002 then rate=1.50337;
if year(admit_date)=2001 then rate=1.57963;
if year(admit_date)=2000 then rate=1.65519;
if year(admit_date)<=1999 then rate=1.72641;

&source._paid_by_mc=rate*(pmt_amt);
run;

/*Calculate total mc payments by ID*/
proc sql;
create table &source._pay_post as select distinct BID_hrs_21,core_year,
sum(&source._paid_by_mc) as &source._paid_by_mc
from &source._meet2_post group by BID_hrs_21,core_year;
quit;

/*merge in mc totals with interview list*/
proc sql;
create table &source.&month_n._post as select
a.BID_hrs,a.id,a.core_year,coalesce(b.&source._paid_by_mc,0) as &source._paid_by_mc&month_n 
from int.core_ids_init_outcomes a
left join
 &source._pay_post b
 on trim(left(a.BID_hrs))=trim(left(b.BID_hrs_21)) and a.core_year=b.core_year;
 quit;

 proc sort data=&source&month_n._post ;
 by BID_hrs core_year;
 run;
 %mend all_other;

/******************************************************************/
/* Run the macro over the mc claims files for 2 years prior to death*/
/******************************************************************/

 %all_other(source=op,month_n=_24m,days_start=0,days_after_core=730);
  %all_other(source=pb,month_n=_24m,days_start=0,days_after_core=730);
   %all_other(source=hh,month_n=_24m,days_start=0,days_after_core=730);
    %all_other(source=hs,month_n=_24m,days_start=0,days_after_core=730);
     %all_other(source=dm,month_n=_24m,days_start=0,days_after_core=730);

 %all_other(source=op,month_n=_12m,days_start=0,days_after_core=365);
  %all_other(source=pb,month_n=_12m,days_start=0,days_after_core=365);
   %all_other(source=hh,month_n=_12m,days_start=0,days_after_core=365);
    %all_other(source=hs,month_n=_12m,days_start=0,days_after_core=365);
     %all_other(source=dm,month_n=_12m,days_start=0,days_after_core=365);

 %all_other(source=op,month_n=_6m,days_start=0,days_after_core=183);
  %all_other(source=pb,month_n=_6m,days_start=0,days_after_core=183);
   %all_other(source=hh,month_n=_6m,days_start=0,days_after_core=183);
    %all_other(source=hs,month_n=_6m,days_start=0,days_after_core=183);
     %all_other(source=dm,month_n=_6m,days_start=0,days_after_core=183);

/******************************************************************/
/* Merge into single file, by id and interview */
/******************************************************************/
*first merge 12m and 6m spending into single dataset;
data mc_costs_all;
merge ip_24m snf_24m hh_24m_post hs_24m_post pb_24m_post op_24m_post dm_24m_post
ip_12m snf_12m hh_12m_post hs_12m_post pb_12m_post op_12m_post dm_12m_post
 ip_6m snf_6m hh_6m_post hs_6m_post pb_6m_post op_6m_post dm_6m_post;
by BID_hrs core_year;
run;

/******************************************************************/
/* Adjust for the wage index */
/******************************************************************/

*add wage index to the costs totals files;
proc sql;
create table mc_costs_all_wi_1 as select a.*, b.wage_index_2012_2
from mc_costs_all a left join
int.core_lmt_xwalk_2 b
on a.BID_hrs=b.bid_hrs and a.core_year=b.core_year;
quit;

/*if wage index is missing, set to 1 and identify with an indicator variable*/
data mc_costs_all_wi_2;
set mc_costs_all_wi_1;
if wage_index_2012_2=. then do;
	wage_index_missing_yes = 1;
	wage_index_2012_2 = 1;
end;
run;

proc freq; table wage_index_missing_yes; run;

%macro wage_ind(source=);
data mc_costs_all_wi_2;
set mc_costs_all_wi_2;
&source._paid_by_mc_24m_wi = &source._paid_by_mc_24m / wage_index_2012_2;
&source._paid_by_mc_12m_wi = &source._paid_by_mc_12m / wage_index_2012_2;
&source._paid_by_mc_6m_wi = &source._paid_by_mc_6m / wage_index_2012_2;
run;
%mend;

%wage_ind(source=ip);
%wage_ind(source=snf);
 %wage_ind(source=op);
  %wage_ind(source=pb);
   %wage_ind(source=hh);
    %wage_ind(source=hs);
     %wage_ind(source=dm);


/******************************************************************/
/* Get totals across all claim types */
/******************************************************************/

data int.mc_costs_12m_6m;
set mc_costs_all_wi_2;
/*total not adjusted for wage index*/
tot_paid_by_mc_24m=sum(of ip_paid_by_mc_24m snf_paid_by_mc_24m hh_paid_by_mc_24m hs_paid_by_mc_24m
pb_paid_by_mc_24m op_paid_by_mc_24m dm_paid_by_mc_24m);

tot_paid_by_mc_12m=sum(of ip_paid_by_mc_12m snf_paid_by_mc_12m hh_paid_by_mc_12m hs_paid_by_mc_12m
pb_paid_by_mc_12m op_paid_by_mc_12m dm_paid_by_mc_12m);

tot_paid_by_mc_6m=sum(of ip_paid_by_mc_6m snf_paid_by_mc_6m hh_paid_by_mc_6m hs_paid_by_mc_6m
pb_paid_by_mc_6m op_paid_by_mc_6m dm_paid_by_mc_6m);

/*wage index adjusted*/
tot_paid_by_mc_24m_wi=sum(of ip_paid_by_mc_24m_wi snf_paid_by_mc_24m_wi hh_paid_by_mc_24m_wi hs_paid_by_mc_24m_wi
pb_paid_by_mc_24m_wi op_paid_by_mc_24m_wi dm_paid_by_mc_24m_wi);

tot_paid_by_mc_12m_wi=sum(of ip_paid_by_mc_12m_wi snf_paid_by_mc_12m_wi hh_paid_by_mc_12m_wi hs_paid_by_mc_12m_wi
pb_paid_by_mc_12m_wi op_paid_by_mc_12m_wi dm_paid_by_mc_12m_wi);

tot_paid_by_mc_6m_wi=sum(of ip_paid_by_mc_6m_wi snf_paid_by_mc_6m_wi hh_paid_by_mc_6m_wi hs_paid_by_mc_6m_wi
pb_paid_by_mc_6m_wi op_paid_by_mc_6m_wi dm_paid_by_mc_6m_wi);

/*label variables*/
label tot_paid_by_mc_24m="Medicare payment total 2 years following interview"
ip_paid_by_mc_24m="IP Medicare payments 2 years following interview" 
snf_paid_by_mc_24m="SNF Medicare payments 2 years following interview"
hh_paid_by_mc_24m="Home health Medicare payments 2 years following interview" 
hs_paid_by_mc_24m="Hospice Medicare payments 2 years following interview"
pb_paid_by_mc_24m="Carrier Medicare payments 2 years following interview" 
op_paid_by_mc_24m="OP Medicare payments 2 years following interview" 
dm_paid_by_mc_24m="DME Medicare payments 2 years following interview"

tot_paid_by_mc_24m_wi="WI adj Medicare payment total 2 years following interview"
ip_paid_by_mc_24m_wi="WI adj IP Medicare payments 2 years following interview" 
snf_paid_by_mc_24m_wi="WI adj SNF Medicare payments 2 years following interview"
hh_paid_by_mc_24m_wi="WI adj Home health Medicare payments 2 years following interview" 
hs_paid_by_mc_24m_wi="WI adj Hospice Medicare payments 2 years following interview"
pb_paid_by_mc_24m_wi="WI adj Carrier Medicare payments 2 years following interview" 
op_paid_by_mc_24m_wi="WI adj OP Medicare payments 2 years following interview" 
dm_paid_by_mc_24m_wi="WI adj DME Medicare payments 2 years following interview"
;

label tot_paid_by_mc_12m="Medicare payment total 1 year following interview"
ip_paid_by_mc_12m="IP Medicare payments 1 year following interview" 
snf_paid_by_mc_12m="SNF Medicare payments 1 year following interview"
hh_paid_by_mc_12m="Home health Medicare payments 1 year following interview" 
hs_paid_by_mc_12m="Hospice Medicare payments 1 year following interview"
pb_paid_by_mc_12m="Carrier Medicare payments 1 year following interview" 
op_paid_by_mc_12m="OP Medicare payments 1 year following interview" 
dm_paid_by_mc_12m="DME Medicare payments 1 year following interview"

tot_paid_by_mc_12m_wi="WI adj Medicare payment total 1 year following interview"
ip_paid_by_mc_12m_wi="WI adj IP Medicare payments 1 year following interview" 
snf_paid_by_mc_12m_wi="WI adj SNF Medicare payments 1 year following interview"
hh_paid_by_mc_12m_wi="WI adj Home health Medicare payments 1 year following interview" 
hs_paid_by_mc_12m_wi="WI adj Hospice Medicare payments 1 year following interview"
pb_paid_by_mc_12m_wi="WI adj Carrier Medicare payments 1 year following interview" 
op_paid_by_mc_12m_wi="WI adj OP Medicare payments 1 year following interview" 
dm_paid_by_mc_12m_wi="WI adj DME Medicare payments 1 year following interview"
;

label tot_paid_by_mc_6m="Medicare payment total 6 months following interview"
ip_paid_by_mc_6m="IP Medicare payments 6 months following interview" 
snf_paid_by_mc_6m="SNF Medicare payments 6 months following interview"
hh_paid_by_mc_6m="Home health Medicare payments 6 months following interview" 
hs_paid_by_mc_6m="Hospice Medicare payments 6 months following interview"
pb_paid_by_mc_6m="Carrier Medicare payments 6 months following interview" 
op_paid_by_mc_6m="OP Medicare payments 6 months following interview" 
dm_paid_by_mc_6m="DME Medicare payments 6 months following interview"

tot_paid_by_mc_6m_wi="WI adj Medicare payment total 6 months following interview"
ip_paid_by_mc_6m_wi="WI adj IP Medicare payments 6 months following interview" 
snf_paid_by_mc_6m_wi="WI adj SNF Medicare payments 6 months following interview"
hh_paid_by_mc_6m_wi="WI adj Home health Medicare payments 6 months following interview" 
hs_paid_by_mc_6m_wi="WI adj Hospice Medicare payments 6 months following interview"
pb_paid_by_mc_6m_wi="WI adj Carrier Medicare payments 6 months following interview" 
op_paid_by_mc_6m_wi="WI adj OP Medicare payments 6 months following interview" 
dm_paid_by_mc_6m_wi="WI adj DME Medicare payments 6 months following interview"
;
run;

proc sort data=int.core_ids_init_outcomes; by bid_hrs core_year; run;
proc sort data=int.mc_costs_12m_6m; by bid_hrs core_year; run;


*merge into overall dataset*;
proc sql;
create table int.core_ids_outcomes(drop=bid_hrs2 id2 core_year2 wi) as select * from
int.core_ids_init_outcomes a left join
int.mc_costs_12m_6m(rename=(bid_hrs=bid_hrs2) rename=(id=id2) rename=(core_year=core_year2) rename=(wage_index_2012_2=wi)) b
on trim(left(a.bid_hrs))=trim(left(b.bid_hrs2)) and a.core_year=b.core_year2;
quit;

proc export data=int.core_ids_outcomes outfile="E:\data\Evan_SAS_practice\Core_00_12_with_outcomes.dta"; run;

proc export data=int.core_ids_1yr outfile="E:\data\Evan_SAS_practice\Core_00_12_FFS.dta"; run;