= V4 Outline MultiLine NoSorting TabWidth=30

H="Medicare costs last 2 years to merge with oop costs"
/* 
Medicare claims 2000-2010
Core Interviews 1998-2010
Exit interviews 2002-2010
OOP data 1992-2010

This file gets OOP costs in last 2 years of life and Medicare costs last 2 years of life
Merges with exit, restricted, n1 and n2 core interviews from HRS

All $ are adjusted for inflation to 2010 dollars

Workflow is as follows:
1. Get dataset of interviews with mc xwalk for all decedents, exit+restricted+mc xwalk
+core n1 + core n2 (dataset is oop_int.r_x_r_n1_n2)
	(Core interviews include dementia probability from Hurd et al paper)
2. Get dataset of OOP data for all decedents from exit and core n1 and n2 core ivws
3. Check Medicare and HMO status 2 years before death and define sample size
4. Get additional information from claims
	Elixhuaser comorbidities, chronic conditions 2 years before death from dx codes
	Hospital, etc LOS 2 years before death
5. Totals of Medicare payments for last 2 years of life
*/


/*Set up file paths that will be used*/

/*source dataset for OOP information 1992-2010*/
libname oop_src "E:\data\hrs_oop_2010\received_data";

/*Project working data directory */
libname oop_int "E:\data\hrs_oop_2010\int_data";

/*Final data directory */
libname oop_fnl "E:\data\hrs_oop_2010\final_data";

/*Medicare claims files - 2010*/
libname medi 'E:\data\cms_DUA_25000_2010';
proc contents data=medi.cmsxref2010;
run;

/*Cleaned HRS 2000-2010 datasets (core, exit and restricted SAS datasets)*/
libname hrs_cln 'E:\data\hrs_cleaned';

/*dementia probabilities*/
libname hrs_dem 'E:\data\hrs_public_2010\dementia';

/*File path for raw data
Some are copied from the Hospice impact project documents saved here:
C:\projects\Hospice_impact_on_utilization\raw_data
Copied over on 9/26/2013 by RG
Folder contains reference wage index adjustment files
Wage index 2010 downloaded from CMS 3/24/14*/

libname oop_wi "E:\data\hrs_oop_2010\ref_data\wage_index";
libname oop_nh "E:\data\hrs_oop_2010\ref_data\nh_costs_by_state";
libname oop_ref "E:\data\hrs_oop_2010\ref_data";


H="Pull exit and restricted interviews and mc xwalk id"
/*
Create respondant dataset with exit, restricted HRS,
and medicare xwalk

Resulting dataset is:
oop_int.exit_restricted_02_to_10_v1
*/

/*******************************************************************/
/*******************************************************************/
/*  Bring medicare xwalk id to exit interview dataset              */
/*******************************************************************/
/*******************************************************************/

proc contents data=hrs_cln.exit_02_to_10_dt(keep=id);
run;

data exit_1;
set hrs_cln.exit_02_to_10_dt;
run;

/*just keep cleaned variables from exit interview*/
data exit;
set exit_1(keep=ID EXIT_YEAR PROXY_EXIT FEMALE MARITAL MARRIED MARITAL_SEP MARITAL_DIV MARITAL_WID MARITAL_NEV
MARITAL_SD MARITAL_MISSING MEDICARE MEDICAREB MEDICAID CHAMPUS HMO MEDIGAP CATINSUR NHRES
HOSPICE FREQRELG CHILD GCHIL ALLCHIL RESCHIL RESCHIL_D RESSPOUSE HHM LIVEALONE LOCATION LOC_HOSP
ICU VENT DIALYSIS DEC_ALL DEC_LIM DEC_WHLD DEC_COMF DEC_CAT DEXP EOLDEC CAPACITY DURATION ADAPP
ADPROB DECMAKER LWILL LW_ALL LW_LIM LW_WHLD LW_COMF LW_CAT HCP DISCUSS ADVDIR EOLPLAN
ADL_BEDBOUND DAYS_BED_ILL ADL_DR ADL_WK ADL_BH ADL_E ADL_TX ADL_T ADL_INDEX ADL_CAT ADL_INDEPENDENT
ADL_PARTIAL ADL_SEVERE IADL_MP IADL_GR IADL_PH IADL_RX IADL_M IADL_IND IADL_CAT IADL_INDEPENDENT
IADL_PARTIAL IADL_SEVERE ADL_SP_HELPER ADL_OTH_HELPER IADL_SP_HELPER IADL_OTH_HELPER adl_helper_count iadl_helper_count adl_helper_1-adl_helper_7 iadl_helper_1-iadl_helper_6 HH_WORKER CANCER_HRS LUNG_HRS HEART_HRS CHF_HRS STROKE_HRS MEMORY_HRS FALLS_HRS
INCONT_HRS PAIN_HRS HTN_HRS DM_HRS PSYCH_HRS ARTH_HRS COMOR_IN_HRS COMOR_C_HRS 
nhres_2yr_exit nh_stays_exit nh_nights_exit nh_ins_exit e_ivw_day e_ivw_month e_ivw_year 
e_ivw_date e_ivw_day_imp) ;
run;


/*HRS - CMS 2010 crosswalk initial processing 
xwalk file: cmsxref2010.sas7bdat*/

data crosswalk_1;
set medi.cmsxref2010;
keep bid_hrs_19 hhid pn;
run;

/*get 2 variables bid_hrs = claims id, id=HRS id*/
data crosswalk_2;
set crosswalk_1;
bid_hrs=bid_hrs_19;
id=trim(hhid)||trim(pn);
drop hhid pn;
drop bid_hrs_19;
run;

proc sort data= crosswalk_2;
by bid_hrs;
run;

proc sort data=exit_1;
by id;
run;

/*bring in xwalk id to exit interview dataset*/
proc sql;
create table exit_xwalk as select
a.*,b.bid_hrs from
exit a
left join
crosswalk_2 b
on a.id=b.id;
quit;

/*check for missing xwalk ids
913 r's with exit interviews are missing xwalk ids*/
data check1;
set exit_xwalk ;
if bid_hrs ='';
run;

/*create indicator for having xwalk id*/
data exit_xwalk_1;
set exit_xwalk;
xwalk_yes=.;
if bid_hrs ='' then xwalk_yes=0;
if bid_hrs~='' then xwalk_yes=1;
run;

proc freq;
table xwalk_yes*exit_year /missprint;
run;

/*keep a version before renaming so can use it later to get spouse exit*/
data exit_xwalk_2;
set exit_xwalk_1;
run;


/*******************************************************************/
/*******************************************************************/
/* Rename variables with  _x suffix for exit dataset  */
/*******************************************************************/
/*******************************************************************/
*options macrogen mprint mlogic;
%macro rename2(lib,dsn,pre,first);
options pageno=1 nodate;
proc contents data=&lib..&dsn;
title "Before Renaming All Variables";
run;
proc sql noprint;
select nvar into :num_vars
from dictionary.tables
where libname="&LIB" and
memname="&DSN";
select distinct(name) into :var1-
:var%TRIM(%LEFT(&num_vars))
from dictionary.columns
where libname="&LIB" and
memname="&DSN" ;
quit;
run;
proc datasets library=&LIB;
modify &DSN;
rename
%do i=1 %to &num_vars;

&&var&i=&first.&&var&i.&&pre.
%end;
;
quit;
run;
options pageno=1 nodate;
proc contents data=&lib..&dsn;
title "After Renaming All Variables";
run;
%mend ;
%rename2(WORK,EXIT_XWALK_2,_x,);

data exit_xwalk_3;
set exit_xwalk_2;
rename id_x=id;
rename bid_hrs_x=BID_hrs;
rename xwalk_yes_x=xwalk_yes;
run;

proc print data=exit_xwalk_3(keep=id BID_hrs obs=10);
run;
proc sort data=exit_xwalk_3;
by id;
run;

/*******************************************************************/
/*******************************************************************/
/*  Merge the exit w/ mc xwalk with the restricted dataset         */
/*******************************************************************/
/*******************************************************************/

proc contents data=hrs_cln.restricted_v2010(keep=id);
run;

data restricted;
set hrs_cln.restricted_v2010;
if id~='';
run;

proc sort data=exit_xwalk_3 nodupkey;
by id;
run;

/*replace id with character id so restricted dataset can be merged in
to the exit dataset*/
data restricted_2;
set restricted;
length id_new $9 hhid $6 pn $3;
id_new=hhid||pn;
drop id;
rename id_new=id;
run;

/*get restricted dataset that is just decedents*/
proc sql;
create table restricted_r as select a.*,b.exit_year_x from
restricted_2 a join
exit_xwalk_3 b on a.id=b.id;
quit;

/*get zip code at time of death to use for wage index adjustment*/
data id_zip;
set restricted_r(rename=(ZIP10_2000=ZIP10));
/*use zip code variable from restricted dataset for year of exit interview*/
zip_exit=vvaluex("zip"||substr(trim(left(exit_year_x)),3,2) );
run;

/*2 obs have missing zip in exit year
They have zip in previous wave so use that*/
data zztestzip1;
set id_zip;
if zip_exit = "";
run;

/*if no zip in exit year, then use zip from wave prior to exit*/
data id_zip_2;
set id_zip;
if zip_exit="" then zip_exit=vvaluex("zip"||substr(trim(left(exit_year_x-2)),3,2)  );
run;

/*check to see if obs still have missing zip - none*/
data zztestzip2;
set id_zip_2;
if zip_exit = "";
run;

/*save a version of the dataset before renaming*/
data restricted_r_1;
set id_zip_2;
run;

/*rename variables in restricted dataset with  _e suffix*/
%rename2(WORK,RESTRICTED_R_1,_e,);

data restricted_r3;
set restricted_r_1;
rename id_e=id;
age_at_death_e=(death_date_e-birth_date_e)/365.25;
label age_at_death_e="Age at death";
death_year_e=year(death_date_e);
run;
proc print data=restricted_r3(keep=id obs=10);
run;
proc sort data=restricted_r3 nodupkey;
by id;
run;

/*this dataset = 6814 decedents from 2002 - 2010 exit interviews
containst exit, mc xwalk id, and restricted info*/
proc sql;
create table exit_restricted_02_to_10 as 
select *
from  exit_xwalk_3 a
left join
restricted_r3 b
on a.id=b.id;
quit;

/*this dataset = 6814 decedents from 2002 - 2010 exit interviews*/
data oop_int.exit_restricted_02_to_10_v1;
set exit_restricted_02_to_10;
if id<0 or id=. then delete;
run;

/*141 decedents missing a cause of death*/
proc freq;
table CAUSE_DEATH_12_N_e;
run;

proc freq;
table death_year_e*EXIT_YEAR_x /missprint;
run;



H="Pull core interviews"
/*Get r's n1 and n2 core interviews*/

libname hrs_cln 'E:\data\hrs_cleaned';
libname oop_int 'E:\data\hrs_oop_2010\int_data';


/*******************************************************************/
/*******************************************************************/
/*  get the negative one core variables for the respondent         */
/*******************************************************************/
/*******************************************************************/

/*full core interview dataset 1998-2010 core ivws*/
proc contents data=hrs_cln.core_00_to_10;
run;

/*list of all core interviews before death date*/
proc sql;
create table r_n1_core_before_death
as select b.*
 from oop_int.exit_restricted_02_to_10_v1 a 
 inner join
hrs_cln.core_00_to_10 b
  on a.id=b.id and a.death_date_e>b.c_ivw_date;
  quit;

proc sort data=r_n1_core_before_death ;
by id c_ivw_date;
run;

/*keep only the n1 core interview
6509 interviews identified
of these, 143 are in 1998 so will not have n2 core*/
data resp_core_n1;
set r_n1_core_before_death;
by id c_ivw_date;
if last.id;
run;
proc freq;
table core_year;
run;

/*******************************************************************/
/*******************************************************************/
/*  get the negative 2 core variables for the respondent         */
/*******************************************************************/
/*******************************************************************/
/*list of all core interviews before n1 interview*/
proc sql;
create table r_n2_core_before_death
as select b.*
 from resp_core_n1 a 
 inner join
hrs_cln.core_00_to_10 b
  on a.id=b.id and a.c_ivw_date>b.c_ivw_date;
  quit;

proc sort data=r_n2_core_before_death ;
by id c_ivw_date;
run;

/*keep only the n2 core interview
6222 interviews identified*/
data resp_core_n2;
set r_n2_core_before_death;
by id c_ivw_date;
if last.id;
run;
proc freq;
table core_year;
run;

/*******************************************************************/
/*******************************************************************/
/*  get the negative 3 core education variable for the respondent   */
/*******************************************************************/
/*******************************************************************/
/*need to do this since education is only asked during r's
first core interview and only backfilled for an overall education
level through 2004*/
proc sql;
create table r_n3_core_before_death
as select b.educ,b.c_ivw_date,b.core_year,b.id
 from resp_core_n2 a 
 inner join
hrs_cln.core_00_to_10 b
  on a.id=b.id and a.c_ivw_date>b.c_ivw_date;
  quit;

proc sort data=r_n3_core_before_death ;
by id c_ivw_date;
run;

/*keep only the n3 core interview
4692 interviews identified*/
data resp_core_n3;
set r_n3_core_before_death;
by id c_ivw_date;
if last.id;
run;
proc freq;
table core_year;
run;

/*******************************************************************/
/* Dementia probabilities */
/*******************************************************************/
/*merge in the HRS dementia probabilities at each core year
Use dementia year - 1 to get the core year that the probability is based on*/
proc contents data=hrs_dem.pdem_withvarnames;
run;

data dem_1;
set hrs_dem.pdem_withvarnames;
core_year_imp = prediction_year-1;
/*create id variable as concat of hhid and pn*/
length id $9 hhid $6 pn $3;
id=hhid||pn;
run;

proc freq;
table core_year_imp;
run;

proc sort data=dem_1 nodupkey;
by id core_year_imp;
run;

proc sort data=resp_core_n1 nodupkey;
by id core_year;
run;

/*n1 core interviews*/
proc sql;
create table resp_dem_core_n1
as select a.*,b.prob_dementia from 
resp_core_n1 a left join
dem_1 b
on a.id=b.id and a.core_year=b.core_year_imp;
quit;

proc sort data=resp_core_n2 nodupkey;
by id core_year;
run;

/*n2 core interviews*/
proc sql;
create table resp_dem_core_n2
as select a.*,b.prob_dementia from 
resp_core_n2 a left join
dem_1 b
on a.id=b.id and a.core_year=b.core_year_imp;
quit;



H="Merge HRS interview datasets, get n1, n2, restr, exit, mc xw"
/*merges the restricted/exit/xwalk dataset with the n1, n2 and n3 core datasets
resulting dataset is saved as
oop_int.r_x_r_n1_n2
*/

/*First rename variables*/

%rename2(WORK,RESP_DEM_CORE_N1,_n1,);
%rename2(WORK,RESP_DEM_CORE_N2,_n2,);
%rename2(WORK,RESP_CORE_N3,_n3,);

/*r's n1 core*/
data resp_core_n1_a;
set RESP_DEM_CORE_N1;
rename id_n1 = id;
run;

proc sort data=resp_core_n1_a nodupkey;
by id;
run;

/*r's n2 core*/
data resp_core_n2_a;
set RESP_DEM_CORE_N2;
rename id_n2 = id; 
run;

proc sort data=resp_core_n2_a nodupkey;
by id;
run;

/*r's n3 core*/
data resp_core_n3_a;
set RESP_CORE_N3;
rename id_n3 = id; 
run;

proc sort data=resp_core_n3_a nodupkey;
by id;
run;

/*merge datasets*/
/*Merge r's interviews with exit/restricted dataset*/
/*Sort r's exit and restricted dataset including r and s xwalk ids*/
proc sort data=oop_int.exit_restricted_02_to_10_v1 out=r_ex_restr;
by id;
run;

data oop_int.r_x_r_n1_n2;
merge r_ex_restr resp_core_n1_a resp_core_n2_a resp_core_n3_a;
by id;
run;


H="Get OOP data for exit, n1, n2 and n3 cores"
/*
Collects OOP data for decedents from exit, n1, n2, and n3 core interview imputations
Dataset is oop_int.oop_x_n1_n2_n3
*/
libname oop_src "E:\data\hrs_oop_2010\received_data";
libname oop_int "E:\data\hrs_oop_2010\int_data";
libname hrs_cln 'E:\data\hrs_cleaned';

proc import datafile="E:\data\hrs_oop_2010\received_data\oopme_final_oldv.dta"  
out=oop_1 replace; 
run;

data oop_int.oop_2 (keep=id year curr_iw_date prev_iw_date months total_OOP hospital_OOP NH_OOP 
doctor_OOP dental_OOP patient_OOP hospice_OOP RX_OOP home_OOP special_OOP non_med_OOP helper_OOP 
insurance_costs NH_NIGHTS md_cov);
set oop_1;
length id $9 hhid $6 pn $3;
id=hhid||pn;
run;

proc sort data=oop_int.oop_2 out=oop_2 nodupkey;
by id year;
run;

data exit_2;
set oop_int.exit_restricted_02_to_10_v1;
keep id exit_year_x death_date_e;
run;

proc sort data=exit_2 nodupkey;
by id exit_year_x;
run;

proc sql;
create table exit_oop
as select * from 
exit_2 a left join
oop_2 b
on a.id=b.id and a.exit_year_x=b.year;
quit;

/*5 decedents do not have OOP imputed data from exit interviews*/
proc freq data=exit_oop;
table year;
run;

data exit_oop_1;
set exit_oop;
run;

/*rename variable macro*/
*options macrogen mprint mlogic;
%macro rename2(lib,dsn,pre,first);
options pageno=1 nodate;
proc contents data=&lib..&dsn;
title "Before Renaming All Variables";
run;
proc sql noprint;
select nvar into :num_vars
from dictionary.tables
where libname="&LIB" and
memname="&DSN";
select distinct(name) into :var1-
:var%TRIM(%LEFT(&num_vars))
from dictionary.columns
where libname="&LIB" and
memname="&DSN" ;
quit;
run;
proc datasets library=&LIB;
modify &DSN;
rename
%do i=1 %to &num_vars;

&&var&i=&first.&&var&i.&&pre.
%end;
;
quit;
run;
options pageno=1 nodate;
proc contents data=&lib..&dsn;
title "After Renaming All Variables";
run;
%mend ;

/*rename exit oop variables with _x suffix*/
%rename2(WORK,EXIT_OOP_1,_x,);

data EXIT_OOP_2;
set EXIT_OOP_1;
rename id_x=id;
run;

/***************************************************************************/
/***************************************************************************/
/*Get OOP data from n1 and n2 core interviews before death*/
/***************************************************************************/
/***************************************************************************/

proc freq data=exit_oop_2;
table year_x;
run;

/*first get all OOP data for decedents for their core interviews (before the exit ivw)*/
proc sql;
create table all_c_oop_deced
as select b.* from
exit_oop_2 a inner join
oop_2 b
on a.id=b.id and a.curr_iw_date_x>b.curr_iw_date;
quit;

proc sort data=all_c_oop_deced;
by id curr_iw_date;
run;

/*keep the n1 core interview*/
data oop_n1;
set all_c_oop_deced;
by id curr_iw_date;
if last.id;
run;

proc freq;
table year;
run;

/*now get the n2 core interview*/
proc sql;
create table oop_n2_1
as select b.* from
oop_n1 a inner join
all_c_oop_deced b
on a.id=b.id and a.curr_iw_date>b.curr_iw_date;
quit;

proc sort data=oop_n2_1;
by id curr_iw_date;
run;

/*keep the n2 core interview*/
data oop_n2;
set oop_n2_1;
by id curr_iw_date;
if last.id;
run;

proc freq;
table year;
run;

/*now get the n3 core interview*/
proc sql;
create table oop_n3_1
as select b.* from
oop_n2 a inner join
all_c_oop_deced b
on a.id=b.id and a.curr_iw_date>b.curr_iw_date;
quit;

proc sort data=oop_n3_1;
by id curr_iw_date;
run;

/*keep the n3 core interview*/
data oop_n3;
set oop_n3_1;
by id curr_iw_date;
if last.id;
run;

proc freq;
table year;
run;


/*rename the n1-n3 oop dataset variables*/
%rename2(WORK,OOP_N1,_n1,);
%rename2(WORK,OOP_N2,_n2,);
%rename2(WORK,OOP_N3,_n3,);

data OOP_N1_2;
set OOP_N1;
rename id_n1=id;
run;

data OOP_N2_2;
set OOP_N2;
rename id_n2=id;
run;

data OOP_N3_2;
set OOP_N3;
rename id_n3=id;
run;

/*merge the 3 OOP datasets so one observation per row, exit, n1 and n2 OOP year data*/
proc sort data=EXIT_OOP_2 nodupkey;
by id;
run;

proc sort data=OOP_N1_2 nodupkey;
by id;
run;

proc sort data=OOP_N2_2 nodupkey;
by id;
run;

proc sort data=OOP_N3_2 nodupkey;
by id;
run;

proc sql;
create table oop_x_n1 as select * from 
exit_oop_2 a left join
oop_n1_2 b
on a.id=b.id ;
quit;

proc sql;
create table oop_x_n1_n2 as select * from
oop_x_n1 a left join
oop_n2_2 b
on a.id=b.id ;
quit;

proc sql;
create table oop_int.oop_x_n1_n2_n3 as select * from
oop_x_n1_n2 a left join
oop_n3_2 b
on a.id=b.id ;
quit;


/*5 have no exit OOP data, 118 missing n1, 250 missing n2, 608 missing n3*/
proc freq;
table year_x year_n1 year_n2 year_n3;
run;

proc freq;
table md_cov_x md_cov_n1;
run;


H="OOP spending totals 24,60 months before death"
/*Start with dataset of OOP data exit, core n1 and n2 and n3
Adjust all OOP spending for inflation to 2010 dollars
Get totals by OOP spending type over the 24 and 60 months prior to death date

Also gets nursing home nights (self reported) over the 24 and 60m prior to death

Final dataset is oop_int.oop_24m_60m
*/

/**********************************************************************/
/**********************************************************************/
/*First adjust all spending for inflation to 2010 dollars
Uses CPI for Medical Services from BLS website, accessed 2/5/2014*/
/**********************************************************************/
/**********************************************************************/

/*create macro to run through all OOP variables to adjust for inflation*/
data adjust_oop_start;
set oop_int.oop_x_n1_n2_n3;
run;

%macro infl(wave,start);
data adjust_oop&wave.;
set adjust_oop&start.;
Array list
           NH_OOP&wave.
           RX_OOP&wave.
           dental_OOP&wave.
           doctor_OOP&wave.
           helper_OOP&wave.
           home_OOP&wave.
           hospice_OOP&wave.
           hospital_OOP&wave.
           non_med_OOP&wave.
           patient_OOP&wave.
           special_OOP&wave.
           total_OOP&wave.
	   insurance_costs&wave. 
;
Do over list;
if year&wave.=1998 then List=list*1.66616;
if year&wave.=2000 then List=list*1.54589;
if year&wave.=2002 then List=list*1.40392;
if year&wave.=2004 then List=list*1.27983;
if year&wave.=2006 then List=list*1.17287;
if year&wave.=2008 then List=list*1.06823;
end;
run;
%mend;

%infl(wave=_x,start=_start);
%infl(wave=_n1,start=_x);
%infl(wave=_n2,start=_n1);
%infl(wave=_n3,start=_n2);

/*final dataset is adjust_oop_n3 with all adjused for inflation*/
proc means data=adjust_oop_start;
var NH_OOP_x home_OOP_n1 total_OOP_n2 total_OOP_n3;
run;

proc means data=adjust_oop_n3;
var NH_OOP_x home_OOP_n1 total_OOP_n2 total_OOP_n3;
run;

/**********************************************************************/
/**********************************************************************/
/*Adjust RX OOP and totals
RX is capped at $300/month */
/**********************************************************************/
/**********************************************************************/
data adjust_rx_start;
set adjust_oop_n3;
run;

%macro rxadj(wave,start);
data adjust_rx&wave.;
set adjust_rx&start.;
rx_old&wave.=rx_OOP&wave.;
total_old&wave.=total_OOP&wave.;
if rx_OOP&wave./months&wave.>300 then rx_OOP&wave.=months&wave.*300;
total_OOP&wave.=total_old&wave.-rx_old&wave.+rx_OOP&wave.;
other_oop&wave.=total_oop&wave. -insurance_costs&wave.- hospital_oop&wave. -doctor_oop&wave. -rx_oop&wave.- nh_oop&wave. -helper_oop&wave.;
run;
%mend;

%rxadj(wave=_x,start=_start);
%rxadj(wave=_n1,start=_x);
%rxadj(wave=_n2,start=_n1);
%rxadj(wave=_n3,start=_n2);

proc means data=adjust_rx_n3;
var RX_OOP_x RX_old_x other_oop_n1;
run;

/*set nursing home spending and nights to 0 where missing in core interviews*/
data nh_adj;
set adjust_rx_n3;
if nh_oop_n1=. then nh_oop_n1=0;
if nh_oop_n2=. then nh_oop_n2=0;
if nh_oop_n3=. then nh_oop_n3=0;
if nh_nights_n1=. then nh_nights_n1=0;
if nh_nights_n2=. then nh_nights_n2=0;
if nh_nights_n3=. then nh_nights_n3=0;
if nh_nights_x=. then nh_nights_x=0;
run;

/**********************************************************************/
/**********************************************************************/
/*is the OOP dataset interview date from the Exit interview the death date
It is the month of death??? Yes!*/
data zzzdates;
set nh_adj;
format death_date_e_x date9. ;
run;
/**********************************************************************/
/**********************************************************************/


/**********************************************************************/
/**********************************************************************/
/*Get totals over 24 and 60 month periods*/
/**********************************************************************/
/**********************************************************************/
/*exit months range 1-202, n1 months=12-145, n2 months=12-152, n3 months=12-118*/
proc freq data=nh_adj;
table months_x months_n1 months_n2 months_n3;
run;

data check_months;
set nh_adj;
total_mos= sum(months_x,months_n1,months_n2,months_n3);
run;

proc freq;
table total_mos;
run;

/*get totals of waves OOP for 24 months and 60 months*/
%let list=total_OOP helper_OOP hospital_OOP nh_OOP doctor_OOP rx_OOP
 insurance_costs other_oop total_old rx_old nh_nights;

%macro all(su=,months=);

%do i=1 %to 11;
%let var=%scan(&list,&i);

data temp_&su._&i;
set nh_adj;

/*if all 24 months accounted for in exit interview*/
if months_x>=&months.  then do;
&var._&su.=&var._x*&months./months_x;
end;

/*if need n1+ exit*/
if months_x+months_n1>=&months. and &var._&su.=. then do;
&var._&su.=&var._x+&var._n1*(&months.-months_x)/(months_n1);
end;

/*if need n1+n2+ exit*/
if months_x+months_n1+months_n2>=&months. and &var._&su.=. then do;
&var._&su.=&var._x+&var._n1+&var._n2*((&months.-months_x-months_n1)/months_n2);
end;

/*if need n1+n2+n3+ exit*/
if months_x+months_n1+months_n2+months_n3>=&months. and &var._&su.=. then do;
&var._&su.=&var._x+&var._n1+&var._n2+&var._n3*((&months.-months_x-months_n1-months_n2)/months_n3);
end;

keep id &var._&su.;
run;

proc sort data=temp_&su._&i;
by id;
run;

%end;

%mend;

%all(su=24m,months=24);
%all(su=60m,months=60);

/*merge the temporary datasets back together*/
/*so dataset all_2 has variables for OOP spending last 24 months of life*/
data all_2;
merge temp_24m_1-temp_24m_11 temp_60m_1-temp_60m_11;
by id;
run;

proc means data=all_2(drop=id);
var _all_;
run;

/*bring in the total months oop data available variables, create indicator for complete
data 24m and 60m*/
proc sql;
create table complete_oop as select a.*,b.total_mos,b.months_x,b.months_n1,b.months_n2,b.months_n3 from
all_2 a left join
check_months b
on a.id=b.id;
quit;

proc freq;
table total_mos months_x months_n1 months_n2 months_n3;
run;

data complete_oop_1;
set complete_oop;
ind_24m_oop_yes=0;
ind_60m_oop_yes=0;
if total_mos>=24 & total_mos~=. then ind_24m_oop_yes=1 ;
if total_mos>=60 & total_mos~=. then ind_60m_oop_yes=1 ;
label ind_24m_oop_yes="Indicator for 24m OOP data available";
label ind_60m_oop_yes="Indicator for 60m OOP data available";
run;

proc freq;
table ind_24m_oop_yes ind_60m_oop_yes;
run;

/*save this dataset*/
data oop_int.oop_24m_60m;
set complete_oop_1;
drop total_mos months_x months_n1 months_n2 months_n3;
run;

H="Merge interviews with OOP totals"

proc sort data=oop_int.oop_24m_60m out=oop nodupkey;
by id;
run;

proc sort data=oop_int.r_x_r_n1_n2 out=ivws nodupkey;
by id;
run;

/*merge oop with HRS interviews*/
proc sql;
create table oop_int.hrs_oop_ivws as select * from
ivws a left join
oop  b
on a.id=b.id;
quit;



H="Set up denominator file data, check vs oop, keep age ge 67 at death"
/************************************************************************
Use merged Medicare denominator file 2000-2010,
Merged and initial cleaning done in file HRS_2010_MC_claims.txt saved
saved under general HRS processing directory
************************************************************************/

proc sort data=medi.dn_2000_2010 out=dn_2000_20102  nodupkey;
by BID year;
run;

*Last (latest year) entry in denominator file;
data dn_last_year;
set dn_2000_20102(rename=bid=bid_hrs);
by BID_hrs year;
if last.BID_hrs then output;
run;

*Frequency table from denominator file of last entries;
*11,000+ obs in 2010 for last year, because those are people who don't have a death date;
proc freq data=dn_last_year;
table death_year year;
run;

/*5764 meet the age >=67
create table of observations 67 or older of age when died per the restricted dataset*/
proc sql;
create table oop_re_age_ge67 as
select * from oop_int.exit_restricted_02_to_10_v1
where age_at_death_e>=67;
quit;

proc freq;
table xwalk_yes;
run;

/*5375 ids of 5764 have the cross walk ids.*/
*create table of observations that have died that have xwalk id;
data oop_age_ge67_in_mc ;
set oop_re_age_ge67 ;
if xwalk_yes=1;
if age_at_death_e>=70 then age_ge_70=1;
if age_at_death_e<70 and age_at_death_e~=. then age_ge_70=0;
run;

*frequency of merged_year variable from oop_re_age_ge67_in_mc above;
proc freq;
table exit_year_x age_ge_70;
run;

/*get a dataset with just decedents exit year, death_year, death date and ids
Limited to those with xwalk id and age 67+ at death*/
data oop_int.oop_sample;
set oop_age_ge67_in_mc ;
keep id bid_hrs exit_year_x death_year_e death_date_e;
run;

H="Check to see if medicare and no hmo for 2 and 5 yrs before death"
/***********************************************************
************************************************************
Determine which observations get dropped from sample because they either 
(a) don't have medicare the whole 24 months before death or 
(b) have HMO sometime in the last 24 months before death

Save one datasets:
oop_int.meet_criteria_2yr, this also has the 5 year variables
************************************************************
***********************************************************/

/*new table adding mc monthly buyin and hmo status to hrs file w/ xwalk id added, 
for year of death per hrs
Count observations in denominator file with death year: 5192*/
proc sql;
create table dn_death_y as select
a.*,b.buyin12,b.year,b.HMOIND12,b.bid_n
from oop_int.oop_sample a inner join
dn_2000_20102 b
on trim(left(a.BID_hrs))=trim(left(b.BID_HRS_19))
and a.death_year_e=b.year;
quit;

proc freq data=dn_death_y;
table death_year_e;
run;
proc sql;
select count(distinct bid_n) from dn_death_y;
quit;

/*Since look back is 2 years, create table of observations with death year is 2002 and later: 4477 observations left*/
proc sql;
create table dn_death_y_02 as
select * from dn_death_y 
where death_year_e>2001 ;
quit;

/*note death month should from restricted file
This trims the buyin12 and hmo12 variables to only have values
entered prior to the patient's death using the death date from HRS*/
data dn_death_y2;
set dn_death_y_02;
death_month_e=month(death_date_e);
if length(trim(left(buyin12)))=12 and death_month_e>0 then do;
buyin_dy=substr(trim(left(buyin12)),1,death_month_e);
hmo_dy=substr(trim(left(HMOIND12)),1,death_month_e);
end;
else do;
buyin_dy=trim(left(buyin12));
hmo_dy=trim(left(HMOIND12));
end;
run;

*all observations have death month;
proc means n;
var death_month_e;
run;
*freq table of death month;
proc freq data=dn_death_y2;
table death_month_e;
run;

/*Now match dn files from 1 year before death
Matches hrs entry for year died with the previous year's mc denominator file, 
pulling in buy in and hmo indicator
to determine mc elgible throughout study time period*/
proc sql;
create table dn_death_y_1bef as select
a.*,
b.year as death_year_l1,
b.buyin12 as buyin12_l1,
b.HMOIND12 as HMOIND12_l1
from dn_death_y2 a inner join
dn_2000_20102 b
on trim(left(a.BID_hrs))=trim(left(b.BID_hrs_19))
and 0<a.year-b.year<=1 order by a.bid_n,year;
quit;

/*Now match dn files from 2 years before death
Matches hrs entry for year died with the previous year's mc denominator file, pulling in buy in and hmo indicator
to determine mc elgible throughout study time period
Use _l2 to denote year prior to death (death year less 2)
3 observations do not have 2 year before denominator file*/
proc sql;
create table dn_death_y_2bef as select
a.*,
b.year as death_year_l2,
b.buyin12 as buyin12_l2,
b.HMOIND12 as HMOIND12_l2
from dn_death_y_1bef a inner join
dn_2000_20102 b
on trim(left(a.BID_hrs))=trim(left(b.BID_hrs_19))
and 1<a.year-b.year<=2 order by a.bid_n,year;
quit;

/*Now match dn files from 3 years before death
Matches hrs entry for year died with the previous year's mc denominator file, pulling in buy in and hmo indicator
to determine mc elgible throughout study time period
Use _l3 to denote 3 years prior to death (death year less 3)
694 observations don't have _l3 denominator file*/
proc sql;
create table dn_death_y_3bef as select
a.*,
b.year as death_year_l3,
b.buyin12 as buyin12_l3,
b.HMOIND12 as HMOIND12_l3
from dn_death_y_2bef a inner join
dn_2000_20102 b
on trim(left(a.BID_hrs))=trim(left(b.BID_hrs_19))
and 2<a.year-b.year<=3 order by a.bid_n,year;
quit;

/*Now match dn files from 4 years before death
Matches hrs entry for year died with the previous year's mc denominator file, pulling in buy in and hmo indicator
to determine mc elgible throughout study time period
Use _l3 to denote 3 years prior to death (death year less 2)
Lose 551 observations: 3429*/
proc sql;
create table dn_death_y_4bef as select
a.*,
b.year as death_year_l4,
b.buyin12 as buyin12_l4,
b.HMOIND12 as HMOIND12_l4
from dn_death_y_3bef a inner join
dn_2000_20102 b
on trim(left(a.BID_hrs))=trim(left(b.BID_hrs_19))
and 3<a.year-b.year<=4 order by a.bid_n,year;
quit;

/*Finally, match dn files from 5 years before death
Matches hrs entry for year died with the previous year's mc denominator file, pulling in buy in and hmo indicator
to determine mc elgible throughout study time period
Use _l5 to denote 5 years prior to death (death year less 5)
557 obs don't have l5 denominator entry n=2872*/
proc sql;
create table dn_death_y_5bef as select
a.*,
b.year as death_year_l5,
b.buyin12 as buyin12_l5,
b.HMOIND12 as HMOIND12_l5
from dn_death_y_4bef a inner join
dn_2000_20102 b
on trim(left(a.BID_hrs))=trim(left(b.BID_hrs_19))
and 4<a.year-b.year<=5 order by a.bid_n,year;
quit;

/**************************************************/
/**************************************************/
/*create variables that have entries for full 24m and 60m pre-death for buyin and hmo variables by combining death year and years prior to death*/
data all_insurance_24m;
set dn_death_y_2bef;

*merge individual year variables into single variable;
buyin_24_l=trim(left(buyin12_l2))||trim(left(buyin12_l1))||trim(left(buyin_dy));
hmo_24_l=trim(left(hmoind12_l2))||trim(left(hmoind12_l1))||trim(left(hmo_dy));
buylength=length(buyin_24_l);
hlength=length(hmo_24_l);

*trim so merged variable is 24 char long to reflect months before death;
buyin_24_lr=reverse(trim(buyin_24_l));
hmo_24_lr=reverse(trim(hmo_24_l));

buyin_24r=substr(trim(left(buyin_24_lr)),1,24);
hmo_24r=substr(trim(left(hmo_24_lr)),1,24);

buyin_24=reverse(trim(buyin_24r));
hmo_24=reverse(trim(hmo_24r));

buylength2_24=length(buyin_24);
hlength2_24=length(hmo_24);

*create indicator variable for mc coverage 0=no, 1=yes;
if length(buyin_24)=24 then do;
if indexc(buyin_24,"0","1","2","A","B") then part_ab_2y=0;
if indexc(buyin_24,"0","1","2","A","B")=0 then part_ab_2y=1;
end;

*create indicator variable for hmo coverage 0=no, 1=yes;
if length(hmo_24)=24 then do;
if index(hmo_24,"000000000000000000000000") then hmo_2y=0;
if index(hmo_24,"000000000000000000000000")=0 then hmo_2y=1;
end;
run;

proc freq data=all_insurance_24m; table part_ab_2y*hmo_2y; run;

data all_insurance_60m;
set dn_death_y_5bef;

*merge individual year variables into single variable;
buyin_60_l=trim(left(buyin12_l5))||trim(left(buyin12_l4))||trim(left(buyin12_l3))||trim(left(buyin12_l2))||trim(left(buyin12_l1))||trim(left(buyin_dy));
hmo_60_l=trim(left(hmoind12_l5))||trim(left(hmoind12_l4))||trim(left(hmoind12_l3))||trim(left(hmoind12_l2))||trim(left(hmoind12_l1))||trim(left(hmo_dy));
buylength=length(buyin_60_l);
hlength=length(hmo_60_l);

*trim so merged variable is 24 or 60 char long to reflect months before death;
buyin_60_lr=reverse(trim(buyin_60_l));
hmo_60_lr=reverse(trim(hmo_60_l));

buyin_60r=substr(trim(left(buyin_60_lr)),1,60);
hmo_60r=substr(trim(left(hmo_60_lr)),1,60);

buyin_60=reverse(trim(buyin_60r));
hmo_60=reverse(trim(hmo_60r));

buylength2_60=length(buyin_60);
hlength2_60=length(hmo_60);


*create indicator variable for mc coverage 0=no, 1=yes;
if length(buyin_60)=60 then do;
if indexc(buyin_60,"0","1","2","A","B") then part_ab_5y=0;
if indexc(buyin_60,"0","1","2","A","B")=0 then part_ab_5y=1;
end;

*create indicator variable for hmo coverage 0=no, 1=yes;
if length(hmo_60)=60 then do;
if index(hmo_60,"000000000000000000000000000000000000000000000000000000000000") then hmo_5y=0;
if index(hmo_60,"000000000000000000000000000000000000000000000000000000000000")=0 then hmo_5y=1;
end;
run;

proc freq data=all_insurance_60m; table part_ab_5y*hmo_5y; run;

/*merge the 2 year and 5 year indicators into a single dataset
Save insurance information to merge with main interview dataset*/
proc sql;
create table oop_int.all_insurance as select
a.id,a.bid_hrs,a.death_year_e,a.death_date_e,a.part_ab_2y,a.hmo_2y,a.hmo_24,a.buyin_24,b.part_ab_5y,b.hmo_5y from
all_insurance_24m a left join
all_insurance_60m b
on a.id=b.id;
quit;


proc freq;
table death_year_e*hmo_2y death_year_e*hmo_5y;
run;

proc freq;
table death_year_e*part_ab_2y death_year_e*part_ab_5y;
run;

proc freq;
table part_ab_2y*hmo_2y part_ab_5y*hmo_5y;
run;


proc sql outobs=100;
select hmo_24,buyin_24,count(*) from oop_int.all_insurance
where  part_ab_2y=1 and hmo_2y=0;
quit;

proc means n;
var hmo_2y part_ab_2y hmo_5y part_ab_5y;
run;

/*3330 of the 4474 observations meet the mc parts a and b coverage and no hmo criteria
Save this as a permanent dataset*/
*create table of observations meeting mc and no hmo requirement;
/***********************************************************************/
/*Need to add the interview info into this table from the oop dataset
want to include nh_nights, curr_iw_date, prev_iw_date, months, md_cov private_ltc 
/***********************************************************************/
proc sql;
create table oop_int.meet_criteria_2yr as
select * from oop_int.all_insurance
where part_ab_2y=1 and hmo_2y=0;
quit;

/*get count of subsample that also meets 5 year criteria *1923, 57.7%*/
proc sql;
select count(distinct id) from oop_int.meet_criteria_2yr
where part_ab_5y=1 and hmo_5y=0;
quit;



H="Report on how to get final sample size"
/*report on how to get to final sample size
Requirements are:
1. age at death => 67
2. have xwalk id
3. have medicare parts a and b for 34 months prior to death
4. do not have hmo coverage for 34 months prior to death*/

ods rtf body ="E:\data\hrs_oop_2010\logs\oop_N_ids_eligible.rtf";
proc sql;
title "Number of decedents 2002-2010 exit interview dataset";
select count(*) from oop_int.exit_restricted_02_to_10_v1;

*age requirement;
title "meet age>=67";
select count(*) from oop_int.exit_restricted_02_to_10_v1
where age_at_death_e>=67;

*mc xwalk id requirement;
title "have the corresponding cross walk bid-hrsid";
select count(*) from oop_int.exit_restricted_02_to_10_v1 
where (xwalk_yes=1 and age_at_death_e>=67);

*death date Jan 1 2002 and later to get full 24 month mc claims information;
title "those who died on or after 01/01/2002 since the earliest available cms data is 2000";
select count(*) from dn_death_y 
where death_year_e>2001 ;

*have insurance information for last 24 months of life;
title "have dn information on last 24 months insurance ";
select count(*) from all_insurance;
title "those with hmo in the last 24 months";
select count(*) from all_insurance where hmo_2y=1 ;
title "those with no hmo without part a and part b in the whole last 24 months";
select count(*) from all_insurance where hmo_2y<1 and part_ab_2y<=0 ;

title "final N, 4474-986-158=3330";
select count(*) from oop_int.meet_criteria_2yr; 

title "number of N that also meet 5 year insurance criteria";
select count(*) from oop_int.meet_criteria_2yr
where hmo_5y=0 and part_ab_5y=1;
quit;

ods rtf close;


H="Merge meet criteria with oop, ivw dataset and save"

proc sort data=oop_int.hrs_oop_ivws out=oop_ivws nodupkey;
by id;
run;

proc sort data=oop_int.all_insurance out=meet nodupkey;
by id;
run;

/**********************************************************************/
/**********************************************************************/
/*Check this merge, drop some of the variables in the meet criteria dataset */
/**********************************************************************/
/**********************************************************************/

/*merge oop / HRS interview dataset with meet criteria variables*/
proc sql;
create table oop_fnl.hrs_oop_ivws_meet as select * from
oop_ivws a left join
meet(drop=death_year_e death_date_e bid_hrs) b
on a.id=b.id;
quit;

proc freq; table part_ab_2y*hmo_2y part_ab_5y*hmo_5y; run;

H="Elix, cc's 24m prior to death - part 1, get all dx codes"
/*******************************************************************/
/*******************************************************************/
/*First get dx codes across all claims for the 2 years before death*/
/*******************************************************************/
/*******************************************************************/

/*******************************************************************/
/*Step 1, get all claims 2 yrs prior to death*/
/*******************************************************************/

/*Macro for all claims except medpar
Run this twice to get two sets of files: xx_meet_###
xx = claim type
### days before death */
%macro other(days_start=,days_bef_death=,source=);

/*Identify claims within certain time from death date defined when run macro*/
proc sql;
create table &source._meet_&days_bef_death. as select a.*,b.death_date_e
from medi.&source._2000_2010 a inner join
oop_int.meet_criteria_2yr b
on trim(left(a.bid_hrs_19))=trim(left(b.bid_hrs))
and &days_start<=b.death_date_e-a.admit_date<=&days_bef_death;
quit;
run;

%mend;

/*Macro for medpar claims
Creates file mp_meet3_###
where ### = days before death */
%macro mp(days_start=,days_bef_death=,source=);
%let source0=mp;

/*Identify claims within certain time from death date*/
proc sql;
create table &source._meet_&days_bef_death. as select a.*,b.death_date_e
from medi.&source0._2000_2010 a inner join
oop_int.meet_criteria_2yr b
on trim(left(a.bid_hrs_19))=trim(left(b.bid_hrs)) 
and &days_start<=b.death_date_e-a.admit_date<=&days_bef_death ;
quit;

/*Identify claims that are partially within the time from death date*/
proc sql;
create table &source._meet2_&days_bef_death. as select a.*,b.death_date_e
from medi.&source0._2000_2010 a inner join
oop_int.meet_criteria_2yr b
on trim(left(a.bid_hrs_19))=trim(left(b.bid_hrs))
and b.death_date_e-a.admit_date>&days_bef_death and b.death_date_e-a.disch_date<=&days_bef_death;
quit;

data &source._meet3_&days_bef_death.;
set &source._meet_&days_bef_death &source._meet2_&days_bef_death;
run;

run;

%mend;

/*Run macros to identify claims that are within 2 years of the death date*/
%mp(days_start=0,days_bef_death=730,source=mp );
%other(days_start=0,days_bef_death=730,source=hh );
%other(days_start=0,days_bef_death=730,source=hs );
%other(days_start=0,days_bef_death=730,source=dm );
%other(days_start=0,days_bef_death=730,source=op );
%other(days_start=0,days_bef_death=730,source=pb );

/*******************************************************************/
/*Step 2, pull out dx codes*/
/*******************************************************************/
/* File created: dx_0_n24m: dx 2 years before dod

Saved in E:\data\oop_2010\int_data

One macro runs through all claim types to determine dx codes present

range1 = 0 - name for final output file
range2 = n24m - name for final output file
days_bef_death = 365*2 - identifies claims dataset to start with*/

%macro dx_time_range(range1=, range2=, days_bef_death=);

/*Process carrier medicare claims to pull out dx codes
Starts with pb_meet which is list of claims 24 months pre-death
Multiple lines per each BID*/
data pb_last_&range2._dx(keep=bid_hrs_19 diag);
set pb_meet_&days_bef_death.(keep=bid_hrs_19 PDGNS_CD DGNS_CD1-DGNS_CD12 );
array dx PDGNS_CD DGNS_CD1-DGNS_CD12;
do over dx;
diag=dx ;
output;
end;
run;
/*check for and remove duplicates, note this doesn't remove blanks*/
proc sort data=pb_last_&range2._dx out=pb_last_&range2._dx2 nodupkey;
by bid_hrs_19 diag;
run;

/*Process outpatient medicare claims to pull out dx codes
Dataset being created: op_last_&range2._dx2*/
data op_last_&range2._dx(keep=bid_hrs_19 diag);
set op_meet_&days_bef_death.(keep=bid_hrs_19 PDGNS_CD DGNSCD01-DGNSCD25  );
array dx PDGNS_CD DGNSCD01-DGNSCD25 ;
do over dx;
diag=dx ;
output;
end;
run;
proc sort data=op_last_&range2._dx out=op_last_&range2._dx2 nodupkey;
by bid_hrs_19 diag;
run;

/*Process medpar medicare claims to pull out dx codes
Dataset being created: mp_last_&range2._dx2*/
data mp_last_&range2._dx(keep=bid_hrs_19 diag);
set mp_meet3_&days_bef_death.(keep=bid_hrs_19 AD_DGNS DGNS_CD01-DGNS_CD25 );
array dx AD_DGNS DGNS_CD01-DGNS_CD25 ;
do over dx;
diag=dx ;
output;
end;
run;
proc sort data=mp_last_&range2._dx out=mp_last_&range2._dx2 nodupkey;
by bid_hrs_19 diag;
run;

/*Process dme medicare claims to pull out dx codes
Dataset being created: dm_last_&range2._dx2*/
data dm_last_&range2._dx(keep=bid_hrs_19 diag);
set dm_meet_&days_bef_death.(keep=bid_hrs_19 PDGNS_CD DGNS_CD1-DGNS_CD12 );
array dx PDGNS_CD DGNS_CD1-DGNS_CD12 ;
do over dx;
diag=dx ;
output;
end;
run;
proc sort data=dm_last_&range2._dx out=dm_last_&range2._dx2 nodupkey;
by bid_hrs_19 diag;
run;

/*Process hh medicare claims to pull out dx codes
Dataset being created: dm_last_&range2._dx2*/
data hh_last_&range2._dx(keep=bid_hrs_19 diag);
set hh_meet_&days_bef_death.(keep=bid_hrs_19 PDGNS_CD DGNSCD01-DGNSCD25 );
array dx PDGNS_CD DGNSCD01-DGNSCD25 ;
do over dx;
diag=dx ;
output;
end;
run;
proc sort data=hh_last_&range2._dx out=hh_last_&range2._dx2 nodupkey;
by bid_hrs_19 diag;
run;

/*Process hs medicare claims to pull out dx codes
Dataset being created: dm_last_&range2._dx2*/
data hs_last_&range2._dx(keep=bid_hrs_19 diag);
set hs_meet_&days_bef_death.(keep=bid_hrs_19 PDGNS_CD DGNSCD01-DGNSCD25 );
array dx PDGNS_CD DGNSCD01-DGNSCD25 ;
do over dx;
diag=dx ;
output;
end;
run;
proc sort data=hs_last_&range2._dx out=hs_last_&range2._dx2 nodupkey;
by bid_hrs_19 diag;
run;


/*set diag variable length = 7 chars since that's the max length from the mc claims
Need to do this because length varies across the different mc claim types*/
data hs_last_&range2._dx3;
length diag $7;
set hs_last_&range2._dx2;
run;
data hh_last_&range2._dx3;
length diag $7;
set hh_last_&range2._dx2;
run;
data mp_last_&range2._dx3;
length diag $7;
set mp_last_&range2._dx2;
run;
data dm_last_&range2._dx3;
length diag $7;
set dm_last_&range2._dx2;
run;
data op_last_&range2._dx3;
length diag $7;
set op_last_&range2._dx2;
run;
data pb_last_&range2._dx3;
length diag $7;
set pb_last_&range2._dx2;
run;


/*merge diagnoses from each claim type into single dataset*/
data dx_all_last_&range2.;
set hs_last_&range2._dx3
hh_last_&range2._dx3
mp_last_&range2._dx3
dm_last_&range2._dx3
op_last_&range2._dx3
pb_last_&range2._dx3;
run;
proc sort data=dx_all_last_&range2.(where=(diag~="")) out=oop_int.dx_&range1._&range2 nodupkey;
by bid_hrs_19 diag;
run;

%mend;


/*run the macro - 24 months pre-death - get sas dataset oop_int.dx_0d_n24m*/
%dx_time_range(range1=0d, range2=n24m, days_bef_death=730);

proc sql;
select count(*) from oop_int.dx_0d_n24m where bid_hrs_19='.';
quit;


H="Elix, etc. - part 2, create elix indicators"
/*Elixhauser index created, added to interview, OOP dataset

oop_fin.hrs_oop_ivws_meet_el_n24m

CAD defined with ICD-9 codes as defined by CMS here:
http://www.mdinteractive.com/files/uploaded/file/cms2013group/CAD_2013_CMS.pdf
*/

/*    Macro rename 
lib=library
dsn=dataset name
pre=suffix to be added to all of the variable names
*/


%macro rename(lib,dsn,pre);
options pageno=1 nodate;
proc contents data=&lib..&dsn;
title "Before Renaming All Variables";
run;

proc sql noprint;
select nvar into :num_vars
from dictionary.tables
where libname="&LIB" and
memname="&DSN";
select distinct(name) into :var1-
:var%TRIM(%LEFT(&num_vars))
from dictionary.columns
where libname="&LIB" and
memname="&DSN";
quit;
run;

proc datasets library=&LIB;
modify &DSN;
rename
%do i=1 %to &num_vars;
&&var&i=&&var&i.._&pre 
%end;
;
quit;
run;
options pageno=1 nodate;
proc contents data=&lib..&dsn;
title "After Renaming All Variables";
run;
%mend rename;


/*Elixhauser index macro
Note includes additional 2 comorbidities: Dementia and Coronary Artery Disease*/

%macro elixhauser(range1=, range2=);

data dx_31_comor_&range2;
set oop_int.dx_&range1._&range2.(rename=(diag=dx_0));
dx=trim(left(dx_0));

if dx~="" then do;

comorbi_1=0;
comorbi_2=0;
comorbi_3=0;
comorbi_4=0;
comorbi_5=0;
comorbi_6=0;
comorbi_7=0;
comorbi_8=0;
comorbi_9=0;
comorbi_10=0;
comorbi_11=0;
comorbi_12=0;
comorbi_13=0;
comorbi_14=0;
comorbi_15=0;
comorbi_16=0;
comorbi_17=0;
comorbi_18=0;
comorbi_19=0;
comorbi_20=0;
comorbi_21=0;
comorbi_22=0;
comorbi_23=0;
comorbi_24=0;
comorbi_25=0;
comorbi_26=0;
comorbi_27=0;
comorbi_28=0;
comorbi_29=0;
comorbi_30=0;
*end of intialize of 30 binary variables;
*add dementia and CAD;
dementia=0;
cad=0;

*do over dx;
	*Congestive Heart Failure;
	if (substr(dx,1,5)='39891' or
		substr(dx,1,5)='40211' or
		substr(dx,1,5)='40291' or
		substr(dx,1,5)='40411' or
		substr(dx,1,5)='40413' or
		substr(dx,1,5)='40491' or
		substr(dx,1,5)='40493' or
		substr(dx,1,3)='428') 
		and comorbi_1=0 
		then comorbi_1=1;*add one binary variables here.;
	*Cardiac Arrhythmias;
	if (substr(dx,1,5)='42610' or
		substr(dx,1,5)='42611' or
		substr(dx,1,5)='42613' or
		substr(dx,1,4)='4262' or
		substr(dx,1,4)='4263' or
		substr(dx,1,4)='4264' or
		substr(dx,1,5)='42650' or
		substr(dx,1,5)='42651' or
		substr(dx,1,5)='42652' or
		substr(dx,1,5)='42653' or
		substr(dx,1,4)='4266' or
		substr(dx,1,4)='4267' or
		substr(dx,1,4)='4268' or
		substr(dx,1,4)='4270' or
		substr(dx,1,4)='4272' or
		substr(dx,1,5)='42731' or
		substr(dx,1,5)='42760' or
		substr(dx,1,4)='4279' or
		substr(dx,1,4)='7850' or
		substr(dx,1,4)='V450' or
		substr(dx,1,4)='V533')
			and comorbi_2=0 
		then comorbi_2=1;
	* Valvular Disease ;
	if (substr(dx,1,5)='09320' or
		substr(dx,1,5)='09321' or
		substr(dx,1,5)='09322' or
		substr(dx,1,5)='09323' or
		substr(dx,1,5)='09324' or
		substr(dx,1,3)='394' or
		substr(dx,1,3)='395' or
		substr(dx,1,3)='396' or
		substr(dx,1,4)='3970' or
		substr(dx,1,4)='3971' or
		substr(dx,1,4)='4240' or
		substr(dx,1,4)='4241' or
		substr(dx,1,4)='4242' or
		substr(dx,1,4)='4243' or
		substr(dx,1,4)='4244' or
		substr(dx,1,4)='4245' or
		substr(dx,1,4)='4246' or
		substr(dx,1,4)='4247' or
		substr(dx,1,4)='4248' or
		substr(dx,1,5)='42490' or
		substr(dx,1,5)='42491' or
		substr(dx,1,4)='7463' or
		substr(dx,1,4)='7464' or
		substr(dx,1,4)='7465' or
		substr(dx,1,4)='7466' or
		substr(dx,1,4)='V422' or
		substr(dx,1,5)='V433')
			and comorbi_3=0 
		then comorbi_3=1;
	*Pulmonary Circulation Disorders;
	if (substr(dx,1,3)='416' or
		substr(dx,1,4)='4179')
			and comorbi_4=0 
		then comorbi_4=1;
	*Peripheral Vascular Disorders;
	if (substr(dx,1,3)='440' or
		substr(dx,1,4)='4412' or
		substr(dx,1,4)='4414' or
		substr(dx,1,4)='4417' or
		substr(dx,1,4)='4419' or
		substr(dx,1,4)='4431' or
		substr(dx,1,4)='4432' or
		substr(dx,1,4)='4438' or
		substr(dx,1,4)='4439' or
		substr(dx,1,4)='4471' or
		substr(dx,1,4)='5571' or
		substr(dx,1,4)='5579' or
		substr(dx,1,4)='V434')
			and comorbi_5=0 
		then comorbi_5=1;
	*Hypertension;
	if ((substr(dx,1,4)='4011' or
		substr(dx,1,4)='4019')) or
	   ((substr(dx,1,5)='40210' or
		substr(dx,1,5)='40290' or
		substr(dx,1,5)='40410' or
		substr(dx,1,5)='40490' or
		substr(dx,1,5)='40511' or
		substr(dx,1,5)='40519' or
		substr(dx,1,5)='40591' or
		substr(dx,1,5)='40599')) 
			and comorbi_6=0 
		then comorbi_6=1;
	*Paralysis;	
	if (substr(dx,1,4)='3420' or
		substr(dx,1,5)='34210' or
		substr(dx,1,5)='34211' or
		substr(dx,1,5)='34212' or
		substr(dx,1,4)='3429' or
		substr(dx,1,3)='343' or
		substr(dx,1,3)='344')
			and comorbi_7=0 
		then comorbi_7=1;
	*Other Neurological Disorders;
	if (substr(dx,1,4)='3319' or
		substr(dx,1,4)='3320' or
		substr(dx,1,4)='3334' or
		substr(dx,1,4)='3335' or
		substr(dx,1,3)='334' or
		substr(dx,1,3)='335' or
		substr(dx,1,3)='340' or
		substr(dx,1,4)='3411' or
		substr(dx,1,4)='3418' or
		substr(dx,1,4)='3419' or
		substr(dx,1,5)='34500' or
		substr(dx,1,5)='34501' or
		substr(dx,1,5)='34510' or
		substr(dx,1,5)='34511' or
		substr(dx,1,4)='3454' or
		substr(dx,1,5)='34550' or
		substr(dx,1,5)='34551' or
		substr(dx,1,4)='3458' or
		substr(dx,1,5)='34590' or
		substr(dx,1,5)='34591' or
		substr(dx,1,4)='3481' or
		substr(dx,1,4)='3483' or
		substr(dx,1,4)='7803' or
		substr(dx,1,4)='7843') 
			and comorbi_8=0 
		then comorbi_8=1;	
	*Chronic Pulmonary Disease;
	if (substr(dx,1,3)='490' or
		substr(dx,1,3)='491' or
		substr(dx,1,3)='492' or
		substr(dx,1,4)='4930' or
		substr(dx,1,4)='4931' or
		substr(dx,1,4)='4932' or
		substr(dx,1,4)='4938' or
		substr(dx,1,5)='49390' or
		substr(dx,1,5)='49391' or
		substr(dx,1,3)='494' or
		substr(dx,1,3)='495' or
		substr(dx,1,3)='496' or
		substr(dx,1,3)='497' or
		substr(dx,1,3)='498' or
		substr(dx,1,3)='499' or
		substr(dx,1,3)='500' or
		substr(dx,1,3)='501' or
		substr(dx,1,3)='502' or
		substr(dx,1,3)='503' or
		substr(dx,1,3)='504' or
		substr(dx,1,3)='505' or
		substr(dx,1,4)='5064') 
			and comorbi_9=0 
		then comorbi_9=1;	
	*Diabetes, uncomplicated;
	if (substr(dx,1,4)='2500' or
		substr(dx,1,4)='2501' or
		substr(dx,1,4)='2502' or
		substr(dx,1,4)='2503') 
			and comorbi_10=0 
		then comorbi_10=1;
	*Diabetes, complicated;
	if (substr(dx,1,4)='2504' or
		substr(dx,1,4)='2505' or
		substr(dx,1,4)='2506' or
		substr(dx,1,4)='2507' or
		substr(dx,1,4)='2509') 
			and comorbi_11=0 
		then comorbi_11=1;
	*Hypothyroidism;
	if (substr(dx,1,3)='243' or
		substr(dx,1,4)='2440' or
		substr(dx,1,4)='2441' or
		substr(dx,1,4)='2442' or
		substr(dx,1,4)='2448' or
		substr(dx,1,4)='2449') 	
			and comorbi_12=0 
		then comorbi_12=1;
	*Renal Failure;
	if (substr(dx,1,5)='40311' or
		substr(dx,1,5)='40391' or
		substr(dx,1,5)='40412' or
		substr(dx,1,5)='40492' or
		substr(dx,1,3)='585' or
		substr(dx,1,3)='586' or
		substr(dx,1,4)='V420' or
		substr(dx,1,4)='V451' or
		substr(dx,1,4)='V560' or
		substr(dx,1,4)='V568') 
			and comorbi_13=0 
		then comorbi_13=1;
	*Liver Disease;
	if (substr(dx,1,5)='07032' or
		substr(dx,1,5)='07033' or
		substr(dx,1,5)='07054' or
		substr(dx,1,4)='4560' or
		substr(dx,1,4)='4561' or
		substr(dx,1,5)='45620' or
		substr(dx,1,5)='45621' or
		substr(dx,1,4)='5710' or
		substr(dx,1,4)='5712' or
		substr(dx,1,4)='5713' or
		substr(dx,1,4)='5714' or
		substr(dx,1,4)='5715' or
		substr(dx,1,4)='5716' or
		substr(dx,1,4)='5718' or
		substr(dx,1,4)='5719' or
		substr(dx,1,4)='5723' or
		substr(dx,1,4)='5728' or
		substr(dx,1,4)='V427') 
			and comorbi_14=0 
		then comorbi_14=1;
	*Peptic Ulcer Disease excluding bleeding;
	if (substr(dx,1,5)='53170' or
		substr(dx,1,5)='53190' or
		substr(dx,1,5)='53270' or
		substr(dx,1,5)='53290' or
		substr(dx,1,5)='53370' or
		substr(dx,1,5)='53390' or
		substr(dx,1,5)='53470' or
		substr(dx,1,5)='53490' or
		substr(dx,1,5)='V1271') 
			and comorbi_15=0 
		then comorbi_15=1;
	*AIDS;
	if (substr(dx,1,3)='042' or
		substr(dx,1,3)='043' or
		substr(dx,1,3)='044') 
			and comorbi_16=0 
		then comorbi_16=1;
	*Lymphoma;
	if (substr(dx,1,3)='200' or
		substr(dx,1,4)='201' or
		substr(dx,1,4)='2020' or
		substr(dx,1,4)='2021' or
		substr(dx,1,4)='2022' or
		substr(dx,1,4)='2023' or
		substr(dx,1,4)='2025' or
		substr(dx,1,4)='2026' or
		substr(dx,1,4)='2027' or
		substr(dx,1,4)='2028' or
		substr(dx,1,4)='2029' or
		substr(dx,1,4)='2030' or
		substr(dx,1,4)='2038' or
		substr(dx,1,4)='2386' or
		substr(dx,1,4)='2733' or
		substr(dx,1,4)='V1071' or
		substr(dx,1,4)='V1072' or
		substr(dx,1,4)='V1079')
			and comorbi_17=0 
		then comorbi_17=1;
	*Metastatic Cancer;
	if (substr(dx,1,3)='196' or
		substr(dx,1,3)='197' or
		substr(dx,1,3)='198' or
		substr(dx,1,4)='199') 
			and comorbi_18=0 
		then comorbi_18=1;	
	*Solid Tumor without Metastisis;
	if (substr(dx,1,2)='14' or
		substr(dx,1,2)='15' or
		substr(dx,1,2)='16' or
		substr(dx,1,3)='170' or
		substr(dx,1,3)='171' or
		substr(dx,1,3)='172' or
		substr(dx,1,3)='174' or
		substr(dx,1,3)='175' or
		substr(dx,1,3)='179' or
		substr(dx,1,2)='18' or
		substr(dx,1,3)='190' or
		substr(dx,1,3)='191' or
		substr(dx,1,3)='192' or
		substr(dx,1,3)='193' or
		substr(dx,1,3)='194' or
		substr(dx,1,3)='195' or
		substr(dx,1,3)='V10')
			and comorbi_19=0 
		then comorbi_19=1;
	*Rheumatoid Arthritis/Collagen Vascular Diseases;
	if (substr(dx,1,4)='7010' or
		substr(dx,1,3)='710' or
		substr(dx,1,3)='714' or
		substr(dx,1,3)='720' or
		substr(dx,1,3)='725') 
			and comorbi_20=0 
		then comorbi_20=1;
	*Coagulopathy;
	if (substr(dx,1,3)='286' or
		substr(dx,1,4)='2871' or
		substr(dx,1,4)='2873' or
		substr(dx,1,4)='2874' or
		substr(dx,1,4)='2875') 
			and comorbi_21=0 
		then comorbi_21=1;
	*Obesity;
	if (substr(dx,1,4)='2780')  
			and comorbi_22=0 
		then comorbi_22=1;
	*Weight Loss;
	if (substr(dx,1,3)='260' or
		substr(dx,1,3)='261' or
		substr(dx,1,3)='262' or
		substr(dx,1,3)='263') 
			and comorbi_23=0 
		then comorbi_23=1;	
	*Fluid and Electrolyte Disorders;
	if (substr(dx,1,3)='276') 
			and comorbi_24=0 
		then comorbi_24=1;
	*Blood Loss Anemia;
	if (substr(dx,1,4)='2800') 
			and comorbi_25=0 
		then comorbi_25=1;
	*Deficiency Anemias;
	if (substr(dx,1,4)='2801' or
		substr(dx,1,4)='2808' or
		substr(dx,1,4)='2809' or
		substr(dx,1,4)='2859') 
			and comorbi_26=0 
		then comorbi_26=1;
	*Alcohol Abuse;
	if (substr(dx,1,4)='2911' or
		substr(dx,1,4)='2912' or
		substr(dx,1,4)='2915' or
		substr(dx,1,4)='2918' or
		substr(dx,1,4)='2919' or
		substr(dx,1,4)='3039' or
		substr(dx,1,4)='3050' or
		substr(dx,1,4)='V113') 
			and comorbi_27=0 
		then comorbi_27=1;
	*Drug Abuse;
	if (substr(dx,1,4)='2920' or
		substr(dx,1,5)='29282' or
		substr(dx,1,5)='29283' or
		substr(dx,1,5)='29284' or
		substr(dx,1,5)='29289' or
		substr(dx,1,4)='2929' or
		substr(dx,1,3)='304' or
		substr(dx,1,4)='3052' or
		substr(dx,1,4)='3053' or
		substr(dx,1,4)='3054' or
		substr(dx,1,4)='3055' or
		substr(dx,1,4)='3056' or
		substr(dx,1,4)='3057' or
		substr(dx,1,4)='3058' or
		substr(dx,1,4)='3059')
			and comorbi_28=0 
		then comorbi_28=1;	
	*Psychoses;
	if (substr(dx,1,3)='295' or
		substr(dx,1,3)='296' or
		substr(dx,1,3)='297' or
		substr(dx,1,3)='298' or
		substr(dx,1,4)='2991') 
			and comorbi_29=0 
		then comorbi_29=1;
	*Depression;
	if (substr(dx,1,4)='3004' or
		substr(dx,1,5)='30112' or
		substr(dx,1,4)='3090' or
		substr(dx,1,4)='3091' or
		substr(dx,1,3)='311')
			and comorbi_30=0 
		then comorbi_30=1;


	*Dementia;
	if (substr(dx,1,4) in ('3310','3311','3312','2900','2901',
             '2902','2903','2912','2948','2949') or
		substr(dx,1,5) in ('29410','29411','29040','29041','29042','29043')) 
		and dementia=0 
          then dementia=1;

	*CAD coronary artery disease;
	if (substr(dx,1,4) in ('4140','4142','4143','4148','4149') or 
		substr(dx,1,3) in ('410','411','412','413') or
		substr(dx,1,5) in ('V4581','V4582'))
		and cad=0 
          then cad=1;

/* CAD list
410.00-410.92
411.0-411.89
412
413.0-413.9
414.00-414.07
414.2
414.3
414.8
414.9
V45.81
V45.82 */

end;
run;


/*check sums of each comorbidity for each ID*/
proc sql;
create table com_test1_&range2 as
select distinct BID_hrs_19,
sum(comorbi_1) as com_1,
sum(comorbi_2) as com_2,
sum(comorbi_3) as com_3,
sum(comorbi_4) as com_4,
sum(comorbi_5) as com_5,
sum(comorbi_6) as com_6,
sum(comorbi_7) as com_7,
sum(comorbi_8) as com_8,
sum(comorbi_9) as com_9,
sum(comorbi_10) as com_10,
sum(comorbi_11) as com_11,
sum(comorbi_12) as com_12,
sum(comorbi_13) as com_13,
sum(comorbi_14) as com_14,
sum(comorbi_15) as com_15,
sum(comorbi_16) as com_16,
sum(comorbi_17) as com_17,
sum(comorbi_18) as com_18,
sum(comorbi_19) as com_19,
sum(comorbi_20) as com_20,
sum(comorbi_21) as com_21,
sum(comorbi_22) as com_22,
sum(comorbi_23) as com_23,
sum(comorbi_24) as com_24,
sum(comorbi_25) as com_25,
sum(comorbi_26) as com_26,
sum(comorbi_27) as com_27,
sum(comorbi_28) as com_28,
sum(comorbi_29) as com_29,
sum(comorbi_30) as com_30,
sum(dementia) as com_31,
sum(cad) as com_32
from dx_31_comor_&range2
group by BID_hrs_19;
quit;

/*define comorbidities as binary indicators*/
data comorbidity_&range2.(keep=BID_hrs_19 comorb_1-comorb_32 comorb_all);
set com_test1_&range2;
array list_com com_1-com_30 com_31 com_32;
array list_com_bin comorb_1-comorb_30 comorb_31 comorb_32;

/*note this defines comorbidity 31 = dementia & 32 = cad*/
do over list_com;
  list_com_bin=0;

  if list_com>0 then do;
    list_com_bin=1;
   end;

end;


/*define aggregate comorbidity as sum of 31 individual indicator vars.
note: CAD not included in this aggregate score*/
comorb_all=comorb_1+comorb_2+comorb_3+comorb_4+comorb_5+comorb_6+comorb_7+
comorb_8+comorb_9+comorb_10+comorb_11+comorb_12+comorb_13+comorb_14+
comorb_15+comorb_16+comorb_17+comorb_18+comorb_19+comorb_20+comorb_21+
comorb_22+comorb_23+comorb_24+comorb_25+comorb_26+comorb_27+comorb_28+
comorb_29+comorb_30+comorb_31;
run;


proc sort data=comorbidity_&range2. nodupkey;
by BID_hrs_19;
run;

proc sort data=oop_int.meet_criteria_2yr out=meettomerge nodupkey;
by bid_hrs;
run;

/*merges with decedent dataset that has mc ffs 2 years pre-death by id
Note if this has to be run on a different dataset (another time period for example
need to rewrite this system since the file name suffixes aren't consistent!*/
proc sql;
create table ids_meet_criteria_&range2.13(drop bid_hrs_19) as
select *
from meettomerge
a left join
comorbidity_&range2. b
on a.BID_hrs=b.BID_hrs_19;
quit;

/*if comorbidity=null, set to zero*/
data oop_int.elix_&range1._&range2;
set ids_meet_criteria_&range2.13;
array list comorb_1-comorb_32 comorb_all;
do over list;
if list=. then list=0;
end;

label comorb_1 ="Congestive Heart Failure";
label comorb_2 ="Cardiac Arrhythmias";
label comorb_3 ="Valvular Disease";
label comorb_4 ="Pulmonary Circulation Disorders";
label comorb_5 ="Peripheral Vascular Disorders";
label comorb_6 ="Hypertension";
label comorb_7 ="Paralysis";
label comorb_8 ="Other Neurological Disorders";
label comorb_9 ="Chronic Pulmonary Disease";
label comorb_10 ="Diabetes, uncomplicated";
label comorb_11 ="Diabetes, complicated";
label comorb_12 ="Hypothyroidism";
label comorb_13 ="Renal Failure";
label comorb_14 ="Liver Disease";
label comorb_15 ="Peptic Ulcer Disease excluding bleeding";
label comorb_16 ="AIDS";
label comorb_17 ="Lymphoma";
label comorb_18 ="Metastatic Cancer";
label comorb_19 ="Solid Tumor without Metastisis";
label comorb_20 ="Rheumatoid Arthritis/Collagen Vascular Diseases";
label comorb_21 ="Coagulopathy";
label comorb_22 ="Obesity";
label comorb_23 ="Weight Loss";
label comorb_24 ="Fluid and Electrolyte Disorders";
label comorb_25 ="Blood Loss Anemia";
label comorb_26 ="Deficiency Anemias";
label comorb_27 ="Alcohol Abuse";
label comorb_28 ="Drug Abuse";
label comorb_29 ="Psychoses";
label comorb_30 ="Depression";
label comorb_31 ="Dementia";
label comorb_32 ="Coronary Artery Disease";
run;


data test;
set oop_int.elix_&range1._&range2;
run;

/*calls rename macro*/
%rename(WORK,TEST,&range1._&range2);

/*rename bid_hrs_&range1._&range2=bid_hrs*/
data oop_int.elix_&range1._&range2._2(rename =(bid_hrs_&range1._&range2=bid_hrs));
set test;
keep bid_hrs_&range1._&range2 comorb:;
run;
proc sort data=oop_int.elix_&range1._&range2._2;
by bid_hrs;
run;

%mend;


/*run macro to get elixhauser comorbidities 24 months pre-death*/
%elixhauser(range1=0d, range2=n24m);

proc freq;
table comorb:;
run;

/*make sure no obs have missing bid field*/
data bid_miss_test;
 set oop_int.elix_0d_n24m_2;
 if bid_hrs = '';
run;


proc contents data=oop_int.elix_0d_n24m_2;
run;


/* merge interview+OOP dataset and elixhauser comorbidities 
Resulting file is:
oop_fin.surgery_ids_last_n24m 
Comorbidites are missing if don't have ffs mc 2 years prior to death*/ 

%macro mergeel(range2=);

proc sort data=oop_fnl.hrs_oop_ivws_meet out=full_merge;
by BID_hrs;
run;

proc sort data=oop_int.elix_0d_&range2._2 out=el_merge_&range2. nodupkey;
by BID_hrs;
run;

proc sql;
create table oop_fnl.hrs_oop_ivws_meet_el_&range2 as select * from 
full_merge a left join
el_merge_&range2. b
on trim(left(a.BID_hrs))=trim(left(b.BID_hrs));
quit;
%mend;

%mergeel(range2=n24m);

proc freq data=oop_fnl.hrs_oop_ivws_meet_el_n24m;
table comorb:;
run;




H="Elix, etc. - part 3, create cc indicators"
/*begin of chronic 21 conditions.

Note this pulls from a list of icd-9 codes associated with each of the chronic
conditions. The file path may need to be updated depending on the PC the
code is run from
*/

/*export list of diagnosis codes to stata*/

proc export data=oop_int.dx_0d_n24m
outfile="E:\data\hrs_oop_2010\int_data\dx_0d_n24m.dta" replace;
run;

/*******************************************************************/
/*put the sas data to stata in to dot format
This is STATA code*/
/*
/*******************************************************************/

clear
set memory 500m

//process diagnosis codes 24 months pre-surgery
use "E:\data\hrs_oop_2010\int_data\dx_0d_n24m.dta",clear

// convert diagnosis codes to string variables, tostring diag,gen(icd9_c)
gen new=ltrim(diag)
icd9 check new,gen(icd9_c)
replace new="" if icd9_c>0 
// convert into dot format (ex 12.1 instead of 121)
icd9 clean new,dots 

replace diag=new
drop icd9_c new

save "E:\data\hrs_oop_2010\int_data\dx_0d_n24m_2.dta",replace


/*******************************************************************/
//Convert back to SAS
//This is SAS Code
/* to the cms 21 chronic comorbidity*/ 
/*******************************************************************/

/*bring in formatted Stata dataset of dx codes*/
proc import 
datafile="E:\data\hrs_oop_2010\int_data\dx_0d_n24m_2.dta" 
out=dx_0d_n24m_2 replace;
run;


/*bring in excel list of dx codes associated with each chronic condition*/
proc import /*datafile="C:\projects\Hospice_impact_on_utilization\raw_data\chronic_21_condition_icd9.xls" */
datafile='E:\data\hrs_oop_2010\ref_data\chronic_21_condition_icd9.xls'
out=icd9_21_chronic dbms=xls replace;
run;

proc contents data=icd9_21_chronic;
run;

/*creates macro variables of each of the chronic conditions listing of dx codes*/
proc sql;
select icd_9 into :chronic_desc1-:chronic_desc21 from icd9_21_chronic;
quit;
%put &chronic_desc10;
%put &chronic_desc5;

/*******************************************************************/
/*Generate chronic conditions indicator variables using dx
codes 24 months pre-death */
/*******************************************************************/

/*macro to create indicator variables for 21 chronic conditions
predeath = n24m  */

%macro cc(predeath=);

/*initialize the chronic conditions variables*/
data list_&predeath._dx;
set dx_0d_&predeath._2;
array list CC_1_AMI
CC_2_ALZH
CC_3_ALZHDMTA
CC_4_ATRIALFB
CC_5_CATARACT
CC_6_CHRNKIDN
CC_7_COPD
CC_8_CHF
CC_9_DIABETES
CC_10_GLAUCOMA
CC_11_HIPFRAC
CC_12_ISCHMCHT
CC_13_DEPRESSN
CC_14_OSTEOPRS
CC_15_RA_OA
CC_16_STRKETIA
CC_17_CNCRBRST
CC_18_CNCRCLRC
CC_19_CNCRPRST
CC_20_CNCRLUNG
CC_21_CNCREndM
;
do over list ;
list=0;
end;

diag_string=diag;

/* for dx codes that begin with numbers, process chronic cond variables*/
if anydigit(substr(trim(left(diag_string)),1,1))=1 then do;
diag=diag_string+0;

if diag in (&chronic_desc1) then CC_1_AMI=1;
if diag in (&chronic_desc2)  then CC_2_ALZH=1;
if diag in (&chronic_desc3)  then CC_3_ALZHDMTA=1;
if diag in (&chronic_desc4) then CC_4_ATRIALFB=1;
if diag in (&chronic_desc5) then CC_5_CATARACT=1;
if diag in (&chronic_desc6) then CC_6_CHRNKIDN=1;
if diag in (&chronic_desc7) then CC_7_COPD=1;
if diag in (&chronic_desc8) then CC_8_CHF=1;
if diag in (&chronic_desc9) then CC_9_DIABETES=1;
if diag in (&chronic_desc10) then CC_10_GLAUCOMA=1;
if diag in (&chronic_desc11) then CC_11_HIPFRAC=1;
if diag in (&chronic_desc12) then CC_12_ISCHMCHT=1;
if diag in (&chronic_desc13) then CC_13_DEPRESSN=1;
if diag in (&chronic_desc14) then CC_14_OSTEOPRS=1;
if diag in (&chronic_desc15) then CC_15_RA_OA=1;
if diag in (&chronic_desc16) then CC_16_STRKETIA=1;
if diag in (&chronic_desc17) then CC_17_CNCRBRST=1;
if diag in (&chronic_desc18) then CC_18_CNCRCLRC=1;
if diag in (&chronic_desc19) then CC_19_CNCRPRST=1;
if diag in (&chronic_desc20) then CC_20_CNCRLUNG=1;
if diag in (&chronic_desc21) then CC_21_CNCREndM=1;
end;

/*deal with dx codes that start with letters
Only two of them in the list we have to worry about*/
if anydigit(substr(trim(left(diag_string)),1,1))=0 then do;
if trim(left(diag_string)) in ("V431") then CC_5_CATARACT=1;
if trim(left(diag_string)) in ("V801") then CC_10_GLAUCOMA=1;
end;

run;

/*aggregate all chronic condition variables by bid*/
proc sql;
create table bid_dx_0_&predeath.(rename=(bid_hrs_19=bid)) as
select distinct bid_hrs_19,
sum(CC_1_AMI) as CC_1_AMI,
sum(CC_2_ALZH) as CC_2_ALZH,
sum(CC_3_ALZHDMTA) as CC_3_ALZHDMTA,
sum(CC_4_ATRIALFB) as CC_4_ATRIALFB,
sum(CC_5_CATARACT) as CC_5_CATARACT,
sum(CC_6_CHRNKIDN) as CC_6_CHRNKIDN,
sum(CC_7_COPD) as CC_7_COPD,
sum(CC_8_CHF) as CC_8_CHF,
sum(CC_9_DIABETES) as CC_9_DIABETES,
sum(CC_10_GLAUCOMA) as CC_10_GLAUCOMA,
sum(CC_11_HIPFRAC) as CC_11_HIPFRAC,
sum(CC_12_ISCHMCHT) as CC_12_ISCHMCHT,
sum(CC_13_DEPRESSN) as CC_13_DEPRESSN,
sum(CC_14_OSTEOPRS) as CC_14_OSTEOPRS,
sum(CC_15_RA_OA) as CC_15_RA_OA,
sum(CC_16_STRKETIA) as CC_16_STRKETIA,
sum(CC_17_CNCRBRST) as CC_17_CNCRBRST,
sum(CC_18_CNCRCLRC) as CC_18_CNCRCLRC,
sum(CC_19_CNCRPRST) as CC_19_CNCRPRST,
sum(CC_20_CNCRLUNG) as CC_20_CNCRLUNG,
sum(CC_21_CNCREndM) as CC_21_CNCREndM

from list_&predeath._dx group by bid_hrs_19;
quit;

/*merge chronic conditions decedent list bid's by bid
This is now a list of those bids with ffs mc last 2 years of life only*/
proc sort data=bid_dx_0_&predeath. nodupkey;
by BID;
run;

proc sort data=oop_int.meet_criteria_2yr out=meettomerge nodupkey;
by bid_hrs;
run;

 proc sql;
 create table bid_dx_0_&predeath.2(drop=bid) as select a.bid_hrs,b.*
 from meettomerge a
 left join
  bid_dx_0_&predeath. b 
 on trim(left(a.bid_hrs))=trim(left(b.bid));
 quit;

/*convert to chronic condition vars. to binary variables*/
 data bid_dx_0_&predeath.3;
 set bid_dx_0_&predeath.2;
 array list CC_1_AMI
CC_2_ALZH
CC_3_ALZHDMTA
CC_4_ATRIALFB
CC_5_CATARACT
CC_6_CHRNKIDN
CC_7_COPD
CC_8_CHF
CC_9_DIABETES
CC_10_GLAUCOMA
CC_11_HIPFRAC
CC_12_ISCHMCHT
CC_13_DEPRESSN
CC_14_OSTEOPRS
CC_15_RA_OA
CC_16_STRKETIA
CC_17_CNCRBRST
CC_18_CNCRCLRC
CC_19_CNCRPRST
CC_20_CNCRLUNG
CC_21_CNCREndM
;
do over list ;
if list>0 then list=1;
if list<=0 then list=0;
end;

/*create aggregated indicators*/
CC_AMI_isch=CC_1_AMI|CC_12_ISCHMCHT;
CC_alzheim=CC_2_ALZH|CC_3_ALZHDMTA;
CC_cncr_chronic=CC_17_CNCRBRST | CC_18_CNCRCLRC | CC_19_CNCRPRST | CC_20_CNCRLUNG | 
	CC_21_CNCREndM ;
run;


proc means;
var CC_1_AMI
CC_2_ALZH
CC_3_ALZHDMTA
CC_4_ATRIALFB
CC_5_CATARACT
CC_6_CHRNKIDN
CC_7_COPD
CC_8_CHF
CC_9_DIABETES
CC_10_GLAUCOMA
CC_11_HIPFRAC
CC_12_ISCHMCHT
CC_13_DEPRESSN
CC_14_OSTEOPRS
CC_15_RA_OA
CC_16_STRKETIA
CC_17_CNCRBRST
CC_18_CNCRCLRC
CC_19_CNCRPRST
CC_20_CNCRLUNG
CC_21_CNCREndM;
run;

%mend;

%cc(predeath=n24m);

/*so resulting datastet is bid_dx_0_n24m3 */

/************************************************************/
/*rename the 12 month pre-surgery chronic condition vars*/
/************************************************************/

/*creates dataset to use in the rename macro below*/
data test;
set bid_dx_0_n24m3;
run;

/*rename macro to add _n24mn0 suffix to the chronic conditions variable names
Data file is still work.test but variables renamed after running this macro*/
%rename(WORK,TEST,n24mn0);

/*Changes name of bid_hrs variable so no _n24mn0*/
data oop_int.chronic_21_n24m_n0_0;
set test;
bid_hrs=bid_hrs_n24mn0;
drop bid_hrs_n24mn0;
run;

proc freq data=oop_int.chronic_21_n24m_n0_0;
table cc: ;
run;
proc contents;
run;

/***************************************************************************/
/* merging chronic conditions variables with the main data file
that also contains the Elixhauser comorbidities */
/***************************************************************************/

%macro mergecc(predeath=);

proc sql;
create table oop_fnl.hrs_oop_ivws_meet_el_cc_&predeath(drop=bid_hrs2)
as select * from
oop_fnl.hrs_oop_ivws_meet_el_&predeath. a
left join
oop_int.chronic_21_&predeath._n0_0(rename=(bid_hrs=bid_hrs2)) b 
on (a.bid_hrs)=(b.bid_hrs2);
quit;

%mend;

%mergecc(predeath=n24m);

/* the above file contains decedents oop and HRS interview data
elixhauser and chronic conditions and insurance data 

File names are:
oop_fin.hrs_oop_ivws_meet_el_cc_n24m
*/

proc contents data=oop_fnl.hrs_oop_ivws_meet_el_cc_n24m;
run;


proc freq data=oop_fnl.hrs_oop_ivws_meet_el_cc_n24m;
table cc_:;
run;



H="Get nights SNF paid for by MC"
/*this creates the dataset oop_fnl.hrs_oop_with_nh_nights with
1. HRS interviews (exit, core n1, n2, n3 and restricted data)
2. OOP spending, nh nights totaled by 24m and 60m
3. Indicators for ffs mc last 2y and 5y
4. Elixhauser comorbidity indicators, last 2 years of life
5. Chronic conditions indicators, last 2 years of life
6. SNF nights, total and paid for by mc, from MC claims
This dataset is then merged with the MC claims payments totals datset 
created in the next few heading sections


REVISION 4/18
Need to get nursing home nights by interview cycle!
working code is in the next heading section*/

/*get list of all interview dates for decedents, use the oop dataset and merge in xwalk id*/
bid_hrs


/*first pull all snf claims x years before death*/

%macro snfnights(days_start=,days_bef_death=,name=);

/*identify claims where entire claim is within the x months prior to death*/
proc sql;
create table snf_meet as select a.*,b.death_date_e
from medi.mp_2000_2010(where=(trim(left(SSLSSNF))="N")) a inner join
oop_int.meet_criteria_2yr b
on trim(left(a.BID_HRS_19))=trim(left(b.BID_hrs))
and &days_start<=b.death_date_e-a.admit_date<=&days_bef_death;
quit;

/*identify claims that span x months prior to death (admission date is prior to start 
of x months but discharge date is within the x month window*/
proc sql;
create table snf_meet2 as select a.*,b.death_date_e
from medi.mp_2000_2010(where=(trim(left(SSLSSNF))="N")) a inner join
oop_int.meet_criteria_2yr b
on trim(left(a.BID_HRS_19))=trim(left(b.BID_hrs))
and b.death_date_e-a.admit_date>&days_bef_death and b.death_date_e-a.disch_date<=&days_bef_death;
quit;

/*Reset the start date = x months before death to just capture part of stay that was 
during the final x months*/
data snf_meet3;
set snf_meet2;
early_admit=1;
label early_admit="admit outside study window = yes";
run;


data snf_meet_4_&name.;
set snf_meet snf_meet3;

window_start=death_date_e-&days_bef_death.;
/*determine days paid for by mc and total snf days for claims fully in the window*/
if early_admit~=1 then do;
snf_days_mc_paid=util_day;
total_snf_los=LOSCNT;
end;

/*for those that claim starts earlier than time window*/
if early_admit=1 then do;
	mc_paid_thru_dt=admit_date+util_day;
	total_snf_los=LOSCNT-(window_start-admit_date);
	if window_start=mc_paid_thru_dt then total_snf_los=1;
	if mc_paid_thru_dt < window_start then do;
		snf_days_mc_paid=0;
	end;
	if mc_paid_thru_dt > window_start then do;
		snf_days_mc_paid= mc_paid_thru_dt - window_start;
	end;
	if mc_paid_thru_dt = window_start then do;
		snf_days_mc_paid=1;
	end;

end;

format admit_date date10.;
format disch_date date10.;
format mc_paid_thru_dt date10.;
format death_date_e date10.;
format window_start date10.;
label mc_paid_thru_dt="Medicaid covered through this date";
label total_snf_los="Total claim SNF LOS";
label snf_days_mc_paid="Claim days paid for by Medicare";

if total_snf_los=snf_days_mc_paid then mc_full=1;
if total_snf_los>snf_days_mc_paid then mc_full=0;
label mc_full="Indicator that stay fully paid for by MC";

run; 

proc freq; table mc_full; run;

proc means; var total_snf_los snf_days_mc_paid; run;

/*sum over all claims*/
proc sql;
create table snf_&name. as select distinct bid_hrs_19,
sum(total_snf_los) as snf_stay_all_&name. ,
sum(snf_days_mc_paid) as los_snf_paid_by_mc_&name. ,
sum(util_day) as tot_util_days_&name.
from snf_meet_4_&name. group by bid_hrs_19;
quit;

proc means; var snf_stay_all_&name. los_snf_paid_by_mc_&name. tot_util_days_&name.; run;

%mend;

%snfnights(days_start=0,days_bef_death=730,name=2y);
%snfnights(days_start=0,days_bef_death=(5*365),name=5y);

/*merge snf nights into the overall dataset*/
%macro mergenh(predeath=);

proc sql;
create table add_nh_&predeath._1
as select a.*,b.snf_stay_all_2y, b.los_snf_paid_by_mc_2y from
oop_fnl.hrs_oop_ivws_meet_el_cc_&predeath. a
left join
snf_2y b 
on (a.bid_hrs)=(b.bid_hrs_19);
quit;

proc sql;
create table add_nh_&predeath._2
as select a.*,b.snf_stay_all_5y, b.los_snf_paid_by_mc_5y from
add_nh_&predeath._1 a
left join
snf_5y b 
on (a.bid_hrs)=(b.bid_hrs_19);
quit;

%mend;

%mergenh(predeath=n24m);

/*if FFS medicare for the full time period, assign snf stay infrmation as no use*/
data add_nh_final;
set add_nh_n24m_2;
if part_ab_5y=1 and hmo_5y=0 and los_snf_paid_by_mc_5y=. then do;
	los_snf_paid_by_mc_5y=0; snf_stay_all_5y=0;
	end;
if part_ab_2y=1 and hmo_2y=0 and los_snf_paid_by_mc_2y=. then do;
	los_snf_paid_by_mc_2y=0; snf_stay_all_2y=0;
	end;
run;

data oop_fnl.hrs_oop_with_nh_nights;
set add_nh_final;
run;

proc freq; table los_snf_paid_by_mc_2y snf_stay_all_2y; run;

/*save version to Stata*/
proc export data=oop_fnl.hrs_oop_with_nh_nights 
outfile="E:\data\hrs_oop_2010\final_data\hrs_oop_with_nh_nights.dta" replace;
run;

H="Accounting for missing nh nights"
/*list of all decedents with their mc id*/
data exit_nh_1;
set oop_int.exit_restricted_02_to_10_v1;
keep id bid_hrs exit_year_x death_date_e stateusps: ;
run;

/*use insurance information to keep only those with ffs medicare last 2 years of life*/
proc sql;
create table exit_nh_2 as select * from exit_nh_1 where id
in (select id from oop_int.meet_criteria_2yr);
quit;

proc sort data=exit_nh_2 nodupkey; by id; run;

/*get interview dates, nh use, md coverage variables from oop dataset*/
proc sort data=oop_int.oop_2 nodupkey; by id curr_iw_date; run;

proc sql;
create table oop_bid_dec_1(drop=id2) as select * from
oop_int.oop_2 a left join
exit_nh_2(rename=(id=id2)) b 
on a.id=b.id2;
quit;

/*drop those without ffs mc last 2 years of life, they are missing bid*/
data oop_bid_dec_2;
set oop_bid_dec_1;
if bid_hrs~=' ';
run;

proc freq; table exit_year_x; run;

proc sort data=oop_bid_dec_2; by id year; run;

/*****************************************************************/
/*Get actual interview dates from core and restricted datasets
interview dates in oop dataset are just by month*/
/*****************************************************************/

/*get interview dates from core datasets, ultimately from restricted data*/
data core_dates;
set hrs_cln.core_00_to_10;
keep id core_year c_ivw_date c_ivw_year c_ivw_month c_ivw_day ;
rename core_year=year;
rename c_ivw_date=ivw_date_e;
rename c_ivw_year=ivw_year_e;
rename c_ivw_month=ivw_month_e;
rename c_ivw_day=ivw_day_e;
run;

/*use dod=exit interview date*/
data exit_dates;
set oop_int.exit_restricted_02_to_10_v1;
keep id exit_year_x death_date_e ;
rename exit_year_x=year;
rename death_date_e=ivw_date_e;
run;

data ivw_dates;
set core_dates exit_dates;
label year="Wave year"
ivw_date_e="Interview date, from restricted"
ivw_year_e="Interview year, restricted"
ivw_month_e="Interview month, restricted"
ivw_day_e="Interview day, restricted";
run;

proc sort data=ivw_dates; by id year;
run;

data ivw_dates_2;
set ivw_dates;
by id;
prev_ivw_date_e=lag(ivw_date_e);
label prev_ivw_date_e="Previous interview date";
if first.id then prev_ivw_date_e=.;
format prev_ivw_date_e date9.;
run;

/*****************************************************************/
/*Merge interview dates into oop interview dataset*/
/*****************************************************************/
proc sql;
create table oop_bid_dec_3 as select a.*,b.ivw_date_e,b.prev_ivw_date_e from
oop_bid_dec_2 a left join
ivw_dates_2 b
on a.id=b.id and a.year=b.year;
run;

/*only keep interviews within 5 years of death date*/
data oop_bid_dec_4;
set oop_bid_dec_3;
if death_date_e-(365.25*5)<=ivw_date_e and ivw_date_e~=.;
format death_date_e date9.;
run;

/*if previous interview date is missing, b/c not in my dataset, assign to be x months
before current interview to match the oop dataset*/
data oop_bid_dec_5;
set oop_bid_dec_4;
prev_ivw_date_e_imp=0;
if prev_ivw_date_e=. then do;
	 prev_ivw_date_e=ivw_date_e-(months*30.5);
	prev_ivw_date_e_imp=1;
end;
label prev_ivw_date_e_imp="Imputed previous interview date, not in restricted ds";
run;
proc freq; table prev_ivw_date_e_imp; run;

/*****************************************************************/
/*Get SNF nights from claims, between interview dates*/
/*****************************************************************/
/*first pull all snf claims x years before death*/

%macro snfnights(days_start=,days_bef_death=,name=);

/*get snf claims only from full medpar dataset*/
data snf_2000_2010;
set medi.mp_2000_2010(where=(trim(left(SSLSSNF))="N"));
run;

/*identify claims where entire claim is within the interview window*/
proc sql;
create table snf_meet as select a.*,b.ivw_date_e,b.prev_ivw_date_e
from snf_2000_2010 a inner join
oop_bid_dec_5 b
on trim(left(a.BID_HRS_19))=trim(left(b.BID_hrs))
and b.prev_ivw_date_e<=a.admit_date and a.disch_date<=b.ivw_date_e;
quit;

/*identify claims that start before the previous interview 
but go into the interview window per the discharge date*/
proc sql;
create table snf_meet2 as select a.*,b.ivw_date_e,b.prev_ivw_date_e
from snf_2000_2010 a inner join
oop_bid_dec_5 b
on trim(left(a.BID_HRS_19))=trim(left(b.BID_hrs))
and a.admit_date<b.prev_ivw_date_e and a.disch_date>b.prev_ivw_date_e ;
quit;

/*Create indicators for admit , discharge dates to be manually reset
No claims span both the current and previous interview dates!*/
data snf_meet3;
set snf_meet2;
admit_trunc=1;
disch_trunc=0;
if disch_date>ivw_date_e then disch_trunc=1;
label admit_trunc="admit outside interview window = yes";
label disch_trunc="disch outside interview window = yes";
run;

proc freq; table admit_trunc disch_trunc; run;

/*identify claims that start after the previous interview
but go past the current interview date*/
proc sql;
create table snf_meet4 as select a.*,b.prev_ivw_date_e,b.ivw_date_e
from snf_2000_2010 a inner join
oop_bid_dec_5 b
on trim(left(a.BID_HRS_19))=trim(left(b.BID_hrs))
and (b.prev_ivw_date_e<=a.admit_date) and (b.ivw_date_e<a.disch_date) 
and (a.admit_date<b.ivw_date_e);
quit;

data snf_meet5;
set snf_meet4;
disch_trunc=1;
run;

/*merge the three snf claims lists into single dataset
and determine mc paid days within window for each claim*/
data snf_all;
set snf_meet snf_meet3 snf_meet5;
if admit_trunc=. then admit_trunc=0;
if disch_trunc=. then disch_trunc=0;
if admit_trunc=0 and disch_trunc=0 then do;
	snf_days_mc_paid=util_day;
	total_snf_los=LOSCNT;
	end;
if admit_trunc=1 and disch_trunc=0 then do;
	mc_paid_thru_dt=admit_date+util_day;
	total_snf_los=LOSCNT-(prev_ivw_date_e-admit_date);
	if prev_ivw_date_e=mc_paid_thru_dt then total_snf_los=1;
	if mc_paid_thru_dt < prev_ivw_date_e then do;
		snf_days_mc_paid=0;
		end;
	if mc_paid_thru_dt > prev_ivw_date_e then do;
		snf_days_mc_paid= mc_paid_thru_dt - prev_ivw_date_e;
		end;
	if mc_paid_thru_dt = prev_ivw_date_e then do;
		snf_days_mc_paid=1;
		end;
	end;
if admit_trunc=0 and disch_trunc=1 then do;
	mc_paid_thru_dt=admit_date+util_day;
	total_snf_los=LOSCNT-(disch_date-ivw_date_e);
	if prev_ivw_date_e=mc_paid_thru_dt then total_snf_los=1;
	if mc_paid_thru_dt < ivw_date_e then do;
		snf_days_mc_paid=util_day;
		end;
	if mc_paid_thru_dt >= ivw_date_e then do;
		snf_days_mc_paid= ivw_date_e - admit_date;
		end;
	end;
format mc_paid_thru_dt date10.;
label mc_paid_thru_dt="Medicaid covered through this date";
label total_snf_los="Total claim SNF LOS";
label snf_days_mc_paid="Claim days paid for by Medicare";

if total_snf_los=snf_days_mc_paid then mc_full=1;
if total_snf_los>snf_days_mc_paid then mc_full=0;
label mc_full="Indicator that stay fully paid for by MC";

run;

proc freq; table admit_trunc disch_trunc total_snf_los snf_days_mc_paid mc_full;
run;

proc means; var total_snf_los snf_days_mc_paid; run;

/*sum over all claims by interview window*/
proc sort data=snf_all; by bid_hrs_19 ivw_date_e; run;

proc sql;
create table snf_ivw as select distinct bid_hrs_19, ivw_date_e,
sum(total_snf_los) as snf_stay_all_ivw ,
sum(snf_days_mc_paid) as los_snf_paid_by_mc_ivw ,
sum(util_day) as tot_util_days_ivw
from snf_all group by bid_hrs_19 , ivw_date_e;
quit;

/************************************************************/
/*merge snf nights data with the oop dataset*/
/************************************************************/
proc sort data=oop_bid_dec_5; by bid_hrs ivw_date_e; run;

proc sort data=snf_ivw ; by bid_hrs_19 ivw_date_e; run;
proc sql;

create table oop_bid_dec_nh(drop=ivw_date_e2) as select * from
oop_bid_dec_5 a left join
snf_ivw(rename=(ivw_date_e=ivw_date_e2)) b 
on a.bid_hrs=b.bid_hrs_19 and a.ivw_date_e=b.ivw_date_e2;
quit;

proc sql; select count( distinct id) from oop_bid_dec_nh ; quit;

data oop_bid_dec_nh_2;
set oop_bid_dec_nh;
if snf_stay_all_ivw =. then snf_stay_all_ivw =0;
if los_snf_paid_by_mc_ivw =. then los_snf_paid_by_mc_ivw =0;
if tot_util_days_ivw = . then tot_util_days_ivw=0;
run;

ods rtf body="E:\data\hrs_oop_2010\logs\nh_by_ivw_dataset.rtf";
proc contents data=oop_bid_dec_nh_2;
run;
proc means; var snf_stay_all_ivw los_snf_paid_by_mc_ivw ; run;

ods rtf close;


H="Medpar mc spending total"
/*Totals are from merged claims files from 2000-2010
Initial claims merging, processing done in HRS_2010_MC_claims.txt code
Filed in general HRS processing code directory
*/

/**********************************************************/
/**********************************************************/
/*totals from mp file*/
/*Note: variable SSLSSNF from mp claims is N=Skilled nursing facility*/
/*Two totals are calculated - one for skilled nursing facility claims
and one for all other claims in the mp file (inpatient claims)*/
/**********************************************************/
/**********************************************************/

%macro mp(month_n=,days_start=,days_bef_death=,source=,equ=,name=);
%let source0=mp;

/*identify claims where entire claim is within the x months prior to death*/
proc sql;
create table &source._meet as select a.*,b.death_date_e
from medi.&source0._2000_2010(where=(trim(left(SSLSSNF))&equ.="N")) a inner join
oop_int.meet_criteria_2yr b
on trim(left(a.BID_HRS_19))=trim(left(b.BID_hrs))
and &days_start<=b.death_date_e-a.admit_date<=&days_bef_death;
quit;

/*identify claims that span x months prior to death (admission date is prior to start 
of x months but discharge date is within the x month window*/
proc sql;
create table &source._meet2 as select a.*,b.death_date_e
from medi.&source0._2000_2010(where=(trim(left(SSLSSNF))&equ.="N")) a inner join
oop_int.meet_criteria_2yr b
on trim(left(a.BID_HRS_19))=trim(left(b.BID_hrs))
and b.death_date_e-a.admit_date>&days_bef_death and b.death_date_e-a.disch_date<=&days_bef_death;
quit;

/*identify fraction of claims that span x month period that should be 
attributed to the x month period
by just using the fraction of time that was included in the span*/
data &source._meet3;
set &source._meet2;
pct_xm=(disch_date-(death_date_e-&days_bef_death))/(disch_date-admit_date);
array list pmt_amt passthru;
do over list;
if list=. then list=0;
/*scale the partial claims by the time within the x month period*/
list=list*pct_xm;
end;

run;

/*adjust for inflation, Uses CPI for Medical Services from 
BLS website, accessed 3/14/2014*/

/*create table merging both the claims fully in the 2 year period 
and those partially in that time
adjust for inflation here also*/
data &source._cost;
set &source._meet &source._meet3;
array list pmt_amt passthru;
do over list;
if list=. then list=0;
end;

if year(admit_date)>=2010 then rate=1;
if year(admit_date)=2009 then rate=1.0350;
if year(admit_date)=2008 then rate=1.06823;
if year(admit_date)=2007 then rate=1.11347;
if year(admit_date)=2006 then rate=1.17287;
if year(admit_date)=2005 then rate=1.22119;
if year(admit_date)=2004 then rate=1.27983;
if year(admit_date)=2003 then rate=1.34381;
if year(admit_date)=2002 then rate=1.40392;
if year(admit_date)=2001 then rate=1.47492;
if year(admit_date)=2000 then rate=1.54589;
if year(admit_date)<=1999 then rate=1.61195;


&source._paid_by_mc=rate*(pmt_amt+passthru);
run;

*calculates total of mc charges for the claim type by hrs bid;
proc sql;
create table &source._pay as select distinct bid_hrs_19,
sum(&source._paid_by_mc) as &source._paid_by_mc 
from &source._cost group by BID_HRS_19;
quit;

*merges the totals above with the hrs dataset that meets the 2 year criteria;
proc sql;
create table &source._&name. as select
a.BID_hrs,a.id,coalesce(b.&source._paid_by_mc,0) as &source._paid_by_mc_&name.
from oop_int.meet_criteria_2yr a
left join
 &source._pay b
 on trim(left(a.BID_hrs))=trim(left(b.bid_hrs_19));
 quit;

 proc sort data=&source._&name. ;
 by BID_hrs;
 run;
%mend;

/*Runs macro to get total for the SNF claims*/
%mp(days_start=0,days_bef_death=(365.25*2),source=snf,equ=,name=2yr );
%mp(days_start=0,days_bef_death=(365.25*5),source=snf,equ=,name=5yr );
/*Runs macro to get total for the inpatient (not SNF) claims*/
%mp(days_start=0,days_bef_death=(365.25*2),source=ip,equ=~,name=2yr );
%mp(days_start=0,days_bef_death=(365.25*5),source=ip,equ=~,name=5yr );

/*************************************************************************/
/*Simple check to view one of the HRS id's claims that are totaled to get the snf number
Just picked an ID number to use*/
/*************************************************************************/

proc sql;
create table test25 as
select * from medi.mp_2000_2010 
where bid_hrs_19="H100000006";
quit;

proc sql;
create table test26 as
select * from test25 
where SSLSSNF="N";
quit;


H="Other types of mc spending totals"
/*macro to calculate totals for the claims that are not in medpar files*/
%macro all_other(source=,month_n=,days_start=,days_bef_death=);

/*identify claims where entire claim is within the x months prior to death*/
proc sql;
create table &source._meet as select a.*
from medi.&source._2000_2010(keep=admit_date BID_hrs_19 pmt_amt) a inner join
oop_int.meet_criteria_2yr b
on trim(left(a.BID_hrs_19))=trim(left(b.BID_hrs))
and &days_start<=b.death_date_e-a.admit_date<=&days_bef_death;
quit;

/*Adjust for inflation*/
data &source._meet2;
set &source._meet;
/*adjust to 2010 dollars*/
if year(admit_date)>=2010 then rate=1;
if year(admit_date)=2009 then rate=1.0350;
if year(admit_date)=2008 then rate=1.06823;
if year(admit_date)=2007 then rate=1.11347;
if year(admit_date)=2006 then rate=1.17287;
if year(admit_date)=2005 then rate=1.22119;
if year(admit_date)=2004 then rate=1.27983;
if year(admit_date)=2003 then rate=1.34381;
if year(admit_date)=2002 then rate=1.40392;
if year(admit_date)=2001 then rate=1.47492;
if year(admit_date)=2000 then rate=1.54589;
if year(admit_date)<=1999 then rate=1.61195;

&source._paid_by_mc=rate*(pmt_amt);
run;

/*Calculate total mc payments by ID*/
proc sql;
create table &source._pay as select distinct BID_hrs_19,sum(&source._paid_by_mc) as &source._paid_by_mc
from &source._meet2 group by BID_hrs_19;
quit;

/*merge in mc totals with full oop dataset*/
proc sql;
create table &source.&month_n as select
a.BID_hrs,coalesce(b.&source._paid_by_mc,0) as &source._paid_by_mc&month_n 
from oop_int.meet_criteria_2yr a
left join
 &source._pay b
 on trim(left(a.BID_hrs))=trim(left(b.BID_hrs_19));
 quit;

 proc sort data=&source&month_n ;
 by BID_hrs;
 run;
 %mend;

/******************************************************************/
/* Run the macro over the mc claims files for 2 years prior to death*/
/******************************************************************/

 %all_other(source=op,month_n=_2yr,days_start=0,days_bef_death=(365*2));
  %all_other(source=pb,month_n=_2yr,days_start=0,days_bef_death=(365*2));
   %all_other(source=hh,month_n=_2yr,days_start=0,days_bef_death=(365*2));
    %all_other(source=hs,month_n=_2yr,days_start=0,days_bef_death=(365*2));
     %all_other(source=dm,month_n=_2yr,days_start=0,days_bef_death=(365*2));

/******************************************************************/
/* Run the macro over the mc claims files for 5 years prior to death*/
/******************************************************************/

 %all_other(source=op,month_n=_5yr,days_start=0,days_bef_death=(365*5));
  %all_other(source=pb,month_n=_5yr,days_start=0,days_bef_death=(365*5));
   %all_other(source=hh,month_n=_5yr,days_start=0,days_bef_death=(365*5));
    %all_other(source=hs,month_n=_5yr,days_start=0,days_bef_death=(365*5));
     %all_other(source=dm,month_n=_5yr,days_start=0,days_bef_death=(365*5));


H="Merge mc spending subtotals into single data file"
/******************************************************************/
/* Merge all subtotals into a single data file */
/******************************************************************/
	 data oop_int.costs_all;
	 merge ip_2yr snf_2yr hh_2yr hs_2yr pb_2yr op_2yr dm_2yr
		ip_5yr snf_5yr hh_5yr hs_5yr pb_5yr op_5yr dm_5yr;
	 by BID_hrs;
	 run;







H="Adjust for wage index by patient zip code"
/******************************************************************/
/* Adjust subtotals for wage index */
/******************************************************************/

/******************************************************************/
/* Pull in wage index file and clean up for states that are missing WI*/
/******************************************************************/
/*bring in 2010 wage index file*/
proc import datafile="E:\data\hrs_oop_2010\ref_data\wage_index\wage_index_cbsa_2010.xls"
out=oop_int.wage_index 
replace;
run;

/*get RI average*/
data wi_ri;
set oop_int.wage_index;
if index(trim(left(Area_Title)),", RI")>0;
run;

proc means;
var wage_index;
run;

/*deal with states that were missing wage index values in the 2010 file
These values are the state averages using the individual cbsa values 
data in the 2010 excel file came from
Note in switching from 2008 to 2010, RI is the only missing state*/
data wage_index2;
set oop_int.wage_index;
cbsa_n=cbsa_code+0;
if trim(left(cbsa_code))~="";
wage_index_2010=Wage_Index;
if index(trim(left(Area_Title)),", RI")>0 then RI=1;
*state 44=RI;
if state_in_wage_index=44 then wage_index_2010=1.0783000; 
run;

*Look at observations from Rhode Island;
proc freq data=wage_index2(where=(ri=1));
table Area_Title;
run;

%let var=ri;
proc means data=wage_index2;
class &var;
var wage_index_2010;
run;

/******************************************************************/
/* Link CBSA codes and zip codes from the WI file*/
/******************************************************************/
/*Bring in xwalk file between CBSA codes and zip codes
Note only keep variables needed from xwalk file because formats 
are missing for some of the other text variables*/
data zip_cb;
set oop_ref.xtract(keep=zip5 cbsa state);
zip_n=zip5+0;
cbsa_n=cbsa+0;
/*If zip code is not missing, add state code*/
if zip_n~=.;
state_n=state+0;
run;

*Remove duplicate entries for zip5 and cbsa from xwalk file;
*Goes from 399045 to 49289 rows;
proc sort data=zip_cb out=zip_cb2 nodupkey;
by zip_n cbsa_n;
run;

*Check to see zip codes in a cbsa code for Rochester, NY;
proc sql;
select zip5, cbsa from zip_cb2
where cbsa_n in (40380);
quit;

/*note several zip codes have multiple cbsa*/
/*create dataset with just one entry for each zip code
8029 zip codes have more than one cbsa code
Just use the first one when sort*/
proc sort data=zip_cb2 out=cbsa_zip_final nodupkey;
by zip_n;
run;

*Check to see zip codes in a cbsa code for Rochester, NY;
proc sql;
select zip_n, cbsa from cbsa_zip_final
where cbsa_n in (40380);
quit;

/******************************************************************/
/* Create dataset with cbsa, wage index and zip code */
/******************************************************************/

/*for zip codes with no cbsa, wage index is left missing
there are also many cbsas with missing wage index*/
proc sql;
create table zip_cbsa_wage_index as
select a.*,b.wage_index_2010 from
cbsa_zip_final a
left join
wage_index2 b
on a.cbsa_n=b.cbsa_n;
quit;

/*Check for and remove duplicates by zip, keep first entry*/
proc sort data=zip_cbsa_wage_index out=zip_cbsa_wage_index2 nodupkey;
by zip_n;
run;


/******************************************************************/
/* Pull in zip code from restricted data */
/******************************************************************/

/*Add zip code to the cost table by id*/
proc sql;
create table cost_zip as
select a.*,b.zip_exit_e from 
oop_int.costs_all a
left join 
oop_int.exit_restricted_02_to_10_v1 b
on a.id=b.id;
quit;


/******************************************************************/
/* Check zip codes in oop data for matching entries in the cbsa file*/
/******************************************************************/

/* 5 observation has a zip code without an associated cbsa */
proc sql; 
select count(distinct cbsa) from cbsa_zip_final;
quit;

proc sql;
select count(distinct zip_exit_e) from cost_zip
where zip_exit_e not in 
(select ZIP5 from cbsa_zip_final);
quit;

proc sql; 
select count(distinct zip_n) from zip_cbsa_wage_index2
where wage_index_2010 is null ;
quit;

proc sql; 
select count(distinct zip_exit_e) from cost_zip
where zip_exit_e not in 
(select ZIP5 from zip_cbsa_wage_index2);
quit;


/******************************************************************/
/* Bring wage index and state code into cost file by zip-cbsa*/
/******************************************************************/
proc sql;
create table cost_id_wage_index as
select a.*,b.wage_index_2010,b.state_n from 
cost_zip a
left join 
zip_cbsa_wage_index2 b
on a.zip_exit_e=b.ZIP5;
quit;

/*1604 observations do not have wage id by cbsa-zip*/
proc sql; 
select count(distinct id) from cost_id_wage_index
where wage_index_2010 is null ;
quit;

/******************************************************************/
/* Bring wage index into cost file by state if missing above*/
/******************************************************************/
/*Get dataset with one wage index per state*/
proc sort data=wage_index2 out=wage_index3 nodupkey;
by state_in_wage_index;
run;

/*Merges in wage index if there's one for the state but was missing for the zip*/
proc sql;
create table cost_id_wage_index2 
as select a.*,coalesce(a.wage_index_2010,b.wage_index_2010) as wage_index_20102
from
cost_id_wage_index a
left join
wage_index3 b
on a.state_n=b.state_in_wage_index;
quit;

/*check for missing values*/
proc means;
var wage_index_2010 wage_index_20102;
run;

/*23 obs have missing state so can't backfill using state wage index*/
proc sql;
select distinct state_n ,count(*) from cost_id_wage_index2
where wage_index_20102=. group by state_n;
quit;

/*********************************************************/
/* Commented out, try to backfill in more manually later */
/*********************************************************/
/*most of these have invalid zip codes too*/
proc sql;
select distinct zip_exit ,count(*) from cost_id_wage_index2
where wage_index_20102=. group by zip_exit;
quit;

/*manually fill in state where zip code is valid and rematch on state*/
data cost_id_wage_index2a;
set cost_id_wage_index2;
if wage_index_20102=. and zip_exit=10065 then state_n=36; /*NY*/
if wage_index_20102=. and zip_exit=33596 then state_n=12; /*FL*/
if wage_index_20102=. and zip_exit=77498 then state_n=48; /*TX*/
if wage_index_20102=. and zip_exit=78542 then state_n=48; /*TX*/
run;

proc sql;
create table cost_id_wage_index2b 
as select a.*,coalesce(a.wage_index_20102,b.wage_index_20102) as wage_index_20102
from
cost_id_wage_index2 a
left join
cost_id_wage_index2a b
on a.state_n=b.state_in_wage_index;
quit;

/*most of these have invalid zip codes too*/
proc sql;
select distinct zip_exit ,count(*) from cost_id_wage_index2b
where wage_index_20082=. group by zip_exit;
quit;
/*********************************************************/
/* End of Commented out                                  */
/*********************************************************/


/******************************************************************/
/* Scale individual costs by wage index*/
/******************************************************************/

/*if missing wage index, set to 1 and create indicator to note no
wage index present b/c bad zip code and missing state
23 observations with wage index assigned = 1*/
data cost_id_wage_index3; 
set cost_id_wage_index2;
wi_missing_yes=0;
if wage_index_20102=. then wi_missing_yes=1;
if wage_index_20102=. then wage_index_20102=1;
label wi_missing_yes="Indicator missing wage index, set to 1";
run;

proc freq; table wi_missing_yes; run;

proc sort data=cost_id_wage_index3 ;
by BID_hrs;
run;

/*macro to adjust prices by wage index
Have two subtotals now - one without wage index adjustment and one with _wi is adjusted*/
%macro wageind(ctype=);
data costs_&ctype._wi (keep=BID_HRS id &ctype._paid_by_mc_2yr &ctype._paid_by_mc_2yr_wi
	&ctype._paid_by_mc_5yr &ctype._paid_by_mc_5yr_wi);
set cost_id_wage_index3;
&ctype._paid_by_mc_2yr_wi=&ctype._paid_by_mc_2yr/wage_index_20102;
&ctype._paid_by_mc_5yr_wi=&ctype._paid_by_mc_5yr/wage_index_20102;
run;

proc sort data=costs_&ctype._wi ;
by BID_hrs id;
run;

%mend;

%wageind(ctype=ip);
%wageind(ctype=snf);
%wageind(ctype=hh);
%wageind(ctype=hs);
%wageind(ctype=pb);
%wageind(ctype=op);
%wageind(ctype=dm);

/*merge individual adjusted costs into single dataset*/
data oop_int.costs_all_wi;
merge costs_ip_wi costs_snf_wi costs_hh_wi costs_hs_wi costs_pb_wi
 costs_op_wi costs_dm_wi;
by BID_hrs id;
run;








H="Calculate total spending "
/******************************************************************/
/* Create new variable for total mc spending of all types */
/******************************************************************/

/*note this final dataset drops observations with missing wage index*/

data oop_fnl.mc_costs_2and5yr;
set oop_int.costs_all_wi;
/*total not adjusted for wage index*/
tot_paid_by_mc_2yr=sum(of ip_paid_by_mc_2yr snf_paid_by_mc_2yr hh_paid_by_mc_2yr hs_paid_by_mc_2yr
pb_paid_by_mc_2yr op_paid_by_mc_2yr dm_paid_by_mc_2yr);
tot_paid_by_mc_5yr=sum(of ip_paid_by_mc_5yr snf_paid_by_mc_5yr hh_paid_by_mc_5yr hs_paid_by_mc_5yr
pb_paid_by_mc_5yr op_paid_by_mc_5yr dm_paid_by_mc_5yr);
/*total adjusted for wage index*/
tot_paid_by_mc_2yr_wi=sum(of ip_paid_by_mc_2yr_wi snf_paid_by_mc_2yr_wi hh_paid_by_mc_2yr_wi hs_paid_by_mc_2yr_wi
pb_paid_by_mc_2yr_wi op_paid_by_mc_2yr_wi dm_paid_by_mc_2yr_wi);
tot_paid_by_mc_5yr_wi=sum(of ip_paid_by_mc_5yr_wi snf_paid_by_mc_5yr_wi hh_paid_by_mc_5yr_wi hs_paid_by_mc_5yr_wi
pb_paid_by_mc_5yr_wi op_paid_by_mc_5yr_wi dm_paid_by_mc_5yr_wi);
run;

/*save version to Stata*/
proc export data=oop_fnl.mc_costs_2and5yr
outfile="E:\data\hrs_oop_2010\final_data\mc_costs_2and5yr.dta" replace;
run;

H="Merge mc spending into oop file"
/* 
Merges subtotals and total medicare spending in last 2 years
of life into oop dataset

Two sets of medicare totals are brought in:
1. Adjusted for inflation only (2010 dollars)
2. Adjusetd for inflation and 2010 wage index

Note: This step is done in Stata

*/


capture log close
clear all
set mem 500m
set more off

local logpath E:\data\hrs_oop_2010\logs
local datapath E:\data\hrs_oop_2010\final_data

log using `logpath'\1-mc_oop_2and5yr_merge-LOG.txt, text replace

cd `datapath'
use hrs_oop_with_nh_nights.dta

merge 1:1 id using mc_costs_2and5yr.dta
//check merge to see that observations with costs were merged
sum _merge if(tot_paid_by_mc_2yr==.)
sum _merge if(tot_paid_by_mc_2yr~=.)

//Create indicator variable to indciate medicare totals present
gen mc_total_d=0
replace mc_total_d=1 if(_merge==3)
drop _merge
tab mc_total_d
//23 missing medciare totals are missing because no link to wage index!
tab mc_total_d if ( part_ab_2y==1 &  hmo_2y==0)


//Label variables for mc spending totals
la var tot_paid_by_mc_2yr "Total mc payments in last 2 years of life"
la var ip_paid_by_mc_2yr "Inpatient mc payments in last 2 years of life"
la var snf_paid_by_mc_2yr "SNF mc payments in last 2 years of life"
la var hh_paid_by_mc_2yr "Home health mc payments in last 2 years of life"
la var hs_paid_by_mc_2yr "Hospice mc payments in last 2 years of life"
la var pb_paid_by_mc_2yr "Carrier mc payments in last 2 years of life"
la var op_paid_by_mc_2yr "Outpatient mc payments in last 2 years of life"
la var dm_paid_by_mc_2yr "DME mc payments in last 2 years of life"

la var tot_paid_by_mc_2yr_wi "Total wage index adj. mc payments in last 2 years of life"
la var ip_paid_by_mc_2yr_wi "Wage index adj. Inpatient mc payments in last 2 years of life"
la var snf_paid_by_mc_2yr_wi "Wage index adj. SNF mc payments in last 2 years of life"
la var hh_paid_by_mc_2yr_wi "Wage index adj. Home health mc payments in last 2 years of life"
la var hs_paid_by_mc_2yr_wi "Wage index adj. Hospice mc payments in last 2 years of life"
la var pb_paid_by_mc_2yr_wi "Wage index adj. Carrier mc payments in last 2 years of life"
la var op_paid_by_mc_2yr_wi "Wage index adj. Outpatient mc payments in last 2 years of life"
la var dm_paid_by_mc_2yr_wi "Wage index adj. DME mc payments in last 2 years of life"

la var tot_paid_by_mc_5yr "Total mc payments in last 5 years of life"
la var ip_paid_by_mc_5yr "Inpatient mc payments in last 5 years of life"
la var snf_paid_by_mc_5yr "SNF mc payments in last 5 years of life"
la var hh_paid_by_mc_5yr "Home health mc payments in last 5 years of life"
la var hs_paid_by_mc_5yr "Hospice mc payments in last 5 years of life"
la var pb_paid_by_mc_5yr "Carrier mc payments in last 5 years of life"
la var op_paid_by_mc_5yr "Outpatient mc payments in last 5 years of life"
la var dm_paid_by_mc_5yr "DME mc payments in last 5 years of life"

la var tot_paid_by_mc_5yr_wi "Total wage index adj. mc payments in last 5 years of life"
la var ip_paid_by_mc_5yr_wi "Wage index adj. Inpatient mc payments in last 5 years of life"
la var snf_paid_by_mc_5yr_wi "Wage index adj. SNF mc payments in last 5 years of life"
la var hh_paid_by_mc_5yr_wi "Wage index adj. Home health mc payments in last 5 years of life"
la var hs_paid_by_mc_5yr_wi "Wage index adj. Hospice mc payments in last 5 years of life"
la var pb_paid_by_mc_5yr_wi "Wage index adj. Carrier mc payments in last 5 years of life"
la var op_paid_by_mc_5yr_wi "Wage index adj. Outpatient mc payments in last 5 years of life"
la var dm_paid_by_mc_5yr_wi "Wage index adj. DME mc payments in last 5 years of life"

//save dataset with costs merged in
save oop_resp_sp_restri_24mand60m_mc.dta,replace

//local for mc costs adjusted by wage index
local mccost2 tot_paid_by_mc_2yr_wi ip_paid_by_mc_2yr_wi snf_paid_by_mc_2yr_wi ///
hh_paid_by_mc_2yr_wi hs_paid_by_mc_2yr_wi pb_paid_by_mc_2yr_wi op_paid_by_mc_2yr_wi ///
 dm_paid_by_mc_2yr_wi 
local mccost5 tot_paid_by_mc_5yr_wi ip_paid_by_mc_5yr_wi snf_paid_by_mc_5yr_wi ///
hh_paid_by_mc_5yr_wi hs_paid_by_mc_5yr_wi pb_paid_by_mc_5yr_wi op_paid_by_mc_5yr_wi ///
 dm_paid_by_mc_5yr_wi  
tabstat `mccost2' `mccost5' if(mc_total_d==1), stat(mean sd count) col(stat)

tabout death_year_e female_x race_e /*age_at_death_e*/ if(mc_total_d==1) ///
using `logpath'\sumstats1.csv, ///
replace sum c(mean tot_paid_by_mc_2yr_wi N tot_paid_by_mc_2yr_wi ) style(csv)

/*
//local for comorbidities present in last 24 months
local comorb comorb_1_0d_n24m comorb_2_0d_n24m comorb_3_0d_n24m ///
comorb_4_0d_n24m comorb_5_0d_n24m comorb_6_0d_n24m comorb_7_0d_n24m ///
comorb_8_0d_n24m comorb_9_0d_n24m comorb_10_0d_n24m comorb_11_0d_n24m ///
comorb_12_0d_n24m comorb_13_0d_n24m comorb_14_0d_n24m comorb_15_0d_n24m ///
comorb_16_0d_n24m comorb_17_0d_n24m comorb_18_0d_n24m comorb_19_0d_n24m ///
comorb_20_0d_n24m comorb_21_0d_n24m ///
comorb_22_0d_n24m comorb_23_0d_n24m comorb_24_0d_n24m comorb_25_0d_n24m ///
comorb_26_0d_n24m comorb_27_0d_n24m comorb_28_0d_n24m comorb_29_0d_n24m ///

tabout `comorb'  if(mc_total_d==1) ///
using `logpath'\sumstats2.csv, ///
replace sum c(mean tot_paid_by_mc_2yr_wi N tot_paid_by_mc_2yr_wi ) style(csv)
*/
log close







H="Table with sample size 2 and 5yr lookbacks"
/*there are likely observations that had nursing home costs that
don't appear in the Medicare paid costs or OOP reported spending
Try to account for that here*/


capture log close
clear all
set mem 500m
set more off

local logpath E:\data\hrs_oop_2010\logs
local datapath E:\data\hrs_oop_2010\final_data

log using `logpath'\2-oop_sample_size-LOG.txt, text replace

cd `datapath'

//full dataset, all decedents
use oop_resp_sp_restri_24mand60m_mc.dta 

mat samp=J(7,2,.)

//total number of decedents, same initial sample 2 and 5yr lookback
sum exit_year_x
mat samp[1,1]=r(N)
mat samp[1,2]=r(N)

*****************************************************
//2 year lookback column
sum exit_year_x if age_at_death_e>=67 & age!=. //decedents 67 and older
mat samp[2,1]=r(N)

sum exit_year_x if age_at_death_e>=67 & age!=. & xwalk_yes==1 //with mc xwalk
mat samp[3,1]=r(N)

sum exit_year_x if age_at_death_e>=67 & age!=. & xwalk_yes==1 & part_ab_2y!=. //with full insur info
mat samp[4,1]=r(N)

sum exit_year_x if age_at_death_e>=67 & age!=. & part_ab_2y==1  // with parts a and  b
mat samp[5,1]=r(N)

sum exit_year_x if age_at_death_e>=67 & age!=. & part_ab_2y==1 &  hmo_2y==0 // with ffs mc
mat samp[6,1]=r(N)

// with ffs mc and full oop data
sum exit_year_x if age_at_death_e>=67 & age!=. & part_ab_2y==1 & hmo_2y==0 & ind_24m_oop_yes==1 
mat samp[7,1]=r(N)

gen byte ind_sample_2yr = 0
replace ind_sample_2yr=1 if age_at_death_e>=67 & age!=. & part_ab_2y==1 & hmo_2y==0 & ind_24m_oop_yes==1
tab ind_sample_2yr, missing
label var ind_sample_2yr "Indicator in 2 yr lookback sample"

*****************************************************
//5 year lookback column
sum exit_year_x if age_at_death_e>=70 & age!=.  //decedents 70 and older
mat samp[2,2]=r(N)

sum exit_year_x if age_at_death_e>=70 & age!=. & xwalk_yes==1 //with mc xwalk
mat samp[3,2]=r(N)

sum exit_year_x if age_at_death_e>=70 & age!=. & xwalk_yes==1 & part_ab_5y!=. //with full insur info
mat samp[4,2]=r(N)

sum exit_year_x if age_at_death_e>=70 & age!=. & part_ab_5y==1  // with parts a and  b
mat samp[5,2]=r(N)

sum exit_year_x if age_at_death_e>=70 & age!=. & part_ab_5y==1 &  hmo_5y==0 // with ffs mc
mat samp[6,2]=r(N)

// with ffs mc and full oop data
sum exit_year_x if age_at_death_e>=70 & age!=. & part_ab_5y==1 & hmo_5y==0 & ind_60m_oop_yes==1 
mat samp[7,2]=r(N)

gen byte ind_sample_5yr = 0
replace ind_sample_5yr=1 if age_at_death_e>=70 & age!=. & part_ab_5y==1 & hmo_5y==0 & ind_60m_oop_yes==1
tab ind_sample_5yr, missing
label var ind_sample_5yr "Indicator in 5 yr lookback sample"


save oop_mc_sample.dta, replace

*****************************************************

mat rownames samp="All decedents, 2002-2010" "Age at death 67+, 70+" "With Medicare link" ///
"Will full insurance info" "With Medicare Parts A&B" "With No HMO" "With full OOP data"

mat colnames samp="2 years" "5 years"

frmttable using `logpath'\2-oop_sample, statmat(samp) ///
title("Sample size determination" \ ///
"2 and 5 year lookback at HRS and Claims") ///
sdec(0) replace

tab part_ab_2y hmo_2y, missing

log close


H="Account for missing nh nights"
/*there are likely observations that had nursing home costs that
don't appear in the Medicare paid costs or OOP reported spending
Try to account for that here*/


capture log close
clear all
set mem 500m
set more off

local logpath E:\data\hrs_oop_2010\logs
local datapath E:\data\hrs_oop_2010\final_data

log using `logpath'\3-add_nh_costs-LOG.txt, text replace

cd `datapath'

//just use dataset where ffs mc last 2 years of life
use oop_mc_sample.dta if ind_sample_2yr==1

//n=3330
tab exit_year_x, missing
sum nh_nights_24m //check for full oop data on nh nights 2 yrs
sum snf_stay_all_2y //check for full SNF claims data on nh nights 2 yrs

//get self reported nursing home nights last 2, 5 years of life/
rename nh_nights_24m nh_nights_sr_24m
rename nh_nights_60m nh_nights_sr_60m
label var nh_nights_sr_24m "Self Report NH nights 2yrs prior to death"
label var nh_nights_sr_60m "Self Report NH nights 5yrs prior to death"

sum nh_nights_sr_24m , detail

sum nh_nights_sr_60m , detail

//medicare reported nursing home nights
sum  snf_stay_all_2y , detail
sum los_snf_paid_by_mc_2y , detail

//if medicare reports more days than self report, assign total days as mc days
//otherwise, keep just the oop days
gen nh_nights_24m = nh_nights_sr_24m if (nh_nights_sr_24m>=snf_stay_all_2y | snf_stay_all_2y==.)
replace nh_nights_24m=snf_stay_all_2y if nh_nights_24m==. & snf_stay_all_2y~=.
label var nh_nights_24m "Total NH nights 2yrs before death, source=self report or claims"
sum nh_nights_24m, detail

gen nh_nights_60m = nh_nights_sr_60m if (nh_nights_sr_60m>=snf_stay_all_5y | snf_stay_all_5y==.)
replace nh_nights_60m=snf_stay_all_5y if nh_nights_60m==. & snf_stay_all_5y~=.
replace nh_nights_60m=. if ind_sample_5yr == 0
label var nh_nights_60m "Total NH nights 5yrs before death, source=self report or claims"
sum nh_nights_60m, detail

//check for nights not paid for by medicare
gen nh_ni_not_mc_24m = 0
replace nh_ni_not_mc_24m=(nh_nights_24m - los_snf_paid_by_mc_2y) if (nh_nights_24m - los_snf_paid_by_mc_2y)>0
label var nh_ni_not_mc_24m "NH Nights not Medicare paid last 2 yrs of life"
sum nh_ni_not_mc_24m, detail

gen nh_ni_not_mc_60m = 0
replace nh_ni_not_mc_60m=(nh_nights_60m - los_snf_paid_by_mc_5y) if (nh_nights_60m - los_snf_paid_by_mc_5y)>0
replace nh_ni_not_mc_60m = . if ind_sample_5yr==0
label var nh_ni_not_mc_60m "NH Nights not Medicare paid last 5 yrs of life"
sum nh_ni_not_mc_60m, detail

//indicator variable for nh total payments imputed
gen byte nh_total_imp_24m = .
replace nh_total_imp_24m =1 if nh_ni_not_mc_24m > 0
replace nh_total_imp_24m =1 if nh_ni_not_mc_24m == 0
label var nh_total_imp_24m "Total HN nights payments (2yrs) imputed = yes"

gen byte nh_total_imp_60m = .
replace nh_total_imp_60m =1 if nh_ni_not_mc_60m > 0
replace nh_total_imp_60m =1 if nh_ni_not_mc_60m == 0
label var nh_total_imp_60m "Total HN nights payments (5yrs) imputed = yes"

//payments for non medicare nights


//label for cause of death
la def cause_death_12_n_e 1 "Infectious Disease (not HIV/AIDS/viral hepatitis)" ///
2 "HIV/AIDS" 3 "Cardiovascular Disease" 4"Chronic Lower Respiratory Disease" ///
5"Other Respiratory Disease" 6"Diabetes" 7"Alzheimers Disease" 9"Neoplasms" ///
10"Kidney Disease (not infectious)" ///
11"Liver, Gallbladder, Stomach and/or Intestinal Disease" ///
12"Accidents, Suicide, Homicide" 13"Other" 14"Unknown"
la val  cause_death_12_n_e cause_death_12_n_e
replace cause_death_12_n_e=14 if cause_death_12_n_e==.
tab cause_death_12_n_e, missing

save oop_24mand60m_mc_add_nh.dta, replace

log close


H="Accounting for other payer SNF days"
Dear Amy et al,

At long last. Here's my proposal for the implicit measurement of Medicaid and private pay spending for individuals in the HRS.  Revisions welcome.
For the period spanning date of death and 2 year look back (possibly 5 yr look back for subgroup):
1.        Count up the total number of nursing home days (self-reported).
Variables created in the "OOP Spending Totals 24,60months before death" section
nh_nights_24m nh_nights_60m , renamed to nh_nights_sr_24m, nh_nights_sr_60m

2.       I believe that the Medicare claims data has the number of nursing home days.  Subtract this number from the self-reported number of days.  If Medicare reports more days than the self-report, use the Medicare number.
Medicare claims nursing home days created in "Get nights SNF paid for by MC" section
Total reported SNF days from Medicare claims:  snf_stay_all_2y , snf_stay_all_5y 
SNF days paid for by Medicare: los_snf_paid_by_mc_2y , los_snf_paid_by_mc_5y

Nursing home days variables used: nh_nights_24m nh_nights_60m

3.       Begin with Medicare-financed nursing home payments as our first component of nursing home payments (total SNF expenditures).  If this is also equal or greater than the self-reported days, then we're done.  We add up Medicare spending with OOP spending for nursing homes, and that's the total. 
If los_snf_paid_by_mc_2y = nh_nights_24m then total NH spending = OOP + MC totals

4.       Suppose that Medicare days do not come close to total nursing home days.  Then we move to impute the total costs of those additional days (that is, total reported days MINUS Medicare-reported days).
If los_snf_paid_by_mc_2y < nh_nights_24m, need to impute!

5.       We also have OOP spending, but we don't know whether some of that was the copay for the Medicare-funded days or whether it was for private-pay days.  So let's ignore for now the copays for Medicare-funded nursing home days. (also those with medi-gap may not have copays as oop expense)
6.       So we take the total number of days not funded by Medicare, and multiply by an average cost of nursing home beds (by state if available Where might we find state-average NH costs? If we do find by-state averages we should not price-adjust those costs, correct?; if not adjusted by our Medicare price index - see below).   Subtract off the patient OOP spending for nursing home care. What is left over is Medicaid spending plus private insurance payments. Should we use the self-report of Medicaid or Private insurance coverage to attribute these costs to one or the other?
nights not funded by medicare: nh_ni_not_mc_24m
imputed cost of remaining nights = nh_ni_not_mc_24m*state average price

Private insurance costs, per Hurd, use 2010 MetLife Mature Market Survey private room rates, by state - use for those that say no medicaid

If medicaid, ust state medicaid rate, from various sources, following Hurd source list


7.       Of course, Medicaid pays less for nursing homes; so we've added back in the implicit "tax" that they impose on nursing homes.  
8.       Regarding the price index - this would be the ratio of unadjusted per capita spending to price-adjusted per capita Medicare spending, both from the Dartmouth Atlas data (side-by-side in the excel spreadsheet in fact).  It's not a perfect price adjustment for nursing home days, but it's a start.
9.       Question: would you want to take the SAS code from Dartmouth to run the price-adjustment for the HRS Medicare claims data? I think it would be better to run the SAS code on these datacould you send it to us?  Then we're not imputing the price adjustment, but we're actually getting in in real terms.  Of course, we'd still need to adjust OOP for regional price level variations. To do this we'd still use the ratio, but it would now be based on these HRS-Medicare data, not the overall Medicare data, right?


H="Look at dementia samples"
capture log close
clear all
set mem 500m
set more off

local logpath E:\data\hrs_oop_2010\logs
local datapath E:\data\hrs_oop_2010\final_data

log using `logpath'\4-mc_oop_dementia_initial-LOG.txt, text replace

cd `datapath'

//this dataset is already limited to ffs, full info last 2 years of life
use oop_24mand60m_mc_add_nh.dta

// look at dementia probability sample sizes

gen byte dem_miss_n1 = .
replace dem_miss_n1=1 if prob_dementia_n1==.
replace dem_miss_n1=0 if prob_dementia_n1!=.

gen byte dem_miss_n2 = .
replace dem_miss_n2=1 if prob_dementia_n2==.
replace dem_miss_n2=0 if prob_dementia_n2!=.

tab dem_miss_n1 dem_miss_n2, missing

//if missing, carry forward n2 probability
gen prob_dem_n1n2 = prob_dementia_n1
replace prob_dem_n1n2=prob_dementia_n2 if prob_dementia_n1==.

//histogram prob_dem_n1n2

gen byte pr_dem_gt50 = .
replace pr_dem_gt50 = 0 if prob_dem_n1n2<=.5 & prob_dem_n1n2!=.
replace pr_dem_gt50 = 1 if prob_dem_n1n2>.5 & prob_dem_n1n2!=.
la var pr_dem_gt50 "Indicator dementia prob gt 0.5"
tab pr_dem_gt50, missing

gen byte pr_dem_gt30 = .
replace pr_dem_gt30 = 0 if prob_dem_n1n2<=.3 & prob_dem_n1n2!=.
replace pr_dem_gt30 = 1 if prob_dem_n1n2>.3 & prob_dem_n1n2!=.
la var pr_dem_gt30 "Indicator dementia prob gt 0.3"
tab pr_dem_gt30, missing

gen byte pr_dem_gt70 = .
replace pr_dem_gt70 = 0 if prob_dem_n1n2<=.7 & prob_dem_n1n2!=.
replace pr_dem_gt70 = 1 if prob_dem_n1n2>.7 & prob_dem_n1n2!=.
la var pr_dem_gt70 "Indicator dementia prob gt 0.7"
tab pr_dem_gt70, missing

//get tables comparing mean spending at different dementia probability cutoffs
mat p50=J(16,2,.)
//first row n each group
tab pr_dem_gt50, missing matcell(r1_50)
mat p50[1,1]=r1_50[2,1] //with dem prob > 50% col 1
mat p50[1,2]=r1_50[1,1] //with dem prob < 50% col 2

//mc vars
local spvars tot_paid_by_mc_2yr_wi ip_paid_by_mc_2yr_wi snf_paid_by_mc_2yr_wi ///
hh_paid_by_mc_2yr_wi hs_paid_by_mc_2yr_wi pb_paid_by_mc_2yr_wi op_paid_by_mc_2yr_wi ///
dm_paid_by_mc_2yr_wi total_oop_24m helper_oop_24m hospital_oop_24m nh_oop_24m ///
doctor_oop_24m rx_oop_24m other_oop_24m

//total mc 2 years, wage index adjusted
local r = 2
foreach v in `spvars'{
sum `v' if pr_dem_gt50==1
mat p50[`r',1]=r(mean)
sum `v' if pr_dem_gt50==0
mat p50[`r',2]=r(mean)
local r = `r'+1
}

mat rownames p50= "N" "Total medicare" "Medicare IP" "Medicare SNF" "Medicare HH" ///
"Medicare hospice" "Medicare Carrier" "Medicare OP" "Medicare DME" ///
"OOP Total" "OOP Helper" "OOP Hospital" "OOP NH" "OOP Doctor" "OOP Other"
mat colnames p50="Prob dem > 50%" "Prob dem <=50%"

mat list p50

frmttable using `logpath'\oop_dem_initial_tables, statmat(p50) ///
title("Dementia, P=.5 cutoff, Medicare and OOP Spending") ///
note("Medicare spending totals are adjusted for the CMS wage index" \ ///
"All $ values adjusted for inflation to 2010$") ///
sdec(0) replace

//get tables comparing mean spending at different dementia probability cutoffs
mat p30=J(16,2,.)
//first row n each group
tab pr_dem_gt30, missing matcell(r1_30)
mat p30[1,1]=r1_30[2,1] //with dem prob > 50% col 1
mat p30[1,2]=r1_30[1,1] //with dem prob < 50% col 2
//total mc 2 years, wage index adjusted
local r = 2
foreach v in `spvars'{
sum `v' if pr_dem_gt30==1
mat p30[`r',1]=r(mean)
sum `v' if pr_dem_gt30==0
mat p30[`r',2]=r(mean)
local r = `r'+1
}

mat rownames p30= "N" "Total medicare" "Medicare IP" "Medicare SNF" "Medicare HH" ///
"Medicare hospice" "Medicare Carrier" "Medicare OP" "Medicare DME" ///
"OOP Total" "OOP Helper" "OOP Hospital" "OOP NH" "OOP Doctor" "OOP Other"
mat colnames p30="Prob dem > 30%" "Prob dem <=30%"

mat list p30

frmttable using `logpath'\oop_dem_initial_tables, statmat(p30) ///
title("Dementia, P=.3 cutoff, Medicare and OOP Spending") ///
note("Medicare spending totals are adjusted for the CMS wage index" \ ///
"All $ values adjusted for inflation to 2010$") ///
sdec(0) addtable

log close


H="Compare dementia to cancer and heart disease groups"
/*Compares spending for dementia patients (defined as probability of dementia = 50%)
with that of cancer, heart disease, infectious disease and sudden death (accidents, etc.)

2 sets of tables, 2 and 5 year look backs
*/

capture log close
clear all
set mem 500m
set more off

local logpath E:\data\hrs_oop_2010\logs
local datapath E:\data\hrs_oop_2010\final_data

log using `logpath'\5-mc_oop_dementia_initial-LOG.txt, text replace

cd `datapath'

//use just sample that meet 2 year criteria (full mc and oop data 2 years from death)
use oop_24mand60m_mc_add_nh.dta if (age_at_death_e>=67 & part_ab_2y==1 & hmo_2y==0  & ind_24m_oop_yes==1) 


// look at dementia probability sample sizes

gen byte dem_miss_n1 = .
replace dem_miss_n1=1 if prob_dementia_n1==.
replace dem_miss_n1=0 if prob_dementia_n1!=.

gen byte dem_miss_n2 = .
replace dem_miss_n2=1 if prob_dementia_n2==.
replace dem_miss_n2=0 if prob_dementia_n2!=.

tab dem_miss_n1 dem_miss_n2, missing

//if missing, carry forward n2 probability
gen prob_dem_n1n2 = prob_dementia_n1
replace prob_dem_n1n2=prob_dementia_n2 if prob_dementia_n1==.

//histogram prob_dem_n1n2

gen byte pr_dem_gt50 = .
replace pr_dem_gt50 = 0 if prob_dem_n1n2<=.5 & prob_dem_n1n2!=.
replace pr_dem_gt50 = 1 if prob_dem_n1n2>.5 & prob_dem_n1n2!=.
la var pr_dem_gt50 "Indicator dementia prob gt 0.5"
tab pr_dem_gt50, missing

gen byte cancer_grp = .
replace cancer_grp=1 if comorb_17_0d_n24m==1 | comorb_18_0d_n24m==1 | comorb_19_0d_n24m==1
replace cancer_grp=0 if comorb_17_0d_n24m==0 & comorb_18_0d_n24m==0 & comorb_19_0d_n24m==0
la var cancer_grp "Indicator cancer, per elix 17, 18, 19)
tab cancer_grp, missing

gen byte heartdis_grp = .
replace heartdis_grp =1 if comorb_1_0d_n24m==1 | comorb_2_0d_n24m==1 | ///
	comorb_3_0d_n24m==1  | comorb_32_0d_n24m==1 
replace heartdis_grp =0 if comorb_1_0d_n24m==0 & comorb_2_0d_n24m==0 & ///
	comorb_3_0d_n24m==0 & comorb_32_0d_n24m==0
la var heartdis_grp "Indicator heart disease, per elix 1,2,3,32)
tab heartdis_grp , missing

gen byte cause_death_sudden = 0
replace cause_death_sudden = 1 if cause_death_12_n_e==12
la var cause_death_sudden "Cause of death = Accidents, Suicide, Homicide" 
tab cause_death_sudden, missing

gen byte cause_death_inf = 0
replace cause_death_inf = 1 if cause_death_12_n_e==1
la var cause_death_inf "Cause of death = Infectious Disease (not HIV/AIDS/viral hepatitis)" 
tab cause_death_inf, missing

table pr_dem_gt50 cancer_grp heartdis_grp , contents(freq)

*****************************************************************************
//Dementia compared with cancer and heart disease, 2 year lookback
*****************************************************************************

//get tables comparing mean, median spending for different disease groups
mat dg_2y=J(20,6,.)
//first row n each group
tab pr_dem_gt50, missing matcell(r1_50)
mat dg_2y[1,1]=r1_50[2,1] //with dem prob > 50% col 1
tab cancer_grp, missing matcell(r1_c)
mat dg_2y[1,3]=r1_c[2,1] //with cancer col 2
tab heartdis_grp , missing matcell(r1_h)
mat dg_2y[1,5]=r1_h[2,1] //with heart disease col 3


//mc vars
local spvars tot_paid_by_mc_2yr_wi ip_paid_by_mc_2yr_wi snf_paid_by_mc_2yr_wi ///
hh_paid_by_mc_2yr_wi hs_paid_by_mc_2yr_wi pb_paid_by_mc_2yr_wi op_paid_by_mc_2yr_wi ///
dm_paid_by_mc_2yr_wi total_oop_24m helper_oop_24m hospital_oop_24m nh_oop_24m ///
doctor_oop_24m rx_oop_24m other_oop_24m nh_nights_24m los_snf_paid_by_mc_2y nh_ni_not_mc_24m ///
medicaid_x

//totals 2 years, wage index adjusted mc payments, oop spend and nh nights
local c=1
foreach d in pr_dem_gt50 cancer_grp heartdis_grp {
	local r = 2
	foreach v in `spvars'{
		sum `v' if `d'==1, detail
		mat dg_2y[`r',`c']=r(mean)
		mat dg_2y[`r',`c'+1]=r(p50)
		local r = `r'+1
		}
	local c = `c'+2
	}

mat rownames dg_2y= "N" "Total medicare" "Medicare IP" "Medicare SNF" "Medicare HH" ///
"Medicare hospice" "Medicare Carrier" "Medicare OP" "Medicare DME" ///
"OOP Total" "OOP Helper" "OOP Hospital" "OOP NH" "OOP Doctor" "OOP Rx" "OOP Other" ///
"Total NH nights, SR or claims" "Nights paid by Medicare" "Nights unknown payer" "Medicaid at death?"

mat colnames dg_2y="Prob dem > 50%" "median" "Cancer" "median" "Heart disease" "median" 

mat list dg_2y

frmttable using `logpath'\5-oop_dem_initial_tables, statmat(dg_2y) ///
title("Dementia, Cancer and Heart Disease Patients" \ ///
"Medicare and OOP Spending Last 2 years of life") ///
note("Medicare spending totals are adjusted for the 2010 CMS wage index" \ ///
"All $ values adjusted for inflation to 2010$")  ///
sdec(2) landscape replace 

*****************************************************************************
//Dementia compared with sudden death and infections disease, 2 year lookback
*****************************************************************************
//get tables comparing mean, median spending for different disease groups
mat dg_cd_2y=J(20,6,.)
//first row n each group
tab pr_dem_gt50, missing matcell(r1_50)
mat dg_cd_2y[1,1]=r1_50[2,1] //with dem prob > 50% col 1
tab cause_death_sudden , missing matcell(r1_s)
mat dg_cd_2y[1,3]=r1_s[2,1] //with heart disease col 3
tab cause_death_inf , missing matcell(r1_i)
mat dg_cd_2y[1,5]=r1_i[2,1] //with heart disease col 5


//totals 2 years, wage index adjusted mc payments, oop spend and nh nights
local c=1
foreach d in pr_dem_gt50 cause_death_sudden cause_death_inf{
	local r = 2
	foreach v in `spvars'{
		sum `v' if `d'==1, detail
		mat dg_cd_2y[`r',`c']=r(mean)
		mat dg_cd_2y[`r',`c'+1]=r(p50)
		local r = `r'+1
		}
	local c = `c'+2
	}

mat rownames dg_cd_2y= "N" "Total medicare" "Medicare IP" "Medicare SNF" "Medicare HH" ///
"Medicare hospice" "Medicare Carrier" "Medicare OP" "Medicare DME" ///
"OOP Total" "OOP Helper" "OOP Hospital" "OOP NH" "OOP Doctor" "OOP Rx" "OOP Other" ///
"Total NH nights, SR or claims" "Nights paid by Medicare" "Nights unknown payer" "Medicaid at death?"

mat colnames dg_cd_2y="Prob dem > 50%" "median" "Sudden death" "median" "Infect disease" "median"


mat list dg_cd_2y

frmttable using `logpath'\5-oop_dem_initial_tables, statmat(dg_cd_2y) ///
title("Dementia, Sudden death and Infectious diseases Patients" \ ///
"Medicare and OOP Spending Last 2 years of life") ///
note("Medicare spending totals are adjusted for the 2010 CMS wage index" \ ///
"All $ values adjusted for inflation to 2010$")  ///
sdec(2) landscape addtable 


******************************************************************************
//Table last 5 years spending
******************************************************************************
keep if part_ab_5y==1 & hmo_5y==0 & ind_60m_oop_yes==1

//get tables comparing mean, median spending for different disease groups
mat dg_5y=J(20,6,.)
//first row n each group
tab pr_dem_gt50, missing matcell(r2_d)
mat dg_5y[1,1]=r2_d[2,1] //with dem prob > 50% col 1
tab cancer_grp, missing matcell(r2_c)
mat dg_5y[1,3]=r2_c[2,1] //with cancer col 2
tab heartdis_grp , missing matcell(r2_h)
mat dg_5y[1,5]=r2_h[2,1] //with heart disease col 3

//mc vars
local spvars5 tot_paid_by_mc_5yr_wi ip_paid_by_mc_5yr_wi snf_paid_by_mc_5yr_wi ///
hh_paid_by_mc_5yr_wi hs_paid_by_mc_5yr_wi pb_paid_by_mc_5yr_wi op_paid_by_mc_5yr_wi ///
dm_paid_by_mc_5yr_wi total_oop_60m helper_oop_60m hospital_oop_60m nh_oop_60m ///
doctor_oop_60m rx_oop_60m other_oop_60m nh_nights_24m los_snf_paid_by_mc_2y ///
nh_ni_not_mc_24m medicaid_x

//total mc 2 years, wage index adjusted
local c=1
foreach d in pr_dem_gt50 cancer_grp heartdis_grp{
	local r = 2
	foreach v in `spvars5'{
		sum `v' if `d'==1, detail
		mat dg_5y[`r',`c']=r(mean)
		mat dg_5y[`r',`c'+1]=r(p50)
		local r = `r'+1
		}
	local c = `c'+2
	}

mat rownames dg_5y= "N" "Total medicare" "Medicare IP" "Medicare SNF" "Medicare HH" ///
"Medicare hospice" "Medicare Carrier" "Medicare OP" "Medicare DME" ///
"OOP Total" "OOP Helper" "OOP Hospital" "OOP NH" "OOP Doctor" "OOP Rx" "OOP Other" ///
"Total NH nights, SR or claims" "Nights paid by Medicare" "Nights unknown payer" "Medicaid at death?"

mat colnames dg_5y="Prob dem > 50%" "median" "Cancer" "median" "Heart disease" "median"

mat list dg_5y

frmttable using `logpath'\5-oop_dem_initial_tables, statmat(dg_5y) ///
title("Dementia, Cancer and Heart Disease Patients" \ ///
"Medicare and OOP Spending Last 5 years of life") ///
note("Medicare spending totals are adjusted for the 2010 CMS wage index" \ ///
"All $ values adjusted for inflation to 2010$" ) ///
sdec(2) landscape addtable

*****************************************************************************
//Dementia compared with sudden death and infections disease, 5 year lookback
*****************************************************************************
//get tables comparing mean, median spending for different disease groups
mat dg_cd_5y=J(20,6,.)
//first row n each group
tab pr_dem_gt50, missing matcell(r2_d)
mat dg_cd_5y[1,1]=r2_d[2,1] //with dem prob > 50% col 1
tab cause_death_sudden, missing matcell(r2_s)
mat dg_cd_5y[1,3]=r2_s[2,1] //with cancer col 2
tab cause_death_inf , missing matcell(r2_i)
mat dg_cd_5y[1,5]=r2_i[2,1] //with heart disease col 3


//total mc 2 years, wage index adjusted
local c=1
foreach d in pr_dem_gt50 cause_death_sudden cause_death_inf{
	local r = 2
	foreach v in `spvars5'{
		sum `v' if `d'==1, detail
		mat dg_cd_5y[`r',`c']=r(mean)
		mat dg_cd_5y[`r',`c'+1]=r(p50)
		local r = `r'+1
		}
	local c = `c'+2
	}

mat rownames dg_cd_5y= "N" "Total medicare" "Medicare IP" "Medicare SNF" "Medicare HH" ///
"Medicare hospice" "Medicare Carrier" "Medicare OP" "Medicare DME" ///
"OOP Total" "OOP Helper" "OOP Hospital" "OOP NH" "OOP Doctor" "OOP Rx" "OOP Other" ///
"Total NH nights, SR or claims" "Nights paid by Medicare" "Nights unknown payer" "Medicaid at death?"

mat colnames dg_cd_5y="Prob dem > 50%" "median" "Sudden death" "median" "Infect disease" "median"

mat list dg_cd_5y

frmttable using `logpath'\5-oop_dem_initial_tables, statmat(dg_cd_5y) ///
title("Dementia, Sudden death and Infectious diseases Patients" \ ///
"Medicare and OOP Spending Last 5 years of life") ///
note("Medicare spending totals are adjusted for the 2010 CMS wage index" \ ///
"All $ values adjusted for inflation to 2010$" ) ///
sdec(2) landscape addtable


log close

