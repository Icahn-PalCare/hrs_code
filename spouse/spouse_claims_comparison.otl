= V4 Outline MultiLine NoSorting TabWidth=30

H="spouse claims comparison"

/*data from spouse_2012.txt code - starting point for this work*/
libname spo_fnl 'E:\data\spouse_intensive\int_data';

/*data for this project with spouse medicare variables added in*/
libname proj_int 'E:\data\spouse_claims\spouse_claims_comparison\int_data';
libname proj_fnl 'E:\data\spouse_claims\spouse_claims_comparison\final_data';

/*2000-2012 medicare claims*/
libname medi 'E:\data\cms_DUA_24548_2012';

/*hrs cleaned & restricted*/
libname hrs_cln 'E:\data\hrs_cleaned'; /*(contains exit, restricted, and core ivw's)*/
libname rand 'E:\data\hrs_public_2012\rand2012\main';

/*dartmouth wage index*/
libname dartm 'E:\data\Dartmouth_misc';
libname dart_wi 'E:\data\Dartmouth_misc\Wage Index';



H="gen ffs at ivw for everyone"
/*determine Spouse ffs medicare before R's death using the 
claims denominator files

Several sets of variables created, looking back 6m, 12m, 18m, 24m from R's death

Also pulls in spouse date of death where available in the claims s_claims_dod*/

/*sort claims denominator file*/

data hrs(keep=id hhid pn c_ivw_date c_ivw_year c_ivw_month core_year);
set hrs_cln.core_00_to_12;
run;

proc sort data=hrs nodupkey;
by id core_year;
run;
/*prepare xwalk id file to merge*/
data crosswalk_1;
set medi.cmsxref2012;
keep bid_hrs_21 hhid pn;
run;

proc sql; 
create table index2 as select *
from hrs a 
left join
crosswalk_1 b
on a.hhid=b.hhid and a.pn=b.pn;
quit;



proc sort data=medi.dn_2000_2012 out=dn  nodupkey;
by bid_hrs_21 year;
run;



/*get dn just for interview year*/

proc sql; 
create table dn_c_ivw_year as select
a.*,b.buyin12,b.year,b.hmoind12
from index2 a inner join
dn b
on trim(left(a.bid_hrs_21))=trim(left(b.bid_hrs_21)) 
and a.c_ivw_year=b.year;
quit;

proc sql;
select count(distinct bid_hrs_21) from dn_c_ivw_year;
quit;



data dn_c_ivw_year2;
set dn_c_ivw_year;
if length(trim(left(buyin12)))=12 and c_ivw_month>0 then do;
buyin_im=substr(trim(left(buyin12)),c_ivw_month,1);
hmo_im=substr(trim(left(HMOIND12)),c_ivw_month,1);
end;
else do;
buyin_im=trim(left(buyin12));
hmo_im=trim(left(HMOIND12));
end;
/*create length of continous a&b and non-hmo coverage vars*/
if indexc(buyin_im,"0","1","2","A","B")=0 then part_ab=1;
if indexc(buyin_im,"0","1","2","A","B") then part_a=0;
if indexc(hmo_im,"1","2","4","A","B","C")=0 then hmo=0;
if indexc(hmo_im,"1","2","4","A","B","C") then hmo=1;
ffs_at_ivw=part_ab=1 and hmo=0;
run;

proc export data=dn_c_ivw_year2 outfile="E:\data\spouse_claims\spouse_claims_comparison\int_data\ffs_status_all_ivws.dta" replace; run;

H="match cem"
capture log close
use "E:\data\hrs_public_2012\rand2012\family\StataSE\rndfamr_c.dta", clear
keep hhidpn s*hhidpn hhid pn
rename s*hhidpn shhidpn* 
reshape long shhidpn , i(hhidpn) j(round)
gen core_year=round*2+1990
rename hhidpn r_id
rename shhidpn s_id
sort r_id core_year
/*xtset r_id core_year, delta(2)
replace s_id=L.s_id if L.s_id==F.s_id & missing(s_id)*/
gen knownspouse=s_id & !missing(s_id)
keep if core_year>=1998
drop round
tempfile temp1
keep if knownspouse
rename (hhid pn) (r_hhid r_pn)
save `temp1'
drop s* knownspouse
rename (r_id r_hhid r_pn) (s_id s_hhid s_pn)
merge 1:m s_id core_year using `temp1',  keep(match)
replace r_id=s_id if missing(r_id) 
replace s_id=. if !knownspouse
drop r_id s_id
gen r_id =r_hhid+r_pn
gen s_id=s_hhid+s_pn
tempfile temp1 
save `temp1'
use "E:\data\serious_ill\int_data\core_ids_1yr_criteria_5.dta" if xwalk_yes==1, clear
replace hseduc=degre>0 
replace hseduc=. if degree==9
//get cesd, will be used for outcome in pscore
replace cesd_tot=2 if missing(cesd_tot)
sort id core_year
by id: gen cesd_tot_p1=cesd_tot[_n+1]
replace female=gender-1 if female==.
replace hisp=hisp_eth if hisp_eth!=.
gen region=inlist(state_wave,"CT","ME","MA","NH","RI","VT","NJ","NY","PA")
replace region=2 if inlist(state_wave,"IN","IL","MI","OH","WI" ) | ///
inlist(state_wave,"IA","KS","MN","MO","NE","ND","SD")
replace region=3 if inlist(state_wave,"DE","DC","FL","GA","MD","SC","NC") | ///
inlist(state_wave,"VA","WV","AL","KY","MS","TN") 
replace region=3 if inlist(state_wave,"AR","LA","OK","TX")
replace region=4 if inlist(state_wave,"AZ","CO","ID","NM","MT") | ///
inlist(state_wave,"UT","NV","WY","AK","CA","HI","OR","WA")
gen northeast=region==1
gen midwest=region==2
gen south=region==3
gen west=region==4


gen age_cat=1 if age_at_core<=70
replace age_cat=2 if age_at<=75 & age_cat==.
replace age_cat=3 if age_at<=80 & age_cat==.
replace age_cat=4 if age_at<=85 & age_cat==.
replace age_cat=5 if age_at<=90 & age_cat==.
replace age_cat=6 if age_at>=90 & age_cat==.
*replace age_cat=7 if age_at>95 & age_cat==.
tab age_cat, gen(age_cat)
tab comor_c, gen(comorb_cat)
replace comorb_cat3=1 if comorb_cat4==1
local matchvars age_cat female white black hisp adl_independent_core ///
srh_pf srh_g srh_ve nw_quartile_65 region northeast midwest south west ///
age_cat1 age_cat2 age_cat3 age_cat4 age_cat5 age_cat6 nhres hseduc

local comorb cancer_hrs lung_hrs heart_hrs chf_hrs stroke_hrs memory_hrs ///
htn_hrs dm_hrs psych_hrs 

merge m:1 id using "E:\data\hrs_cleaned\death_date_2012.dta", ///
keepusing(death_all) keep(match master) nogen
rename death_all r_death_date
gen r_death_year=year(r_death_date)
*destring id, gen(r_id)
rename id r_id 
gen adl_iadl_sp_helper=adl_sp_helper | iadl_sp_helper
label var adl_iadl_sp "Spouse is main ADL or IADL helper"
gen comorb_index=0
foreach x in `comorb' {
	replace comorb_index=comorb_index+1 if `x'==1
}


//get last core year
by r_id, sort: egen lcd=max(c_ivw_date)
sort r_id core_year
by r_id: gen ncd=c_ivw_date[_n+1]
local comorb cancer_hrs lung_hrs heart_hrs chf_hrs stroke_hrs memory_hrs ///
htn_hrs dm_hrs psych_hrs comorb_cat1 comorb_cat2 comorb_cat3 adl_iadl_sp_helper ///
cesd_tot medicaid medigap champus networth_adj adl_impair ///

keep r_id c_ivw_* core_year lcd `matchvars' `comorb' age_at_core ressp ///
comor_c_hrs cesd_tot* r_death* comorb_index ncd

foreach x in `matchvars' `comorb' ncd lcd comorb_index comor_c_hrs age_at_core c_ivw_date ///
c_ivw_month c_ivw_year ressp {
	rename `x' r_`x'
}
describe
tempfile temp2
save `temp2'
rename r_* s_*
tempfile temp3
save `temp3'
use `temp1', clear
merge 1:1 r_id core_year using `temp2', keep(match) gen(rmatch)
merge 1:1 s_id core_year using `temp3', keep(match) gen(smatch)
drop if s_age_at_core<65
*keep if r_ressp==1 & s_ressp==1
/*gen id=r_hhid+r_pn
merge m:1 id using "E:\data\hrs_cleaned\death_date_2012.dta", ///
keepusing(death_all) keep(match master) nogen
rename death_all r_death_date
replace id=s_hhid+s_pn
merge m:1 id using "E:\data\hrs_cleaned\death_date_2012.dta", ///
 keepusing(death_all) keep(match master) nogen
drop id
rename death_all s_death_date
gen s_death_year=year(s_death_date)*/
sort r_id core_year
gen survives_spouse=r_death_date<s_death_date if r_death_date!=.
drop if s_death_date<s_c_ivw_date | r_death_date<s_c_ivw_date
gen cy=core_year if s_c_ivw_date<r_death_date & !missing(r_death_date)
by r_id s_id, sort: egen lcy=max(cy)
gen ind_n1_ivw=core_year==lcy
replace ind_n1_ivw=0 if survives==0
replace ind_n1_ivw=0 if s_ncd<r_death_date
drop *lcd cy lcy *ncd
/*
tempfile temp1
save `temp1'
keep id
duplicates drop*/
gen n=1

foreach x in r s {
	foreach y in `matchvars' `comorb' {
		local match `match' `x'_`y'
}
}
di "`match'"
sum `match'
foreach x in `match' {
qui sum n if `x'==.
if r(N)>0 {
di "`x'"
di r(N)
}
}




gen sagecat=floor((s_age_at_core-65)/5)+1
replace sagecat=6 if sagecat>6
gen ragecat=floor((r_age_at_core-65)/5)+1
replace ragecat=6 if ragecat>6

*preserve
local match /*r_comorb_cat1 r_comorb_cat2 r_comorb_cat3 r_adl_independent_core ///
r_srh_pf r_srh_g r_srh_ve */s_age_cat1 s_age_cat2 s_age_cat3 s_age_cat4 s_age_cat5 s_age_cat6 ///
s_comorb_cat1 s_comorb_cat2 s_comorb_cat3  ///
s_female s_black s_hisp s_adl_independent_core s_srh_pf s_srh_g ///
s_srh_ve 
/*
local match r_age_cat ///
r_comorb_cat1 r_comorb_cat2 r_comorb_cat3 ///
r_female r_black r_hisp r_adl_independent_core ///
r_srh_pf r_age_cat ///
s_comorb_cat1 s_comorb_cat2 s_comorb_cat3  ///
s_adl_independent_core s_srh_pf 
*/
tab s_nw_q, gen(nw)
local match r_age_cat2 r_age_cat3 r_age_cat4 r_age_cat5 r_age_cat6 /// 
 r_comorb_cat1 r_comorb_cat2 r_comorb_cat3  r_adl_independent_core ///
r_srh_pf r_srh_g r_srh_ve s_age_cat2 s_age_cat3 s_age_cat4 s_age_cat5 s_age_cat6 ///
nw2 nw3 nw4 s_comorb_cat1 s_comorb_cat2 s_comorb_cat3  ///
s_female s_black s_hisp s_adl_independent_core s_srh_pf s_srh_g ///
s_srh_ve r_nhres s_nhres r_adl_iadl_sp_helper r_cesd_tot s_cesd_tot

local match r_comorb_cat1 r_comorb_cat2 r_comorb_cat3  r_adl_independent_core ///
r_srh_pf  s_age_at_core ///
nw1 s_comorb_cat2 s_comorb_cat3  ///
s_female s_black s_hisp s_adl_independent_core s_srh_pf ///
r_nhres s_nhres r_adl_iadl_sp_helper r_cesd_tot s_cesd_tot

gen blackhisp=s_black==1 | s_hisp==1

local match r_age_at_core r_comorb_cat2 r_comorb_cat3 r_adl_independent_core ///
r_srh_g r_srh_v s_age_at_core ///
nw2 nw3 nw4 s_comorb_cat2 s_comorb_cat3 ///
s_female s_black s_hisp s_adl_independent_core s_srh_g s_srh_v ///
r_nhres r_adl_iadl_sp_helper r_cesd_tot s_cesd_tot s_nhres
/*cem `match' core_year(#0), treatment(ind_n1_ivw)
*pstest `match' `region' core_year, treated(ind_) both mweight(cem_we) support(cem_matched)


cem r_age_at_core (75 85) r_comorb_cat2 r_comorb_cat3 r_adl_independent_core ///
r_srh_g r_srh_v s_age_at_core (75 85) ///
nw2 nw3 nw4 s_comorb_cat2 s_comorb_cat3 ///
s_female s_black s_hisp s_adl_independent_core s_srh_g s_srh_v ///
r_nhres r_adl_iadl_sp_helper r_cesd_tot s_cesd_tot s_nhres, treatment(ind_n1_ivw)

*pstest `match' `region' core_year, treated(ind_) both mweight(cem_we) support(cem_matched)
cem r_age_at_core (75 85) s_age_at_core (75 85)  ///
s_comorb_cat2 s_comorb_cat3 r_comorb_cat2 r_comorb_cat3 ///
r_srh_pf s_srh_pf nw1 s_female s_black s_hisp s_adl_independent_core ///
r_nhres s_nhres r_adl_iadl_sp_helper r_cesd_tot (2.5) s_cesd_tot (2.5) ///
 core_year(#0), treatment(ind_n1_ivw)
 
*pstest `match' `region' core_year, treated(ind_) both mweight(cem_we) support(cem_matched)

cem r_age_at_core (75 85) s_age_at_core (75 85)  ///
s_comorb_cat2 s_comorb_cat3 r_comorb_cat2 r_comorb_cat3 ///
r_srh_pf s_srh_pf nw1 s_female s_black s_hisp s_adl_independent_core ///
/*r_nhres s_nhres*/ r_adl_iadl_sp_helper r_cesd_tot (2.5) s_cesd_tot (2.5) ///
 core_year(#0), treatment(ind_n1_ivw)
*/log using "E:\data\spouse_claims\logs\CEM_`c(current_date)'.txt", text replace

gen s_core_year_n1=core_year
destring s_id, replace
merge 1:1 s_id s_core_year_n1 using "E:\data\spouse_claims\data\int_data\spouse_claims_v1.dta", ///
keep(match master) gen(spm) keepusing(*ffs* s_part_ab* s_hmo*)
//1515 remain after excluding those w/o ffs at r death date
drop if ind_==1 & spm==1

/*cem sagecat (#0) r_adl_independent s_comorb_cat2 s_comorb_cat3 ///
s_hseduc s_female s_black s_hisp ///
r_comorb_cat2 r_comorb_cat3 core_year(#0) ,treatment(ind_)

cem sagecat (#0) ragecat (#0) r_adl_independent s_comorb_cat2 s_comorb_cat3 ///
s_hseduc s_female s_black s_hisp ///
r_comorb_cat2 r_comorb_cat3 core_year(#0) ,treatment(ind_)
keep if core_year>=2000
 *pstest `match' core_year, both treated(ind_) mweight(cem_w) support(cem_m)
*/
cem s_age_at_core (54.5 64.5 74.5 84.5) r_age_at_core (54.5 64.5 74.5 84.5) ///
r_adl_independent s_comorb_cat2 s_comorb_cat3 ///
s_hseduc s_female s_black s_hisp ///
r_comorb_cat2 r_comorb_cat3 core_year(#0) ,treatment(ind_)

set seed 95
gen sort2=rnormal()
sort cem_strata ind_ sort2
by cem_strata ind_: gen obsnum=_n
by cem_strata ind_: gen ncs=_N if !ind_
by cem_strata ind_: gen nss=_N if ind_
by cem_strata: egen n_controls=max(ncs)
by cem_strata: egen n_survivingspouses=max(nss)
gen cpers=n_controls/n_surv
gen matchid=round(obsnum)
replace matchid=floor((obsnum/cpers)+.0001) if !ind_ & cpers>1
replace matchid=1 if matchid==0
replace matchid=ceil(obsnum*cpers) if !ind_ & cpers<1
gen rdd=r_death_date if ind_ & cem_matched==1
by cem_strata matchid, sort: egen index_date=max(rdd)
gen index_month=month(index_date)
gen index_year=year(index_date)
replace index_date=. if s_death_date<index_date
replace index_date=. if s_c_ivw_date<index_date
log close
saveold  "E:\data\spouse_claims\spouse_claims_comparison\int_data\spouse_cem1.dta", replace


H="get index date"
/*Import Matched sample info*/
proc import datafile="E:\data\spouse_claims\spouse_claims_comparison\int_data\spouse_cem1.dta" out=spouse replace; run;

data proj_int.spouse1;
set spouse;
run;

data index1 (keep=s_id s_hhid s_pn index_date index_month index_year);
set proj_int.spouse1;
if cem_matched=1;
run;

/*prepare xwalk id file to merge*/
data crosswalk_1;
set medi.cmsxref2012;
keep bid_hrs_21 hhid pn;
run;

proc sql; 
create table index2 as select *
from index1 a 
left join
crosswalk_1 b
on a.s_hhid=b.hhid and a.s_pn=b.pn;
quit;

data proj_int.index;
set index2;
run;

H="continuous ffs before"
/*determine Spouse ffs medicare before R's death using the 
claims denominator files

Several sets of variables created, looking back 6m, 12m, 18m, 24m from R's death

Also pulls in spouse date of death where available in the claims s_claims_dod*/

/*sort claims denominator file*/

proc sort data=medi.dn_2000_2012 out=dn  nodupkey;
by bid_hrs_21 year;
run;

proc sort data=proj_int.index out=index1 nodupkey;
by bid_hrs_21 index_date;
run;

/*get dn just for interview year*/

proc sql; 
create table dn_index_year as select
a.*,b.buyin12,b.year,b.hmoind12
from index1 a inner join
dn b
on trim(left(a.bid_hrs_21))=trim(left(b.bid_hrs_21)) 
and a.index_year=b.year;
quit;


proc sql;
select count(distinct bid_hrs_21) from dn_index_year;
quit;



data dn_index_year2;
set dn_index_year;
if length(trim(left(buyin12)))=12 and index_month>0 then do;
buyin_iy=substr(trim(left(buyin12)),1,index_month);
hmo_iy=substr(trim(left(HMOIND12)),1,index_month);
end;
else do;
buyin_iy=trim(left(buyin12));
hmo_iy=trim(left(HMOIND12));
end;
buyin_im=substr(trim(left(buyin12)),index_month,1);
hmo_im=substr(trim(left(HMOIND12)),index_month,1);
format index_date date9.;
run;
proc means n;
var index_month;
run;

proc sql;
create table dn_index_year_bef as select
a.bid_hrs_21,a.index_date,a.year as index_year,
b.year as index_year_bef,
b.year, b.buyin12,b.HMOIND12
from dn_index_year a inner join
dn b
on trim(left(a.bid_hrs_21))=trim(left(b.bid_hrs_21))
and 0<a.year-b.year<=1 order by bid_hrs_21,year;
quit;


/* and the year before... 1922 have the -2 year dn file*/
proc sql;
create table dn_index_year_2bef as select
a.bid_hrs_21,a.index_date,a.index_year,a.index_year_bef,
b.year as index_year_2bef,
b.year,b.buyin12,b.HMOIND12
from dn_index_year_bef a inner join
dn b
on trim(left(a.bid_hrs_21))=trim(left(b.bid_hrs_21))
and 0<a.index_year_bef-b.year<=1 order by bid_hrs_21,year;
quit;

/*merge the insurance data for death year, -1 and -2 years into single dataset*/
proc sql;
create table all_insurance as select a.*,b.buyin12 as buyin_bef,b.HMOIND12 as hmo_bef from
dn_index_year2 a
left join
dn_index_year_bef b
on trim(left(a.bid_hrs_21))=trim(left(b.bid_hrs_21)) and a.index_date=b.index_date;
quit;

proc sql;
create table all_insurance2 as select a.*,b.buyin12 as buyin_2bef,b.HMOIND12 as hmo_2bef from
all_insurance a
left join
dn_index_year_2bef b
on trim(left(a.bid_hrs_21))=trim(left(b.bid_hrs_21)) and a.index_date=b.index_date; 
quit;


/*merge death year and year before death buy-in and hmo variables
Trim so the final variable _6m is 6 months pre-death
Note: indicator variables for parts a and b and hmo are null if don't
have information for full 6 months pre-death*/
data all_insurance3;
set all_insurance2;
buyin_2y=trimn(left(buyin_2bef))||trimn(left(buyin_bef))||trimn(left(buyin_iy));
hmo_2y=trimn(left(hmo_2bef))||trimn(left(hmo_bef))||trimn(left(hmo_iy));

buyin_2y_r=reverse(trim(buyin_2y));
hmo_2y_r=reverse(trim(hmo_2y));


/*create length of continous a&b and non-hmo coverage vars*/
if indexc(buyin_2y_r,"0","1","2","A","B")=0 then part_ab_n_mos=length(buyin_2y_r)-1;
if indexc(buyin_2y_r,"0","1","2","A","B") then part_ab_n_mos=indexc(buyin_2y_r,"0","1","2","A","B")-1;
if indexc(hmo_2y_r,"1","2","4","A","B","C")=0 then non_hmo_d_n_mos=length(hmo_2y_r)-1;
if indexc(hmo_2y_r,"1","2","4","A","B","C") then non_hmo_d_n_mos=indexc(hmo_2y_r,"1","2","4","A","B","C")-1;
if indexc(buyin_im,"0","1","2","A","B")=1 then part_ab_at_index_dt=0;
if indexc(buyin_im,"0","1","2","A","B")=0 then part_ab_at_index_dt=1;
if indexc(hmo_im,"1","2","4","A","B","C")=1 then hmo_d_at_index_dt=1;
if indexc(hmo_im,"1","2","4","A","B","C")=0 then hmo_d_at_index_dt=0;
if part_ab_n_mos<=non_hmo_d_n_mos then cont_ffs_n_mos=part_ab_n_mos;
if non_hmo_d_n_mos<part_ab_n_mos then cont_ffs_n_mos=non_hmo_d_n_mos;
run;


data proj_int.ffs_before;
set all_insurance3;
run;


H="continuous ffs after"
/*determine Spouse ffs medicare before R's death using the 
claims denominator files

Several sets of variables created, looking back 6m, 12m, 18m, 24m from R's death

Also pulls in spouse date of death where available in the claims s_claims_dod*/

/*sort claims denominator file*/

proc sort data=medi.dn_2000_2012 out=dn  nodupkey;
by bid_hrs_21 year;
run;

proc sort data=proj_int.index out=index1 nodupkey;
by bid_hrs_21 index_date;
run;

/*get dn just for interview year*/

proc sql; 
create table dn_index_year as select
a.*,b.buyin12,b.year,b.hmoind12
from index1 a inner join
dn b
on trim(left(a.bid_hrs_21))=trim(left(b.bid_hrs_21)) 
and a.index_year=b.year;
quit;


proc sql;
select count(distinct bid_hrs_21) from dn_index_year;
quit;



data dn_index_year2;
set dn_index_year;
if length(trim(left(buyin12)))=12 and index_month>0 then do;
buyin_iy=substr(trim(left(buyin12)),index_month,13-index_month);
hmo_dy=substr(trim(left(HMOIND12)),index_month,13-index_month);
buyin_at_death=substr(trim(left(buyin12)),index_month,1);
hmo_at_death=substr(trim(left(HMOIND12)),index_month,1);
end;
else do;
buyin_iy=trim(left(buyin12));
hmo_iy=trim(left(HMOIND12));
end;
format index_date date9.;
run;
proc means n;
var index_month;
run;


proc sql;
create table dn_index_year_aft as select
a.bid_hrs_21,a.bid_hrs_21,a.index_date,a.year as index_year,
b.year as index_year_aft,
b.year,b.buyin12,b.HMOIND12
from dn_index_year a inner join
dn b
on trim(left(a.bid_hrs_21))=trim(left(b.bid_hrs_21))
and a.year-b.year=-1 order by bid_hrs_21,year;
quit;


/* and the year aftore... 1790 have the +2 year dn file*/
proc sql;
create table dn_index_year_2aft as select
a.bid_hrs_21,a.index_date,a.index_year,a.index_year_aft,
b.year as index_year_2aft,
b.year,b.buyin12,b.HMOIND12
from dn_index_year_aft a inner join
dn b
on trim(left(a.bid_hrs_21))=trim(left(b.bid_hrs_21))
and a.index_year_aft-b.year=-1 order by bid_hrs_21,year;
quit;

/*merge the insurance data for death year, +1 and +2 years into single dataset*/
proc sql;
create table all_insurance as select a.*,b.buyin12 as buyin_aft,b.HMOIND12 as hmo_aft from
dn_index_year2 a
left join
dn_index_year_aft b
on trim(left(a.bid_hrs_21))=trim(left(b.bid_hrs_21)) and a.index_date=b.index_date;
quit;

proc sql;
create table all_insurance2 as select a.*,b.buyin12 as buyin_2aft,b.HMOIND12 as hmo_2aft from
all_insurance a
left join
dn_index_year_2aft b
on trim(left(a.bid_hrs_21))=trim(left(b.bid_hrs_21)) and a.index_date=b.index_date;
quit;


/*merge death year and year aftore death buy-in and hmo variables
Trim so the final variable _p6m is 6 months post-death
Note: indicator variables for parts a and b and hmo are null if don't
have information for full 6 months post-death*/
data all_insurance3;
set all_insurance2;
buyin_2y=trimn(left(buyin_iy))||trimn(left(buyin_aft))||trimn(left(buyin_2aft));
hmo_2y=trimn(left(hmo_dy))||trimn(left(hmo_aft))||trimn(left(hmo_2aft));

/*create length of continous a&b and non-hmo coverage vars*/
if indexc(buyin_2y,"0","1","2","A","B")=0 then part_ab_p_mos=length(buyin_2y);
if indexc(buyin_2y,"0","1","2","A","B") then part_ab_p_mos=indexc(buyin_2y,"0","1","2","A","B");
if indexc(hmo_2y,"1","2","4","A","B","C")=0 then non_hmo_d_p_mos=length(hmo_2y);
if indexc(hmo_2y,"1","2","4","A","B","C") then non_hmo_d_p_mos=indexc(hmo_2y,"1","2","4","A","B","C");
if indexc(buyin_at_death,"0","1","2","A","B")=1 then part_ab_at_death=0;
if indexc(buyin_at_death,"0","1","2","A","B")=0 then part_ab_at_death=1;
if indexc(hmo_at_death,"1","2","4","A","B","C")=1 then hmo_d_at_death=1;
if indexc(hmo_at_death,"1","2","4","A","B","C")=0 then hmo_d_at_death=0;

if part_ab_p_mos<=non_hmo_d_p_mos then cont_ffs_p_mos=part_ab_p_mos;
if non_hmo_d_p_mos<part_ab_p_mos then cont_ffs_p_mos=non_hmo_d_p_mos;
run;

data proj_int.ffs_after;
set all_insurance3;
run;

H="get claims before & after"
proc sort data=proj_int.index out=index1 nodupkey;
by bid_hrs_21 s_id index_date;
run;




/**************************************************************************/
/* ************** S Claims Before R's Death  ******************************/
/**************************************************************************/
/*macro to get claims before death
saves datasets for each claim type / time window to the spo_mc_i directory*/
%macro claims(days_start=,days_bef_index=,source=,suf=);

/*claims fully within x time of death date*/
proc sql;
create table &source._meet_1 as select a.*,b.index_date,b.s_id 
from medi.&source._2000_2012 a inner join
index1 b
on trim(left(a.bid_hrs_21))=trim(left(b.bid_hrs_21))
and &days_start<=b.index_date-a.admit_date<=&days_bef_index ;
quit;

/*claims that start earlier than x time but span into x time before death*/
proc sql;
create table &source._meet_2 as select a.*,b.index_date,b.s_id 
from medi.&source._2000_2012 a inner join
index1 b
on trim(left(a.bid_hrs_21))=trim(left(b.bid_hrs_21))
and b.index_date-a.admit_date>&days_bef_index and b.index_date-a.disch_date<=&days_bef_index;
quit;

data proj_int.&source._meet_&suf.(compress=yes);
set &source._meet_1 &source._meet_2;
run;
%mend;

/*6m before death*/
*%claims(days_start=0,days_bef_index=183,source=hh,suf=6m); /*home health*/
*%claims(days_start=0,days_bef_index=183,source=hs,suf=6m); /*hospice*/
*%claims(days_start=0,days_bef_index=183,source=mp,suf=6m); /*medpar*/
*%claims(days_start=0,days_bef_index=183,source=dm,suf=6m); /*dme*/
*%claims(days_start=0,days_bef_index=183,source=op,suf=6m); /*outpatient*/
*%claims(days_start=0,days_bef_index=183,source=pb,suf=6m); /*carrier*/
/*12m before death*/
%claims(days_start=0,days_bef_index=365,source=hh,suf=12m); /*home health*/
%claims(days_start=0,days_bef_index=365,source=hs,suf=12m); /*hospice*/
%claims(days_start=0,days_bef_index=365,source=mp,suf=12m); /*medpar*/
%claims(days_start=0,days_bef_index=365,source=dm,suf=12m); /*dme*/
%claims(days_start=0,days_bef_index=365,source=op,suf=12m); /*outpatient*/
%claims(days_start=0,days_bef_index=365,source=pb,suf=12m); /*carrier*/
/*18m before death*/
*%claims(days_start=0,days_bef_index=548,source=hh,suf=18m); /*home health*/
*%claims(days_start=0,days_bef_index=548,source=hs,suf=18m); /*hospice*/
*%claims(days_start=0,days_bef_index=548,source=mp,suf=18m); /*medpar*/
*%claims(days_start=0,days_bef_index=548,source=dm,suf=18m); /*dme*/
*%claims(days_start=0,days_bef_index=548,source=op,suf=18m); /*outpatient*/
*%claims(days_start=0,days_bef_index=548,source=pb,suf=18m); /*carrier*/
/*run for 24m before death*/
%claims(days_start=0,days_bef_index=365*2,source=hh,suf=24m); /*home health*/
%claims(days_start=0,days_bef_index=365*2,source=hs,suf=24m); /*hospice*/
%claims(days_start=0,days_bef_index=365*2,source=mp,suf=24m); /*medpar*/
%claims(days_start=0,days_bef_index=365*2,source=dm,suf=24m); /*dme*/
%claims(days_start=0,days_bef_index=365*2,source=op,suf=24m); /*outpatient*/
%claims(days_start=0,days_bef_index=365*2,source=pb,suf=24m); /*carrier*/

/**************************************************************************/
/* ************** S Claims After R's Death   ******************************/
/**************************************************************************/
/*macro to get claims after death
saves datasets for each claim type / time window to the spo_mc_i directory*/
%macro claims(days_start=,days_aft_index=,source=,suf=);

/*claims fully within x time of death date*/
proc sql;
create table &source._meet_1 as select a.*,b.index_date,b.s_id 
from medi.&source._2000_2012 a inner join
index1 b
on trim(left(a.bid_hrs_21))=trim(left(b.bid_hrs_21))
and &days_start<=a.admit_date - b.index_date<=&days_aft_index ;
quit;

/*claims that start earlier than R's DOD but span after R's death*/
proc sql;
create table &source._meet_2 as select a.*,b.index_date,b.s_id 
from medi.&source._2000_2012 a inner join
index1 b
on trim(left(a.bid_hrs_21))=trim(left(b.bid_hrs_21))
and a.admit_date<b.index_date
and &days_start<=a.disch_date - b.index_date;
quit;

data proj_int.&source._meet_&suf.(compress=yes);
set &source._meet_1 &source._meet_2;
format disch_date date9.;
format admit_date date9.;
run;
%mend;

/*6m after death*/
*%claims(days_start=0,days_aft_index=183,source=hh,suf=p6m); /*home health*/
*%claims(days_start=0,days_aft_index=183,source=hs,suf=p6m); /*hospice*/
*%claims(days_start=0,days_aft_index=183,source=mp,suf=p6m); /*medpar*/
*%claims(days_start=0,days_aft_index=183,source=dm,suf=p6m); /*dme*/
*%claims(days_start=0,days_aft_index=183,source=op,suf=p6m); /*outpatient*/
*%claims(days_start=0,days_aft_index=183,source=pb,suf=p6m); /*carrier*/
/*12m before death*/
%claims(days_start=0,days_aft_index=365,source=hh,suf=p12m); /*home health*/
%claims(days_start=0,days_aft_index=365,source=hs,suf=p12m); /*hospice*/
%claims(days_start=0,days_aft_index=365,source=mp,suf=p12m); /*medpar*/
%claims(days_start=0,days_aft_index=365,source=dm,suf=p12m); /*dme*/
%claims(days_start=0,days_aft_index=365,source=op,suf=p12m); /*outpatient*/
%claims(days_start=0,days_aft_index=365,source=pb,suf=p12m); /*carrier*/
/*18m before death*/
*%claims(days_start=0,days_aft_index=548,source=hh,suf=p18m); /*home health*/
*%claims(days_start=0,days_aft_index=548,source=hs,suf=p18m); /*hospice*/
*%claims(days_start=0,days_aft_index=548,source=mp,suf=p18m); /*medpar*/
*%claims(days_start=0,days_aft_index=548,source=dm,suf=p18m); /*dme*/
*%claims(days_start=0,days_aft_index=548,source=op,suf=p18m); /*outpatient*/
*%claims(days_start=0,days_aft_index=548,source=pb,suf=p18m); /*carrier*/
/*run for 24m before death*/
%claims(days_start=0,days_aft_index=365*2,source=hh,suf=p24m); /*home health*/
%claims(days_start=0,days_aft_index=365*2,source=hs,suf=p24m); /*hospice*/
%claims(days_start=0,days_aft_index=365*2,source=mp,suf=p24m); /*medpar*/
%claims(days_start=0,days_aft_index=365*2,source=dm,suf=p24m); /*dme*/
%claims(days_start=0,days_aft_index=365*2,source=op,suf=p24m); /*outpatient*/
%claims(days_start=0,days_aft_index=365*2,source=pb,suf=p24m); /*carrier*/

/**************************************************************************/
/* ********************* S Diagnosis Lists   ******************************/
/**************************************************************************/

%macro dx_time_range(range1=, range2=, suf=);
/*pulls just dx codes from carrier claims*/
data pb_last_&range2._dx(keep=bid_hrs_21 s_id diag index_date);
set proj_int.pb_meet_&suf.(keep=bid_hrs_21 s_id PDGNS_CD DGNSCD01-DGNSCD12 index_date);
array dx PDGNS_CD DGNSCD01-DGNSCD12;
do over dx;
diag=dx ;
output;
end;
run;
proc sort data=pb_last_&range2._dx out=pb_last_&range2._dx2 nodupkey;
by bid_hrs_21 s_id index_date diag;
run;

/*outpatient claims*/
data op_last_&range2._dx(keep=bid_hrs_21 s_id diag index_date);
set proj_int.op_meet_&suf.(keep=bid_hrs_21 s_id PDGNS_CD DGNSCD01-DGNSCD25  index_date);
array dx PDGNS_CD DGNSCD01-DGNSCD25 ;
do over dx;
diag=dx ;
output;
end;
run;
proc sort data=op_last_&range2._dx out=op_last_&range2._dx2 nodupkey;
by bid_hrs_21 s_id index_date diag;
run;

/*medpar claims*/
data mp_last_&range2._dx(keep=bid_hrs_21 s_id diag index_date);
set proj_int.mp_meet_&suf.(keep=bid_hrs_21 s_id AD_DGNS DGNS_CD01-DGNS_CD25 index_date );
array dx D_DGNS DGNS_CD01-DGNS_CD25 ;
do over dx;
diag=dx ;
output;
end;
run;
proc sort data=mp_last_&range2._dx out=mp_last_&range2._dx2 nodupkey;
by bid_hrs_21 s_id index_date diag;
run;

/*dme claims*/
data dm_last_&range2._dx(keep=bid_hrs_21 s_id diag index_date);
set proj_int.dm_meet_&suf.(keep=bid_hrs_21 s_id PDGNS_CD DGNSCD01-DGNSCD12 index_date);
array dx PDGNS_CD DGNSCD01-DGNSCD12 ;
do over dx;
diag=dx ;
output;
end;
run;
proc sort data=dm_last_&range2._dx out=dm_last_&range2._dx2 nodupkey;
by bid_hrs_21 s_id index_date diag;
run;

/*home health agency*/
data hh_last_&range2._dx(keep=bid_hrs_21 s_id diag index_date);
set proj_int.hh_meet_&suf.(keep=bid_hrs_21 s_id PDGNS_CD DGNSCD01-DGNSCD25 index_date);
array dx PDGNS_CD DGNSCD01-DGNSCD25 ;
do over dx;
diag=dx ;
output;
end;
run;
proc sort data=hh_last_&range2._dx out=hh_last_&range2._dx2 nodupkey;
by bid_hrs_21 s_id index_date diag;
run;

/*hospice*/
data hs_last_&range2._dx(keep=bid_hrs_21 s_id diag index_date);
set proj_int.hs_meet_&suf.(keep=bid_hrs_21 s_id PDGNS_CD DGNSCD01-DGNSCD25 index_date);
array dx PDGNS_CD DGNSCD01-DGNSCD25 ;
do over dx;
diag=dx ;
output;
end;
run;
proc sort data=hs_last_&range2._dx out=hs_last_&range2._dx2 nodupkey;
by bid_hrs_21 s_id index_date diag;
run;

/*set diag variable length = 7 chars since that's the max length from the mc claims
Need to do this because length varies across the different mc claim types*/
data hs_last_&range2._dx3;
length diag $7;
set hs_last_&range2._dx2;
run;
data hh_last_&range2._dx3;
length diag $7;
set hh_last_&range2._dx2;
run;
data mp_last_&range2._dx3;
length diag $7;
set mp_last_&range2._dx2;
run;
data dm_last_&range2._dx3;
length diag $7;
set dm_last_&range2._dx2;
run;
data op_last_&range2._dx3;
length diag $7;
set op_last_&range2._dx2;
run;
data pb_last_&range2._dx3;
length diag $7;
set pb_last_&range2._dx2;
run;

data dx_all_last_&range2.;
set hs_last_&range2._dx3
hh_last_&range2._dx3
mp_last_&range2._dx3
dm_last_&range2._dx3
op_last_&range2._dx3
pb_last_&range2._dx3;
run;

proc sort data=dx_all_last_&range2.(where=(diag~="")) out=proj_int.dx_&range1._&range2 nodupkey;
by bid_hrs_21 s_id index_date diag;
run;

%mend;

/*run macro to create data files proj_int.dx_0d_n6m proj_int.dx_0d_n12m and proj_int.dx_0d_n24m */
*%dx_time_range(range1=0d, range2=n6m, suf=6m);
%dx_time_range(range1=0d, range2=n12m, suf=12m);
*%dx_time_range(range1=0d, range2=n24m, suf=24m);

/*run for dx lists after R's death*/
*%dx_time_range(range1=0d, range2=p6m, suf=p6m);
%dx_time_range(range1=0d, range2=p12m, suf=p12m);
*%dx_time_range(range1=0d, range2=p24m, suf=p24m);



/*get spouse medicare costs by claim type and total, adjusted for inflation
to 2012$, monthly, 24m before and after R's death

begins with claims lists from "Get S MC claims lists..." section

final dataset is spo_mc_i.hrs_elix_cc_pay*/


/****************************************************************/
/*medpar claims, time periods before R's death*******************/
/****************************************************************/
/*macro for medpar claims, splits into costs for snf and ip claims
for time periods before r's death*/
%macro mp(source=,equ=,name=);
data proj_int.&source._meet_&name.;
set proj_int.mp_meet_&name.;
if (trim(left(SSLSSNF)))&equ.="N";
run;
%mend;

%mp(source=ip,equ=~,name=24m);
%mp(source=ip,equ=~,name=p24m);
%mp(source=snf,equ=,name=24m);
%mp(source=snf,equ=,name=p24m);

H="elixhauser"
/*creates indicators for each of the Elixhauser comorbidities
based on the dx codes lists 6, 12, and 24m before and after R's death

resulting dataset is proj_int.hrs_elix*/

/*rename macro - called within the elixhauser macro
to add time suffix to variables

lib=library
dsn=dataset name
pre=suffix to be added to all of the variable names
*/

%macro rename(lib,dsn,pre);
options pageno=1 nodate;
proc contents data=&lib..&dsn;
title "Before Renaming All Variables";
run;

proc sql noprint;
select nvar into :num_vars
from dictionary.tables
where libname="&LIB" and
memname="&DSN";
select distinct(name) into :var1-
:var%TRIM(%LEFT(&num_vars))
from dictionary.columns
where libname="&LIB" and
memname="&DSN";
quit;
run;

proc datasets library=&LIB;
modify &DSN;
rename
%do i=1 %to &num_vars;
&&var&i=&&var&i.._&pre 
%end;
;
quit;
run;
options pageno=1 nodate;
proc contents data=&lib..&dsn;
title "After Renaming All Variables";
run;
%mend rename;



/*Elixhauser index macro
Note includes additional 2 comorbidities: Dementia and Coronary Artery Disease*/

%macro elixhauser(range1=, range2=);

data dx_31_comor_&range2;
set proj_int.dx_&range1._&range2(rename=(diag=dx_0));
dx=trim(left(dx_0));

if dx~="" then do;

comorbi_1=0;
comorbi_2=0;
comorbi_3=0;
comorbi_4=0;
comorbi_5=0;
comorbi_6=0;
comorbi_7=0;
comorbi_8=0;
comorbi_9=0;
comorbi_10=0;
comorbi_11=0;
comorbi_12=0;
comorbi_13=0;
comorbi_14=0;
comorbi_15=0;
comorbi_16=0;
comorbi_17=0;
comorbi_18=0;
comorbi_19=0;
comorbi_20=0;
comorbi_21=0;
comorbi_22=0;
comorbi_23=0;
comorbi_24=0;
comorbi_25=0;
comorbi_26=0;
comorbi_27=0;
comorbi_28=0;
comorbi_29=0;
comorbi_30=0;
*end of intialize of 30 binary variables;
*add dementia and CAD;
dementia=0;
cad=0;

*do over dx;
	*Congestive Heart Failure;
	if (substr(dx,1,5)='39891' or
		substr(dx,1,5)='40211' or
		substr(dx,1,5)='40291' or
		substr(dx,1,5)='40411' or
		substr(dx,1,5)='40413' or
		substr(dx,1,5)='40491' or
		substr(dx,1,5)='40493' or
		substr(dx,1,3)='428') 
		and comorbi_1=0 
		then comorbi_1=1;*add one binary variables here.;
	*Cardiac Arrhythmias;
	if (substr(dx,1,5)='42610' or
		substr(dx,1,5)='42611' or
		substr(dx,1,5)='42613' or
		substr(dx,1,4)='4262' or
		substr(dx,1,4)='4263' or
		substr(dx,1,4)='4264' or
		substr(dx,1,5)='42650' or
		substr(dx,1,5)='42651' or
		substr(dx,1,5)='42652' or
		substr(dx,1,5)='42653' or
		substr(dx,1,4)='4266' or
		substr(dx,1,4)='4267' or
		substr(dx,1,4)='4268' or
		substr(dx,1,4)='4270' or
		substr(dx,1,4)='4272' or
		substr(dx,1,5)='42731' or
		substr(dx,1,5)='42760' or
		substr(dx,1,4)='4279' or
		substr(dx,1,4)='7850' or
		substr(dx,1,4)='V450' or
		substr(dx,1,4)='V533')
			and comorbi_2=0 
		then comorbi_2=1;
	* Valvular Disease ;
	if (substr(dx,1,5)='09320' or
		substr(dx,1,5)='09321' or
		substr(dx,1,5)='09322' or
		substr(dx,1,5)='09323' or
		substr(dx,1,5)='09324' or
		substr(dx,1,3)='394' or
		substr(dx,1,3)='395' or
		substr(dx,1,3)='396' or
		substr(dx,1,4)='3970' or
		substr(dx,1,4)='3971' or
		substr(dx,1,4)='4240' or
		substr(dx,1,4)='4241' or
		substr(dx,1,4)='4242' or
		substr(dx,1,4)='4243' or
		substr(dx,1,4)='4244' or
		substr(dx,1,4)='4245' or
		substr(dx,1,4)='4246' or
		substr(dx,1,4)='4247' or
		substr(dx,1,4)='4248' or
		substr(dx,1,5)='42490' or
		substr(dx,1,5)='42491' or
		substr(dx,1,4)='7463' or
		substr(dx,1,4)='7464' or
		substr(dx,1,4)='7465' or
		substr(dx,1,4)='7466' or
		substr(dx,1,4)='V422' or
		substr(dx,1,5)='V433')
			and comorbi_3=0 
		then comorbi_3=1;
	*Pulmonary Circulation Disorders;
	if (substr(dx,1,3)='416' or
		substr(dx,1,4)='4179')
			and comorbi_4=0 
		then comorbi_4=1;
	*Peripheral Vascular Disorders;
	if (substr(dx,1,3)='440' or
		substr(dx,1,4)='4412' or
		substr(dx,1,4)='4414' or
		substr(dx,1,4)='4417' or
		substr(dx,1,4)='4419' or
		substr(dx,1,4)='4431' or
		substr(dx,1,4)='4432' or
		substr(dx,1,4)='4438' or
		substr(dx,1,4)='4439' or
		substr(dx,1,4)='4471' or
		substr(dx,1,4)='5571' or
		substr(dx,1,4)='5579' or
		substr(dx,1,4)='V434')
			and comorbi_5=0 
		then comorbi_5=1;
	*Hypertension;
	if ((substr(dx,1,4)='4011' or
		substr(dx,1,4)='4019')) or
	   ((substr(dx,1,5)='40210' or
		substr(dx,1,5)='40290' or
		substr(dx,1,5)='40410' or
		substr(dx,1,5)='40490' or
		substr(dx,1,5)='40511' or
		substr(dx,1,5)='40519' or
		substr(dx,1,5)='40591' or
		substr(dx,1,5)='40599')) 
			and comorbi_6=0 
		then comorbi_6=1;
	*Paralysis;	
	if (substr(dx,1,4)='3420' or
		substr(dx,1,5)='34210' or
		substr(dx,1,5)='34211' or
		substr(dx,1,5)='34212' or
		substr(dx,1,4)='3429' or
		substr(dx,1,3)='343' or
		substr(dx,1,3)='344')
			and comorbi_7=0 
		then comorbi_7=1;
	*Other Neurological Disorders;
	if (substr(dx,1,4)='3319' or
		substr(dx,1,4)='3320' or
		substr(dx,1,4)='3334' or
		substr(dx,1,4)='3335' or
		substr(dx,1,3)='334' or
		substr(dx,1,3)='335' or
		substr(dx,1,3)='340' or
		substr(dx,1,4)='3411' or
		substr(dx,1,4)='3418' or
		substr(dx,1,4)='3419' or
		substr(dx,1,5)='34500' or
		substr(dx,1,5)='34501' or
		substr(dx,1,5)='34510' or
		substr(dx,1,5)='34511' or
		substr(dx,1,4)='3454' or
		substr(dx,1,5)='34550' or
		substr(dx,1,5)='34551' or
		substr(dx,1,4)='3458' or
		substr(dx,1,5)='34590' or
		substr(dx,1,5)='34591' or
		substr(dx,1,4)='3481' or
		substr(dx,1,4)='3483' or
		substr(dx,1,4)='7803' or
		substr(dx,1,4)='7843') 
			and comorbi_8=0 
		then comorbi_8=1;	
	*Chronic Pulmonary Disease;
	if (substr(dx,1,3)='490' or
		substr(dx,1,3)='491' or
		substr(dx,1,3)='492' or
		substr(dx,1,4)='4930' or
		substr(dx,1,4)='4931' or
		substr(dx,1,4)='4932' or
		substr(dx,1,4)='4938' or
		substr(dx,1,5)='49390' or
		substr(dx,1,5)='49391' or
		substr(dx,1,3)='494' or
		substr(dx,1,3)='495' or
		substr(dx,1,3)='496' or
		substr(dx,1,3)='497' or
		substr(dx,1,3)='498' or
		substr(dx,1,3)='499' or
		substr(dx,1,3)='500' or
		substr(dx,1,3)='501' or
		substr(dx,1,3)='502' or
		substr(dx,1,3)='503' or
		substr(dx,1,3)='504' or
		substr(dx,1,3)='505' or
		substr(dx,1,4)='5064') 
			and comorbi_9=0 
		then comorbi_9=1;	
	*Diabetes, uncomplicated;
	if (substr(dx,1,4)='2500' or
		substr(dx,1,4)='2501' or
		substr(dx,1,4)='2502' or
		substr(dx,1,4)='2503') 
			and comorbi_10=0 
		then comorbi_10=1;
	*Diabetes, complicated;
	if (substr(dx,1,4)='2504' or
		substr(dx,1,4)='2505' or
		substr(dx,1,4)='2506' or
		substr(dx,1,4)='2507' or
		substr(dx,1,4)='2509') 
			and comorbi_11=0 
		then comorbi_11=1;
	*Hypothyroidism;
	if (substr(dx,1,3)='243' or
		substr(dx,1,4)='2440' or
		substr(dx,1,4)='2441' or
		substr(dx,1,4)='2442' or
		substr(dx,1,4)='2448' or
		substr(dx,1,4)='2449') 	
			and comorbi_12=0 
		then comorbi_12=1;
	*Renal Failure;
	if (substr(dx,1,5)='40311' or
		substr(dx,1,5)='40391' or
		substr(dx,1,5)='40412' or
		substr(dx,1,5)='40492' or
		substr(dx,1,3)='585' or
		substr(dx,1,3)='586' or
		substr(dx,1,4)='V420' or
		substr(dx,1,4)='V451' or
		substr(dx,1,4)='V560' or
		substr(dx,1,4)='V568') 
			and comorbi_13=0 
		then comorbi_13=1;
	*Liver Disease;
	if (substr(dx,1,5)='07032' or
		substr(dx,1,5)='07033' or
		substr(dx,1,5)='07054' or
		substr(dx,1,4)='4560' or
		substr(dx,1,4)='4561' or
		substr(dx,1,5)='45620' or
		substr(dx,1,5)='45621' or
		substr(dx,1,4)='5710' or
		substr(dx,1,4)='5712' or
		substr(dx,1,4)='5713' or
		substr(dx,1,4)='5714' or
		substr(dx,1,4)='5715' or
		substr(dx,1,4)='5716' or
		substr(dx,1,4)='5718' or
		substr(dx,1,4)='5719' or
		substr(dx,1,4)='5723' or
		substr(dx,1,4)='5728' or
		substr(dx,1,4)='V427') 
			and comorbi_14=0 
		then comorbi_14=1;
	*Peptic Ulcer Disease excluding bleeding;
	if (substr(dx,1,5)='53170' or
		substr(dx,1,5)='53190' or
		substr(dx,1,5)='53270' or
		substr(dx,1,5)='53290' or
		substr(dx,1,5)='53370' or
		substr(dx,1,5)='53390' or
		substr(dx,1,5)='53470' or
		substr(dx,1,5)='53490' or
		substr(dx,1,5)='V1271') 
			and comorbi_15=0 
		then comorbi_15=1;
	*AIDS;
	if (substr(dx,1,3)='042' or
		substr(dx,1,3)='043' or
		substr(dx,1,3)='044') 
			and comorbi_16=0 
		then comorbi_16=1;
	*Lymphoma;
	if (substr(dx,1,3)='200' or
		substr(dx,1,4)='201' or
		substr(dx,1,4)='2020' or
		substr(dx,1,4)='2021' or
		substr(dx,1,4)='2022' or
		substr(dx,1,4)='2023' or
		substr(dx,1,4)='2025' or
		substr(dx,1,4)='2026' or
		substr(dx,1,4)='2027' or
		substr(dx,1,4)='2028' or
		substr(dx,1,4)='2029' or
		substr(dx,1,4)='2030' or
		substr(dx,1,4)='2038' or
		substr(dx,1,4)='2386' or
		substr(dx,1,4)='2733' or
		substr(dx,1,4)='V1071' or
		substr(dx,1,4)='V1072' or
		substr(dx,1,4)='V1079')
			and comorbi_17=0 
		then comorbi_17=1;
	*Metastatic Cancer;
	if (substr(dx,1,3)='196' or
		substr(dx,1,3)='197' or
		substr(dx,1,3)='198' or
		substr(dx,1,4)='199') 
			and comorbi_18=0 
		then comorbi_18=1;	
	*Solid Tumor without Metastisis;
	if (substr(dx,1,2)='14' or
		substr(dx,1,2)='15' or
		substr(dx,1,2)='16' or
		substr(dx,1,3)='170' or
		substr(dx,1,3)='171' or
		substr(dx,1,3)='172' or
		substr(dx,1,3)='174' or
		substr(dx,1,3)='175' or
		substr(dx,1,3)='179' or
		substr(dx,1,2)='18' or
		substr(dx,1,3)='190' or
		substr(dx,1,3)='191' or
		substr(dx,1,3)='192' or
		substr(dx,1,3)='193' or
		substr(dx,1,3)='194' or
		substr(dx,1,3)='195' or
		substr(dx,1,3)='V10')
			and comorbi_19=0 
		then comorbi_19=1;
	*Rheumatoid Arthritis/Collagen Vascular Diseases;
	if (substr(dx,1,4)='7010' or
		substr(dx,1,3)='710' or
		substr(dx,1,3)='714' or
		substr(dx,1,3)='720' or
		substr(dx,1,3)='725') 
			and comorbi_20=0 
		then comorbi_20=1;
	*Coagulopathy;
	if (substr(dx,1,3)='286' or
		substr(dx,1,4)='2871' or
		substr(dx,1,4)='2873' or
		substr(dx,1,4)='2874' or
		substr(dx,1,4)='2875') 
			and comorbi_21=0 
		then comorbi_21=1;
	*Obesity;
	if (substr(dx,1,4)='2780')  
			and comorbi_22=0 
		then comorbi_22=1;
	*Weight Loss;
	if (substr(dx,1,3)='260' or
		substr(dx,1,3)='261' or
		substr(dx,1,3)='262' or
		substr(dx,1,3)='263') 
			and comorbi_23=0 
		then comorbi_23=1;	
	*Fluid and Electrolyte Disorders;
	if (substr(dx,1,3)='276') 
			and comorbi_24=0 
		then comorbi_24=1;
	*Blood Loss Anemia;
	if (substr(dx,1,4)='2800') 
			and comorbi_25=0 
		then comorbi_25=1;
	*Deficiency Anemias;
	if (substr(dx,1,4)='2801' or
		substr(dx,1,4)='2808' or
		substr(dx,1,4)='2809' or
		substr(dx,1,4)='2859') 
			and comorbi_26=0 
		then comorbi_26=1;
	*Alcohol Abuse;
	if (substr(dx,1,4)='2911' or
		substr(dx,1,4)='2912' or
		substr(dx,1,4)='2915' or
		substr(dx,1,4)='2918' or
		substr(dx,1,4)='2919' or
		substr(dx,1,4)='3039' or
		substr(dx,1,4)='3050' or
		substr(dx,1,4)='V113') 
			and comorbi_27=0 
		then comorbi_27=1;
	*Drug Abuse;
	if (substr(dx,1,4)='2920' or
		substr(dx,1,5)='29282' or
		substr(dx,1,5)='29283' or
		substr(dx,1,5)='29284' or
		substr(dx,1,5)='29289' or
		substr(dx,1,4)='2929' or
		substr(dx,1,3)='304' or
		substr(dx,1,4)='3052' or
		substr(dx,1,4)='3053' or
		substr(dx,1,4)='3054' or
		substr(dx,1,4)='3055' or
		substr(dx,1,4)='3056' or
		substr(dx,1,4)='3057' or
		substr(dx,1,4)='3058' or
		substr(dx,1,4)='3059')
			and comorbi_28=0 
		then comorbi_28=1;	
	*Psychoses;
	if (substr(dx,1,3)='295' or
		substr(dx,1,3)='296' or
		substr(dx,1,3)='297' or
		substr(dx,1,3)='298' or
		substr(dx,1,4)='2991') 
			and comorbi_29=0 
		then comorbi_29=1;
	*Depression;
	if (substr(dx,1,4)='3004' or
		substr(dx,1,5)='30112' or
		substr(dx,1,4)='3090' or
		substr(dx,1,4)='3091' or
		substr(dx,1,3)='311')
			and comorbi_30=0 
		then comorbi_30=1;


	*Dementia;
	if (substr(dx,1,4) in ('3310','3311','3312','2900','2901',
             '2902','2903','2912','2948','2949') or
		substr(dx,1,5) in ('29410','29411','29040','29041','29042','29043')) 
		and dementia=0 
          then dementia=1;

	*CAD coronary artery disease;
	if (substr(dx,1,4) in ('4140','4142','4143','4148','4149') or 
		substr(dx,1,3) in ('410','411','412','413') or
		substr(dx,1,5) in ('V4581','V4582'))
		and cad=0 
          then cad=1;

/* CAD list
410.00-410.92
411.0-411.89
412
413.0-413.9
414.00-414.07
414.2
414.3
414.8
414.9
V45.81
V45.82 */

end;
run;


/*check sums of each comorbidity for each s_id*/
proc sql;
create table com_test1_&range2 as
select distinct BID_hrs_21, s_id, index_date,
sum(comorbi_1) as com_1,
sum(comorbi_2) as com_2,
sum(comorbi_3) as com_3,
sum(comorbi_4) as com_4,
sum(comorbi_5) as com_5,
sum(comorbi_6) as com_6,
sum(comorbi_7) as com_7,
sum(comorbi_8) as com_8,
sum(comorbi_9) as com_9,
sum(comorbi_10) as com_10,
sum(comorbi_11) as com_11,
sum(comorbi_12) as com_12,
sum(comorbi_13) as com_13,
sum(comorbi_14) as com_14,
sum(comorbi_15) as com_15,
sum(comorbi_16) as com_16,
sum(comorbi_17) as com_17,
sum(comorbi_18) as com_18,
sum(comorbi_19) as com_19,
sum(comorbi_20) as com_20,
sum(comorbi_21) as com_21,
sum(comorbi_22) as com_22,
sum(comorbi_23) as com_23,
sum(comorbi_24) as com_24,
sum(comorbi_25) as com_25,
sum(comorbi_26) as com_26,
sum(comorbi_27) as com_27,
sum(comorbi_28) as com_28,
sum(comorbi_29) as com_29,
sum(comorbi_30) as com_30,
sum(dementia) as com_31,
sum(cad) as com_32
from dx_31_comor_&range2
group by BID_hrs_21, s_id, index_date;
quit;

/*define comorbidities as binary indicators*/
data comorbidity_&range2.(keep=BID_hrs_21 s_id index_date
	comorb_1-comorb_32 comorb_all);
set com_test1_&range2;
array list_com com_1-com_30 com_31 com_32;
array list_com_bin comorb_1-comorb_30 comorb_31 comorb_32;

/*note this defines comorbidity 31 = dementia & 32 = cad*/
do over list_com;
  list_com_bin=0;

  if list_com>0 then do;
    list_com_bin=1;
   end;

end;

/*define aggregate comorbidity as sum of 30 individual indicator vars.
note: CAD not included in this aggregate score*/
comorb_all=comorb_1+comorb_2+comorb_3+comorb_4+comorb_5+comorb_6+
comorb_7+comorb_8+comorb_9+comorb_10+comorb_11+comorb_12+comorb_13+
comorb_14+comorb_15+comorb_16+comorb_17+comorb_18+comorb_19+comorb_20+
comorb_21+comorb_22+comorb_23+comorb_24+comorb_25+comorb_26+comorb_27+
comorb_28+comorb_29+comorb_30+comorb_31;
run;


proc sort data=comorbidity_&range2. nodupkey;
by BID_hrs_21 s_id index_date;
run;

/*merges with list of s's with xwalk s_id, dod & ffs mc 6m before R's death*/
proc sql;
create table s_ids_w_xwalk_&range2._1(drop=BID_hrs_212 s_id2) as
select a.bid_hrs_21,a.s_id,a.index_date,b.* 
from proj_int.index a 
left join
comorbidity_&range2.(rename=(BID_hrs_21=BID_hrs_212) rename=(s_id=s_id2))  b
on trim(left(a.bid_hrs_21))=trim(left(b.BID_hrs_212)) and
	a.s_id=b.s_id2 and a.index_date=b.index_date;
quit;

/*if comorbidity=null, set to zero for this group with the ffs mc 6m*/
data elix_&range1._&range2;
set s_ids_w_xwalk_&range2._1;
array list comorb_1-comorb_32 comorb_all;
do over list;
	if list=. then list=0;
	end;

label comorb_1 ="Congestive Heart Failure";
label comorb_2 ="Cardiac Arrhythmias";
label comorb_3 ="Valvular Disease";
label comorb_4 ="Pulmonary Circulation Disorders";
label comorb_5 ="Peripheral Vascular Disorders";
label comorb_6 ="Hypertension";
label comorb_7 ="Paralysis";
label comorb_8 ="Other Neurological Disorders";
label comorb_9 ="Chronic Pulmonary Disease";
label comorb_10 ="Diabetes, uncomplicated";
label comorb_11 ="Diabetes, complicated";
label comorb_12 ="Hypothyroidism";
label comorb_13 ="Renal Failure";
label comorb_14 ="Liver Disease";
label comorb_15 ="Peptic Ulcer Disease excluding bleeding";
label comorb_16 ="AIDS";
label comorb_17 ="Lymphoma";
label comorb_18 ="Metastatic Cancer";
label comorb_19 ="Solid Tumor without Metastisis";
label comorb_20 ="Rheumatoid Arthritis/Collagen Vascular Diseases";
label comorb_21 ="Coagulopathy";
label comorb_22 ="Obesity";
label comorb_23 ="Weight Loss";
label comorb_24 ="Fluid and Electrolyte Disorders";
label comorb_25 ="Blood Loss Anemia";
label comorb_26 ="Deficiency Anemias";
label comorb_27 ="Alcohol Abuse";
label comorb_28 ="Drug Abuse";
label comorb_29 ="Psychoses";
label comorb_30 ="Depression";
label comorb_31 ="Dementia";
label comorb_32 ="Coronary Artery Disease";

run;

data test;
set elix_&range1._&range2;
run;

/*calls rename macro*/
%rename(WORK,TEST,&range1._&range2);

/*rename r&s BID variables*/
data elix_&range1._&range2._2
	(rename =(s_id_&range1._&range2=s_id)
	rename =(bid_hrs_21_&range1._&range2=bid_hrs_21)
	rename = (index_date_&range1._&range2=index_date));
set test;
keep bid_hrs_21_&range1._&range2 s_id_&range1._&range2 index_date_&range1._&range2 comorb:;
run;

proc sort data=elix_&range1._&range2._2 nodup;
by bid_hrs_21 s_id index_date;
run;

%mend;

/*run macro to get elixhauser comorbidities 6, 12, 24m pre and post death
resulting datasets are spo_int.elix_0d_x#m_2
x = n=before, p=after death
# = 6, 12, or 24 for time window (months) 
have s_id and bid_hrs_21 to merge back to dataset*/
*%elixhauser(range1=0d, range2=n6m);
%elixhauser(range1=0d, range2=n12m);
%elixhauser(range1=0d, range2=n24m);

*%elixhauser(range1=0d, range2=p6m);
%elixhauser(range1=0d, range2=p12m);
%elixhauser(range1=0d, range2=p24m);


/*combine the 6 sets of variables into a single dataset
then merge this into main hrs spouse dataset*/
data proj_int.elix_all;
merge /*elix_0d_n6m_2*/ elix_0d_n12m_2 elix_0d_n24m_2
/*elix_0d_p6m_2*/ elix_0d_p12m_2 elix_0d_p24m_2;
by bid_hrs_21 s_id index_date;
run;



H="mc spending"
/*get spouse medicare costs by claim type and total, adjusted for inflation
to 2012$, monthly, 24m before and after R's death

begins with claims lists from "Get S MC claims lists..." section

final dataset is proj_int.hrs_elix_cc_pay*/



%macro mp_index_dt(source=);
*get claims that overlap with date of death;

data &source._meet_admit;
set proj_int.&source._meet_24m;
if index_date=admit_date and admit_date~=disch_date;
admit_on_index_date=1;
run;


data &source._meet_both;
set proj_int.&source._meet_24m;
if index_date=disch_date and admit_date=disch_date;
admit_on_index_date=1;
disch_on_index_date=1;
run;




data &source._cost;
set &source._meet_admit &source._meet_both;
array list pmt_amt passthru;
do over list;
if list=. then list=0;
end;

if year(admit_date)>=2012 then rate=1;
if year(admit_date)=2011 then rate=1.03902;
if year(admit_date)=2010 then rate=1.07086;
if year(admit_date)=2009 then rate=1.10835;
if year(admit_date)=2008 then rate=1.1439;
if year(admit_date)=2007 then rate=1.1923;
if year(admit_date)=2006 then rate=1.25586;
if year(admit_date)=2005 then rate=1.30783;
if year(admit_date)=2004 then rate=1.37027;
if year(admit_date)=2003 then rate=1.43908;
if year(admit_date)=2002 then rate=1.50337;
if year(admit_date)=2001 then rate=1.57963;
if year(admit_date)=2000 then rate=1.65519;
if year(admit_date)<=1999 then rate=1.72641;


&source._paid_by_mc=rate*(pmt_amt+passthru);
&source._paid_by_mc_index_dt=(1/(disch_date-admit_date+1))*&source._paid_by_mc;
run;

proc sql;
create table &source._pay as select distinct bid_hrs_21,s_id,index_date,
sum(&source._paid_by_mc_index_dt) as &source._paid_by_mc_index_dt,
sum(admit_on_index_date) as &source._admit_dod, sum(disch_on_index_date) as &source._disch_dod
from &source._cost group by bid_hrs_21,s_id,index_date;
quit;

%mend;
%mp_index_dt(source=ip);
%mp_index_dt(source=snf);


%macro claims_index_dt(source=);
*get claims that start with date of death;

data &source._meet_admit;
set proj_int.&source._meet_24m;
if index_date=admit_date; 
run;



data &source._cost;
set &source._meet_admit;
array list pmt_amt passthru;
do over list;
if list=. then list=0;
end;

if year(admit_date)>=2012 then rate=1;
if year(admit_date)=2011 then rate=1.03902;
if year(admit_date)=2010 then rate=1.07086;
if year(admit_date)=2009 then rate=1.10835;
if year(admit_date)=2008 then rate=1.1439;
if year(admit_date)=2007 then rate=1.1923;
if year(admit_date)=2006 then rate=1.25586;
if year(admit_date)=2005 then rate=1.30783;
if year(admit_date)=2004 then rate=1.37027;
if year(admit_date)=2003 then rate=1.43908;
if year(admit_date)=2002 then rate=1.50337;
if year(admit_date)=2001 then rate=1.57963;
if year(admit_date)=2000 then rate=1.65519;
if year(admit_date)<=1999 then rate=1.72641;


&source._paid_by_mc_index_dt=rate*(pmt_amt);
run;

proc sql;
create table &source._pay as select distinct bid_hrs_21,s_id,index_date,
sum(&source._paid_by_mc_index_dt) as &source._paid_by_mc_index_dt
from &source._cost group by bid_hrs_21,s_id,index_date;
quit;

%mend;

%claims_index_dt(source=op);
%claims_index_dt(source=pb);
%claims_index_dt(source=hh);
%claims_index_dt(source=hs);
%claims_index_dt(source=dm);

data mc_costs_doda;
merge ip_pay snf_pay op_pay pb_pay hh_pay hs_pay dm_pay ;
bid_hrs_21=bid_hrs_21;
by bid_hrs_21 s_id index_date;
run;


data mc_costs_dod;
set mc_costs_doda;
tot_paid_by_mc_index_dt=ip_paid_by_mc_index_dt+snf_paid_by_mc_index_dt+op_paid_by_mc_index_dt +
pb_paid_by_mc_index_dt+hs_paid_by_mc_index_dt+dm_paid_by_mc_index_dt;
run;


%macro mp_claims(days_start=,days_bef_index=,source=,name=);

*first get claims lists for the specific claims type, snf or ip;
data &source._meet;
set proj_int.&source._meet_24m;
win_start_dt=index_date-&days_bef_index;
win_stop_dt=index_date-&days_start;
format admit_date disch_date win_start_dt win_stop_dt date9.;
run;

/*identify claims where entire claim is within the x months prior to death*/
data &source._meet_1;
set &source._meet;
if win_start_dt<=admit_date<win_stop_dt and
	win_start_dt<=disch_date<win_stop_dt;
run;

/*identify claims where start before window but end during window*/
data &source._meet_2;
set &source._meet;
if win_start_dt>admit_date and
	win_start_dt<=disch_date<win_stop_dt;
run;

/*identify fraction of claims to be attributed to period before death
by just using the fraction of time that was included in the time window*/
data &source._meet_3;
set &source._meet_2;
pct_xm=(disch_date-win_start_dt)/(disch_date-admit_date+1);
array list pmt_amt passthru;
do over list;
if list=. then list=0;
/*scale the partial claims by the time within the x month period*/
list=list*pct_xm;
end;

run;

/*claims where start within window but end after R's death*/
data &source._meet_4;
set &source._meet;
if win_start_dt<=admit_date<win_stop_dt and
	disch_date>=win_stop_dt;
run;

/*again fraction to attribute to window*/
data &source._meet_5;
set &source._meet_4;
pct_xm=(win_stop_dt-admit_date+1)/(disch_date-admit_date+1);
array list pmt_amt passthru;
do over list;
if list=. then list=0;
/*scale the partial claims by the time within the x month period*/
list=list*pct_xm;
end;
run;

/*claims where start before and end after window*/
data &source._meet_6;
set &source._meet;
if win_start_dt>admit_date and
	disch_date>=win_stop_dt;
run;

/*again fraction to attribute to window*/
data &source._meet_7;
set &source._meet_6;
pct_xm=(win_stop_dt-win_start_dt)/(disch_date-admit_date+1);
array list pmt_amt passthru;
do over list;
if list=. then list=0;
/*scale the partial claims by the time within the x month period*/
list=list*pct_xm;
end;
run;

/*merge claims into single dataset, adjust for inflation
Uses CPI for Medical Services from BLS website, accessed 5/4/2015*/
data &source._cost;
set &source._meet_1 &source._meet_3 &source._meet_5 &source._meet_7;
array list pmt_amt passthru;
do over list;
if list=. then list=0;
end;

if year(admit_date)>=2012 then rate=1;
if year(admit_date)=2011 then rate=1.03902;
if year(admit_date)=2010 then rate=1.07086;
if year(admit_date)=2009 then rate=1.10835;
if year(admit_date)=2008 then rate=1.1439;
if year(admit_date)=2007 then rate=1.1923;
if year(admit_date)=2006 then rate=1.25586;
if year(admit_date)=2005 then rate=1.30783;
if year(admit_date)=2004 then rate=1.37027;
if year(admit_date)=2003 then rate=1.43908;
if year(admit_date)=2002 then rate=1.50337;
if year(admit_date)=2001 then rate=1.57963;
if year(admit_date)=2000 then rate=1.65519;
if year(admit_date)<=1999 then rate=1.72641;


&source._paid_by_mc=rate*(pmt_amt+passthru);
run;

*calculates total of mc charges for the claim type by hrs bid;
proc sql;
create table &source._pay as select distinct bid_hrs_21,s_id,index_date,
sum(&source._paid_by_mc) as &source._paid_by_mc 
from &source._cost group by bid_hrs_21,s_id,index_date;
quit;

/*merge into a full bid list of those s's with ffs mc 6m or more*/
proc sql;
create table &source._&name. as select 
a.bid_hrs_21,a.s_id,a.index_date,coalesce(b.&source._paid_by_mc,0) as &source._paid_by_mc_&name.
from proj_int.index a
left join
 &source._pay b
 on trim(left(a.bid_hrs_21))=trim(left(b.bid_hrs_21)) and a.s_id=b.s_id and a.index_date=b.index_date;
 quit;

proc sort data=&source._&name.; by bid_hrs_21 s_id index_date; run;

%mend;



%macro claims(days_start=,days_bef_index=,source=,name=);

*first get claims lists for the specific claims type, not snf or ip;
data &source._meet;
set proj_int.&source._meet_24m;
win_start_dt=index_date-&days_bef_index;
win_stop_dt=index_date-&days_start;
format admit_date disch_date win_start_dt win_stop_dt date9.;
run;

/*identify claims where start of claim is within the x months prior to death*/
data proj_int.&source._meet&name.;
set &source._meet;
if win_start_dt<=admit_date<win_stop_dt;
run;


/*adjust for inflation
Uses CPI for Medical Services from BLS website, accessed 5/4/2015*/
data &source._cost;
set proj_int.&source._meet&name.;
array list pmt_amt passthru;
do over list;
if list=. then list=0;
end;

if year(admit_date)>=2012 then rate=1;
if year(admit_date)=2011 then rate=1.03902;
if year(admit_date)=2010 then rate=1.07086;
if year(admit_date)=2009 then rate=1.10835;
if year(admit_date)=2008 then rate=1.1439;
if year(admit_date)=2007 then rate=1.1923;
if year(admit_date)=2006 then rate=1.25586;
if year(admit_date)=2005 then rate=1.30783;
if year(admit_date)=2004 then rate=1.37027;
if year(admit_date)=2003 then rate=1.43908;
if year(admit_date)=2002 then rate=1.50337;
if year(admit_date)=2001 then rate=1.57963;
if year(admit_date)=2000 then rate=1.65519;
if year(admit_date)<=1999 then rate=1.72641;


&source._paid_by_mc=rate*(pmt_amt);
run;

*calculates total of mc charges for the claim type by hrs bid;
proc sql;
create table &source._pay as select distinct bid_hrs_21,s_id,index_date,
sum(&source._paid_by_mc) as &source._paid_by_mc 
from &source._cost group by bid_hrs_21,s_id,index_date;
quit;

/*merge into a full bid list of those s's with ffs at death*/
proc sql;
create table &source._&name. as select 
a.bid_hrs_21,a.s_id,a.index_date,coalesce(b.&source._paid_by_mc,0) as &source._paid_by_mc_&name.
from proj_int.index a
left join
 &source._pay b
 on trim(left(a.bid_hrs_21))=trim(left(b.bid_hrs_21)) and a.s_id=b.s_id and a.index_date=b.index_date;
 quit;

proc sort data=&source._&name.; by bid_hrs_21 s_id index_date; run;

%mend;




/****************************************************************/
/*all claims, time periods after R's death********************/
/****************************************************************/
%macro mp_claims_p(days_start=,days_aft_index=,source=,name=);

*first get claims lists for the specific claims type, snf or ip;
data &source._meet;
set proj_int.&source._meet_p24m;
win_end_dt=index_date+&days_aft_index;
win_start_dt=index_date+&days_start;
format admit_date disch_date win_end_dt win_start_dt date9.;
run;

/*identify claims where entire claim is within the x months after death*/
data &source._meet_1;
set &source._meet;
if win_start_dt<admit_date<=win_end_dt and
	win_start_dt<disch_date<=win_end_dt;
run;

/*identify claims where start before window but end during window*/
data &source._meet_2;
set &source._meet;
if win_start_dt>=admit_date and
	win_start_dt<disch_date<=win_end_dt;
run;

/*identify fraction of claims to be attributed to period after death
by just using the fraction of time that was included in the time window*/
data &source._meet_3;
set &source._meet_2;
pct_xm=(disch_date-win_start_dt)/(disch_date-admit_date+1);
array list pmt_amt passthru;
do over list;
if list=. then list=0;
/*scale the partial claims by the time within the x month period*/
list=list*pct_xm;
end;
run;

/*claims where start within window but end after window*/
data &source._meet_4;
set &source._meet;
if win_start_dt<admit_date<=win_end_dt and
	disch_date>win_end_dt ;
run;

/*again fraction to attribute to window*/
data &source._meet_5;
set &source._meet_4;
pct_xm=(win_end_dt-admit_date+1)/(disch_date-admit_date+1);
array list pmt_amt passthru;
do over list;
if list=. then list=0;
/*scale the partial claims by the time within the x month period*/
list=list*pct_xm;
end;
run;

/*claims where start before window but end after window*/
data &source._meet_6;
set &source._meet;
if win_start_dt>=admit_date and
	disch_date>win_end_dt ;
run;

/*again fraction to attribute to window*/
data &source._meet_7;
set &source._meet_6;
pct_xm=(win_end_dt -win_start_dt)/(disch_date-admit_date+1);
array list pmt_amt passthru;
do over list;
if list=. then list=0;
/*scale the partial claims by the time within the x month period*/
list=list*pct_xm;
end;
run;
/*merge claims into single dataset, adjust for inflation*/
data &source._cost;
set &source._meet_1 &source._meet_3 &source._meet_5 &source._meet_7;
array list pmt_amt passthru;
do over list;
if list=. then list=0;
end;

if year(admit_date)>=2012 then rate=1;
if year(admit_date)=2011 then rate=1.03902;
if year(admit_date)=2010 then rate=1.07086;
if year(admit_date)=2009 then rate=1.10835;
if year(admit_date)=2008 then rate=1.1439;
if year(admit_date)=2007 then rate=1.1923;
if year(admit_date)=2006 then rate=1.25586;
if year(admit_date)=2005 then rate=1.30783;
if year(admit_date)=2004 then rate=1.37027;
if year(admit_date)=2003 then rate=1.43908;
if year(admit_date)=2002 then rate=1.50337;
if year(admit_date)=2001 then rate=1.57963;
if year(admit_date)=2000 then rate=1.65519;
if year(admit_date)<=1999 then rate=1.72641;

&source._paid_by_mc=rate*(pmt_amt+passthru);
run;

*calculates total of mc charges for the claim type by hrs bid;
proc sql;
create table &source._pay as select distinct bid_hrs_21,s_id,index_date,
sum(&source._paid_by_mc) as &source._paid_by_mc 
from &source._cost group by bid_hrs_21,s_id,index_date;
quit;

/*merge into a full bid list of those s's with ffs mc at death*/
proc sql;
create table &source._&name. as select 
a.bid_hrs_21,a.s_id,a.index_date,coalesce(b.&source._paid_by_mc,0) as &source._paid_by_mc_&name.
from proj_int.index a
left join
 &source._pay b
 on trim(left(a.bid_hrs_21))=trim(left(b.bid_hrs_21)) and a.s_id=b.s_id and a.index_date=b.index_date;
 quit;

proc sort data=&source._&name.; by bid_hrs_21 s_id index_date; run;

%mend;




/****************************************************************/
/*all claims, time periods after R's death********************/
/****************************************************************/
%macro claims_p(days_start=,days_aft_index=,source=,name=);

*first get claims lists for the specific claims type, snf or ip;
data &source._meet;
set proj_int.&source._meet_p24m;
win_end_dt=index_date+&days_aft_index;
win_start_dt=index_date+&days_start;
format admit_date disch_date win_end_dt win_start_dt date9.;
run;

/*identify claims where entire claim is within the x months after death*/
data proj_int.&source._meet&name.;
set &source._meet;
if win_start_dt<admit_date<=win_end_dt;
run;


/*adjust for inflation*/
data &source._cost;
set proj_int.&source._meet&name.;
array list pmt_amt;
do over list;
if list=. then list=0;
end;

if year(admit_date)>=2012 then rate=1;
if year(admit_date)=2011 then rate=1.03902;
if year(admit_date)=2010 then rate=1.07086;
if year(admit_date)=2009 then rate=1.10835;
if year(admit_date)=2008 then rate=1.1439;
if year(admit_date)=2007 then rate=1.1923;
if year(admit_date)=2006 then rate=1.25586;
if year(admit_date)=2005 then rate=1.30783;
if year(admit_date)=2004 then rate=1.37027;
if year(admit_date)=2003 then rate=1.43908;
if year(admit_date)=2002 then rate=1.50337;
if year(admit_date)=2001 then rate=1.57963;
if year(admit_date)=2000 then rate=1.65519;
if year(admit_date)<=1999 then rate=1.72641;

&source._paid_by_mc=rate*(pmt_amt);
run;

*calculates total of mc charges for the claim type by hrs bid;
proc sql;
create table &source._pay as select distinct bid_hrs_21,s_id,index_date,
sum(&source._paid_by_mc) as &source._paid_by_mc 
from &source._cost group by bid_hrs_21,s_id,index_date;
quit;

/*merge into a full bid list of those s's with ffs mc at death*/
proc sql;
create table &source._&name. as select 
a.bid_hrs_21,a.s_id,a.index_date,coalesce(b.&source._paid_by_mc,0) as &source._paid_by_mc_&name.
from proj_int.index a
left join
 &source._pay b
 on trim(left(a.bid_hrs_21))=trim(left(b.bid_hrs_21)) and a.s_id=b.s_id and a.index_date=b.index_date;
 quit;

proc sort data=&source._&name.; by bid_hrs_21 s_id index_date; run;

%mend;

%macro days_nesting();

%do i=1 %to 24 ;


%mp_claims(days_start=floor((&i.-1)*30.417),days_bef_index=floor(&i.*30.417), source=snf,  name=m&i.);
%mp_claims(days_start=floor((&i.-1)*30.417),days_bef_index=floor(&i.*30.417), source=ip,  name=m&i.);
%claims(days_start=floor((&i.-1)*30.417),days_bef_index=floor(&i.*30.417), source=pb,  name=m&i.);
%claims(days_start=floor((&i.-1)*30.417),days_bef_index=floor(&i.*30.417), source=op,  name=m&i.);
%claims(days_start=floor((&i.-1)*30.417),days_bef_index=floor(&i.*30.417), source=hh,  name=m&i.);
%claims(days_start=floor((&i.-1)*30.417),days_bef_index=floor(&i.*30.417), source=hs,  name=m&i.);
%claims(days_start=floor((&i.-1)*30.417),days_bef_index=floor(&i.*30.417), source=dm,  name=m&i.);
%mp_claims_p(days_start=floor((&i.-1)*30.417),days_aft_index=floor(&i.*30.417), source=snf,  name=m&i.p);
%mp_claims_p(days_start=floor((&i.-1)*30.417),days_aft_index=floor(&i.*30.417), source=ip,  name=m&i.p);
%claims_p(days_start=floor((&i.-1)*30.417),days_aft_index=floor(&i.*30.417), source=op,  name=m&i.p);
%claims_p(days_start=floor((&i.-1)*30.417),days_aft_index=floor(&i.*30.417), source=pb,  name=m&i.p);
%claims_p(days_start=floor((&i.-1)*30.417),days_aft_index=floor(&i.*30.417), source=hh,  name=m&i.p);
%claims_p(days_start=floor((&i.-1)*30.417),days_aft_index=floor(&i.*30.417), source=hs,  name=m&i.p);
%claims_p(days_start=floor((&i.-1)*30.417),days_aft_index=floor(&i.*30.417), source=dm,  name=m&i.p);


%end;
%mend;

%days_nesting();




%macro merge(l=,source=,time=,p=);
data &source._&time._m1;
set &source._m1&p.;
run;

%do i=2 %to 24 ;
%let l = %eval(&i.-1) ;

data &source._&time._m&i.;
merge &source._&time._m&l. &source._m&i.&p.;
run;
%end;

data &source._&time.;
set &source._&time._m24;
run;
%mend;

%merge(source=ip,time=bef,p=);
%merge(source=ip,time=aft,p=p);
%merge(source=snf,time=bef,p=);
%merge(source=snf,time=aft,p=p);
%merge(source=op,time=bef,p=);
%merge(source=op,time=aft,p=p);
%merge(source=pb,time=bef,p=);
%merge(source=pb,time=aft,p=p);
%merge(source=hh,time=bef,p=);
%merge(source=hh,time=aft,p=p);
%merge(source=hs,time=bef,p=);
%merge(source=hs,time=aft,p=p);
%merge(source=dm,time=bef,p=);
%merge(source=dm,time=aft,p=p);

/*now merge into single dataset of MC costs and get totals for each time window*/
data mc_costs_all;
merge ip_bef snf_bef op_bef pb_bef hh_bef hs_bef dm_bef 
ip_aft snf_aft op_aft pb_aft hh_aft hs_aft dm_aft;
by bid_hrs_21 s_id index_date;
run;

%macro total();

data mc_costs_all2;
set mc_costs_all;
%do i=1 %to 24;
tot_paid_by_mc_m&i.=ip_paid_by_mc_m&i. + snf_paid_by_mc_m&i. + op_paid_by_mc_m&i. + 
pb_paid_by_mc_m&i. + hh_paid_by_mc_m&i. + hs_paid_by_mc_m&i. + dm_paid_by_mc_m&i.;
tot_paid_by_mc_m&i.p=ip_paid_by_mc_m&i.p + snf_paid_by_mc_m&i.p + op_paid_by_mc_m&i.p + 
pb_paid_by_mc_m&i.p + hh_paid_by_mc_m&i.p + hs_paid_by_mc_m&i.p + dm_paid_by_mc_m&i.p;
%end;
run;
%mend;

%total();

data mc_costs_all3;
merge mc_costs_all2 mc_costs_dod;
by  bid_hrs_21 s_id index_date;
run;

/*save permanent dataset*/
data proj_int.mc_costs_monthly;
set mc_costs_all3;
run;



H="other utilization"




/*additional outcome variables

Spouse - monthly pre and post R's death:
Hospital # visits
Hospital nights
# ED visits
# OP visits*/


/*get spouse medicare costs by claim type and total, adjusted for inflation
to 2012$, monthly, 24m before and after R's death

begins with claims lists from "Get S MC claims lists..." section

final dataset is proj_int.hrs_elix_cc_pay*/

proc sort data=proj_int.index out=index1 nodupkey;
by bid_hrs_21 index_date;
run;



/*****************************************************************************/
/*get admissions and ip ed visits from ip claims monthly pre R's death*/
/*****************************************************************************/




%macro pre_admissions(days_start=,days_bef_index=,suffix=,su=);

/*pull list of ip claims from all medpar claims x days pre-death*/
data ip_meet_&suffix._1a;
set proj_int.mp_meet_24m(where=(trim(left(SSLSSNF))~="N"));
win_start_dt=index_date-&days_bef_index;
win_stop_dt=index_date-&days_start;
format admit_date disch_date win_start_dt win_stop_dt date9.;
run;

data ip_meet_&suffix._1;
set ip_meet_&suffix._1a;
if win_start_dt<=admit_date<=win_stop_dt or 
win_start_dt<=disch_date<=win_stop_dt;
run;

data ip_&suffix._2;
set ip_meet_&suffix._1;
if icarecnt=. then icarecnt=0; /*medpar intensive care day count*/
if CRNRYDAY=. then CRNRYDAY=0; /*medpar coronary day count*/
icu_days=icarecnt+CRNRYDAY;


/*truncate stays where the admit is before x days pre- R's death
or discharge is after R's death so can get accurate LOS*/
admit_date2=admit_date;
disch_date2=disch_date;
if admit_date<win_start_dt then do;
	admit_date2=win_start_dt;
	admit_trunc=1;
	end;
if win_stop_dt <disch_date then do;
	disch_date2=win_stop_dt;
	disch_trunc=1;	
	end;
adj_los=disch_date2-admit_date2;
if disch_date-admit_date=0 then adj_los=1;
run;

/*determine if mental health dx is present*/
data ip_&suffix._2a;
set ip_&suffix._2;
/*first, check if mental health is the admitting diagnosis*/
adm_mental_ill=0;

/*dx list from the AHRQ CCS Multi dx Tool, 2015, for Mental Illness Level 1 category*/
	if (substr(ad_dgns,1,3)='290' or
		substr(ad_dgns,1,3)='291' or
		substr(ad_dgns,1,3)='292' or
		substr(ad_dgns,1,3)='293' or
		substr(ad_dgns,1,3)='294' or
		substr(ad_dgns,1,3)='295' or
		substr(ad_dgns,1,3)='296' or
		substr(ad_dgns,1,3)='297' or
		substr(ad_dgns,1,3)='298' or
		substr(ad_dgns,1,3)='299' or
		substr(ad_dgns,1,3)='300' or
		substr(ad_dgns,1,3)='301' or
		substr(ad_dgns,1,3)='302' or
		substr(ad_dgns,1,3)='303' or
		substr(ad_dgns,1,3)='304' or
		substr(ad_dgns,1,3)='305' or
		substr(ad_dgns,1,3)='306' or
		substr(ad_dgns,1,3)='307' or
		substr(ad_dgns,1,3)='308' or
		substr(ad_dgns,1,3)='309' or
		substr(ad_dgns,1,3)='310' or
		substr(ad_dgns,1,3)='311' or
		substr(ad_dgns,1,3)='312' or
		substr(ad_dgns,1,3)='313' or
		substr(ad_dgns,1,3)='314' or
		substr(ad_dgns,1,3)='315' or
		substr(ad_dgns,1,3)='316' or
		substr(ad_dgns,1,3)='317' or
		substr(ad_dgns,1,3)='318' or
		substr(ad_dgns,1,3)='319' or
		substr(ad_dgns,1,4)='3310' or
		substr(ad_dgns,1,4)='3311' or
		substr(ad_dgns,1,4)='3312' or
		substr(ad_dgns,1,5)='33182' or
		substr(ad_dgns,1,5)='33392' or
		substr(ad_dgns,1,4)='3575' or
		substr(ad_dgns,1,4)='4255' or
		substr(ad_dgns,1,4)='5353' or
		substr(ad_dgns,1,4)='5710' or
		substr(ad_dgns,1,4)='5711' or
		substr(ad_dgns,1,4)='5712' or
		substr(ad_dgns,1,4)='5713' or
		substr(ad_dgns,1,4)='6483' or
		substr(ad_dgns,1,4)='6484' or
		substr(ad_dgns,1,4)='6555' or
		substr(ad_dgns,1,5)='76071' or
		substr(ad_dgns,1,5)='76072' or
		substr(ad_dgns,1,5)='76073' or
		substr(ad_dgns,1,5)='76075' or
		substr(ad_dgns,1,4)='7795' or
		substr(ad_dgns,1,4)='7903' or
		substr(ad_dgns,1,3)='797' or 
		substr(ad_dgns,1,4)='9650' or
		substr(ad_dgns,1,4)='9800' or
		substr(ad_dgns,1,3)='E95' or
		substr(ad_dgns,1,3)='V11' or
		substr(ad_dgns,1,4)='V154' or
		substr(ad_dgns,1,5)='V1582' or
		substr(ad_dgns,1,3)='V40' or
		substr(ad_dgns,1,5)='V6284' or
		substr(ad_dgns,1,5)='V6285' or
		substr(ad_dgns,1,5)='V6542' or
		substr(ad_dgns,1,4)='V663' or
		substr(ad_dgns,1,4)='V673' or
		substr(ad_dgns,1,4)='V701' or
		substr(ad_dgns,1,4)='V702' or
		substr(ad_dgns,1,4)='V710' or
		substr(ad_dgns,1,3)='V79') 
		and adm_mental_ill=0 
		then adm_mental_ill=1;*set to 1 if not flagged already;

	   /*now check if mental illness is any of the diagnoses present for the claim*/
any_dx_mental_ill=0;
array dx DGNS_CD01-DGNS_CD25 ;
do over dx;
	if (substr(dx,1,3)='290' or
		substr(dx,1,3)='291' or
		substr(dx,1,3)='292' or
		substr(dx,1,3)='293' or
		substr(dx,1,3)='294' or
		substr(dx,1,3)='295' or
		substr(dx,1,3)='296' or
		substr(dx,1,3)='297' or
		substr(dx,1,3)='298' or
		substr(dx,1,3)='299' or
		substr(dx,1,3)='300' or
		substr(dx,1,3)='301' or
		substr(dx,1,3)='302' or
		substr(dx,1,3)='303' or
		substr(dx,1,3)='304' or
		substr(dx,1,3)='305' or
		substr(dx,1,3)='306' or
		substr(dx,1,3)='307' or
		substr(dx,1,3)='308' or
		substr(dx,1,3)='309' or
		substr(dx,1,3)='310' or
		substr(dx,1,3)='311' or
		substr(dx,1,3)='312' or
		substr(dx,1,3)='313' or
		substr(dx,1,3)='314' or
		substr(dx,1,3)='315' or
		substr(dx,1,3)='316' or
		substr(dx,1,3)='317' or
		substr(dx,1,3)='318' or
		substr(dx,1,3)='319' or
		substr(dx,1,4)='3310' or
		substr(dx,1,4)='3311' or
		substr(dx,1,4)='3312' or
		substr(dx,1,5)='33182' or
		substr(dx,1,5)='33392' or
		substr(dx,1,4)='3575' or
		substr(dx,1,4)='4255' or
		substr(dx,1,4)='5353' or
		substr(dx,1,4)='5710' or
		substr(dx,1,4)='5711' or
		substr(dx,1,4)='5712' or
		substr(dx,1,4)='5713' or
		substr(dx,1,4)='6483' or
		substr(dx,1,4)='6484' or
		substr(dx,1,4)='6555' or
		substr(dx,1,5)='76071' or
		substr(dx,1,5)='76072' or
		substr(dx,1,5)='76073' or
		substr(dx,1,5)='76075' or
		substr(dx,1,4)='7795' or
		substr(dx,1,4)='7903' or
		substr(dx,1,3)='797' or 
		substr(dx,1,4)='9650' or
		substr(dx,1,4)='9800' or
		substr(dx,1,3)='E95' or
		substr(dx,1,3)='V11' or
		substr(dx,1,4)='V154' or
		substr(dx,1,5)='V1582' or
		substr(dx,1,3)='V40' or
		substr(dx,1,5)='V6284' or
		substr(dx,1,5)='V6285' or
		substr(dx,1,5)='V6542' or
		substr(dx,1,4)='V663' or
		substr(dx,1,4)='V673' or
		substr(dx,1,4)='V701' or
		substr(dx,1,4)='V702' or
		substr(dx,1,4)='V710' or
		substr(dx,1,3)='V79') 
		and any_dx_mental_ill=0 
		then any_dx_mental_ill=1;*set to 1 if not flagged already;
	end;

run;



proc sort data=ip_&suffix._2a;
by BID_hrs_21 s_id index_date;
run;

proc sql;
create table ip_&suffix._3a as select distinct bid_hrs_21,s_id,index_date,
/*total Hospital LOS*/
sum(adj_los) as n_hospd_&suffix. label="total hospital days &suffix."
from ip_&suffix._2a group by bid_hrs_21,s_id,index_date;
quit;

data ip_&suffix._2b;
set ip_&suffix._2a;
if win_start_dt<=admit_date<win_stop_dt;
em_urgent_admit=0; /*Urgent , emergent admissions from admission type*/
if type_adm in (1,2) then em_urgent_admit=1;
em_admit=0;
if type_adm=1 then em_admit=1;
urgent_admit=0;
if type_adm=2 then urgent_admit=1;
elect_admit=0;
if type_adm=3 then elect_admit=1;
ind_ed_charge=0; /*ED charges as another indicator of ED use*/
if ER_AMT>0 & ER_AMT~=. then ind_ed_charge=1;
if ER_AMT=0 | ER_AMT=. then ind_ed_charge=0;
run;

proc sql;
create table ip_&suffix._3b as select distinct bid_hrs_21,s_id,index_date,
/*total ICU days*/
sum(icu_days) as icu_days_&suffix. label="total icu days &suffix.",
/*count of IP admissions, all types*/
count(*) as n_ip_admit_&suffix. label="total n of hospital admit &suffix.",
/*count of admissions with any ED charges*/
count(case when ind_ed_charge=1 then ind_ed_charge else . end) as n_ED_ip_&suffix. 
	label="total n of ED visits with subsequent admit &suffix.",
/*count of admissions for mental illness, per admitting dx*/
count(case when adm_mental_ill=1 then adm_mental_ill else . end) as n_mental_ill_adm_dx_ip_&suffix. 
	label="total n of admissions admit dx=mental illness &suffix.",
/*count of admissions for mental illness, per any dx code*/
count(case when any_dx_mental_ill=1 then any_dx_mental_ill else . end) as n_mental_ill_any_dx_ip_&suffix. 
	label="total n of admissions with any dx of mental illness &suffix."
 from ip_&suffix._2b group by bid_hrs_21,s_id,index_date;
quit;

proc sql;
create table ip_&suffix._3 as select *
from ip_&suffix._3a a 
left join ip_&suffix._3b b
on a.bid_hrs_21=b.bid_hrs_21 and a.index_date=b.index_date;
quit;

data ip_&suffix.;
set ip_&suffix._3;
if icu_days_&suffix.>n_hospd_&suffix. then icu_days_&suffix.=n_hospd_&suffix.;
run;




proc sort data=ip_&suffix.; by bid_hrs_21 s_id index_date; run;

%mend;

/*****************************************************************************/
/*get admissions and ip ed visits from ip claims monthly post R's death*/
/*****************************************************************************/
%macro post_admissions(days_start=,days_aft_index=,suffix=);

/*pull list of ip claims from all medpar claims x days post-death*/
data ip_meet_&suffix._1a;
set proj_int.mp_meet_p24m(where=(trim(left(SSLSSNF))~="N"));
win_stop_dt=index_date+&days_aft_index;
win_start_dt=index_date+&days_start;
format admit_date disch_date win_stop_dt win_start_dt date9.;
run;

data ip_meet_&suffix._1;
set ip_meet_&suffix._1a;
if win_start_dt<=admit_date<=win_stop_dt or 
win_start_dt<=disch_date<=win_stop_dt;
run;

data ip_&suffix._2;
set ip_meet_&suffix._1;
if icarecnt=. then icarecnt=0; /*medpar intensive care day count*/
if CRNRYDAY=. then CRNRYDAY=0; /*medpar coronary day count*/
icu_days=icarecnt+CRNRYDAY;


/*truncate stays where the admit is before R's death
or discharge is after the x days after R's death so can get accurate LOS*/
admit_date2=admit_date;
disch_date2=disch_date;
if admit_date<win_start_dt then do;
	admit_date2=win_start_dt;
	admit_trunc=1;
	end;
if win_stop_dt<disch_date then do;
	disch_date2=win_stop_dt;
	disch_trunc=1;	
	end;
adj_los=disch_date2-admit_date2;
if disch_date-admit_date=0 then adj_los=1;
run;

/*determine if mental health dx is present in the IP claim*/
data ip_&suffix._2a;
set ip_&suffix._2;
/*determine if mental health dx is admitting dx for hospitalization*/
adm_mental_ill=0;

/*dx list from the AHRQ CCS Multi dx Tool, 2015, for Mental Illness Level 1 category*/
	if (substr(ad_dgns,1,3)='290' or
		substr(ad_dgns,1,3)='291' or
		substr(ad_dgns,1,3)='292' or
		substr(ad_dgns,1,3)='293' or
		substr(ad_dgns,1,3)='294' or
		substr(ad_dgns,1,3)='295' or
		substr(ad_dgns,1,3)='296' or
		substr(ad_dgns,1,3)='297' or
		substr(ad_dgns,1,3)='298' or
		substr(ad_dgns,1,3)='299' or
		substr(ad_dgns,1,3)='300' or
		substr(ad_dgns,1,3)='301' or
		substr(ad_dgns,1,3)='302' or
		substr(ad_dgns,1,3)='303' or
		substr(ad_dgns,1,3)='304' or
		substr(ad_dgns,1,3)='305' or
		substr(ad_dgns,1,3)='306' or
		substr(ad_dgns,1,3)='307' or
		substr(ad_dgns,1,3)='308' or
		substr(ad_dgns,1,3)='309' or
		substr(ad_dgns,1,3)='310' or
		substr(ad_dgns,1,3)='311' or
		substr(ad_dgns,1,3)='312' or
		substr(ad_dgns,1,3)='313' or
		substr(ad_dgns,1,3)='314' or
		substr(ad_dgns,1,3)='315' or
		substr(ad_dgns,1,3)='316' or
		substr(ad_dgns,1,3)='317' or
		substr(ad_dgns,1,3)='318' or
		substr(ad_dgns,1,3)='319' or
		substr(ad_dgns,1,4)='3310' or
		substr(ad_dgns,1,4)='3311' or
		substr(ad_dgns,1,4)='3312' or
		substr(ad_dgns,1,5)='33182' or
		substr(ad_dgns,1,5)='33392' or
		substr(ad_dgns,1,4)='3575' or
		substr(ad_dgns,1,4)='4255' or
		substr(ad_dgns,1,4)='5353' or
		substr(ad_dgns,1,4)='5710' or
		substr(ad_dgns,1,4)='5711' or
		substr(ad_dgns,1,4)='5712' or
		substr(ad_dgns,1,4)='5713' or
		substr(ad_dgns,1,4)='6483' or
		substr(ad_dgns,1,4)='6484' or
		substr(ad_dgns,1,4)='6555' or
		substr(ad_dgns,1,5)='76071' or
		substr(ad_dgns,1,5)='76072' or
		substr(ad_dgns,1,5)='76073' or
		substr(ad_dgns,1,5)='76075' or
		substr(ad_dgns,1,4)='7795' or
		substr(ad_dgns,1,4)='7903' or
		substr(ad_dgns,1,3)='797' or 
		substr(ad_dgns,1,4)='9650' or
		substr(ad_dgns,1,4)='9800' or
		substr(ad_dgns,1,3)='E95' or
		substr(ad_dgns,1,3)='V11' or
		substr(ad_dgns,1,4)='V154' or
		substr(ad_dgns,1,5)='V1582' or
		substr(ad_dgns,1,3)='V40' or
		substr(ad_dgns,1,5)='V6284' or
		substr(ad_dgns,1,5)='V6285' or
		substr(ad_dgns,1,5)='V6542' or
		substr(ad_dgns,1,4)='V663' or
		substr(ad_dgns,1,4)='V673' or
		substr(ad_dgns,1,4)='V701' or
		substr(ad_dgns,1,4)='V702' or
		substr(ad_dgns,1,4)='V710' or
		substr(ad_dgns,1,3)='V79') 
		and adm_mental_ill=0 
		then adm_mental_ill=1;*set to 1 if not flagged already;

	   /*now check if mental illness is any of the diagnoses present for the claim*/
any_dx_mental_ill=0;
array dx DGNS_CD01-DGNS_CD25 ;
do over dx;
	if (substr(dx,1,3)='290' or
		substr(dx,1,3)='291' or
		substr(dx,1,3)='292' or
		substr(dx,1,3)='293' or
		substr(dx,1,3)='294' or
		substr(dx,1,3)='295' or
		substr(dx,1,3)='296' or
		substr(dx,1,3)='297' or
		substr(dx,1,3)='298' or
		substr(dx,1,3)='299' or
		substr(dx,1,3)='300' or
		substr(dx,1,3)='301' or
		substr(dx,1,3)='302' or
		substr(dx,1,3)='303' or
		substr(dx,1,3)='304' or
		substr(dx,1,3)='305' or
		substr(dx,1,3)='306' or
		substr(dx,1,3)='307' or
		substr(dx,1,3)='308' or
		substr(dx,1,3)='309' or
		substr(dx,1,3)='310' or
		substr(dx,1,3)='311' or
		substr(dx,1,3)='312' or
		substr(dx,1,3)='313' or
		substr(dx,1,3)='314' or
		substr(dx,1,3)='315' or
		substr(dx,1,3)='316' or
		substr(dx,1,3)='317' or
		substr(dx,1,3)='318' or
		substr(dx,1,3)='319' or
		substr(dx,1,4)='3310' or
		substr(dx,1,4)='3311' or
		substr(dx,1,4)='3312' or
		substr(dx,1,5)='33182' or
		substr(dx,1,5)='33392' or
		substr(dx,1,4)='3575' or
		substr(dx,1,4)='4255' or
		substr(dx,1,4)='5353' or
		substr(dx,1,4)='5710' or
		substr(dx,1,4)='5711' or
		substr(dx,1,4)='5712' or
		substr(dx,1,4)='5713' or
		substr(dx,1,4)='6483' or
		substr(dx,1,4)='6484' or
		substr(dx,1,4)='6555' or
		substr(dx,1,5)='76071' or
		substr(dx,1,5)='76072' or
		substr(dx,1,5)='76073' or
		substr(dx,1,5)='76075' or
		substr(dx,1,4)='7795' or
		substr(dx,1,4)='7903' or
		substr(dx,1,3)='797' or 
		substr(dx,1,4)='9650' or
		substr(dx,1,4)='9800' or
		substr(dx,1,3)='E95' or
		substr(dx,1,3)='V11' or
		substr(dx,1,4)='V154' or
		substr(dx,1,5)='V1582' or
		substr(dx,1,3)='V40' or
		substr(dx,1,5)='V6284' or
		substr(dx,1,5)='V6285' or
		substr(dx,1,5)='V6542' or
		substr(dx,1,4)='V663' or
		substr(dx,1,4)='V673' or
		substr(dx,1,4)='V701' or
		substr(dx,1,4)='V702' or
		substr(dx,1,4)='V710' or
		substr(dx,1,3)='V79') 
		and any_dx_mental_ill=0 
		then any_dx_mental_ill=1;*set to 1 if not flagged already;
	end;

run;


proc sort data=ip_&suffix._2a;
by BID_hrs_21 s_id index_date;
run;

proc sql;
create table ip_&suffix._3a as select distinct bid_hrs_21,s_id,index_date,
/*total Hospital LOS*/
sum(adj_los) as n_hospd_&suffix. label="total hospital days &suffix."
from ip_&suffix._2a group by bid_hrs_21,s_id,index_date;
quit;

data ip_&suffix._2b;
set ip_&suffix._2a;
if win_start_dt<admit_date<=win_stop_dt;
em_urgent_admit=0; /*Urgent , emergent admissions from admission type*/
if type_adm in (1,2) then em_urgent_admit=1;
em_admit=0;
if type_adm=1 then em_admit=1;
urgent_admit=0;
if type_adm=2 then urgent_admit=1;
elect_admit=0;
if type_adm=3 then elect_admit=1;
ind_ed_charge=0; /*ED charges as another indicator of ED use*/
if ER_AMT>0 & ER_AMT~=. then ind_ed_charge=1;
if ER_AMT=0 | ER_AMT=. then ind_ed_charge=0;
run;

proc sql;
create table ip_&suffix._3b as select distinct bid_hrs_21,s_id,index_date,
/*count of IP admissions, all types*/
count(*) as n_ip_admit_&suffix. label="total n of hospital admit &suffix.",
/*count of admissions with any ED charges*/
count(case when ind_ed_charge=1 then ind_ed_charge else . end) as n_ED_ip_&suffix. 
	label="total n of ED visits with subsequent admit &suffix.",
/*total ICU days*/
sum(icu_days) as icu_days_&suffix. label="total icu days &suffix.",
/*count of admissions for mental illness, per admitting dx*/
count(case when adm_mental_ill=1 then adm_mental_ill else . end) as n_mental_ill_adm_dx_ip_&suffix. 
	label="total n of admissions admit dx=mental illness &suffix.",
/*count of admissions for mental illness, per any dx code*/
count(case when any_dx_mental_ill=1 then any_dx_mental_ill else . end) as n_mental_ill_any_dx_ip_&suffix. 
	label="total n of admissions with any dx of mental illness &suffix."
 from ip_&suffix._2b group by bid_hrs_21,s_id,index_date;
quit;

proc sql;
create table ip_&suffix._3 as select *
from ip_&suffix._3a a 
left join ip_&suffix._3b b
on a.bid_hrs_21=b.bid_hrs_21 and a.index_date=b.index_date;
quit;

data ip_&suffix.;
set ip_&suffix._3;
if icu_days_&suffix.>n_hospd_&suffix. then icu_days_&suffix.=n_hospd_&suffix.;
run;



proc sort data=ip_&suffix.; by bid_hrs_21 s_id index_date; run;

%mend;



/*****************************************************************************/
/*get outpatient visits and ed use from op claims monthly pre and post R's death*/
/*****************************************************************************/
%macro op(days=,suffix=);

data op_meet_&suffix.;
set proj_int.op_meet&suffix.(keep=bid_hrs_21 s_id admit_date disch_date 
	index_date RVCNTR01-RVCNTR45);
run;

proc sort data=op_meet_&suffix.; by bid_hrs_21 s_id admit_date; run;

data ed_op_&suffix._1;
set op_meet_&suffix.;
ed_op=0;
array list RVCNTR01-RVCNTR45;
do over list;
	if list >= 450 and list < 460 and ed_op=0 then  
	ed_op = 1;
	end;
run;



proc sql;
create table op_&suffix. as select distinct bid_hrs_21,s_id,index_date,
count(case when ed_op=1 then ed_op else . end)
	as n_ed_op_visits_&suffix. label="n of OP ED visits &suffix.",
count(*) as n_op_visits_&suffix. label="n OP visits &suffix."
	from ed_op_&suffix._1 group by bid_hrs_21,s_id,index_date;
quit;


proc sort data=op_&suffix.; by bid_hrs_21 s_id index_date; run;

%mend;

%macro claims_nesting();

%do i=1 %to 24 ;
%pre_admissions(days_start=floor((&i.-1)*30.417),days_bef_index=floor(&i.*30.417), suffix=m&i.,su=m&i.);
%post_admissions(days_start=floor((&i.-1)*30.417),days_aft_index=floor(&i.*30.417),suffix=m&i.p);
%op(suffix=m&i.);
%op(suffix=m&i.p);
%end;
%mend;
%claims_nesting();

data ip_meet_24m;
set proj_int.ip_meet_24m;
run;

%pre_admissions(days_start=-1,days_bef_index=0,suffix=dod,su=_24m);
proc sql;
create table op_meet_dod1 as select * from
index1a a 
left join medi.op_2000_2012 b
on a.bid_hrs_21=b.bid_hrs_21 and a.index_date=b.index_date and a.index_date=b.admit_date;
quit;

data op_meet_dod;
set op_meet_dod1(keep=bid_hrs_21 s_id admit_date disch_date 
	index_date RVCNTR01-RVCNTR45);
run;
data op_meet_doda;
set op_meet_dod(where=(admit_date=index_date));
run;
proc sort data=op_meet_doda; by bid_hrs_21 s_id admit_date; run;

data ed_op_dod_1;
set op_meet_doda;
ed_op=0;
array list RVCNTR01-RVCNTR45;
do over list;
	if list >= 450 and list < 460 and ed_op=0 then  
	ed_op = 1;
	end;
run;


proc sql;
create table op_0 as select distinct bid_hrs_21,s_id,index_date,
count(case when ed_op=1 then ed_op else . end)
	as n_ed_op_visits_dod label="n of OP ED visits dod",
count(*) as n_op_visits_dod label="n OP visits dod"
	from ed_op_dod_1 group by bid_hrs_21,s_id,index_date;
quit;


proc sort data=op_0; by bid_hrs_21 s_id index_date; run;

data ip_0;
set ip_dod;
run;

proc sort data=ip_0; by bid_hrs_21 s_id index_date; run;
%macro claims_all(source=,);
data &source._all_1;
merge &source._0 &source._m1 &source._m1p;
by bid_hrs_21 s_id index_date;
run;


%do i=2 %to 24 ;
%let l=%eval(&i-1);
data &source._all_&i.;
merge &source._all_&l. &source._m&i. &source._m&i.p;
by bid_hrs_21 s_id index_date;
run;
%end;

data &source._all;
set &source._all_24;
run;

%mend;

%claims_all(source=ip);
%claims_all(source=op);

/*now bring in to list of obs with ffs medicare at R's death*/
proc sql;
create table add_ip(drop=s_id2) as select 
a.bid_hrs_21,a.s_id,b.*
from proj_int.index a
left join
ip_all(rename=(s_id=s_id2)) b
 on trim(left(a.bid_hrs_21))=trim(left(b.bid_hrs_21)) and a.s_id=b.s_id2 and a.index_date=b.index_date;
 quit;

proc sql;
create table proj_int.op_ip_monthly(drop=s_id2) as select *
from add_ip a
left join
op_all(rename=(s_id=s_id2)) b
 on trim(left(a.bid_hrs_21))=trim(left(b.bid_hrs_21)) and a.s_id=b.s_id2 and a.index_date=b.index_date;
 quit;



H="regional data"
/*get zip code for index year, also get birth date*/

data index1;
set proj_int.index;
run;

data trackera;
set hrs_cln.restr_tracker_v2012(keep=id hhid pn birth_date zip:stateusps:);
if id~=.;
rename zip10_2010=ZIP10;
drop zip10_2000 zip92-zip96 stateusps92-stateusps96;
s_id=id;
drop id;
run;

data trackerb(drop=hhid pn);
set trackera;
ZIP01=ZIP00;
zip03=zip02;
zip05=zip04;
zip07=zip08;
zip09=zip08;
zip11=ZIP10;
stateusps01=stateusps00;
stateusps03=stateusps02;
stateusps05=stateusps04;
stateusps07=stateusps08;
stateusps09=stateusps08;
stateusps11=stateusps10;
run;

data trackerc;
set trackerb;
if zip00='' then zip00=zip98;
if zip02='' then zip02=zip00;
if zip04='' then zip04=zip02;
if zip06='' then zip06=zip04;
if zip08='' then zip08=zip06;
if zip10='' then zip10=zip08;
if zip12='' then zip12=zip10;
if zip01='' then zip01=zip02;
if zip03='' then zip03=zip04;
if zip05='' then zip05=zip06;
if zip07='' then zip07=zip08;
if zip09='' then zip09=zip10;
if zip11='' then zip11=zip12;
if stateusps00='' then stateusps00=stateusps98;
if stateusps02='' then stateusps02=stateusps00;
if stateusps04='' then stateusps04=stateusps02;
if stateusps06='' then stateusps06=stateusps04;
if stateusps08='' then stateusps08=stateusps06;
if stateusps10='' then stateusps10=stateusps08;
if stateusps12='' then stateusps12=stateusps10;
if stateusps01='' then stateusps01=stateusps02;
if stateusps03='' then stateusps03=stateusps04;
if stateusps05='' then stateusps05=stateusps06;
if stateusps07='' then stateusps07=stateusps08;
if stateusps09='' then stateusps09=stateusps10;
if stateusps11='' then stateusps11=stateusps12;
run;

proc sort data=trackerc out=tracker;
by s_id;
run;

proc transpose data=tracker out=tracker1;
by s_id;
var zip00-zip12;
run;

data tracker2(keep=s_id zip index_year);
set tracker1(rename=(col1=zip1));
index_year=input(substr(_name_,4),5.)+2000;
zip=zip1+0;
run;

proc transpose data=tracker out=tracker3;
by s_id;
var stateusps00-stateusps12;
run;

data tracker4(keep=s_id stateusps index_year);
set tracker3(rename=(col1=stateusps));
index_year=input(substr(_name_,10),5.)+2000;
run;

proc sql;
create table zipa as select * from
index1 a 
left join tracker2 b
on a.s_id=b.s_id and a.index_year=b.index_year
left join tracker4 c
on a.s_id=c.s_id and a.index_year=c.index_year;
quit;

proc sql;
create table zip as select a.*,b.birth_date from
zipa a
left join tracker b
on a.s_id=b.s_id;
quit;

data zip_cb;
set dartm.xtract(keep=zip5 cbsa state metrodiv);
if metrodiv~='' then cbsa=metrodiv;
zip_n=zip5+0;
cbsa_n=cbsa+0;
/*If zip code is not missing, add state code*/
if zip_n~=.;
state_n=state+0;
run;

proc sort data=zip_cb out=zip_cb2 nodupkey;
by zip_n cbsa_n;
run;

/*note several zip codes have multiple cbsa*/
/*create dataset with just one entry for each zip code
8029 zip codes have more than one cbsa code
Just use the first one when sort*/
proc sort data=zip_cb2 out=cbsa_zip_final nodupkey;
by zip_n;
run;

*Check to see zip codes in a cbsa code for Rochester, NY;
proc sql;
select zip_n, cbsa from cbsa_zip_final
where cbsa_n in (40380);
quit;



/*bring in 2012 wage index file*/
data wage_index;
set dart_wi.wage_index_2012;
run;

/*for zip codes with no cbsa, wage index is left missing
there are also many cbsas with missing wage index*/
proc sql;
create table zip_cbsa_wage_index as
select a.*,b.wage_index_2012 from
cbsa_zip_final a
left join
wage_index b
on a.cbsa_n=b.cbsa_n;
quit;

/*Check for and remove duplicates by zip, keep first entry*/
proc sort data=zip_cbsa_wage_index out=zip_cbsa_wage_index2 nodupkey;
by zip_n;
run;

/******************************************************************/
/* Merge the wage index into the interview dataset by the cleaned zip */
/******************************************************************/

proc sql;
create table zip_wi as select a.*,b.wage_index_2012 from 
zip a 
left join
zip_cbsa_wage_index2 b
on a.zip=b.zip_n;
quit;


/*n=76792 ivws are missing the wage index when matched just by zip*/
data miss_wi;
set zip_wi;
if wage_index_2012 =.;
run;

/******************************************************************/
/* Bring in  WI by state if missing by zip (b/c not in a metro area) */
/******************************************************************/
proc sort data=wage_index out=wage_index3 nodupkey;
by state_in_wage_index;
run;

data wage_index4; set wage_index3; if state_in_wage_index~='';
run;


/*Merges in wage index if there's one for the state but was missing for the zip*/
proc sql;
create table zip_wi_2
as select a.*,coalesce(a.wage_index_2012,b.wage_index_2012) as wage_index_2012_2
from
zip_wi a
left join
wage_index4 b
on a.stateusps=b.ST;
quit;

/*check for missing values*/
proc means;
var wage_index_2012 wage_index_2012_2;
run;



data proj_int.zip_wi;
set zip_wi_2;
/* create census regions */
if stateusps in ('CT','ME','MA','NH','RI','VT','NJ','NY','PA') then REGION=1;
   else if stateusps in ('IN','IL','MI','OH','WI','IA','KS','MN','MO','NE','ND','SD') then REGION=2;
   else if stateusps in ('DE','DC','FL','GA','MD','NC','SC','VA','WV','AL','KY','MS','TN',
        'AR','LA','OK','TX' ) then REGION=3;
   else if stateusps in ('AZ','CO','ID','NM','MT','UT','NV','WY','AK','CA','HI','OR','WA') then REGION=4;
/*create census divisions */
if stateusps in ('CT','ME','MA','NH','RI','VT') then DIVISION=1;
   else if stateusps in ('NJ','NY','PA') then DIVISION=2;
   else if stateusps in ('IN','IL','MI','OH','WI') then DIVISION=3;
   else if stateusps in ('IA','KS','MN','MO','NE','ND','SD') then DIVISION=4;
   else if stateusps in ('DE','DC','FL','GA','MD','NC','SC','VA','WV') then DIVISION=5;
   else if stateusps in ('AL','KY','MS','TN') then DIVISION=6;
   else if stateusps in ('AR','LA','OK','TX' ) then DIVISION=7;
   else if stateusps in ('AZ','CO','ID','NM','MT','UT','NV','WY') then DIVISION=8;
   else if stateusps in ('AK','CA','HI','OR','WA') then DIVISION=9;

/* create medicaid eligibility groupings: =>138% or <138% */
if stateusps in ('AL','AK','FL','GA','ID','KS','LA','ME','MS','MO','MT','NE','NC',
        'OK','SC','SD','TN','TX','UT','VA','WI','WY') then MEDICAID_138=0;
   else if stateusps in ('AR','AZ','CA','CO','CT','DE','DC','HI','IN','IL','IA',
        'KY','MA','MI','MN','MD','NH','ND','NM','NV','NJ','NY','OH','OR','PA',
        'RI','VT','WV','WA') then MEDICAID_138=1;
label region='Census Region: 1=NE,2=MW,3=S,4=W';
label division='Census Division';
label medicaid_138='Medicaid eligibility GE 138% FPL';
run;



H="combine into one dataset"


proc sql; 
create table tomerge as select * from
proj_int.index a left join
proj_int.ffs_before b 
on a.bid_hrs_21=b.bid_hrs_21 and a.index_date=b.index_date
left join 
proj_int.ffs_after c
on a.bid_hrs_21=c.bid_hrs_21 and a.index_date=c.index_date
left join 
proj_int.elix_all d
on a.bid_hrs_21=d.bid_hrs_21 and a.index_date=d.index_date
left join
proj_int.mc_costs_monthly e
on a.bid_hrs_21=e.bid_hrs_21 and a.index_date=e.index_date
left join
proj_int.op_ip_monthly f
on a.bid_hrs_21=f.bid_hrs_21 and a.index_date=f.index_date
left join 
proj_int.zip_wi g
on a.bid_hrs_21=g.bid_hrs_21 and a.index_date=g.index_date
;
quit;
data spouse1;
set proj_int.spouse1;
run;
proc sql;
create table spouse_matched_int_dataset as select * from
proj_int.spouse1 a 
left join
tomerge b 
on a.s_id=b.s_id and a.index_date=b.index_date;
quit;

proc sort data=spouse_matched_int_dataset out=proj_int.spouse_cem_int_dataset nodupkey;
by s_id core_year index_date;
run;
proc export data=proj_int.spouse_cem_int_dataset outfile="E:\data\spouse_claims\spouse_claims_comparison\int_data\spouse_cem_int_dataset.dta" replace;
run;

H="table 1"
clear all
set more off
capture log close

local datapath "E:\data\spouse_claims\spouse_claims_comparison\int_data\"
local logpath "E:\data\spouse_claims\spouse_claims_comparison\logs\"

cd `logpath'
use `datapath'\spouse_cem1, clear

local match r_age_at_core r_comorb_cat2 r_comorb_cat3 r_adl_independent_core ///
r_srh_g r_srh_v s_age_at_core ///
nw2 nw3 nw4 s_comorb_cat2 s_comorb_cat3 ///
s_female s_black s_hisp s_adl_independent_core s_pf ///
r_nhres r_adl_iadl_sp_helper r_cesd_tot s_cesd_tot s_nhres

local rivars1 r_comorb_cat2 r_comorb_cat3 r_adl_independent_core ///
r_srh_pf r_nhres 
local rivars2 r_adl_iadl_sp_helper
local rivars3
local rcvars1 r_age_at_core
local rcvars2 r_cesd_tot
local rcvars3
local scvars1 s_age_at_core
local scvars2 s_cesd_tot
local scvars3 s_northeast s_midwest s_west s_south
local sivars1 nw1 s_comorb_cat2 s_comorb_cat3 ///
s_female s_hseduc s_black s_hisp s_adl_independent_core s_srh_pf ///
s_nhres

local anv
*local rivars2 
local rivars3

local vars Respondent_vars `rcvars1' `rivars1' `rcvars2'  `rivars2' `rcvars3' `rivars3' ///
"Spouse Vars" `scvars1' `sivars1' `scvars2' `sivars2' `scvars3' `sivars3'
local rows `vars' N

local rn : word count `rows'
di "`rn'"
mat tab1=J(`rn',6,.)
mat stars=J(`rn',6,0)
local r=1
local c=1
gen weight=1
foreach b in bonnet {
log using pstests.txt, text replace

foreach time in 0 1 {
if `time'==1 replace weight=cem_weight
svyset [pw=weight]
foreach group in "0" "1" {
	foreach s in r s {
		local r=`r'+1
		foreach round in 1 2 3 {
			foreach x of local `s'cvars`round' {
				qui sum `x' if inlist(ind_,`group') [aw=weight]
				mat tab1[`r',`c']=r(mean) 
				*mat tab1[`r',`c'+1]=r(sd)
				if "`group'"=="1" {
					svy: reg `x' ind_
					test ind_ 
					mat tab1[`r',`c'+1]=r(p)
					mat stars[`r',`c'+1]=(r(p)<.05)+(r(p)<.01)
}
				local r=`r'+1
}
			foreach x of local `s'ivars`round' {
				qui sum `x' if inlist(ind_,`group') [aw=weight]
				mat tab1[`r',`c']=r(mean)*100
				if "`group'"=="1" {
					svy: tab `x' ind_
					mat tab1[`r',`c'+1]=e(p_Pear)
					mat stars[`r',`c'+1]=(e(p_Pear)<.05)+(e(Pear)<.01)
}
				local r=`r'+1
}
}
}
	sum n if inlist(ind_,`group')
	mat tab1[`r',`c']=r(N)
	local c=`c'+1
	if "`group'"=="1" local c=`c'+1
	local r=1
}
keep if cem_ma==1
}
mat rownames tab1=`rows'


frmttable using table_1_cem_matched.rtf, replace statmat(tab1) ///
title("Sample Characteristics, before and after match (pre FFS determination)") ///
ctitles("" "" "Pre match" "" "" "Post match" "" \ "" "Control" "Survivors" "P" "Control" ///
"Survivors" "P") varlabels sdec(2)

use `datapath'spouse_cem_int_dataset if cem_ma==1, clear
gen ffs_at_index=part_ab_at_index==1 & hmo_d_at_i==0
gen weight=cem_weight
svyset [pw=weight]
mat tab1=J(`rn',6,.)
mat stars=J(`rn',6,0)
local r=1
local c=1


foreach time in 0 1 {
preserve
keep if s_female==`time'
foreach group in "0" "1" {
	foreach s in r s {
		local r=`r'+1
		foreach round in 1 2 3 {
			foreach x of local `s'cvars`round' {
				qui sum `x' if inlist(ind_,`group') [aw=weight]
				mat tab1[`r',`c']=r(mean) 
				*mat tab1[`r',`c'+1]=r(sd)
				if "`group'"=="1" {
					svy: reg `x' ind_
					test ind_
					mat tab1[`r',`c'+1]=r(p)
					mat stars[`r',`c'+1]=(r(p)<.05)+(r(p)<.01)
}
				local r=`r'+1
}
			foreach x of local `s'ivars`round' {
				qui sum `x' if inlist(ind_,`group') [aw=weight]
				mat tab1[`r',`c']=r(mean)*100
				if "`group'"=="1" {
					svy: tab `x' ind_
					mat tab1[`r',`c'+1]=e(p_Pear)
					mat stars[`r',`c'+1]=(e(p_Pear)<.05)+(e(p_Pear)<.01)
}
				local r=`r'+1
}
}
}
	sum n if inlist(ind_,`group')
	mat tab1[`r',`c']=r(N)
	local c=`c'+1
	if "`group'"=="1" local c=`c'+1
	local r=1
}
restore
}
mat rownames tab1=`rows'

frmttable using table_1_cem_matched.rtf, addtable statmat(tab1) ///
title("Sample Characteristics, by gender after match (pre FFS determination)") ///
ctitles("" "" "Male Spouses" "" "" "Female Spouses" "" \ "" "Control" "Survivors" "P" "Control" ///
"Survivors" "P") varlabels sdec(2)

use `datapath'spouse_cem_int_dataset, clear
gen ffs_at_index=part_ab_at_index==1 & hmo_d_at_i==0
keep if ffs_at_index==1
gen weight=cem_w
mat tab1=J(`rn',6,.)
mat stars=J(`rn',6,0)
local r=1
local c=1

svyset [pw=weight]
foreach time in 0 1 {
preserve
keep if s_female==`time'
foreach group in "0" "1" {
	foreach s in r s {
		local r=`r'+1
		foreach round in 1 2 3 {
			foreach x of local `s'cvars`round' {
				qui sum `x' if inlist(ind_,`group') [aw=weight]
				mat tab1[`r',`c']=r(mean) 
				*mat tab1[`r',`c'+1]=r(sd)
				if "`group'"=="1" {
					svy: reg `x' ind_
					test ind_
					mat tab1[`r',`c'+1]=r(p)
					mat stars[`r',`c'+1]=(r(p)<.05)+(r(p)<.01)
}
				local r=`r'+1
}
			foreach x of local `s'ivars`round' {
				qui sum `x' if inlist(ind_,`group') [aw=weight]
				mat tab1[`r',`c']=r(mean)*100
				if "`group'"=="1" {
					svy: tab `x' ind_
					mat tab1[`r',`c'+1]=e(p_Pear)
					mat stars[`r',`c'+1]=(e(p_Pear)<.05)+(e(p_Pear)<.01)
}
				local r=`r'+1
}
}
}
	sum n if inlist(ind_,`group')
	mat tab1[`r',`c']=r(N)
	local c=`c'+1
	if "`group'"=="1" local c=`c'+1
	local r=1
}
restore
}
mat rownames tab1=`rows'

frmttable using table_1_cem_matched.rtf, addtable statmat(tab1) ///
title("Sample Characteristics, by gender after match (FFS at index date only)") ///
ctitles("" "" "Male Spouses" "" "" "Female Spouses" "" \ "" "Control" "Survivors" "P" "Control" ///
"Survivors" "P") varlabels sdec(2)


cem s_age_at_core (64.5 74.5 84.5) r_age_at_core (64.5 74.5 84.5) ///
r_adl_independent s_comorb_cat2 s_comorb_cat3 ///
s_hseduc s_female s_black s_hisp ///
r_comorb_cat2 r_comorb_cat3 core_year(#0) ,treatment(ind_)

replace weight=cem_w
mat tab1=J(`rn',6,.)
mat stars=J(`rn',6,0)
local r=1
local c=1

svyset [pw=weight]
foreach time in 0 1 {
preserve
keep if s_female==`time'
foreach group in "0" "1" {
	foreach s in r s {
		local r=`r'+1
		foreach round in 1 2 3 {
			foreach x of local `s'cvars`round' {
				qui sum `x' if inlist(ind_,`group') [aw=weight]
				mat tab1[`r',`c']=r(mean) 
				*mat tab1[`r',`c'+1]=r(sd)
				if "`group'"=="1" {
					svy: reg `x' ind_
					test ind_
					mat tab1[`r',`c'+1]=r(p)
					mat stars[`r',`c'+1]=(r(p)<.05)+(r(p)<.01)
}
				local r=`r'+1
}
			foreach x of local `s'ivars`round' {
				qui sum `x' if inlist(ind_,`group') [aw=weight]
				mat tab1[`r',`c']=r(mean)*100
				if "`group'"=="1" {
					svy: tab `x' ind_
					mat tab1[`r',`c'+1]=e(p_Pear)
					mat stars[`r',`c'+1]=(e(p_Pear)<.05)+(e(p_Pear)<.01)
}
				local r=`r'+1
}
}
}
	sum n if inlist(ind_,`group') & cem_m==1
	mat tab1[`r',`c']=r(N)
	local c=`c'+1
	if "`group'"=="1" local c=`c'+1
	local r=1
}
restore
}
mat rownames tab1=`rows'

frmttable using table_1_cem_matched.rtf, addtable statmat(tab1) ///
title("Sample Characteristics, FFS at index date only") ///
ctitles("" "" "Male Spouses" "" "" "Female Spouses" "" \ "" "Control" "Survivors" "P" "Control" ///
"Survivors" "P") varlabels sdec(2) note(45 surviving spouses dropped whose matches did not have FFS)
}


//now include nhres in match
cem s_age_at_core (64.5 74.5 84.5) r_age_at_core (64.5 74.5 84.5) ///
r_adl_independent s_comorb_cat2 s_comorb_cat3 ///
s_hseduc s_female s_black s_hisp ///
r_comorb_cat2 r_comorb_cat3 s_nhres core_year(#0) ,treatment(ind_)


replace weight=cem_w
mat tab1=J(`rn',6,.)
mat stars=J(`rn',6,0)
local r=1
local c=1

svyset [pw=weight]
foreach time in 0 1 {
preserve
keep if s_female==`time'
foreach group in "0" "1" {
	foreach s in r s {
		local r=`r'+1
		foreach round in 1 2 3 {
			foreach x of local `s'cvars`round' {
				qui sum `x' if inlist(ind_,`group') [aw=weight]
				mat tab1[`r',`c']=r(mean) 
				*mat tab1[`r',`c'+1]=r(sd)
				if "`group'"=="1" {
					svy: reg `x' ind_
					test ind_
					mat tab1[`r',`c'+1]=r(p)
					mat stars[`r',`c'+1]=(r(p)<.05)+(r(p)<.01)
}
				local r=`r'+1
}
			foreach x of local `s'ivars`round' {
				qui sum `x' if inlist(ind_,`group') [aw=weight]
				mat tab1[`r',`c']=r(mean)*100
				if "`group'"=="1" {
					svy: tab `x' ind_
					mat tab1[`r',`c'+1]=e(p_Pear)
					mat stars[`r',`c'+1]=(e(p_Pear)<.05)+(e(p_Pear)<.01)
}
				local r=`r'+1
}
}
}
	sum n if inlist(ind_,`group') & cem_m==1
	mat tab1[`r',`c']=r(N)
	local c=`c'+1
	if "`group'"=="1" local c=`c'+1
	local r=1
}
restore
}
mat rownames tab1=`rows'

frmttable using table_1_cem_matched.rtf, addtable statmat(tab1) ///
title("Sample Characteristics, FFS at index date only") ///
ctitles("" "" "Male Spouses" "" "" "Female Spouses" "" \ "" "Control" "Survivors" "P" "Control" ///
"Survivors" "P") varlabels sdec(2) note(45 surviving spouses dropped whose matches did not have FFS)



H="variable setup in stata"
/*General data setup for the spouse dataset
Limited to decedents with FFS MC 6m prior to death, partner at time of death,
with spouse mc id*/

capture log close

clear all
set more off

//Server file paths
local logpath E:\data\spouse_claims\spouse_claims_comparison\logs
local projdatapath E:\data\spouse_claims\spouse_claims_comparison\int_data

log using `logpath'\2-HRS_Spouse_claims_sample_char.txt, text replace

cd `projdatapath'

use spouse_cem_int_dataset.dta if cem_ma==1, clear
gen ffs_at_index=part_ab_at_index==1 & hmo_d_at_i==0

*********************************************************
gen age=(index_date-birth_date)/365.25

//temporary patch to get total index_dt spending (claims admit_dt index_dt)

foreach y in tot ip snf op pb hh hs dm {
	replace `y'_paid_by_mc_index_dt=0 if `y'_paid_by_mc_index_dt==.
}
replace tot_paid_by_mc_index_dt=ip_paid_by_mc_index_dt+ ///
 snf_paid_by_mc_index_dt+op_paid_by_mc_index_dt + ///
 pb_paid_by_mc_index_dt+hs_paid_by_mc_index_dt+dm_paid_by_mc_index_dt

replace cont_ffs_p_mos=cont_ffs_p_mos-1 if cont_ffs_p_mos>0
gen inscope_n_mos=cont_ffs_n_mos
gen inscope_p_mos=cont_ffs_p_mos

foreach x in tot ip snf op pb hh hs dm {
	forvalues i=1/24 {
		replace `x'_paid_by_mc_m`i'=. if inscope_n_mos<`i'
		replace `x'_paid_by_mc_m`i'p=. if inscope_p_mos<`i'

}
}

foreach x in n_ip_admit_ n_hospd_ n_op_visits_ {
	forvalues i=1/24 {
		replace `x'm`i'=. if inscope_n_mos<`i'
		replace `x'm`i'p=. if inscope_p_mos<`i'
		replace `x'm`i'=0 if inscope_n_mos>=`i'&`x'm`i'==.
		replace `x'm`i'p=0 if inscope_p_mos>=`i'&`x'm`i'p==.

}
}

//spouse medicare spending variables
local mcsp tot_paid_by_mc_ ip_paid_by_mc_ snf_paid_by_mc_ op_paid_by_mc_ ///
pb_paid_by_mc_ hh_paid_by_mc_ hs_paid_by_mc_ dm_paid_by_mc_

//replace wage index=1 if wage index is missing
gen wage_index_missing=wage_index_2012_2==.
replace wage_index_2012_2=1 if wage_index_2012_2==.
//monthly
forvalues i=1/24 {
	foreach v in `mcsp' {
		gen `v'wi_m`i'=`v'm`i'/wage_index_2012_2
		gen `v'wi_m`i'p=`v'm`i'p/wage_index_2012_2
}
}
//at death
foreach v in `mcsp' {	
		replace `v'index_dt=0 if `v'index_dt==.
		gen `v'wi_index_dt=`v'index_dt/wage_index_2012_2
}

local sutil n_ip_admit_ n_hospd_ //n_op_visits_ 
local rutil r_n_ip_admit_ r_n_hospd_ r_n_op_visits_

foreach x in `sutil' {
	foreach p in "" "p" {
		forvalues i= 1(3)24 {
			gen `x'm_`i'_to_`=`i'+2'`p'=0 if `x'm`i'`p'!=.
			foreach j in 0 1 2  {
				replace `x'm_`i'_to_`=`i'+2'`p'=`x'm_`i'_to_`=`i'+2'`p'+ ///
				 `x'm`=`i'+`j''`p' if `x'm`=`i'+`j''`p'!=.
}
}
}
replace `x'm_1_to_3=`x'm_1_to_3 + `x'dod if `x'dod!=.
}

//note--this is a patch; needs to be changed in the sas program-get mc claims lists
replace n_ip_admit_m_1_to_3=n_ip_admit_m_1_to_3 +ip_admit_dod if ip_admit_dod!=.

foreach x in tot ip snf op pb hh hs dm {
	forvalues i= 1(3)24 {
		gen `x'_paid_by_mc_wi_m_`i'_to_`=`i'+2'=`x'_paid_by_mc_wi_m`i' 
		foreach j in 1 2  {
			replace `x'_paid_by_mc_wi_m_`i'_to_`=`i'+2'= ///
			 `x'_paid_by_mc_wi_m_`i'_to_`=`i'+2'+`x'_paid_by_mc_wi_m`=`i'+`j'' ///
			 if `x'_paid_by_mc_wi_m`=`i'+`j''!=.
}

		gen `x'_paid_by_mc_wi_m_`i'_to_`=`i'+2'p=`x'_paid_by_mc_wi_m`i'p 
		foreach j in 1 2 {
			replace `x'_paid_by_mc_wi_m_`i'_to_`=`i'+2'p= ///
			 `x'_paid_by_mc_wi_m_`i'_to_`=`i'+2'p +`x'_paid_by_mc_wi_m`=`i'+`j''p ///
			 if `x'_paid_by_mc_wi_m`=`i'+`j''p!=.

}
}
	replace `x'_paid_by_mc_wi_m_1_to_3=`x'_paid_by_mc_wi_m_1_to_3+ ///
	 `x'_paid_by_mc_wi_index_dt if `x'_paid_by_mc_wi_index_dt!=.

}

forvalues i=1/24 {
	foreach p in "" "p" {
		gen ip_admit_ind_m`i'`p'=n_ip_admit_m`i'`p'>=1 if n_ip_admit_m`i'`p'!=.
}
}
replace ip_admit_ind_m1=1 if ip_admit_dod==1

forvalues i=1(3)24 {
	foreach p in "" "p" {
		gen ip_admit_ind_m_`i'_to_`=`i'+2'`p'=n_ip_admit_m_`i'_to_`=`i'+2'`p'>=1 ///
		 if n_ip_admit_m_`i'_to_`=`i'+2'`p'!=.
}
}

//get six, 12, 24m spending admits ed visits

foreach m in 6 12 24 {
	foreach p in "" p {
		foreach x in `sutil' ip_admit_ind_ tot_paid_by_mc_wi_ ip_paid_by_mc_wi_ {
			gen `x'`p'`m'm=0	
				forvalues i=1/`m' {
					replace `x'`p'`m'm=`x'`p'`m'm+`x'm`i'`p' if !missing(`x'm`i'`p')
}
}
*		gen ip_admit_ind_`m'm`p'=n_ip_admit_`p'`m'm>0 if !missing(n_ip_admit_`p'`m'm)
}
}		

*********************************************************
/*
//create indicator variables for S any hospitalization, hosp due to mental illness,
//ICU use, and ED use
foreach t in 6m 12m 18m 24m p6m p12m p18m p24m{
	gen icu_ind_`t'=1 if icu_days_`t'>0 & icu_days_`t'!=.
	replace icu_ind_`t'=0 if icu_days_`t'==0
	la var icu_ind_`t' "S Any ICU use `t'"
	la var icu_days_`t' "S ICU days `t'"
	
	gen admit_ind_`t'=1 if n_ip_admit_`t'>0 & n_ip_admit_`t'!=.
	replace admit_ind_`t'=0 if n_ip_admit_`t'==0
	la var admit_ind_`t' "S Any Hospitalization `t'"
	la var n_ip_admit_`t' "S Number hospitalizations `t'"
	
	la var n_hospd_`t' "S Hospital days `t'"
	
	gen ed_ind_`t'=1 if n_ed_`t'>0 & n_ed_`t'!=.
	replace ed_ind_`t'=0 if n_ed_`t'==0
	la var ed_ind_`t' "S Any ED use `t'"
	la var  n_ed_`t' "S Number ED visits `t'"
	
	la var n_op_visits_`t' "S Number Outpatient visits `t'"

	gen admit_mental_ill_ind_`t'=1 if n_mental_ill_adm_dx_ip_`t'>0 & n_mental_ill_adm_dx_ip_`t'!=.
	replace admit_mental_ill_ind_`t'=0 if n_mental_ill_adm_dx_ip_`t'==0
	la var admit_mental_ill_ind_`t' "S Any mental illness hospital admit (adm dx) `t'"
	
	gen ip_any_dx_mental_ill_ind_`t'=1 if n_mental_ill_any_dx_ip_`t'>0 & n_mental_ill_any_dx_ip_`t'!=.
	replace ip_any_dx_mental_ill_ind_`t'=0 if n_mental_ill_any_dx_ip_`t'==0
	la var ip_any_dx_mental_ill_ind_`t' "S Any mental illness dx from IP claim (any dx) `t'"	
}
*/
**************************************************************************
//create variables for s spending, utilization in 6-12m, 12m-18m, 18m-24m windows
//for plotting spending over time

//check id for duplicates
sort s_id
quietly by s_id : gen dup2 = cond(_N==1,0,_n)
tab dup2 //2 instances with spouse with more than one partner

************************************************************
//save this dataset
save E:\data\spouse_claims\spouse_claims_comparison\final_data\spouse_claims_comparison_clean.dta, replace

*********************************************************
log close



H="sample derivation"
/*Limited to decedents with FFS MC 6m prior to death, married at time of death,
with spouse mc id*/
clear all
mata: mata clear
set more off
capture log close
import excel "E:\data\Dartmouth_misc\EOL_mc_2yrs_HRR\DAP_HRR_03_07_to_merge.xls", sheet("Sheet1") firstrow case(lower) clear
keep hrr totalmedic
rename hrr hrrnum
xtile eol_spending_quintile=tot, nq(5)
xtile eol_spending_quartile=tot, nq(4)
gen eol_spending_3_cat=eol_spending_quartile
replace eol_spending_3_cat=eol_spending_3_cat-1 if inlist(eol_spending_3_cat,3,4)
label define eol_spending_3_cat 1 "Bottome Quartile" 2 "Middle 50%" 3 "Top quartile"
label values eol_spending_3_cat eol_spending_3_cat
gen eol_spending_low=eol_spending_3_cat==1
gen eol_spending_mid=eol_spending_3_cat==2
gen eol_spending_high=eol_spending_3_cat==3
label var eol_spending_low "Bottom Quartile EOL spending by Dartmouth HRR"
label var eol_spending_mid "Middle 50% EOL spending by Dartmouth HRR"
label var eol_spending_high "Top Quartile EOL spending by Dartmouth HRR"
label var eol_spending_3_cat "EOL Spending Group by Dartmouth HRR, Adjusted"
label var eol_spending_quintile "EOL Spending Quintile by Dartmouth HRR, Adjusted"
tab eol_spending_quartile, gen(eol_spend_quart)
label var eol_spend_quart1 "Quartile EOL spending by HRR: Low"
label var eol_spend_quart2 "Quartile EOL spending by HRR: Mid-low"
label var eol_spend_quart3 "Quartile EOL spending by HRR: Mid-high"
label var eol_spend_quart4 "Quartile EOL spending by HRR: High"
tempfile temp1
save "`temp1'"

/*General data setup for the spouse dataset
Limited to decedents with FFS MC 6m prior to death, partner at time of death,
with spouse mc id*/

capture log close

clear all
set more off

//Server file paths
local logpath E:\data\spouse_claims\spouse_claims_comparison\logs
local projdatapath E:\data\spouse_claims\spouse_claims_comparison\final_data

log using `logpath'\2-HRS_Spouse_claims_sample_char.txt, text replace

cd `projdatapath'

use spouse_claims_comparison_clean.dta
gen id=s_hhid+s_pn
merge 1:1 id core_year using "E:\data\serious_ill\int_data\core_ids_1yr_criteria_5.dta", keep(match master) nogen keepusing(hrrnum)
merge m:1 hrrnum using `temp1', keep(match master) nogen 
**************************************
drop if s_death_date<index_date
//now include nhres in match
cem s_age_at_core (54.5 64.5 74.5 84.5) r_age_at_core (54.5 64.5 74.5 84.5) ///
r_adl_independent s_comorb_cat2 s_comorb_cat3 ///
s_hseduc s_female s_black s_hisp ///
r_comorb_cat2 r_comorb_cat3 ffs_at_index core_year(#0) ,treatment(ind_)

gen yes=1
gen alive=s_death_date>index_date
gen has_xwalk=1
replace ffs_at_index=0 if has_xwalk==0
gen has_core=s_c_ivw_date!=. & ffs_at_index==1
label var yes "N with index date 2000-2012"
label var alive "Alive at index date"
label var has_core "with n1 core interview"
label var has_xwalk "with Medicare xwalk"
label var ffs_at_index "with FFS Medicare at index date"

mat sample=J(6,6,.)
local r=1
local c=1

foreach i in !=. ==0 ==1 {
foreach f in 0 1 {
	foreach x in yes alive has_xwalk ffs_at_index has_core cem_m {
		sum yes if `x'==1 & ind_`i' & s_female==`f'
		mat sample[`r',`c']=r(N)
		local r=`r'+1
}
	local c=`c'+1
	local r=1
}
}
mat rownames sample=yes alive has_xwalk ffs_at_index_dt has_core
frmttable using "`logpath'\comparison_sample_derivation.rtf", ///
statmat(sample) title("Sample derivation, comparison group") replace ///
ctitles("" "" "All""" "" "With CEM match" \"" "N Total" "N Control" "N Survivors" ///
"N Total" "N Control" "N Survivors") varlabels sdec(0) ///



keep if cem_m==1
save spouse_claims_comparison_sample.dta, replace


H="table 1 with outcomes"
clear all
set more off
capture log close



local datapath "E:\data\spouse_claims\spouse_claims_comparison\int_data\"
local logpath "E:\data\spouse_claims\spouse_claims_comparison\logs\"

cd `logpath'
use `datapath'\spouse_cem1, clear

local match r_age_at_core r_comorb_cat2 r_comorb_cat3 r_adl_independent_core ///
r_srh_g r_srh_v s_age_at_core ///
nw2 nw3 nw4 s_comorb_cat2 s_comorb_cat3 ///
s_female s_black s_hisp s_adl_independent_core s_pf ///
r_nhres r_adl_iadl_sp_helper r_cesd_tot s_cesd_tot s_nhres

foreach s in r s {
	label var `s'_comorb_cat2 "`s' comorbidity mild"
	label var `s'_comorb_cat3 "`s' comorbidity moderate/severe"
}
label var s_northeast "Northeast"
label var s_midwest "Midwest"
label var s_west "West"
label var s_south "South"
label var nw1 "Networth quartile, low"
local rivars1 r_comorb_cat2 r_comorb_cat3 r_adl_independent_core 
local rivars2 
local rivars3
local rcvars1 r_age_at_core
local rcvars2 
local rcvars3
local scvars1 s_age_at_core
local scvars2 
local scvars3 
local sivars1 s_female s_hseduc s_comorb_cat2 s_comorb_cat3 ///
 s_black s_hisp 
 
local anv
*local rivars2 
local rivars3

local vars Respondent_vars `rcvars1' `rivars1' `rcvars2'  `rivars2' `rcvars3' `rivars3' ///
"--" "Spouse Vars" `scvars1' `sivars1' `scvars2' `sivars2' `scvars3' `sivars3'
local rows `vars' N

local rn : word count `rows'
di "`rn'"
mat tab1=J(`rn',6,.)
mat stars=J(`rn',6,0)
local r=1
local c=1
gen weight=1
foreach b in bonnet {
log using pstests.txt, text replace

foreach time in 0 1 {
if `time'==1 replace weight=cem_weight
svyset [pw=weight]
foreach group in "0" "1" {
	foreach s in r s {
		local r=`r'+1
		foreach round in 1 2 3 {
			foreach x of local `s'cvars`round' {
				qui sum `x' if inlist(ind_,`group') [aw=weight]
				mat tab1[`r',`c']=r(mean) 
				*mat tab1[`r',`c'+1]=r(sd)
				if "`group'"=="1" {
					svy: reg `x' ind_
					test ind_ 
					mat tab1[`r',`c'+1]=r(p)
					mat stars[`r',`c'+1]=(r(p)<.05)+(r(p)<.01)
}
				local r=`r'+1
}
			foreach x of local `s'ivars`round' {
				qui sum `x' if inlist(ind_,`group') [aw=weight]
				mat tab1[`r',`c']=r(mean)*100
				if "`group'"=="1" {
					svy: tab `x' ind_
					mat tab1[`r',`c'+1]=e(p_Pear)
					mat stars[`r',`c'+1]=(e(p_Pear)<.05)+(e(Pear)<.01)
}
				local r=`r'+1
}
}
		if "`s'"=="r" local r=`r'+1
}
	sum n if inlist(ind_,`group')
	mat tab1[`r',`c']=r(N)
	local c=`c'+1
	if "`group'"=="1" local c=`c'+1
	local r=1
}
keep if cem_ma==1
}
mat rownames tab1=`rows'


frmttable using table_1_sample, replace statmat(tab1) ///
title("Matching variables, before and after match (pre FFS determination)") ///
ctitles("" "" "Pre match" "" "" "Post match" "" \ "" "Control" "Survivors" "P" "Control" ///
"Survivors" "P") varlabels sdec(2)

}

local datapath "E:\data\spouse_claims\spouse_claims_comparison\final_data\"
local logpath "E:\data\spouse_claims\spouse_claims_comparison\logs\"

cd `logpath'
use `datapath'\spouse_claims_comparison_sample, clear


local match r_age_at_core r_comorb_cat2 r_comorb_cat3 r_adl_independent_core ///
r_srh_g r_srh_v s_age_at_core ///
nw2 nw3 nw4 s_comorb_cat2 s_comorb_cat3 ///
s_female s_white s_black s_hisp s_adl_independent_core s_pf ///
r_nhres r_adl_iadl_sp_helper r_cesd_tot s_cesd_tot s_nhres
gen s_died_1yr=s_death_date-index_date<366
gen s_died_2yr=s_death_date-index_date<731
label var s_died_1yr "Spouse death <=365 days after index"
label var s_died_2yr "Spouse death <=730 days after index"
local rivars1 r_white r_black r_hisp r_hseduc s_medicaid s_medigap s_champus ///
r_comorb_cat1 r_comorb_cat2 r_comorb_cat3 r_adl_independent_core ///
r_srh_pf // r_nhres 
local rivars2 r_adl_iadl_sp_helper
local rivars3
local rcvars1 r_age_at_core
local rcvars2 r_cesd_tot
local rcvars3
local scvars1 s_age_at_core 
local scvars2 s_networth_adj /*s_cesd_tot*/
local scvars3 
local sivars1 s_female s_white s_black s_hisp  s_hseduc 
local sivars2 nw1 s_medicaid s_medigap s_champus s_comorb_cat1 s_comorb_cat2 s_comorb_cat3 ///
s_adl_independent_core s_srh_pf ///
//s_nhres
local sivars3 s_northeast s_midwest s_west s_south eol_spend_quart1 ///
eol_spend_quart2 eol_spend_quart3 eol_spend_quart4
local coutcomes1 tot_paid_by_mc_wi_12m tot_paid_by_mc_wi_p12m ///
 ip_paid_by_mc_wi_12m ip_paid_by_mc_wi_p12m n_hospd_12m n_hospd_p12m 
local coutcomes2
local coutcomes3
local ioutcomes1 ip_admit_ind_12m ip_admit_ind_p12m s_died_1yr s_died_2yr
local ioutcomes2
local ioutcomes3


foreach s in r s {
	label var `s'_comorb_cat1 "`s' comorbidity: none"
	label var `s'_comorb_cat2 "`s' comorbidity: mild"
	label var `s'_comorb_cat3 "`s' comorbidity: moderate/severe"
}

label var s_northeast "Northeast"
label var s_midwest "Midwest"
label var s_west "West"
label var s_south "South"
label var nw1 "Bottom quartile networth"
label var tot_paid_by_mc_wi_12m "Total Paid by MC 12m prior to index"
label var tot_paid_by_mc_wi_p12m "Total Paid by MC 12m post index"
label var ip_paid_by_mc_wi_12m "IP Paid by MC 12m prior to index"
label var ip_paid_by_mc_wi_12m "IP Paid by MC 12m post index"
label var n_hospd_12m "Total Hospital days 12m prior to index"
label var n_hospd_p12m "Total Hospital days 12m post index"
label var ip_admit_ind_12m "Ind. any IP admit 12m prior to index"
label var ip_admit_ind_p12m "Ind. any IP admit 12m post index"
local vars Respondent_vars `rcvars1' `rivars1' `rcvars2'  `rivars2' `rcvars3' `rivars3' ///
"--" "Spouse Vars" `scvars1' `sivars1' `scvars2' `sivars2' `scvars3' `sivars3' ///
"--" "Utilization" `coutcomes1' `coutcomes2' `coutcomes3' `ioutcomes1' `ioutcomes2' `ioutcomes3'
local rows `vars' N

foreach time in 2 1 0 {
local rn : word count `rows'
di "`rn'"
local loc `time'
di `loc'
mat tab1`loc'=J(`rn',3,.)
mat stars`loc'=J(`rn',3,0)
local r=1
local c=1


preserve

if `time'<2 keep if s_female==`time'
local table addtable

foreach b in bonnet {

svyset [pw=cem_weight]
foreach group in "0" "1" {
	foreach s in r s {
		local r=`r'+1
		foreach round in 1 2 3 {
			foreach x of local `s'cvars`round' {
				qui sum `x' if inlist(ind_,`group') [aw=cem_weight]
				mat tab1`loc'[`r',`c']=r(mean) 
				*mat tab1`loc'[`r',`c'+1]=r(sd)
				if "`group'"=="1" {
					svy: reg `x' ind_
					test ind_ 
					mat tab1`loc'[`r',`c'+1]=r(p)
					mat stars`loc'[`r',`c'+1]=(r(p)<.05)+(r(p)<.01)
}
				local r=`r'+1
}
			foreach x of local `s'ivars`round' {
				qui sum `x' if inlist(ind_,`group') [aw=cem_weight]
				mat tab1`loc'[`r',`c']=r(mean)*100
				if "`group'"=="1" {
					svy: tab `x' ind_
					mat tab1`loc'[`r',`c'+1]=e(p_Pear)
					mat stars`loc'[`r',`c'+1]=(e(p_Pear)<.05)+(e(Pear)<.01)
}
				local r=`r'+1
}
}
		local r=`r'+1
}	
	local r=`r'+1
	foreach round in 1 2 3 {
		foreach x of local coutcomes`round' {
			qui sum `x' if inlist(ind_,`group') [aw=cem_weight]
			mat tab1`loc'[`r',`c']=r(mean) 
			*mat tab1`loc'[`r',`c'+1]=r(sd)
			if "`group'"=="1" {
				svy: reg `x' ind_
				test ind_ 
				mat tab1`loc'[`r',`c'+1]=r(p)
				mat stars`loc'[`r',`c'+1]=(r(p)<.05)+(r(p)<.01)
}
			local r=`r'+1
}
		foreach x of local ioutcomes`round' {
			qui sum `x' if inlist(ind_,`group') [aw=cem_weight]
			mat tab1`loc'[`r',`c']=r(mean)*100
			if "`group'"=="1" {
				svy: tab `x' ind_
				mat tab1`loc'[`r',`c'+1]=e(p_Pear)
				mat stars`loc'[`r',`c'+1]=(e(p_Pear)<.05)+(e(Pear)<.01)
}
			local r=`r'+1

}
}
	sum n if inlist(ind_,`group')
	mat tab1`loc'[`r',`c']=r(N)
	local c=`c'+1
	if "`group'"=="1" local c=`c'+1
	local r=1
}
mat rownames tab1`loc'=`rows'
}
restore

}

frmttable using table_1_sample, addtable statmat(tab12) ///
title("Sample Characteristics, after match") ///
ctitles("" "Control" "Survivors" "P") varlabels sdec(2) ///
note(Characteristics after dropping those without a match after FFS and reweighting)

/*
frmttable using table_1_sample, addtable statmat(tab10) merge(tab11) ///
title("Sample Characteristics, after match") ///
ctitles("" "" "Male Spouses" "" "" "Female Spouses" "" \ "" "Control" "Survivors" "P" "Control" ///
"Survivors" "P") varlabels sdec(2)
*/
frmttable, statmat(tab10) store(tab0) ///
title("Sample Characteristics, after match") ///
/*ctitles("" "" "Male Spouses" "" "" "Female Spouses" "" \ "" "Control" "Survivors" "P" "Control" ///
"Survivors" "P")*/ varlabels sdec(2)
frmttable, statmat(tab11) store(tab1) ///
title("Sample Characteristics, after match") ///
/*ctitles("" "" "Male Spouses" "" "" "Female Spouses" "" \ "" "Control" "Survivors" "P" "Control" ///
"Survivors" "P")*/ varlabels sdec(2)

frmttable using table_1_sample, addtable replay(tab0) merge(tab1) ///
title("Sample Characteristics, after match by gender") ///
ctitles("" "" "Male Spouses" "" "" "Female Spouses" "" \ "" "Control" "Survivors" "P" "Control" ///
"Survivors" "P") varlabels sdec(2)

foreach g in "0,1" 0 1 {
preserve
keep if inlist(s_female,`g')
if "`g'"=="0" local group ", Male spouse only"
if "`g'"=="1" local group ", Female spouses only"
mat tabl=J(17,4,.)
local r=1
local c=1


foreach j in 0 1 {
	sum s_female if ind_==`j'
	local denom=r(N)
forvalues i=22(-3)1 {
	sum s_female if cont_ffs_n_mos>=`i' & ind_==`j'
	mat tabl[`r',`c']=r(N)
	mat tabl[`r',`c'+1]=(r(N)/`denom')*100
	local r=`r'+1
}
	sum s_female if part_ab_at_index==1 & hmo_d_at_index==0 & ind_==`j'
	mat tabl[`r',`c']=r(N)
	mat tabl[`r',`c'+1]=(r(N)/`denom')*100
	local r=`r'+1

forvalues i=1(3)24 {
	sum s_female if cont_ffs_p_mos>=`i' & ind_==`j'
	mat tabl[`r',`c']=r(N)
	mat tabl[`r',`c'+1]=(r(N)/`denom')*100
	local r=`r'+1
}
local r=1
local c=`c'+2
}
mat rownames tabl="22-24" "19-21" "16-18" "13-15" "10-12" "7-9" "4-6" "-1-3" ///
"at index" "+1-3" "4-6" "7-9" "10-12" "13-15" "16-18" "19-21" "22-24"

frmttable using table_1_sample, addtable statmat(tabl) title("FFS sample size at different periods`group'") ///
ctitles("Time frame" "N Controls w/ FFS" "% of total" ///
"N Survivors with FFS" "% of total") sdec(0,1,0,1) ///
note("FFS determined at closest point in period to death")
restore
}

mat tabl=J(6,4,.)
local r=1 
local c=1

forvalues i=2000(2)2010 {
	foreach g in  1 0 {
		foreach ind in 0 1 {
			sum s_female if s_female==`g' & ind_==`ind' & core_year==`i'
			mat tabl[`r',`c']=r(N)
			local c=`c'+1
}
}
	local c=1
	local r=`r'+1
}

mat rownames tabl=2000 2002 2004 2006 2008 2010 


frmttable using table_1_sample, addtable  statmat(tabl) ctitles("Core" "Women" "" "Men" ""\"" "Matched" ///
"Bereaved" "Matched" "Bereaved") sdec(0) title("Sample by core year")


H="three month spending tables"
/*three month tables 
variables are tot_paid_by_mc_
			  n_ip_admit_
			  n_op_visits_
			  n_hospd_
we want N if !=., N if !=0, mean, old 6m vars for total and gender*/


capture log close

clear all
set more off

//Server file paths
local logpath E:\data\spouse_claims\spouse_claims_comparison\logs\graphs
local projdatapath E:\data\spouse_claims\spouse_claims_comparison\final_data

log using `logpath'\comparison_3month_tables.txt, text replace

cd `projdatapath'

use spouse_claims_comparison_clean.dta, clear
gen cont_ffs__mos=cont_ffs_n_mos
keep if ffs_at_index==1
preserve
foreach x in tot_paid_by_mc_wi_ n_ip_admit_ n_op_visits_ {
	foreach p in "" "p" {
		mat spending`p'=J(8,6,.)
		local r=1
		local c=1

		gen `x'`p'=0
		forvalues i=1(3)24 {
			qui sum `x'm_`i'_to_`=`i'+2'`p' if cont_ffs_`p'_mos>=`i'
			mat spending`p'[`r',1]=r(mean)
			mat spending`p'[`r',2]=r(N)
			qui sum `x'm_`i'_to_`=`i'+2'`p' if `x'm_`i'_to_`=`i'+2'`p'!=0 & cont_ffs_`p'_mos>=`i'
			mat spending`p'[`r',3]=r(mean)
			mat spending`p'[`r',4]=r(N)
			qui replace `x'`p'=`x'`p'+`x'm_`i'_to_`=`i'+2'`p' if `x'm_`i'_to_`=`i'+2'`p'!=.
			qui sum `x'`p'
			mat spending`p'[`r',5]=r(mean)
			local r=`r'+1
}
		local r=2

		/*foreach n in 6 12 18 24 {
			qui sum `x'`p'`n'm 
			mat spending`p'[`r',6]=r(mean)
			local r=`r'+2
}
*/
	mat rownames spending`p'="0-3" "3-6" "6-9" "9-12" "12-15" "15-18" "18-21" "21-24"

}
	if "tot_paid_by_mc_wi_"=="`x'" {
		local this replace
}
	else {
		local this addtable
}
	frmttable using `logpath'\3month_spending_util_tables, `this' statmat(spending) title("`x' 24m prior to index date") ///
	 ctitles("" "Mean" "N" "Mean if !=0" "N" "Cumulative") sdec(2,0,2,0,2) 
	 
	frmttable using `logpath'\3month_spending_util_tables, addtable statmat(spendingp) title("`x' , 24m after index date") ///
	 ctitles("" "Mean" "N" "Mean if !=0" "N" "Cumulative") sdec(2,0,2,0,2) 
}

restore
preserve
mat ip=J(8,5,.)
mat ipaft=J(8,5,.)

local r=1 
local c=1
gen yes=1
gen ever=0
forvalues i=1(3)24 {
	sum yes if cont_ffs_n_mos>=`i'
	mat ip[`r',1]=r(N)
	sum ip_admit_ind_m_`i'_to_`=`i'+2' if cont_ffs_n_mos>=`i'
	mat ip[`r',2]=r(N)*r(mean)
	mat ip[`r',3]=r(mean)*100
	replace ever=1 if ip_admit_ind_m_`i'_to_`=`i'+2'==1
	sum ever
	mat ip[`r',4]=r(mean)*100
	sum ever if cont_ffs_n_mos>=`i'
	mat ip[`r',5]=r(mean)*100
	local r=`r'+1
}

replace ever=0
local r=1

forvalues i=1(3)24 {
	sum yes if cont_ffs_p_mos>=`i'
	mat ipaft[`r',1]=r(N)
	sum ip_admit_ind_m_`i'_to_`=`i'+2'p if cont_ffs_p_mos>=`i'
	mat ipaft[`r',2]=r(N)*r(mean)
	mat ipaft[`r',3]=r(mean)*100
	replace ever=1 if ip_admit_ind_m_`i'_to_`=`i'+2'p==1
	sum ever
	mat ipaft[`r',4]=r(mean)*100
	sum ever if cont_ffs_p_mos>=`i'
	mat ipaft[`r',5]=r(mean)*100
	local r=`r'+1
}

foreach a in "" "aft" {
	mat rownames ip`a'="0-3" "3-6" "6-9" "9-12" "12-15" "15-18" "18-21" "21-24"
}
	
frmttable using `logpath'\3month_ip_admit_ind, statmat(ip) ///
title("Indicator IP admission prior to index date") sdec(0,0,2) replace ///
ctitles("" "N in scope" "N Yes" "% Yes" "% Cumul" "% Cumul in scope") ///
note(In scope defined as continuous fee for service Medicare at the ///
point of period closest to index date)
	
frmttable using `logpath'\3month_ip_admit_ind, statmat(ipaft) ///
title("Indicator IP admission after index date") sdec(0,0,2) addtable ///
ctitles("" "N in scope" "N Yes" "% Yes" "% Cumul" "% Cumul in scope") ///
note(In scope defined as continuous fee for service Medicare at the ///
point of period closest to index date)

mat ip=J(8,5,.)
mat ipaft=J(8,5,.)

local r=1 
local c=1
replace ever=0
keep if inscope_p_mos>=24

forvalues i=1(3)24 {
	sum yes if cont_ffs_n_mos>=`i'
	mat ip[`r',1]=r(N)
	sum ip_admit_ind_m_`i'_to_`=`i'+2' if cont_ffs_n_mos>=`i'
	mat ip[`r',2]=r(N)*r(mean)
	mat ip[`r',3]=r(mean)*100
	replace ever=1 if ip_admit_ind_m_`i'_to_`=`i'+2'==1
	sum ever
	mat ip[`r',4]=r(mean)*100
	sum ever if cont_ffs_n_mos>=`i'
	mat ip[`r',5]=r(mean)*100
	local r=`r'+1
}

replace ever=0
local r=1

forvalues i=1(3)24 {
	sum yes if cont_ffs_p_mos>=`i'
	mat ipaft[`r',1]=r(N)
	sum ip_admit_ind_m_`i'_to_`=`i'+2'p if cont_ffs_p_mos>=`i'
	mat ipaft[`r',2]=r(N)*r(mean)
	mat ipaft[`r',3]=r(mean)*100
	replace ever=1 if ip_admit_ind_m_`i'_to_`=`i'+2'p==1
	sum ever
	mat ipaft[`r',4]=r(mean)*100
	sum ever if cont_ffs_p_mos>=`i'
	mat ipaft[`r',5]=r(mean)*100
	local r=`r'+1
}

foreach a in "" "aft" {
	mat rownames ip`a'="0-3" "3-6" "6-9" "9-12" "12-15" "15-18" "18-21" "21-24"
}
	
frmttable using `logpath'\3month_ip_admit_ind, statmat(ip) ///
title("Indicator IP admission prior to index date" "24m survivors only") sdec(0,0,2) addtable ///
ctitles("" "N in scope" "N Yes" "% Yes" "% Cumul" "% Cumul in scope") ///
note(In scope defined as continuous fee for service Medicare at the ///
point of period closest to index date)
	
frmttable using `logpath'\3month_ip_admit_ind, statmat(ipaft) ///
title("Indicator IP admission after index date" "24m survivors only") sdec(0,0,2) addtable ///
ctitles("" "N in scope" "N Yes" "% Yes" "% Cumul" "% Cumul in scope") ///
note(In scope defined as continuous fee for service Medicare at the ///
point of period closest to index date)


H="three month spending graphs"
/*General data setup for the dataset
Limited to decedents with FFS MC 6m prior to Index Date, partner at time of Index Date,
with mc id*/

capture log close

clear all
set more off

//Server file paths
local logpath E:\data\spouse_claims\spouse_claims_comparison\logs
local projdatapath E:\data\spouse_claims\spouse_claims_comparison\final_data


cd `projdatapath'

use spouse_claims_comparison_sample.dta
cd `logpath'\graphs
svyset [pw=cem_w]
//note-you can use these next lines to drop the top 3% of pre-Index Date_spenders
/*
gen perstime=s_cont_ffs_n_mos
replace perstime=24 if perstime>24
gen npt=s_tot_paid_by_mc_24m/perstime
gen pperstime=s_cont_ffs_p_mos
replace pperstime=24 if ppers>24
gen ppt=s_tot_paid_by_mc_p24m/pperstime
gen pt=npt+ppt
gsort -npt
drop if _n<50
*/

forvalues n=1(3)24 {
	sum tot_paid_by_mc_wi_m_`n'_to_`=`n'+2' if inscope_n_mos>=`n' [aw=cem_w]
	gen ffs_tot`n'=. 
	sum tot_paid_by_mc_wi_m_`n'_to_`=`n'+2'p if inscope_p_mos>=`n' [aw=cem_w]
	gen ffs_tot`=`n'+25'=.
	sum tot_paid_by_mc_wi_m_`n'_to_`=`n'+2' if inscope_n_mos>=`n' & s_female==0 [aw=cem_w]
	gen m_ffs_tot`n'=.
	sum tot_paid_by_mc_wi_m_`n'_to_`=`n'+2'p if inscope_p_mos>=`n' & s_female==0 [aw=cem_w]
	gen m_ffs_tot`=`n'+25'=.
	sum tot_paid_by_mc_wi_m_`n'_to_`=`n'+2' if inscope_n_mos>=`n' & s_female==1 [aw=cem_w]
	gen f_ffs_tot`n'=.
	sum tot_paid_by_mc_wi_m_`n'_to_`=`n'+2'p if inscope_p_mos>=`n' & s_female==1 [aw=cem_w]
	gen f_ffs_tot`=`n'+25'=.
	sum tot_paid_by_mc_wi_m_`n'_to_`=`n'+2' if inscope_n_mos>=`n' [aw=cem_w]
	gen s_ffs_tot`n'=.
	sum tot_paid_by_mc_wi_m_`n'_to_`=`n'+2'p if inscope_p_mos>=`n' [aw=cem_w]
	gen s_ffs_tot`=`n'+25'=.
	sum tot_paid_by_mc_wi_m_`n'_to_`=`n'+2' if inscope_n_mos>=`n' & s_female==0 [aw=cem_w]
	gen m_s_ffs_tot`n'=.
	sum tot_paid_by_mc_wi_m_`n'_to_`=`n'+2'p if inscope_p_mos>=`n' & s_female==0 [aw=cem_w]
	gen m_s_ffs_tot`=`n'+25'=.
	sum tot_paid_by_mc_wi_m_`n'_to_`=`n'+2' if inscope_n_mos>=`n' & s_female==1 [aw=cem_w]
	gen f_s_ffs_tot`n'=.
	sum tot_paid_by_mc_wi_m_`n'_to_`=`n'+2'p if inscope_p_mos>=`n' & s_female==1 [aw=cem_w]
	gen f_s_ffs_tot`=`n'+25'=.
}

foreach x of varlist *ffs_tot* {
gen sd`x'=.
}
sort ind_
foreach ind in 0 1 {
forvalues n=1(3)24 {
	sum tot_paid_by_mc_wi_m_`n'_to_`=`n'+2' if ind_==`ind' & inscope_n_mos>=`n' [aw=cem_w]
	replace ffs_tot`n'=r(mean) if ind_==`ind' & inscope_n_mos>=`n' 
	replace sdffs_tot`n'=r(sd) if ind_==`ind' & inscope_n_mos>=`n'
	sum tot_paid_by_mc_wi_m_`n'_to_`=`n'+2'p if ind_==`ind' & inscope_p_mos>=`n' [aw=cem_w]
	replace ffs_tot`=`n'+25'=r(mean) if ind_==`ind' & inscope_p_mos>=`n'
	replace sdffs_tot`=`n'+25'=r(sd) if ind_==`ind' & inscope_p_mos>=`n'
	sum tot_paid_by_mc_wi_m_`n'_to_`=`n'+2' if ind_==`ind' & inscope_n_mos>=`n' & s_female==0 [aw=cem_w]
	replace m_ffs_tot`n'=r(mean) if ind_==`ind' & inscope_n_mos>=`n' & s_female==0 
	replace sdm_ffs_tot`n'=r(sd) if ind_==`ind' & inscope_n_mos>=`n' & s_female==0 
	sum tot_paid_by_mc_wi_m_`n'_to_`=`n'+2'p if ind_==`ind' & inscope_p_mos>=`n' & s_female==0 [aw=cem_w]
	replace m_ffs_tot`=`n'+25'=r(mean) if ind_==`ind' & inscope_p_mos>=`n' & s_female==0 
	replace sdm_ffs_tot`=`n'+25'=r(sd) if ind_==`ind' & inscope_p_mos>=`n' & s_female==0 
	sum tot_paid_by_mc_wi_m_`n'_to_`=`n'+2' if ind_==`ind' & inscope_n_mos>=`n' & s_female==1 [aw=cem_w]
	replace f_ffs_tot`n'=r(mean) if ind_==`ind' & inscope_n_mos>=`n' & s_female==1 
	replace sdf_ffs_tot`n'=r(sd) if ind_==`ind' & inscope_n_mos>=`n' & s_female==1 
	sum tot_paid_by_mc_wi_m_`n'_to_`=`n'+2'p if ind_==`ind' & inscope_p_mos>=`n' & s_female==1 [aw=cem_w]
	replace f_ffs_tot`=`n'+25'=r(mean) if ind_==`ind' & inscope_p_mos>=`n' & s_female==1 
	replace sdf_ffs_tot`=`n'+25'=r(sd) if ind_==`ind' & inscope_p_mos>=`n' & s_female==1 
	sum tot_paid_by_mc_wi_m_`n'_to_`=`n'+2' if ind_==`ind' & inscope_p_mos>=24 [aw=cem_w]
	replace s_ffs_tot`n'=r(mean) if ind_==`ind' & inscope_p_mos>=24
	replace sds_ffs_tot`n'=r(sd) if ind_==`ind' & inscope_p_mos>=24
	sum tot_paid_by_mc_wi_m_`n'_to_`=`n'+2'p if ind_==`ind' & inscope_p_mos>=24 [aw=cem_w]
	replace s_ffs_tot`=`n'+25'=r(mean) if ind_==`ind' & inscope_p_mos>=24 
	replace sds_ffs_tot`=`n'+25'=r(sd) if ind_==`ind' & inscope_p_mos>=24 
	sum tot_paid_by_mc_wi_m_`n'_to_`=`n'+2' if ind_==`ind' & inscope_p_mos>=24 & s_female==0 [aw=cem_w]
	replace m_s_ffs_tot`n'=r(mean) if ind_==`ind' & inscope_p_mos>=24 & s_female==0 
	replace sdm_s_ffs_tot`n'=r(sd) if ind_==`ind' & inscope_p_mos>=24 & s_female==0 
	sum tot_paid_by_mc_wi_m_`n'_to_`=`n'+2'p if ind_==`ind' & inscope_p_mos>=24 & s_female==0 [aw=cem_w]
	replace m_s_ffs_tot`=`n'+25'=r(mean) if ind_==`ind' & inscope_p_mos>=24 & s_female==0 
	replace sdm_s_ffs_tot`=`n'+25'=r(sd) if ind_==`ind' & inscope_p_mos>=24 & s_female==0 
	sum tot_paid_by_mc_wi_m_`n'_to_`=`n'+2' if ind_==`ind' & inscope_p_mos>=24 & s_female==1 [aw=cem_w]
	replace f_s_ffs_tot`n'=r(mean) if ind_==`ind' & inscope_p_mos>=24 & s_female==1 
	replace sdf_s_ffs_tot`n'=r(sd) if ind_==`ind' & inscope_p_mos>=24 & s_female==1 
	sum tot_paid_by_mc_wi_m_`n'_to_`=`n'+2'p if ind_==`ind' & inscope_p_mos>=24 & s_female==1 [aw=cem_w]
	replace f_s_ffs_tot`=`n'+25'=r(mean) if ind_==`ind' & inscope_p_mos>=24 & s_female==1 
	replace sdf_s_ffs_tot`=`n'+25'=r(sd) if ind_==`ind' & inscope_p_mos>=24 & s_female==1 
}
}


/*
forvalues n=1(3)24 {
	by ind_, sort: gen tot_ffs_n`n'=tot_paid_by_mc_wi_m_`n'_to_`=`n'+2' if inscope_n_mos>=`n' 
	by ind_, sort: gen tot_ffs_p`n'=tot_paid_by_mc_wi_m_`n'_to_`=`n'+2'p if inscope_p_mos>=`n'
	by ind_, sort: egen ffs_tot`n'=mean(tot_ffs_n`n')
	by ind_, sort: egen ffs_tot`=`n'+25'=mean(tot_ffs_p`n')
	by ind_, sort: egen m_ffs_tot`n'=mean(tot_ffs_n`n') if s_female==0
	by ind_, sort: egen m_ffs_tot`=`n'+25'=mean(tot_ffs_p`n') if s_female==0
	by ind_, sort: egen f_ffs_tot`n'=mean(tot_ffs_n`n') if s_female==1
	by ind_, sort: egen f_ffs_tot`=`n'+25'=mean(tot_ffs_p`n') if s_female==1
	by ind_, sort: egen s_ffs_tot`n'=mean(tot_ffs_n`n') if inscope_p_mos>=24
	by ind_, sort: egen s_ffs_tot`=`n'+25'=mean(tot_ffs_p`n') if inscope_p_mos>=24 
	by ind_, sort: egen f_s_ffs_tot`n'=mean(tot_ffs_n`n') if inscope_p_mos>=24 & s_female==1  
	by ind_, sort: egen f_s_ffs_tot`=`n'+25'=mean(tot_ffs_p`n') if inscope_p_mos>=24 & s_female==1 
	by ind_, sort: egen m_s_ffs_tot`n'=mean(tot_ffs_n`n') if inscope_p_mos>=24 & s_female==0 
	by ind_, sort: egen m_s_ffs_tot`=`n'+25'=mean(tot_ffs_p`n') if inscope_p_mos>=24 & s_female==0 

}
*/
keep s_id *ffs_tot* s_female index_date ind_

foreach x of varlist ffs* m_* f_* s_ffs* {
	sum `x'
	gen n`x'=r(N)
}
reshape long ffs_tot tot_ffs f_ffs_tot m_ffs_tot s_ffs_tot m_s_ffs_tot ///
 f_s_ffs_tot  sdffs_tot  sdf_ffs_tot sdm_ffs_tot sds_ffs_tot sdm_s_ffs_tot ///
 sdf_s_ffs_tot nffs_tot  nf_ffs_tot nm_ffs_tot ns_ffs_tot nm_s_ffs_tot ///
 nf_s_ffs_tot , i(s_id index_date) j(t)
gen source="comparison" if !ind_
replace source="spouse" if ind_
gen time=-(t+2)/3 if t<=24
replace time=(t-23)/3 if t>=24

label define time -8 "21-24m" -7 "19-21" -6 "16-18" -5 "13-15" -4 "9-12" ///
 -3 "7-9" -2 "4-6" -1 "0-3" 8 "21-24m" 7 "19-21" 6 "16-18" 5 "13-15" 4 "9-12" ///
 3 "7-9" 2 "4-6" 1 "0-3" 
label values time time
preserve
collapse m_s_ffs_tot f_s_ffs_tot ffs_tot f_ffs_tot m_ffs_tot s_ffs_tot  ///
 sdm_s_ffs_tot sdf_s_ffs_tot sdffs_tot sdf_ffs_tot sdm_ffs_tot sds_ffs_tot ///
 nm_s_ffs_tot nf_s_ffs_tot nffs_tot nf_ffs_tot nm_ffs_tot ns_ffs_tot, by(time source)

foreach x in ffs_tot f_ffs_tot m_ffs_tot s_ffs_tot m_s_ffs_tot f_s_ffs_tot {
by time source, sort: gen ulci`x'=`x'+invttail(n`x'-1,0.025)*(sd`x'/sqrt(n`x'))
by time source, sort: gen llci`x'=`x'-invttail(n`x'-1,0.025)*(sd`x'/sqrt(n`x'))
}
label var ffs_tot "Total MC Spending, all in scope"
label var f_ffs_tot "Total MC Spending, females"
label var m_ffs_tot "Total MC Spending, males"
label var s_ffs_tot "Total MC Spending, 24m Survivors only"
gen before=time if time<0
gen after=time if time>0


/*
foreach x in ffs_tot  {
twoway (connected m_`x' time if source=="spouse") (connected f_`x' time if source=="spouse") ///
(connected m_`x' time if source=="comparison") (connected f_`x' time if source=="comparison") , ///
 xline(0) xtitle("Months from index date")title("Mean Medicare Costs By Time from Index Date, 3month intervals") ///
 xlab(-8 -4 -1 1 4 8, valuelabel) ///
 note("WI Adjusted to 2012 $") subtitle("by gender ") legend(label(1 "Male Spouses") ///
label(2 "Female Spouses") label(3 "Male Comparison") label(4 "Female Comparison")) ///
yscale(range(1500 3500))  ylabel(1500 2000 2500 3000 3500)
graph save mc_costs_comparison_spouse_gender`x'.gph, replace
graph export mc_costs_comparison_spouse_gender_tot3months.pdf, replace

}

foreach x in ffs_tot  {
twoway (connected m_`x' time) (connected f_`x' time) (lfit m_`x' before) (lfit m_`x' after) ///
(lfit f_`x' before) (lfit f_`x' after), ///
 xline(0) xtitle("Months from index date")title("Mean Medicare Costs By Time from Index Date, 3month intervals") ///
 xlab(-8 -4 -1 1 4 8, valuelabel) ///
 note("WI Adjusted to 2012 $") subtitle("by gender ") legend(label(1 "Males") ///
label(2 "Females")) yscale(range(1500 3500))  ylabel(1500 2000 2500 3000 3500)
graph save mc_costs_comparison_spouse_gender`x'.gph, replace
graph export mc_costs_comparison_spouse_gender_tot3months_prepost.pdf, replace

}
*/
/*
foreach x in s_ffs_tot {
twoway (connected m_`x' time if source=="spouse") (connected f_`x' time if source=="spouse") ///
(connected m_`x' time if source=="comparison") (connected f_`x' time if source=="comparison") , ///
xline(0) xtitle("Months from index date")  ///
 xlab(-8 -4 -1 1 4 8, valuelabel) ///
note("WI Adjusted to 2012 $" "24m survivors only") subtitle("by gender ") ///
legend(label(1 "Male Spouses") ///
label(2 "Female Spouses") label(3 "Male Comparison") label(4 "Female Comparison")) ///
yscale(range(1500 3500))  ylabel(1500 2000 2500 3000 3500)
graph save mc_costs_comparison_spouse_gender`x'.gph, replace
graph export mc_costs_comparison_spouse_gender_survivors3months.pdf, replace
}

foreach g in "" "m_" "f_" {
	local gend 
	if "`g'"=="m_" local gend "Male"
	if "`g'"=="f_" local gend "Female"
twoway (connected `g'ffs_tot time if source=="spouse") (connected `g'ffs_tot time if source=="comparison"),  ///
xline(0) xtitle("Months from index date")  ///
 xlab(-8 -4 -1 1 4 8, valuelabel) yscale(range(1500 3500))  ylabel(1500 2000 2500 3000 3500) ///
note("WI Adjusted to 2012 $") subtitle("All `gend' Respondents")  legend(order( 1 "Bereaved Spouses" 2 "Matched Spouses")) ///
 ytitle()
graph save mc_costs_comparison_spouse_all, replace
graph export "Non-CI graphs/mc_costs_comparison_spouse_`g'all3months.pdf", replace

twoway (connected `g's_ffs_tot time if source=="spouse") (connected `g's_ffs_tot time if source=="comparison"), ///
 xline(0) xtitle("Months from index date") ytitle()  ///
 xlab(-8 -4 -1 1 4 8, valuelabel)  yscale(range(1500 3500))  ylabel(1500 2000 2500 3000 3500) ///
note("WI Adjusted to 2012 $" )  legend(order( 1 "Bereaved Spouses" 2 "Matched Spouses")) ///
 subtitle("24m `gend' Survivors only")
graph save mc_costs_comparison_spouse_24m_survivors, replace
graph export "Non-CI graphs/mc_costs_comparison_spouse_24m_`g'survivors3months.pdf", replace
}



foreach g in "" "m_" "f_" {
	local gend 
	if "`g'"=="m_" local gend "Male"
	if "`g'"=="f_" local gend "Female"
twoway (connected `g'ffs_tot time if source=="spouse") (connected `g'ffs_tot time if source=="comparison") ///
(rcap ulci`g'ffs_tot llci`g'ffs_tot time if source=="spouse") (rcap ulci`g'ffs_tot llci`g'ffs_tot time if source=="comparison"),  ///
xline(0) xtitle("Months from index date")  ///
 xlab(-8 -4 -1 1 4 8, valuelabel) yscale(range(1500 3500))  ylabel(1500 2000 2500 3000 3500) ///
note("WI Adjusted to 2012 $") subtitle("All `gend' Respondents")  legend(order( 1 "Bereaved Spouses" 2 "Matched Spouses")) ///
 ytitle()
graph save mc_costs_comparison_spouse_all_ci, replace
graph export "CI graphs/mc_costs_comparison_spouse_`g'all3months_ci.pdf", replace

twoway (connected `g's_ffs_tot time if source=="spouse") (connected `g's_ffs_tot time if source=="comparison") ///
(rcap ulci`g's_ffs_tot llci`g's_ffs_tot time if source=="spouse") (rcap ulci`g's_ffs_tot llci`g's_ffs_tot time if source=="comparison"),  ///
 xline(0) xtitle("Months from index date")  ///
 xlab(-8 -4 -1 1 4 8, valuelabel)  ytitle() yscale(range(1500 3500))  ylabel(1500 2000 2500 3000 3500) ///
note("WI Adjusted to 2012 $")  legend(order( 1 "Bereaved Spouses" 2 "Matched Spouses")) ///
 label(3 "") label(4 "") ) subtitle("24m `gend' Survivors only")
graph save mc_costs_comparison_spouse_24m_survivors_ci, replace
graph export "CI graphs/mc_costs_comparison_spouse_24m_`g'survivors3months_ci.pdf", replace
}
/*General data setup for the dataset
Limited to decedents with FFS MC 6m prior to Index Date, partner at time of Index Date,
with mc id*/
*/
foreach g in "" "m_" "f_" {
	local gend 
	if "`g'"=="m_" local gend "Male"
	if "`g'"=="f_" local gend "Female"
twoway (connected `g'ffs_tot time if source=="spouse") (connected `g'ffs_tot time if source=="comparison"),  ///
xline(0) xtitle("Months from index date")  ///
 xlab(-8 -4 -1 1 4 8, valuelabel) yscale(range(1500 3500))  ylabel(1500 2000 2500 3000 3500) ///
note("WI Adjusted to 2012 $") subtitle("All `gend' Respondents")  legend(order( 1 "Bereaved Spouses" 2 "Matched Spouses")) ///

graph save mc_costs_comparison_spouse_all, replace
graph export "Non-CI graphs/mc_costs_comparison_spouse_`g'all3months.pdf", replace

twoway (connected `g's_ffs_tot time if source=="spouse") (connected `g's_ffs_tot time if source=="comparison"), ///
 xline(0) xtitle("Months from index date")  ///
 xlab(-8 -4 -1 1 4 8, valuelabel)  yscale(range(1500 3500))  ylabel(1500 2000 2500 3000 3500) ///
note("WI Adjusted to 2012 $" )  legend(order( 1 "Bereaved Spouses" 2 "Matched Spouses")) ///
 subtitle("24m `gend' Survivors only")
graph save mc_costs_comparison_spouse_24m_survivors, replace
graph export "Non-CI graphs/mc_costs_comparison_spouse_24m_`g'survivors3months.pdf", replace
}

foreach g in "" "m_" "f_" {
	local gend 
	if "`g'"=="m_" local gend "Male"
	if "`g'"=="f_" local gend "Female"
twoway (connected `g'ffs_tot time if source=="spouse") (connected `g'ffs_tot time if source=="comparison") ///
(rcap ulci`g'ffs_tot llci`g'ffs_tot time if source=="spouse") (rcap ulci`g'ffs_tot llci`g'ffs_tot time if source=="comparison"),  ///
xline(0) xtitle("Months from index date")  ///
 xlab(-8 -4 -1 1 4 8, valuelabel) yscale(range(1500 3500))  ylabel(1500 2000 2500 3000 3500) ///
note("WI Adjusted to 2012 $") subtitle("All `gend' Respondents")  legend(order( 1 "Bereaved Spouses" 2 "Matched Spouses")) ///

graph save mc_costs_comparison_spouse_all_ci, replace
graph export "CI graphs/mc_costs_comparison_spouse_`g'all3months_ci.pdf", replace

twoway (connected `g's_ffs_tot time if source=="spouse") (connected `g's_ffs_tot time if source=="comparison") ///
(rcap ulci`g's_ffs_tot llci`g's_ffs_tot time if source=="spouse") (rcap ulci`g's_ffs_tot llci`g's_ffs_tot time if source=="comparison"),  ///
 xline(0) xtitle("Months from index date")  ///
 xlab(-8 -4 -1 1 4 8, valuelabel)  yscale(range(1500 3500))  ylabel(1500 2000 2500 3000 3500) ///
note("WI Adjusted to 2012 $")  legend(order( 1 "Bereaved Spouses" 2 "Matched Spouses")) ///
 subtitle("24m `gend' Survivors only")
graph save mc_costs_comparison_spouse_24m_survivors_ci, replace
graph export "CI graphs/mc_costs_comparison_spouse_24m_`g'survivors3months_ci.pdf", replace
}


H="4-6m pre death regression"


clear all
set more off
capture log close

local datapath "E:\data\spouse_claims\spouse_claims_comparison\final_data\"
local logpath "E:\data\spouse_claims\spouse_claims_comparison\logs\"

cd `logpath'
use `datapath'\spouse_claims_comparison_sample, clear
label var s_northe "Northeast"
label var s_midw "Midwest"
label var s_west "West"
label var s_south "South"
label var nw1 "Networth lowest quartile"
foreach s in r s {
	label var `s'_comorb_cat2 "`s' comorbidities mild"
	label  var `s'_comorb_cat3 "`s' comorbidities mod/severe"
}
label var ind_n1_ivw "Indicator Bereaved Spouse"
label var r_age_at_core "R age at n1 ivw"
label var s_age_at_core "S age at n1 ivw"

local match ragecat r_comorb_cat2 r_comorb_cat3 r_adl_independent_core ///
r_srh_pf sagecat ///
s_comorb_cat2 s_comorb_cat3 ///
s_female s_hseduc s_black s_hisp s_adl_independent_core s_srh_pf ///
r_nhres r_adl_iadl_sp_helper s_nhres

local region s_northeast eol_quart_1
local match r_age_at_core r_adl_independent r_comorb_cat2 r_comorb_cat3 ///
s_age_at_core s_female s_black s_hseduc s_comorb_cat2 s_comorb_cat3

log using `logpath'comparison_regressions_log_4_6m.txt, text replace
local table replace


forvalues g =0/1 {
outreg, clear
  qui glm tot_paid_by_mc_wi_m_4_to_6 i.ind_ `match'  i.core_year if s_female==`g' [iw=cem_w], link(log) fam(gamma) cluster(s_hhid) eform
  qui margins, dydx(*) post 
  qui outreg, varlabels merge stats(b p) ctitles("" "Pooled") title("Medicare costs 4-6 months before index date, Female=`g'")
forvalues yr= 2000(2)2010 {
  qui glm tot_paid_by_mc_wi_m_4_to_6 i.ind_ `match'  if core_year==`yr' & s_female==`g' [iw=cem_w], link(log) fam(gamma) eform
est sto est`yr'
  qui margins, dydx(*) post
  qui outreg, merge stats(b p) ctitles("" "`yr'") varlabels
}
 qui  suest est*, cluster(s_hhid)
test ([est2000_tot_paid_by_mc_wi_m_4_to]1.ind_n1_ivw=0) ///
([est2002_tot_paid_by_mc_wi_m_4_to]1.ind_n1_ivw=0) ///
([est2004_tot_paid_by_mc_wi_m_4_to]1.ind_n1_ivw=0) ///
([est2006_tot_paid_by_mc_wi_m_4_to]1.ind_n1_ivw=0) ///
([est2008_tot_paid_by_mc_wi_m_4_to]1.ind_n1_ivw=0) ///
([est2010_tot_paid_by_mc_wi_m_4_to]1.ind_n1_ivw=0), mtest

test [est2000_tot_paid_by_mc_wi_m_4_to]:1.ind_n1_ivw=[est2002_tot_paid_by_mc_wi_m_4_to]:1.ind_n1_ivw=[est2004_tot_paid_by_mc_wi_m_4_to]:1.ind_n1_ivw=[est2006_tot_paid_by_mc_wi_m_4_to]:1.ind_n1_ivw=[est2008_tot_paid_by_mc_wi_m_4_to]:1.ind_n1_ivw=[est2010_tot_paid_by_mc_wi_m_4_to]:1.ind_n1_ivw,mtest


outreg using `logpath'comparison_regressions_4_6m, replay `table'
local table addtable
}

forvalues g =0/1 {
outreg, clear
  glm tot_paid_by_mc_wi_m_4_to_6 i.ind_ `match'  i.core_year if s_female==`g' [iw=cem_w], link(log) fam(gamma) cluster(s_hhid) eform
  *margins, dydx(1.ind_) post 
  qui outreg, varlabels merge stats(e_b p) ctitles("" "Pooled") title("Medicare costs 4-6 months before index date, Female=`g'")
forvalues yr= 2000(2)2010 {
  glm tot_paid_by_mc_wi_m_4_to_6 i.ind_ `match'  if core_year==`yr' & s_female==`g' [iw=cem_w], link(log) fam(gamma) eform
est sto est`yr'
  *margins, dydx(1.ind_) post
  qui outreg, merge stats(e_b p) ctitles("" "`yr'") varlabels
}
 qui  suest est*, cluster(s_hhid)
test ([est2000_tot_paid_by_mc_wi_m_4_to]1.ind_n1_ivw=0) ///
([est2002_tot_paid_by_mc_wi_m_4_to]1.ind_n1_ivw=0) ///
([est2004_tot_paid_by_mc_wi_m_4_to]1.ind_n1_ivw=0) ///
([est2006_tot_paid_by_mc_wi_m_4_to]1.ind_n1_ivw=0) ///
([est2008_tot_paid_by_mc_wi_m_4_to]1.ind_n1_ivw=0) ///
([est2010_tot_paid_by_mc_wi_m_4_to]1.ind_n1_ivw=0), mtest
test [est2000_tot_paid_by_mc_wi_m_4_to]:1.ind_n1_ivw=[est2002_tot_paid_by_mc_wi_m_4_to]:1.ind_n1_ivw=[est2004_tot_paid_by_mc_wi_m_4_to]:1.ind_n1_ivw=[est2006_tot_paid_by_mc_wi_m_4_to]:1.ind_n1_ivw=[est2008_tot_paid_by_mc_wi_m_4_to]:1.ind_n1_ivw=[est2010_tot_paid_by_mc_wi_m_4_to]:1.ind_n1_ivw,mtest

local table addtable
outreg using `logpath'comparison_regressions_4_6m, replay `table'

}


H="year after regression"


clear all
set more off
capture log close

local datapath "E:\data\spouse_claims\spouse_claims_comparison\final_data\"
local logpath "E:\data\spouse_claims\spouse_claims_comparison\logs\"

cd `logpath'
use `datapath'\spouse_claims_comparison_sample, clear
label var s_northe "Northeast"
label var s_midw "Midwest"
label var s_west "West"
label var s_south "South"
label var nw1 "Networth lowest quartile"
foreach s in r s {
	label var `s'_comorb_cat2 "`s' comorbidities mild"
	label  var `s'_comorb_cat3 "`s' comorbidities mod/severe"
}
label var ind_n1_ivw "Indicator Bereaved Spouse"
label var r_age_at_core "R age at n1 ivw"
label var s_age_at_core "S age at n1 ivw"

local match ragecat r_comorb_cat2 r_comorb_cat3 r_adl_independent_core ///
r_srh_pf sagecat ///
s_comorb_cat2 s_comorb_cat3 ///
s_female s_hseduc s_black s_hisp s_adl_independent_core s_srh_pf ///
r_nhres r_adl_iadl_sp_helper s_nhres

local region s_northeast eol_quart_1
local match r_age_at_core r_adl_independent r_comorb_cat2 r_comorb_cat3 ///
s_age_at_core s_female s_black s_hseduc s_comorb_cat2 s_comorb_cat3

log using `logpath'comparison_regressions_f_12mp.txt, text replace
local table replace


forvalues g =0/1 {
outreg, clear
  qui glm tot_paid_by_mc_wi_p12m i.ind_ `match'  i.core_year if s_female==`g' [iw=cem_w], link(log) fam(gamma) cluster(s_hhid) eform
  qui margins, dydx(*) post 
  qui outreg, varlabels merge stats(b p) ctitles("" "Pooled") title("Medicare costs 12m post index date, Female=`g'")
forvalues yr= 2000(2)2010 {
  qui glm tot_paid_by_mc_wi_p12m i.ind_ `match'  if core_year==`yr' & s_female==`g' [iw=cem_w], link(log) fam(gamma) eform
est sto est`yr'
  qui margins, dydx(*) post
  qui outreg, merge stats(b p) ctitles("" "`yr'") varlabels
}
 qui  suest est*, cluster(s_hhid)
test ([est2000_tot_paid_by_mc_wi_p12m]1.ind_n1_ivw=0) ///
([est2002_tot_paid_by_mc_wi_p12m]1.ind_n1_ivw=0) ///
([est2004_tot_paid_by_mc_wi_p12m]1.ind_n1_ivw=0) ///
([est2006_tot_paid_by_mc_wi_p12m]1.ind_n1_ivw=0) ///
([est2008_tot_paid_by_mc_wi_p12m]1.ind_n1_ivw=0) ///
([est2010_tot_paid_by_mc_wi_p12m]1.ind_n1_ivw=0), mtest

test [est2000_tot_paid_by_mc_wi_p12m]:1.ind_n1_ivw=[est2002_tot_paid_by_mc_wi_p12m]:1.ind_n1_ivw=[est2004_tot_paid_by_mc_wi_p12m]:1.ind_n1_ivw=[est2006_tot_paid_by_mc_wi_p12m]:1.ind_n1_ivw=[est2008_tot_paid_by_mc_wi_p12m]:1.ind_n1_ivw=[est2010_tot_paid_by_mc_wi_p12m]:1.ind_n1_ivw,mtest


outreg using `logpath'comparison_regressions_f_12mp, replay `table'
local table addtable
}

forvalues g =0/1 {
outreg, clear
  glm tot_paid_by_mc_wi_p12m i.ind_ `match'  i.core_year if s_female==`g' [iw=cem_w], link(log) fam(gamma) cluster(s_hhid) eform
  *margins, dydx(1.ind_) post 
  qui outreg, varlabels merge stats(e_b p) ctitles("" "Pooled") title("Medicare costs 12m post index date, Female=`g'")
forvalues yr= 2000(2)2010 {
  glm tot_paid_by_mc_wi_p12m i.ind_ `match'  if core_year==`yr' & s_female==`g' [iw=cem_w], link(log) fam(gamma) eform
est sto est`yr'
  *margins, dydx(1.ind_) post
  qui outreg, merge stats(e_b p) ctitles("" "`yr'") varlabels
}
 qui  suest est*, cluster(s_hhid)
test ([est2000_tot_paid_by_mc_wi_p12m]1.ind_n1_ivw=0) ///
([est2002_tot_paid_by_mc_wi_p12m]1.ind_n1_ivw=0) ///
([est2004_tot_paid_by_mc_wi_p12m]1.ind_n1_ivw=0) ///
([est2006_tot_paid_by_mc_wi_p12m]1.ind_n1_ivw=0) ///
([est2008_tot_paid_by_mc_wi_p12m]1.ind_n1_ivw=0) ///
([est2010_tot_paid_by_mc_wi_p12m]1.ind_n1_ivw=0), mtest
test [est2000_tot_paid_by_mc_wi_p12m]:1.ind_n1_ivw=[est2002_tot_paid_by_mc_wi_p12m]:1.ind_n1_ivw=[est2004_tot_paid_by_mc_wi_p12m]:1.ind_n1_ivw=[est2006_tot_paid_by_mc_wi_p12m]:1.ind_n1_ivw=[est2008_tot_paid_by_mc_wi_p12m]:1.ind_n1_ivw=[est2010_tot_paid_by_mc_wi_p12m]:1.ind_n1_ivw,mtest

local table addtable
outreg using `logpath'comparison_regressions_f_12mp, replay `table'

}


H="reshape long for meglm"
