= V4 Outline MultiLine NoSorting TabWidth=30

H="Hysterectomy Project Outline"
/*Follows the Surgery Code 2010 Claims 20140324 to create dataset for Hysterectomy Study

Outline will be as follows:
1. Identify index surgeries that meet selection criteria
2. Check IP claims for claims that span continuous hospital stays 
	and save a list of all hospital stays for beneficiaries
	that have an index surgery
3. Identify index surgery information
	a. Presence of complications
	b. Index surgery hospital stay LOS
	c. Index surgery hospital stay discharge status / destination codes
4. Check insurance status 6m and 12m pre-surgery to determine
	sample selection (Medicare parts a and b and no hmo coverage required)
5. Identify number of hospital admissions in the 6 months pre-surgery
6. Identify post-surgery hospital and snf use in the 12 months post-surgery
	a. Days from surgery to next IP admission
	b. Total number of days spent in a hospital
	c. Count of hospital admissions
	d. Total number of days in a SNF
7. Identify Elixhauser comorbidities 6 and 12 months pre surgery
8. Identify chronic conditions 6 and 12 months pre surgery


/*Set up project libraries in SAS
Note created separate folders for the 2012 claims data files*/

/*********************************************************/
/*Unique to Amy's computer - 2012 Claims*/
/*********************************************************/
/*Medicare claims files - 2012*/
libname medi 'E:\data\cms_DUA_24548_2012';

/*Surgery project data files*/
libname sur_fin "E:\data\surgery_hysterectomy\final_2012clms";

/*Surgery project temporary data files*/
libname sur_int "E:\data\surgery_hysterectomy\int_2012clms";

/*Procedures project raw data files
Reference files like list of chronic conditions ICD-9 codes*/
libname ref_data "E:\data\surgery_hysterectomy\ref_data";

/*Cleaned HRS 2000-2012 dataset & Death Date dataset*/
libname hrs_cln 'E:\data\hrs_cleaned';

/*Dementia Probabilities--note, not updated to 2012*/
libname hrs_dem 'E:\data\hrs_public_2012\dementia';



H="Identify Surgeries that Meet Criteria"
/*Identify claims with particular procedure codes present from the
ip claims file

Final file created: sur_int.last_surgery_date
List of index surgery  by beneficiary id

Keep additional information needed about this claim / surgery:
1. Complications (type of complications? can look to original surgery for it)
2. LOS
3. Discharge status (to home, SNF, etc)
4. Admission type (to track if ER admission or not)
*/
%let source0=ip;

proc sort data=medi.&source0._2000_2012 ;
by BID_HRS_21;
run;

/*Create claim id for full set of ip claims 2000-2012*/
/*sequential, unique ID for each claim in this file*/
data sur_int.&source0._2000_2012_claim_id;
set medi.&source0._2000_2012;
	clm_id=_N_;
run;

/*check no duplicates of new claim id*/
proc sort data=sur_int.&source0._2000_2012_claim_id nodupkey ;
by clm_id;
run;

proc contents order=casecollate data=sur_int.&source0._2000_2012_claim_id;
run;

/*check to confirm that all dx and procedure codes are using icd-9 codes*/
proc freq data=sur_int.&source0._2000_2012_claim_id;
table PDVRSNCD DVRSCD01-DVRSCD25 PVRSCD01-PVRSCD25;
run;

proc sql;
create table &source0._meet as select BID_hrs_21,
PRCDRCD01,PRCDRCD02,PRCDRCD03,PRCDRCD04,
PRCDRCD05,PRCDRCD06,PRCDRCD07,PRCDRCD08,
PRCDRCD09,PRCDRCD10,PRCDRCD11,PRCDRCD12,
PRCDRCD13,PRCDRCD14,PRCDRCD15,PRCDRCD16,
PRCDRCD17,PRCDRCD18,PRCDRCD19,PRCDRCD20,
PRCDRCD21,PRCDRCD22,PRCDRCD23,PRCDRCD24,
PRCDRCD25,
TYPE_ADM,
PRCDRDT01,PRCDRDT02,PRCDRDT03,
PRCDRDT04,PRCDRDT05,PRCDRDT06,PRCDRDT07,
PRCDRDT08,PRCDRDT09,PRCDRDT10,PRCDRDT11,
PRCDRDT12,PRCDRDT13,PRCDRDT14,PRCDRDT15,
PRCDRDT16,PRCDRDT17,PRCDRDT18,PRCDRDT19,
PRCDRDT20,PRCDRDT21,PRCDRDT22,PRCDRDT23,
PRCDRDT24,PRCDRDT25,
AD_DGNS ,
DGNSCD01,DGNSCD02,DGNSCD03,DGNSCD04,DGNSCD05,
DGNSCD06,DGNSCD07,DGNSCD08,DGNSCD09,DGNSCD10,
DGNSCD11,DGNSCD12,DGNSCD13,DGNSCD14,DGNSCD15,
DGNSCD16,DGNSCD17,DGNSCD18,DGNSCD19,DGNSCD20,
DGNSCD21,DGNSCD22,DGNSCD23,DGNSCD24,DGNSCD25,
STUS_CD,
clm_id,
admit_date,
disch_date
from sur_int.&source0._2000_2012_claim_id ;
quit;

proc contents data=sur_int.&source0._2000_2012_claim_id(keep=PRCDR:);
run;
proc sql outobs=2;
select PRCDRCD01,PRCDRDT01 from sur_int.&source0._2000_2012_claim_id;
quit;

/*creates table with each procedure as a separate row*/

data proc_long(keep=BID_hrs_21 TYPE_ADM procedure procedure_date AD_DGNS DGNSCD01-DGNSCD25
	STUS_CD clm_id admit_date disch_date);
set ip_meet;
array list PRCDRCD01-PRCDRCD25;
array date PRCDRDT01-PRCDRDT25;
do over list;
if list~="" then do;
procedure=list;
procedure_date=mdy(substr(trim(left(date)),5,2),substr(trim(left(date)),7,2),substr(trim(left(date)),1,4));
output;
end;
end;
format procedure_date date10.;
run;

/*rename admit date and discharge date to be is_ for index surgery
This way can use this index surgery information to check against
claims lists pre- and post-surgery*/
data proc_long2(rename=(admit_date=is_admit_date) rename=(disch_date=is_disch_date));
set proc_long;
format admit_date date10.;
format disch_date date10.;
run; 

/* Identify surgeries that meet the criteria
Indicator variable surgery_meet = 1 if yes, include in sample 
1700 surgeries meet the criteria*/
data surgery_meet;
set proc_long2;
if length(compress(procedure))>0 then do;

if procedure+0 in (683, 684, 685, 686, 687, 689, 6849, 6839, 6869, 6841, 6831, 6851, 6861, 6871, 6859, 6879) then surgery_meet=1;

if substr(compress(procedure),1,3)+0 in (683, 684, 685, 686, 687, 689) then surgery_meet=1;

end;
/*only keep observations in work.surgery_meet that meet criteria*/
if surgery_meet then output;

run;

proc freq data=surgery_meet;
table procedure;
run;

/*****************************************************************************/
/*Look at number of qualifying procedures per bid*/
/*****************************************************************************/
/*Identify the most recent surgery from the list that meet the criteria for each 
beneficiary id*/
proc sort data=surgery_meet;
by bid_hrs_21 procedure_date;
run;

/*get count of qualifying procedures per beneficary, regardless of surgery dates
so a beneficiary can have more than 1 surgery on the same date*/
data surg_meet_count1;
set surgery_meet;
by bid_hrs_21;
	if first.bid_hrs_21 then pro_count=1;
	else pro_count+1;
run;

data surg_meet_count2(rename=pro_count=pro_cnt_all);
set surg_meet_count1(keep=bid_hrs_21 pro_count);
by bid_hrs_21;
if last.bid_hrs_21;
label pro_count="Procedure count, all qualifying procedures";
run;

/*now get list of surgeries on seperate dates*/
proc sort data=surgery_meet out=surg_meet_count3 nodupkey;
by bid_hrs_21 procedure_date;
run;

data surg_meet_count4;
set surg_meet_count3;
by bid_hrs_21;
	if first.bid_hrs_21 then pro_count=1;
	else pro_count+1;
run;


data surg_meet_count5(rename=pro_count=pro_cnt_date);
set surg_meet_count4(keep=bid_hrs_21 pro_count);
by bid_hrs_21;
if last.bid_hrs_21;
label pro_count="Procedure count, only count 1 per procedure date";
run;

/*finally with separate medicare claims*/
proc sort data=surgery_meet out=surg_meet_count6 nodupkey;
by bid_hrs_21 clm_id;
run;

data surg_meet_count7;
set surg_meet_count6;
by bid_hrs_21;
	if first.bid_hrs_21 then pro_count=1;
	else pro_count+1;
run;

data surg_meet_count8(rename=pro_count=pro_cnt_clm);
set surg_meet_count7(keep=bid_hrs_21 pro_count);
by bid_hrs_21;
if last.bid_hrs_21;
label pro_count="Procedure count, only count 1 per claim";
run;

ods rtf body='E:\data\surgery_hysterectomy\logs\Procedure_counts.rtf';

title "Count of qualifying procedures, including multiple surgeries on the same date";
proc freq data=surg_meet_count2; table pro_cnt_all; run;

title "Count of qualifying procedures with separate procedure dates";
proc freq data=surg_meet_count5; table pro_cnt_date; run;

title "Count of qualifying procedures with separate Medicare claims";
proc freq data=surg_meet_count8; table pro_cnt_clm; run;

ods rtf close;

/*final file list of index surgery by bid
243 beneficiaries have index surgery identified*/
data last_surgery_date_1;
set surgery_meet ;
by bid_hrs_21 procedure_date ;
if last.bid_hrs_21;
run;

/*now merge in procedure counts so can carry through dataset*/
data counts;
merge surg_meet_count2 surg_meet_count5 surg_meet_count8;
by bid_hrs_21;
run;

proc freq; table pro_cnt_all pro_cnt_date pro_cnt_clm; run;

proc sql;
create table sur_int.last_surgery_date as select a.*,b.pro_cnt_all,b.pro_cnt_date,b.pro_cnt_clm from
last_surgery_date_1 a left join
counts b
on a.bid_hrs_21=b.bid_hrs_21;
quit;

H=" Check for continuous stay"
/*
Check list of IP claims for cases where multiple claims are present
for a single hospital stay

This is identified where 
1. start day of claim is within 1 day of end
date of the claim before AND
2. discharge code = 2 or 5 for transfer for inpatient care

Need to check index surgery to determine if more than one claim
is associated with that hospital stay in order to calculate LOS, etc.

If discharge destination code = 02 (transferred to short term general hospital
for inpatient care) or = 05 (transferred to anoter type of institution for inpatient care)
and the discharge date of 1st claim is the the same or one day before the admit
date for the next claim, then the clai/*
Check list of IP claims for cases where multiple claims are present
for a single hospital stay

This is identified where 
1. start day of claim is within 1 day of end
date of the claim before AND
2. discharge code = 2 or 5 for transfer for inpatient care

Need to check index surgery to determine if more than one claim
is associated with that hospital stay in order to calculate LOS, etc.

If discharge destination code = 02 (transferred to short term general hospital
for inpatient care) or = 05 (transferred to anoter type of institution for inpatient care)
and the discharge date of 1st claim is the the same or one day before the admit
date for the next claim, then the claims are part of the same inpatient stay.

List of claims with new start/ end dates that span overall stay
is saved as sur_int.ip_cont_stay_clms_merged
If multiple claims were merged into single stay observation, ind_clm_merge=1

*/

/*Step 1: get dataset of ip claims only from the medpar file
Use medpar file with the unique claim id assigned*/
data sur_int.ip_2000_2012;
set sur_int.ip_2000_2012_claim_id/*(where=(trim(left(SSLSSNF))~="N"))*/;
run;

/*step 2: only keep claims where the bid had an index surgery
923 claims identified
This list of claims includes the index surgery claim*/
proc sql;
create table mp_cont_stay_1 as select a.*,b.procedure_date,b.is_admit_date,b.is_disch_date
from sur_int.ip_2000_2012 a inner join
sur_int.last_surgery_date b
on trim(left(a.bid_hrs_21))=trim(left(b.bid_hrs_21)) ;
quit;

proc sort data=mp_cont_stay_1 ;
by bid_hrs_21 admit_date;
run;

/*change formats of dates*/
data mp_cont_stay_2 ;
set mp_cont_stay_1 ;
format admit_date date10.;
format disch_date date10.;
run;

/***********************************************************************/
/*         Determine days from current obs. claim admit date
	   to previous claim discharge date                   */
/***********************************************************************/

/*sort ascending to calculate days from previous claim to current claim*/
proc sort data=mp_cont_stay_2 ;
by bid_hrs_21 admit_date disch_date;
run;

/*new variable
daydiff_prev = days from previous claim end date to current claim start date
If claim is the first claim for that BID, then set daydiff_prev = null */
data mp_cont_stay_3 ;
set mp_cont_stay_2 ;
by bid_hrs_21;
daydiff_prev = admit_date - LAG(disch_date) ;
if first.bid_hrs_21 then daydiff_prev = . ;
run;

proc freq data=mp_cont_stay_3 ;
table daydiff_prev;
run;

/***********************************************************************/
/*         Identify claims that, just using start/end dates
	   appear to be for continuous hospital stays                  */
/***********************************************************************/

proc sort data=mp_cont_stay_3 ;
by bid_hrs_21 admit_date disch_date;
run;

/*keep a list of just claims where next claim starts on the same
day or day after discharge from index surgery claim
There are 42 such claims*/
data mp_cont_stay_4 ;
set mp_cont_stay_3(where=(daydiff_prev<2));
run;
data mp_cont_stay_5 ;
set mp_cont_stay_4(where=(daydiff_prev~=.)) ;
run;
proc freq data=mp_cont_stay_5;
table daydiff_prev;
run;

/***********************************************************************/
/*         Add indicator for claims with discharge codes
           indicating patient transferred for further
           inpatient care                                    */
/***********************************************************************/

/*check discharge destination code for surgeries where the next claim
starts either the same day as discharge from surgery claim or day after
add indicator to dataset that claim has the discharge code*/
proc freq data=mp_cont_stay_3;
table stus_cd;
run;

data mp_cont_stay_6;
set mp_cont_stay_3;
dstn_cd_cont=0;
if STUS_CD in(02,05) then dstn_cd_cont=1;
run;

proc freq data=mp_cont_stay_6;
table dstn_cd_cont;
run;

proc freq data=mp_cont_stay_6(where=(dstn_cd_cont=1)) ;
table STUS_CD ;
run;

/********************************************************************/
/* Merge claim start and end dates if they have the required
discharge destination codes and claim dates are within one day */
/********************************************************************/

proc sort data=mp_cont_stay_6 out=mp_cont_stay_7;
     by bid_hrs_21 admit_date disch_date;
run;

data mp_cont_stay_8;
set mp_cont_stay_7;
retain stay_start stay_end;
       by bid_hrs_21 admit_date;
          /* Handle claims that are for distinct stay
             Distinct stay if more than 1 day between claim dates or
             claim dates overlap but discharge destination code does not
             indicate transferred for inpatient care  */
	ind_clm_merge=.; /*initialize the indicator variable for merged claims*/
if (daydiff_prev > 1 or daydiff_prev=.) or
              (daydiff_prev <2 and daydiff_prev~=. and lag(dstn_cd_cont)=0) then do;
             stay_start = admit_date;
             stay_end = disch_date;
			 ind_clm_merge=0;
             end;
          /* Handle claims that are for continous stays */
          if (daydiff_prev <2 and daydiff_prev~=. and lag(dstn_cd_cont)=1) then do;
             stay_end = disch_date;
			 ind_clm_merge=1;
             end;
          format stay_start date10. stay_end date10.;
run;

/*12 cases where claims dates are merged*/
proc freq;
table ind_clm_merge /missprint;
run;

/********************************************************************/
/* Drop claims so there is only one claim per stay with the overall
stay start and end dates */
/********************************************************************/

data mp_cont_stay_9;
set mp_cont_stay_8;
by bid_hrs_21 stay_start;
   j = 0;
   if last.stay_start then j=j+1;
run;

proc freq;
table j;
run;
/*1.41% of claims (13) are merged with an additional claim*/

/*save the new ip stay dataset sur_int.ip_cont_stay_clms_merged*/
data sur_int.ip_cont_stay_clms_merged;
set mp_cont_stay_9;
if j=1;
drop j;
label ind_clm_merge="Indicator for stay dates merged over multiple claims";
run;

/*12 (1.32%) of the 910 stays have multiple claims dates merged
to get stay start / end dates*/
proc freq data=sur_int.ip_cont_stay_clms_merged;
table ind_clm_merge /missprint;
run;



H=" Index Surgery Defined"
/*note-this needs work

/*start of MACRO */

/*Macro for all claims files except for medpar
Creates file source_meet_after_&name._2 which has the first claim after
1 year of surgery
*/
%macro other_post(days_start=,source=,name=);

/*Identify claims within certain time from procedure date defined when run macro*/
proc sql;
create table &source._meet_after_&name. as select a.*,b.procedure_date,b.is_admit_date
from medi.&source._2000_2012 a inner join
sur_fin.surgery_ids_last b
on trim(left(a.bid_hrs_21))=trim(left(b.bid_hrs_21))
and a.admit_date-b.procedure_date<=&days_start
and a.admit_date>=is_admit_date;
quit;
run;

data &source._meet_after_&name._1a;
set &source._meet_after_&name.;
format admit_date date9. disch_date date9.;
run;

proc sort data=&source._meet_after_&name._1a;
by bid_hrs_21 admit_date;
run;

data &source._meet_after_&name._2;
set &source._meet_after_&name._1a;
by bid_hrs_21;
rename admit_date = follow_up_dt_&name._ps;
run;
%mend;

/*Macro for medpar claims*/
%macro mp_post(days_start=,source=,name=);
%let source0=mp;

/*Identify claims within certain time from procedure date*/
proc sql;
create table &source._meet_after_&name. as select a.*,b.procedure_date,b.is_admit_date
from medi.&source0._2000_2012 a inner join
sur_fin.surgery_ids_last b
on trim(left(a.bid_hrs_21))=trim(left(b.bid_hrs_21)) 
and a.admit_date-b.procedure_date<=&days_start
and a.admit_date>=b.is_admit_date;
quit;
run;

data &source._meet_after_&name._1a;
set &source._meet_after_&name.;
format admit_date date9. disch_date date9.;
run;

proc sort data=&source._meet_after_&name._1a;
by bid_hrs_21 admit_date;
run;

data &source._meet_after_&name._2;
set &source._meet_after_&name._1a;
by bid_hrs_21;
run;

%mend;
/*Run macros to identify claims that are after 60 days from surgery date*/
%mp_post(days_start=60,source=mp,name=60d );
%other_post(days_start=60,source=hh,name=60d );
%other_post(days_start=60,source=hs,name=60d );
%other_post(days_start=60,source=dm,name=60d );
%other_post(days_start=60,source=op,name=60d );
%other_post(days_start=60,source=pb,name=60d );

/*Run macros to identify claims that are after 1 year from surgery date*/
%mp_post(days_start=366,source=mp,name=1yr );
%other_post(days_start=366,source=hh,name=1yr );
%other_post(days_start=366,source=hs,name=1yr );
%other_post(days_start=366,source=dm,name=1yr );
%other_post(days_start=366,source=op,name=1yr );
%other_post(days_start=366,source=pb,name=1yr );

/*combine to get follow up date at least 1 year post surgery to use in
survival analysis */

/*for medpar claims, create indicator for cases where discharge code indicates died*/
proc freq data=mp_meet_after_1yr_2;
table dschrgcd*dstntncd /missprint;
run;

data mp_after_1yr_3(keep=bid_hrs_21 follow_up_dt_1yr_ps died_post_1yr);
set mp_meet_after_1yr_2;
if dschrgcd='B' then died_post_1yr=1;
follow_up_dt_1yr_ps = disch_date;
run;

data all_after_1yr;
set mp_after_1yr_3 hh_meet_after_1yr_2  hs_meet_after_1yr_2  dm_meet_after_1yr_2 
 op_meet_after_1yr_2  pb_meet_after_1yr_2;
run;

proc sort data=all_after_1yr;
by bid_hrs_21 follow_up_dt_1yr_ps ;
run;

data sur_int.all_after_1yr_1;
set all_after_1yr;
by bid_hrs_21 ;
if first.bid_hrs_21 ;
run;

/*none of the medpar claims where the beneficiary died
got used in the final dataset with the claim right after 1 year post surgery*/
proc freq;
table died_post_1yr /missprint;
run;

/*merge in the follow up dates to the overall dataset*/

%macro mergefu(presurg=);

proc sql;
create table sur_fin.surgery_ids_last_comor_&presurg.2(drop=bid_hrs2 died_post_1yr )
as select * from
sur_fin.surgery_ids_last_comor_&presurg. a
left join
sur_int.all_after_1yr_1(rename=(bid_hrs_21=bid_hrs2)) b 
on (a.bid_hrs_21)=(b.bid_hrs2);
quit;

%mend;

%mergefu(presurg=n6m);
%mergefu(presurg=n12m);


data all_after_60d;
set mp_meet_after_60d_2 hh_meet_after_60d_2  hs_meet_after_60d_2  dm_meet_after_60d_2 
 op_meet_after_60d_2  pb_meet_after_60d_2;
run;

/*Add information about index surgery claim

Information needed is:
From index surgery claim
1. Complications 
From index surgery hospital overall stay
2. LOS 
3. Discharge destination code

Resulting dataset is saved as:
sur_int.index_sur_stay

Also save intermediate dataset sur_int.hospital_stays
Use list of all hospital stays to determine number of 
hospitalizations pre-surgery and details re. post-surgery
hospitalizations later in the code


*note-not using these here. instead looking at next 60days
/*************************************************************************/
/*Identify complications from dx codes for index surgery
Dataset created: sur_int.compl*/
/*************************************************************************/

data sur_int.compl;
set sur_int.last_surgery_date;

dx_1=trim(left(DGNSCD01));
if dx_1~="" then do;
	
/*initialize complications variables*/
comp_uti=0;
comp_pe=0;
comp_inf=0;
comp_rf=0;
comp_mi=0;
comp_del=0;
comp_kf=0;
comp_any=0;
comp_deh=0;
comp_int=0;
comp_pne=0;
comp_strk=0;
comp_dvt=0;
comp_hmrg=0;
end;

array dx DGNSCD01-DGNSCD25 ;
do over dx;
/*UTI*/
if substr(dx,1,4)='5990' and comp_uti=0 
	then comp_uti=1;

/*PE*/
if substr(dx,1,4)='4151'
	 and comp_pe=0 
	then comp_pe=1;

/*post-op hemorrhage*/
if substr(dx,1,5)='99811'
	 and comp_hmrg=0 
	then comp_hmrg=1;

/*Stroke*/
if substr(dx,1,5)='43491'
	 and comp_strk=0 
	then comp_strk=1;

/*Internal*/
if substr(dx,1,4)='9983'
	 and comp_int=0 
	then comp_int=1;

/*Dehiscence*/
if (substr(dx,1,5)='99831'
	or substr(dx,1,5)='99832')
	 and comp_deh=0 
	then comp_deh=1;

/*Infection*/
if (substr(dx,1,4)='9985'
	or substr(dx,1,5)='99851'
	or substr(dx,1,5)='99859')
	 and comp_inf=0 
	then comp_inf=1;

/*Resp Failure*/
if substr(dx,1,5)='51881' and comp_rf=0
	then comp_rf=1;

/*MI*/
if substr(dx,1,3)=410
	and comp_mi=0 
	then comp_mi=1;

/*Delirium*/
if (substr(dx,1,4)='2930'
	or substr(dx,1,4)='2931')
	 and comp_del=0 
	then comp_del=1;

/*kidney failure*/
if (substr(dx,1,4)='5845'
	or substr(dx,1,4)='5846'
	or substr(dx,1,4)='5847'
	or substr(dx,1,4)='5848'
	or substr(dx,1,4)='5849')
	 and comp_kf=0 
	then comp_kf=1;

/*Pneumonia*/
if (substr(dx,1,3)='480'
	or substr(dx,1,3)='481'
	or substr(dx,1,3)='482'
	or substr(dx,1,3)='483'
	or substr(dx,1,3)='484'
	or substr(dx,1,3)='485'
	or substr(dx,1,3)='486')
	 and comp_pne=0 
	then comp_pne=1;

if (comp_uti=1  
	or comp_pe=1
	or comp_inf=1
	or comp_rf=1
	or comp_mi=1
	or comp_del=1
	or comp_kf=1
	or comp_deh=1
	or comp_int=1
	or comp_pne=1
	or comp_strk=1
	or comp_dvt=1
	or comp_hmrg=1)
	and comp_any=0
	then comp_any=1; 

end;
run;

proc freq;
table comp_uti comp_pe comp_inf comp_rf comp_mi comp_del;
run;

proc freq;
table comp_any;
run;


/*************************************************************************/
/*Check for presence of complications dx codes in admitting dx field
Decision made not to include admitting dx in the dx codes used to determine
if complications were present during the index surgery stay*/
/*************************************************************************/

/*************************************************************************/
/*************************************************************************/
/*************************************************************************/
/*************************************************************************/
/*Identify hospital stay that contain the index surgery                  */
/*************************************************************************/

/*Step 1 - Check index surgery / claim list to see if all claims
have the surgery procedure date within the admit date and discharge
date time window*/
/*check procedure dates in list of index surgeries*/
data index_surg_stay_test;
set sur_int.compl;
index_stay_test=0;
if (is_admit_date<= procedure_date <= is_disch_date) then index_stay_test=1;
run;
/*2 index surgeries are not within their original claim dates*/
proc freq;
table index_stay_test;
run;
data index_surg_stay_test2;
set index_surg_stay_test(where=(index_stay_test=0));
run;
/*these surgeries are all 1 day prior to the claim start date
so recode stay start date as day of the surgery*/

/*Step 2 - For theobservations where the procedure date
is coded as 1 day before admission, re-code admission
start date as the procedure date */
proc sql;
create table index_surg_stay_2 as select * from sur_int.ip_cont_stay_clms_merged
where bid_hrs_21 in (select bid_hrs_21 from index_surg_stay_test2);
quit;

data index_surg_stay_3;
set index_surg_stay_2 ;
st_proc=stay_start - procedure_date;
if (st_proc = 1) then do;
	mod_stay_start=1;
	stay_start=procedure_date;
	end;
label mod_stay_start="Indicator for start day modified to include procedure date in stay";
drop st_proc;
run;

proc freq;
table mod_stay_start;
run;

/*Step 3 - Bring in the modified stay_start date to the overall list of hopsital stays*/
/*first check list of surgeries stays for duplicates*/
proc sort data=sur_int.ip_cont_stay_clms_merged out=test2 nodupkey;
by bid_hrs_21 stay_end;
run;

proc sql;
create table index_surg_stay_4 as select
a.*,b.mod_stay_start,b.stay_start as new_stay_start from
sur_int.ip_cont_stay_clms_merged a left join
index_surg_stay_3 b
on (a.bid_hrs_21=b.bid_hrs_21 and a.stay_end=b.stay_end);
quit;

proc freq;
table mod_stay_start;
run;

data index_surg_stay_5 ;
set index_surg_stay_4 ;
if mod_stay_start=1 then stay_start=new_stay_start;
drop daydiff_prev dstn_cd_cont new_stay_start;
if mod_stay_start=. then mod_stay_start=0;
run;

proc freq;
table mod_stay_start ind_clm_merge /missprint;
run;

/*Step 4 - assign indicator to index surgery hospital stays*/
/*save this list of hospital stays with the indicator to use
to look at pre and post surgery hospitalizations
This is list of all ip stays for the cohort that had an
index surgery indentified
910 unique hospital stays*/
data sur_int.hospital_stays;
set index_surg_stay_5;
index_stay=0;
if (stay_start<= procedure_date <= stay_end) then index_stay=1;
run;

/*243 index surgeries identified, this matches the index surgery claim list*/
proc freq;
table index_stay;
run;

/*************************************************************************/
/*Need to merge in index surgery stay start/end dates  
Replacing is_admit_date and is_disch_date from claims with dates
from overall stay (in cases where stay info is merged from mult claims   */
/*************************************************************************/
data index_surg_1;
set sur_int.hospital_stays (keep=bid_hrs_21 procedure_date is_admit_date is_disch_date stay_start stay_end index_stay);
if index_stay=1;
run;

data index_surg_2;
set index_surg_1;
is_admit_date=stay_start;
is_disch_date=stay_end;
run;

/*merge in index surgery start end dates to overall hospital stay
dataset*/
proc sql;
create table hospital_stays_r2 as select a.*,b.is_admit_date as
	is_admit_date_new, b.is_disch_date as is_disch_date_new from
sur_int.hospital_stays a
left join index_surg_2 b
on (a.bid_hrs_21=b.bid_hrs_21);
quit;

data sur_int.hospital_stays_2;
set hospital_stays_r2;
drop is_admit_date is_disch_date;
rename is_admit_date_new=is_admit_date;
rename is_disch_date_new=is_disch_date;
run;

/*************************************************************************/
/*Merge in stay start date / end date to index
surgery claim information with complications indicators                  */
/*************************************************************************/

/*drop is_admit and is_disch dates from complications dataset
so can add in updated dates from surgery stay (not individ claims*/
data compl_1;
set sur_int.compl;
drop is_admit_date is_disch_date;
run;

/*list of surgery claims to merge the start / end day information in to*/
proc sort data=compl_1;
by bid_hrs_21 procedure_date;
run;

/*get list of just index surgery stay information to merge*/
data index_surg_stay_7;
set sur_int.hospital_stays_2(where=(index_stay=1));
run;

proc sort data=index_surg_stay_7;
by bid_hrs_21 procedure_date;
run;

proc sql;
create table index_sur_stay_8 as select 
	a.*, b.stay_start, b.stay_end,b.stus_cd as stay_dstn_cd, 
	b. mod_stay_start, b.ind_clm_merge, b.is_admit_date, b.is_disch_date
from compl_1 a left join
index_surg_stay_7 b
on (a.bid_hrs_21=b.bid_hrs_21 and a.procedure_date=b.procedure_date);
quit;

proc freq;
table stay_dstn_cd mod_stay_start ind_clm_merge;
run;

/*check of days from stay start to surgery
most should be within a day or two and they are*/
data index_sur_stay_9;
set index_sur_stay_8 ;
days_to_surg = procedure_date-stay_start;
run;

proc freq;
table days_to_surg;
run;

/*Calculate length of stay for index surgery
This is last calculation so save this version of the data to the int_data folder*/
data sur_int.index_sur_stay;
set index_sur_stay_9;
index_LOS=stay_end - stay_start;
if index_LOS=0 then index_LOS=1;
run;

proc freq;
table index_LOS /missprint;
run;

/*************************************************************************/
/*View Discharge status - Do not have this var in ip claims*/
/*************************************************************************/
/*A = discharged alive, B = discharged dead 
proc freq data=sur_int.index_sur_stay;
table DSCHRGCD /missprint;
run;
*/
/*************************************************************************/
/*View Discharge destination status*/
/*************************************************************************/
/* See medpar appendix for additional codes
01 = discharged to home / self care (routine charge)
02 = Discharged/transferred to other short term general hospital for inpatient care.
03 = Discharged/transferred to skilled nursing facility (SNF)
04 = Discharged/transferred to intermediate care facility (ICF).
05 = Discharged/transferred to another type of institution for inpatient care.
06 = Discharged/transferred to home health service organization.
20 = Expired (did not recover - Christian Science patient).
50 = Hospice - home 
51 = Hospice - medical facility 
61 = Discharged/transferred within this institution to a hospital-based Medicare
approved swing bed
62 = Discharged/transferred to an inpatient rehab. facility including distinct
parts units of a hospital.
63 = Discharged/transferred to a long term care hospitals.
*/

proc freq data=sur_int.index_sur_stay;
table stay_dstn_cd /missprint;
run;




H="check for mc parts a&b"
/*
last_surgery_date
to have part a part b in the last 6m, and no hmo
Use mc denominator file to determine insurance status*/


/*sort denominator file, remove duplicate entries on id and year*/
proc sort data=medi.dn_2000_2012 out=dn_2000_20122  nodupkey;
by bid_hrs_21 year;
run;

/*latest surgery year variable defined*/
data r_sp;
set sur_int.index_sur_stay;
r_year=year(procedure_date);
run;

/*pull medicare ab status and hmo status variables from dn file
for latest surgery year from above*/
proc sql;
create table dn_surg_y as select
a.*,b.buyin12,b.year,b.HMOIND12
from r_sp a inner join
dn_2000_20122 b
on trim(left(a.bid_hrs_21))=trim(left(b.bid_hrs_21))
and a.r_year=b.year;
quit;

/*check frequency for surgery years*/
proc freq data=dn_surg_y;
table r_year;
run;
/*243 surgeries that meet criteria with denominator data*/
proc sql;
select count(distinct bid_hrs_21) from dn_surg_y;
quit;

/* Trim buyin and hmo variables to only reflect time before the surgery */
data dn_surg_y2;
set dn_surg_y;
surg_month=month(procedure_date);
if length(trim(left(buyin12)))=12 and surg_month>0 then do;
buyin_sy=substr(trim(left(buyin12)),1,surg_month);
hmo_sy=substr(trim(left(HMOIND12)),1,surg_month);
end;
else do;
buyin_sy=trim(left(buyin12));
hmo_sy=trim(left(HMOIND12));
end;
run;
proc means n;
var  surg_month;
run;

/*Look at year prior to surgery to get records of complete 12 months prior to surgery
only have the -1 year dn file
If surgery was within 1 year or 6 months of Jan 2000, then get null for buyin_ vars*/
proc sql;
create table dn_surg_y_bef as select
a.bid_hrs_21,a.year as surg_year,b.year as surg_year_bef,b.year,b.buyin12,b.HMOIND12
from dn_surg_y a inner join
dn_2000_20122 b
on trim(left(a.bid_hrs_21))=trim(left(b.bid_hrs_21))
and 0<a.year-b.year<=1 order by bid_hrs_21,year;
quit;

proc sql;
create table all_insurance as select a.*,b.buyin12 as buyin_bef,b.HMOIND12 as hmo_bef from
dn_surg_y2 a
left join
dn_surg_y_bef b
on trim(left(a.bid_hrs_21))=trim(left(b.bid_hrs_21));
quit;

/*merge surgery year and year before surgery buy-in and hmo variables
Trim so the final variable _1y shows 12 months pre-surgery
Variable _6m is 6 months pre-surgery
Note: indicator variables for parts a and b and hmo are null if don't
have information for full 12 or 6 months pre-surgery*/
data all_insurance2;
set all_insurance;
buyin_2y=trim(left(buyin_bef))||trim(left(buyin_sy));
hmo_2y=trim(left(hmo_bef))||trim(left(hmo_sy));

/*create 12 month variables*/
buyin_2y_r=reverse(trim(buyin_2y));
hmo_2y_r=reverse(trim(hmo_2y));

if length(buyin_2y_r)>11 then buyin_1y_r=substr(trim(left(buyin_2y)),1,12);
if length(hmo_2y_r)>11 then hmo_1y_r=substr(trim(left(hmo_2y)),1,12);

if length(buyin_2y_r)<12 then buyin_1y_r="";
if length(hmo_2y_r)<12 then hmo_1y_r="";

buyin_1y=reverse(trim(buyin_1y_r));
hmo_1y=reverse(trim(hmo_1y_r));

/*create indicator variable for mc coverage 0=no, 1=yes*/
if length(buyin_1y)=12 then do;
if indexc(buyin_1y,"0","1","2","A","B") then part_ab_1y=0;
if indexc(buyin_1y,"0","1","2","A","B")=0 then part_ab_1y=1;
end;
/*create indicator variable for hmo coverage 0=no, 1=yes*/
if length(hmo_1y)=12 then do;
if index(hmo_1y,"00000000000") then hmo_d_1y=0;
if index(hmo_1y,"00000000000")=0 then hmo_d_1y=1;
end;

/*create 6 month variable*/
if length(buyin_2y_r)>5 then buyin_6m_r=substr(trim(left(buyin_2y)),1,6);
if length(hmo_2y_r)>5 then hmo_6m_r=substr(trim(left(hmo_2y)),1,6);

if length(buyin_2y_r)<6 then buyin_6m_r="";
if length(hmo_2y_r)<6 then hmo_6m_r="";

buyin_6m=reverse(trim(buyin_6m_r));
hmo_6m=reverse(trim(hmo_6m_r));

/*create indicator variable for mc coverage 6 mo. 0=no, 1=yes*/
if length(buyin_6m)=6 then do;
if indexc(buyin_6m,"0","1","2","A","B") then part_ab_6m=0;
if indexc(buyin_6m,"0","1","2","A","B")=0 then part_ab_6m=1;
end;
if length(hmo_6m)=6 then do;
if index(hmo_6m,"00000") then hmo_d_6m=0;
if index(hmo_6m,"00000")=0 then hmo_d_6m=1;
end;

run;

/*25 (9 missing=34) observations were within 6months of Jan. 2000 so don't have 6 months pre-surgery data*/
proc freq;
table part_ab_6m*hmo_d_6m;
run;

/*20 (23 missing=43) observations were within 12months of Jan. 2000 so don't have 12 months pre-surgery data*/
proc freq;
table part_ab_1y*hmo_d_1y;
run;

/*bring in gender, reason for entitlement, dob, esrd indicator
 from claims denominator file*/
proc sql;
create table all_ins_gender as select a.*,b.sex,b.CREC,b.BENE_DOB,b.esrd_ind, b.DEATH_DT from
all_insurance2 a
left join dn_2000_20122 b
on trim(left(a.bid_hrs_21))=trim(left(b.bid_hrs_21))
and a.year=b.year;
quit;

proc freq data=all_ins_gender;
table sex CREC esrd_ind CREC*esrd_ind /missprint;
run;

proc contents order=casecollate data=all_ins_gender;
run;

data surgery_ids_last_1(drop=dgnscd01-dgnscd25 ad_dgns BUYIN12 HMOIND12 
surg_month year buyin_1y_r buyin_2y buyin_2y_r r_year buyin_6m_r 
buyin_bef buyin_sy hmo_1y_r hmo_2y hmo_2y_r hmo_6m_r hmo_bef hmo_sy);
set all_ins_gender;
rename sex=claims_sex;
rename bene_dob=claims_dob;
rename esrd_ind=claims_esrd_ind;
rename DEATH_DT=claims_dod;
run;

proc freq data=surgery_ids_last_1;
table claims_dod /missprint;
run;

/*deal with claims dod missing values that are coded as "00000000"
and change format for dob and dod to dates*/
data surgery_ids_last_2;
set surgery_ids_last_1;
if claims_dod=00000000 then claims_dod=.;
claims_dob2=input(claims_dob,yymmdd8.);
claims_dod2=input(claims_dod,yymmdd8.);
run;

proc freq;
table claims_dod2 /missprint;
run;

data sur_fin.surgery_ids_last;
set surgery_ids_last_2;
drop claims_dob claims_dod;
format claims_dob2 date10. claims_dod2 date10.;
label claims_dob2="Beneficiary dob from claims" claims_dod2="Beneficiary dod from claims";
run;

H="number hosp admissions last 6mos"
/*Start with list of all hospital stays for bid's with an index surgery:
sur_int.hospital_stays_2

Identify number of hospital admissions in the 6 months prior to
the index surgery procedure date

Merge count of pre-hospital stays into dataset: sur_fin.surgery_ids_last

Final dataset created: sur_fin.surgery_ids_6m_pre_adm 
*/

/*Identify all stays 6 months pre-surgery*/

/*start with list of all hospital stays*/
proc sort data=sur_int.hospital_stays_2;
by bid_hrs_21;
run;

/*drop stays that are the index stay*/
data pre_surg_hosp_1;
set sur_int.hospital_stays_2(where=(index_stay=0));
run;

/*identify stays that are 6 months pre-surgery date*/
data pre_surg_hosp_2 ;
set pre_surg_hosp_1 ;
if 0 <= procedure_date-stay_start<=183;
run;


/*Identify stays that are partially within the time from procedure date*/
data pre_surg_hosp_3 ;
set pre_surg_hosp_1 ;
if (procedure_date-stay_start>183 and procedure_date-stay_end<=183);
run;

/*merge the two lists*/
data pre_surg_hosp_4;
set pre_surg_hosp_2 pre_surg_hosp_3 ;
run;

proc sort data=pre_surg_hosp_4;
by bid_hrs_21 stay_start;
run;

/*Assign count variable to count claims in 6 months pre-surgery for each bid*/
data pre_surg_adm_count;
set pre_surg_hosp_4;
admit_6m_pre +1;
by bid_hrs_21;
if first.bid_hrs_21 then admit_6m_pre =1;
run;

proc freq;
table admit_6m_pre;
run;

/*keep only the  final count of pre-surgery admissions*/
proc sort data=pre_surg_adm_count;
by bid_hrs_21 stay_start;
run;

data pre_surg_adm_count_1;
set pre_surg_adm_count;
by bid_hrs_21;
if last.bid_hrs_21;
run;
/*319 patients had an ip admission within the 6 months pre-surgery*/
proc freq;
table admit_6m_pre;
run;

/**************************************************************************************/
/*Bring count of pre-surgery claims in to main dataset*/
/**************************************************************************************/

/*Merge count of hospital admissions pre-surgery into dataset*/
proc sql;
create table surgery_ids_6m_pre_adm_1 as select
a.*, b.admit_6m_pre
from sur_fin.surgery_ids_last a left join
pre_surg_adm_count_1 b
on trim(left(a.bid_hrs_21))=trim(left(b.bid_hrs_21));
quit;

proc freq;
table admit_6m_pre;
run;

/*create indicator variable for pre-surgery hospital admission
= 0 - no pre surgery admissions
= 1 - one or more pre surgery admissions
if no pre-surgery admission, set number admissions to zero */
data sur_fin.surgery_ids_6m_pre_adm;
set surgery_ids_6m_pre_adm_1;
if admit_6m_pre=. then admit_6m_pre=0;
admit_ind_6m_pre=0;
if admit_6m_pre>0 then admit_ind_6m_pre=1;
run;


/*************************************************************************/
/*View Number of Admissions 6 months pre-surgery*/
/*************************************************************************/

ods rtf file='E:\data\surgery_hysterectomy\logs\pre-surg.rtf';
proc freq;
table admit_6m_pre admit_ind_6m_pre /missprint;
run;
ods rtf close;

proc sort data=sur_fin.surgery_ids_6m_pre_adm ;
by admit_6m_pre;
run;


/*************************************************************************/
/*Check high number of admissions beneficiaries
The table generated shows the claim prior to the index surgery claim*/
/*************************************************************************/
proc sql;
create table high_pre_surg_cl as select *
from sur_fin.surgery_ids_6m_pre_adm
where admit_6m_pre>5;
quit;

/*all claims for those high admissions beneficiaries*/
proc sql;
create table high_pre_surg_cl_2 as select *
from pre_surg_adm_count
where bid_hrs_21 in
(select bid_hrs_21 from high_pre_surg_cl);
quit;


H="identify snf days post-surgery"

/*Identify SNF claims 12 months after index surgery

Start with file with pre- and post- surgery ip admissions information:
sur_fin.surgery_ids_post_adm

Get 1 year post-surgery SNF information:
1. SNF indicator
2. SNF days
3. SNF death from discharge destination code?

Dataset saved is: sur_fin.surgery_ids_post_adm_snf2*/

/*Identify snf claims from the medpar file*/
data sur_int.snf_2000_2012;
set medi.mp_2000_2012(where=(trim(left(SSLSSNF))="N"));
run;

/*Identify claims within 1 year from procedure date
Use dataset which includes the claim id
Creates 1 file sur_int.snf_meet_post_365*/

/*Filter claims list by date range post-surgery
Note this contains the surgery admission
Do in multiple steps to check that it works*/

/*step 1: only keep claims where the bid had an index surgery
110 claims identified*/
proc sql;
create table snf_meet1_post_365_step1 as select a.*,b.procedure_date
from sur_int.snf_2000_2012 a inner join
sur_fin.surgery_ids_last b
on trim(left(a.bid_hrs_21))=trim(left(b.bid_hrs_21)) ;
quit;

/*step 2: drop claims where admission date is pre-surgery date
97 claims identified (110-97 = 13 clams were pre-surgery)*/
proc sql;
create table snf_meet1_post_365_step2 as select *
from snf_meet1_post_365_step1 
where 0<=(admit_date - procedure_date); 
quit;

/*step 3: drop claims where admit date is more than 1 year from surgery date
Left with 22 claims where admit date is within 1 year of surgery*/
proc sql;
create table snf_meet1_post_365_step3 as select *
from snf_meet1_post_365_step2 
where (admit_date - procedure_date)<365; 
quit;

/*Identify claims entirely within 1 year post surgery
Step 4: drop claims that aren't entirely within 1 year from surgery date
21 claims left, so 1 claim starts within 1 year but patient isn't
discharged until after 1 year, need to count this patient seperately
to calculate the number of days spent in the SNF in the year post-surgery*/
proc sql;
create table snf_meet1_post_365 as select *
from snf_meet1_post_365_step3 
where (disch_date - procedure_date)<365; 
quit;


/*Identify claims that are partially within the time from procedure date*/
proc sql;
create table snf_meet2_post_365 as select *
from snf_meet1_post_365_step3 
where (disch_date - procedure_date)>=365; 
quit;

/*For claims partially in 1 year of surgery, truncate end date to just get 
days w/i 1 year
create indicator variable that claim end date is truncated*/
data snf_meet2_post_365_1;
set snf_meet2_post_365;
disch_date = procedure_date+365;
snf_disch_date_mod = 1;
label snf_disch_date_mod = "Disch date mod; at 12 mo from proced date";
format disch_date date10.;
run;

proc freq;
table snf_disch_date_mod ;
run;

data snf_meet_post_365;
set snf_meet1_post_365 snf_meet2_post_365_1;
run;

proc freq;
table snf_disch_date_mod ;
run;


/*save final files to project int_data directory*/
data sur_int.snf_meet_post_365 ;
set  snf_meet_post_365;
run;

/*check claims dates are actually either including the surgery procedure date
or after procedure date*/
data snf_test;
set sur_int.snf_meet_post_365;
pro_to_snf_admit=admit_date - procedure_date;
run;

proc freq; 
table pro_to_snf_admit;
run;

/*************************************************************/
/*calculate total number of days spent in SNF by BID*/
/*************************************************************/

data post_snf_days_1;
set sur_int.snf_meet_post_365;
calc_snf_LOS=disch_date-admit_date;
run;

proc sort data=post_snf_days_1;
by bid_hrs_21 admit_date;
run;

proc sql;
create table adm_tot_snf_days_post as select distinct bid_hrs_21,sum(calc_snf_LOS)
	as snf_days_post_12m
	from post_snf_days_1 group by bid_hrs_21;
quit;

proc freq;
table snf_days_post_12m;
run;

data zzztest_snf1;
set adm_tot_snf_days_post(where=(snf_days_post_12m>100));
run;

proc sql;
create table zzztest_snf2 
as select calc_snf_LOS,procedure_date,admit_date,disch_date,bid_hrs_21
from post_snf_days_1 where bid_hrs_21 in (select bid_hrs_21 from zzztest_snf1);
quit;

data zzztest_snf3;
set zzztest_snf2;
format disch_date date10. admit_date date10.;
pro_to_disch = disch_date - procedure_date;
run;

 

/*calculate snf utilization days total for bid
This is a check because snf days should be capped at 100
1 observation has >100 snf utilization days*/
proc sql;
create table util_days as select distinct
bid_hrs_21,sum(util_day) as snf_util_post_12m
from post_snf_days_1 group by bid_hrs_21;
quit;

proc freq;
table snf_util_post_12m;
run;



/*************************************************************/
/*Merge into main dataset that already contains the hospital
stay information post and pre surgery
resulting dataset name is sur_fin.surgery_ids_post_adm_snf2*/
/*************************************************************/
proc sql;
create table 
sur_fin.surgery_ids_post_adm_snf as select
a.*,coalesce(b.snf_days_post_12m,0) as snf_days_post_12m
from sur_fin.surgery_ids_post_adm a
left join
adm_tot_snf_days_post b
on trim(left(a.bid_hrs_21))=trim(left(b.bid_hrs_21));
quit;


proc sql;
create table 
sur_fin.surgery_ids_post_adm_snf2a as select
a.*,coalesce(b.snf_util_post_12m,0) as snf_util_days_post_12m
from sur_fin.surgery_ids_post_adm_snf a
left join
util_days b
on trim(left(a.bid_hrs_21))=trim(left(b.bid_hrs_21));
quit;


ods rtf file='E:\data\surgery_hysterectomy\logs\post-surg.rtf';
proc freq data=sur_fin.surgery_ids_post_adm_snf2;
table admit_12m_post admit_ind_12m_post days_post_surg_to_adm 
	hosp_days_post_12m snf_days_post_12m snf_util_days_post_12m /missprint ;
run;
ods rtf close;

/*************************************************************/
/*Check individuals with more than 100 days SNF*/
/*************************************************************/
data table test_snf_1; 
set sur_fin.surgery_ids_post_adm_snf2;
if snf_days_post_12m>100;
run;

proc sql;
create table test_snf_2
as select * from sur_int.snf_meet_post_365  
where bid_hrs_21 in (select bid_hrs_21 from test_snf_1);
quit;

proc freq data=sur_int.snf_meet_post_365;
table PRVNUM3;
run;

proc freq data=test_snf_2;
table PRVNUM3;
run;

data test_snf_3(keep=bid_hrs_21 admit_date disch_date procedure_date exhst_dt los_snf qlfyfrom qlfythru cvrlvldt loscnt util_day wrngcd);
set test_snf_2;
bene_exh_date=exhst_dt;
if exhst_dt=0000000 then exhst_dt=.;
if exhst_dt=0 then  exhst_dt=.;
bene_exh_date = datejul(exhst_dt);
format admit_date date10.;
format disch_date date10.;
*format bene_exh_date date10.;
los_snf = disch_date-admit_date;
run; 

/*
data test_snf_3;
set test_snf_2;
keep bid_hrs admit_date disch_date procedure_date bene_exh_date los_snf qlfyfrom_n qlfythru_n adm_qual dis_qual;
if exhst_dt=0000000 then bene_exh_date=.;
bene_exh_date = datejul(exhst_dt);
qlfyfrom_n = datejul(qlfyfrom);
qlfythru_n = datejul(qlfythru);
format admit_date date10.;
format disch_date date10.;
format bene_exh_date date10.;
los_snf = disch_date-admit_date;
adm_qual = admit_date - qlfyfrom;
dis_qual = disch_date - qlfythru;
run; 
*/

proc sort data=test_snf_3;
by bid_hrs_21 admit_date disch_date;
run;

/*no claims overlap to cause the > 100 days
all admit dates within 1 year of procedure date (so no cases of long
stays that started more than 1 year before procedure date causing us to
count days that weren't within 1 year of surgery*/
data test_snf_4;
set test_snf_3;
day_diff_pro = procedure_date - admit_date;
by bid_hrs_21;
	day_diff_clm = admit_date - lag(disch_date);
	if first.bid_hrs_21 then day_diff_clm=.;
run;

proc freq;
table day_diff_clm day_diff_pro ;
run;


/*************************************************************************/
/*Look for indicator of hospital death 12 months post-surgery*/
/*************************************************************************/

/*0 obs have death indicated from snf claims in the 12m post-surgery*/
proc freq data=snf_meet1_post_365_step3;
table  DSCHRGCD*DSTNTNCD;
run;

data snf_death_1;
set snf_meet1_post_365_step3;
if DSTNTNCD=20;
run;

proc sort data=snf_death_1 nodupkey;
by bid_hrs_21;
run;

data snf_death_2(keep=bid_hrs_21 snf_dod snf_dod_ind);
set snf_death_1;
snf_dod = disch_date;
snf_dod_ind = 1;
run;

/*bring in SNF death date to dataset*/
proc sql;
create table 
surgery_ids_post_adm_snf2b as select
a.*,b.snf_dod,b.snf_dod_ind
from sur_fin.surgery_ids_post_adm_snf2a a
left join
snf_death_2 b
on trim(left(a.bid_hrs_21))=trim(left(b.bid_hrs_21));
quit;

/*0 obs has death from IP and SNF claim
Checked and the IP death date is later than the SNF date so use IP*/
proc freq;
table ip_dod_ind*snf_dod_ind /missprint;
run;

data zztest;
set surgery_ids_post_adm_snf2b ;
if ip_dod_ind=1 & snf_dod_ind=1;
run;

/*if no IP death date, use SNF death date*/
data sur_fin.surgery_ids_post_adm_snf2(drop=snf_dod snf_dod_ind);
set surgery_ids_post_adm_snf2b;
if ip_dod = . then ip_dod=snf_dod;
if ip_dod_ind = . then ip_dod_ind=snf_dod_ind;
run;

proc freq;
table ip_dod_ind /missprint;
run;
/*final dataset is sur_fin.surgery_ids_post_adm_snf2*/



H="identify post-surgery hospitalizations"
/*
/*Start with list of all hospital stays for bid's with an index surgery:
sur_int.hospital_stays

Merge into dataset with 6 month pre-surg. admission count
sur_fin.surgery_ids_6m_pre_adm

Information needed:
1. # hospital admissions
2. # days to first hospital admission post surgery
3. # days in hospital, inpatient setting
4. Indicator for hospital death per claims discharge code??

Resulting dataset is:
sur_fin.surgery_ids_post_adm
*/

/****************************************************************/
/*Determine number of admissions in 12 months post surgery*/
/****************************************************************/

/****************************************************************/
/*Identify IP hospital stays 12 months post surgery*/
/****************************************************************/

proc sort data=sur_int.hospital_stays_2;
by bid_hrs_21;
run;

/*drop stays that are the index stay*/
data post_surg_hosp_1;
set sur_int.hospital_stays_2(where=(index_stay=0));
run;

/*identify stays that are 12 months post-surgery date*/
data post_surg_hosp_2 ;
set post_surg_hosp_1 ;
if 0 <= stay_end - procedure_date <= 365;
run;


/*Identify stays that are partially within the time from procedure date*/
data post_surg_hosp_3 ;
set post_surg_hosp_1 ;
if (stay_end - procedure_date >365 and stay_start-procedure_date<=365);
run;

/*merge the two lists*/
data post_surg_hosp_4;
set post_surg_hosp_2 post_surg_hosp_3 ;
run;

/*117 hospital stays identified*/
proc sort data=post_surg_hosp_4;
by bid_hrs_21 stay_start;
run;

/****************************************************************/
/*Assign count for stays 12 months post surgery*/
/****************************************************************/

/*Assign count variable to count claims in 12 months post-surgery for each bid*/
data post_surg_adm_count;
set post_surg_hosp_4;
admit_12m_post +1;
by bid_hrs_21;
if first.bid_hrs_21 then admit_12m_post =1;
run;

proc freq;
table admit_12m_post ;
run;

/*keep only the final count of post-surgery admissions*/
proc sort data=post_surg_adm_count;
by bid_hrs_21 stay_start;
run;

data post_surg_adm_count_1;
set post_surg_adm_count;
by bid_hrs_21;
if last.bid_hrs_21;
label admit_12m_post ="Hospital IP Admissions 12 months post-surgery";
run;
/*365 patients had an ip admission within the 12 months post-surgery*/
proc freq;
table admit_12m_post;
run;

/****************************************************************/
/*Determine date from surgery to 1st admission post-surgery */
/****************************************************************/

/*create table with the first post-surgery claim only
use that admission date to determine days from surgery to admission
variables are blank if no post-surgery admission*/
data adm_post_date;
set post_surg_adm_count(where=(admit_12m_post=1));
frst_post_admt_dt=stay_start;
label frst_post_admt_dt ="Date of first post-surgery hospital admission";
days_post_surg_to_adm=frst_post_admt_dt - procedure_date;
label days_post_surg_to_adm ="Days from surgery to first post-surgery admission";
run;

proc sort data=adm_post_date;
by days_post_surg_to_adm;
run;

proc freq data=adm_post_date;
table days_post_surg_to_adm;
run;



/*******need to look at somebody else; look at bid=H100014421 to see this person's claims,
he was admitted the day after the procedure date*/
data check2;
set post_surg_hosp_4(rename=(clm_id=post_clm)) sur_int.hospital_stays(rename=(clm_id=surg_clm));
where bid_hrs_21='H100014421';
run;
/*checks out - transferred to long term care hospital after index surgery*/

/****************************************************************/
/*Determine total days spent in the hospital 1 year post-surgery */
/****************************************************************/
data post_hosp_days_1;
set post_surg_adm_count;
calc_stay_LOS=stay_end-stay_start;
if calc_stay_LOS=0 then calc_stay_LOS=1 ;
run;

proc sort data=post_hosp_days_1;
by bid_hrs_21 stay_start;
run;

proc sql;
create table adm_tot_hosp_days_post as select distinct bid_hrs_21,sum(calc_stay_LOS)
	as hosp_days_post_12m
	from post_hosp_days_1 group by bid_hrs_21;
quit;

proc freq;
table hosp_days_post_12m;
run;

/****************************************************************/
/*Merge new variables into index hosp dataset */
/****************************************************************/
/*Merge count of hospital admissions post-surgery into dataset
This is the dataset that already includes the pre-surgery admissions count*/

proc sql;
create table surgery_ids_post_adm_1 as select
a.*, b.admit_12m_post 
from sur_fin.surgery_ids_6m_pre_adm a left join
post_surg_adm_count_1 b
on trim(left(a.bid_hrs_21))=trim(left(b.bid_hrs_21));
quit;

/*create indicator variable for post-surgery hospital admission
= 0 - no post surgery admissions
= 1 - one or more post surgery admissions
if no post-surgery admission, set number admissions to zero */
data surgery_ids_post_adm_2 ;
set surgery_ids_post_adm_1 ;
if admit_12m_post=. then admit_12m_post=0;
admit_ind_12m_post=0;
if admit_12m_post>0 then admit_ind_12m_post=1;
run;

/*Merge date to first admission post surgery into dataset*/

proc sql;
create table surgery_ids_post_adm_3 as select
a.*, b.frst_post_admt_dt, b.days_post_surg_to_adm
from surgery_ids_post_adm_2 a left join
adm_post_date b
on trim(left(a.bid_hrs_21))=trim(left(b.bid_hrs_21));
quit;

/*Merge in number hospital days 12 months post surgery*/

proc sql;
create table 
sur_fin.surgery_ids_post_adm_a as select
a.*,coalesce(b.hosp_days_post_12m,0) as hosp_days_post_12m
from surgery_ids_post_adm_3 a
left join
adm_tot_hosp_days_post b
on trim(left(a.bid_hrs_21))=trim(left(b.bid_hrs_21));
quit;

/*************************************************************************/
/*View Number of Admissions 12 months post-surgery*/
/*************************************************************************/
proc freq;
table admit_12m_post admit_ind_12m_post days_post_surg_to_adm 
	hosp_days_post_12m /missprint;
run;

/*************************************************************************/
/*Look for indicator of hospital death 12 months post-surgery*/
/*************************************************************************/

/*46 obs have death indicated from IP claims in the 12m post-surgery*/
proc freq data=post_surg_hosp_4;
table STUS_CD;
run;

data hosp_death_1;
set post_surg_hosp_4;
if  STUS_CD=20;
run;

proc sort data=hosp_death_1 nodupkey;
by bid_hrs_21;
run;

data hosp_death_2(keep=bid_hrs_21 ip_dod ip_dod_ind);
set hosp_death_1;
ip_dod = disch_date;
ip_dod_ind = 1;
label ip_dod="Death date from IP claims"
ip_dod_ind="Indicator for DOD from IP claims";
run;

/*bring in IP death date to dataset*/
proc sql;
create table 
sur_fin.surgery_ids_post_adm as select
a.*,b.ip_dod,b.ip_dod_ind
from sur_fin.surgery_ids_post_adm_a a
left join
hosp_death_2 b
on trim(left(a.bid_hrs_21))=trim(left(b.bid_hrs_21));
quit;

proc freq;
table ip_dod_ind /missprint;
run;

/*final dataset is sur_fin.surgery_ids_post_adm*/


H="identify all claims 6m & 12m pre-surgery"
/*Identify claims of all types 6 months and 12 months before surgery
Use these claims lists to identify Elixhauser comorbidities and
chronic conditions*/

/*start of MACRO */

/*Macro for all claims files except for medpar
Run this twice to get two sets of files: xx_meet_###
xx = claim type
### days before surgery (183=6 months, 365=12 months*/
%macro other(days_start=,days_bef_surg=,source=);

/*Identify claims within certain time from procedure date defined when run macro*/
proc sql;
create table &source._meet_&days_bef_surg. as select a.*,b.procedure_date
from medi.&source._2000_2012 a inner join
sur_fin.surgery_ids_last b
on trim(left(a.bid_hrs_21))=trim(left(b.bid_hrs_21))
and &days_start<=b.procedure_date-a.admit_date<=&days_bef_surg;
quit;
run;

%mend;

/*Macro for medpar claims
Creates file ip_meet3_###
where ### = 183 or 365 - days before surgery*/
%macro mp(days_start=,days_bef_surg=,source=);
%let source0=mp;

/*Identify claims within certain time from procedure date*/
proc sql;
create table &source._meet_&days_bef_surg. as select a.*,b.procedure_date
from medi.&source0._2000_2012 a inner join
sur_fin.surgery_ids_last b
on trim(left(a.bid_hrs_21))=trim(left(b.bid_hrs_21)) 
and &days_start<=b.procedure_date-a.admit_date<=&days_bef_surg ;
quit;

/*Identify claims that are partially within the time from procedure date*/
proc sql;
create table &source._meet2_&days_bef_surg. as select a.*,b.procedure_date
from medi.&source0._2000_2012 a inner join
sur_fin.surgery_ids_last b
on trim(left(a.bid_hrs_21))=trim(left(b.bid_hrs_21))
and b.procedure_date-a.admit_date>&days_bef_surg and b.procedure_date-a.disch_date<=&days_bef_surg;
quit;

data &source._meet3_&days_bef_surg.;
set &source._meet_&days_bef_surg &source._meet2_&days_bef_surg;
run;

run;

%mend;

/*Run macros to identify claims that are within 6 months of the surgery date*/
%mp(days_start=0,days_bef_surg=183,source=mp );
%other(days_start=0,days_bef_surg=183,source=hh );
%other(days_start=0,days_bef_surg=183,source=hs );
%other(days_start=0,days_bef_surg=183,source=dm );
%other(days_start=0,days_bef_surg=183,source=op );
%other(days_start=0,days_bef_surg=183,source=pb );

/*Run macros to identify claims that are within 1 year of the surgery date*/
%mp(days_start=0,days_bef_surg=365,source=mp );
%other(days_start=0,days_bef_surg=365,source=hh );
%other(days_start=0,days_bef_surg=365,source=hs );
%other(days_start=0,days_bef_surg=365,source=dm );
%other(days_start=0,days_bef_surg=365,source=op );
%other(days_start=0,days_bef_surg=365,source=pb );


H="identify dx codes"
proc contents data=hh_meet_365;
run;
/* Two files created:
1. dx_0_n6m: dx 6 months from surgery date
2. dx_0_n12m: dx 12 months from surgery date

Saved in E:\data\surgery_hysterectomy\int_data

One macro runs through all claim types to determine dx codes present

range1 = 0 - name for final output file
range2 = n6m or n12m - name for final output file
days_bef_surg = 183 or 365 - identifies claims dataset to start with*/

%macro dx_time_range(range1=, range2=, days_bef_surg=);

/*Process carrier medicare claims to pull out dx codes
Starts with pb_meet which is list of claims 6 / 12 months pre-surgery
List of all diagnosis codes in 6 / 12 months pre-surgery
Multiple lines per each BID*/
data pb_last_&range2._dx(keep=bid_hrs_21 diag);
set pb_meet_&days_bef_surg.(keep=bid_hrs_21 PDGNS_CD DGNSCD01-DGNSCD12 );
array dx PDGNS_CD DGNSCD01-DGNSCD12;
do over dx;
diag=dx ;
output;
end;
run;
/*check for and remove duplicates, note this doesn't remove blanks*/
proc sort data=pb_last_&range2._dx out=pb_last_&range2._dx2 nodupkey;
by bid_hrs_21 diag;
run;


/*Process outpatient medicare claims to pull out dx codes
Dataset being created: op_last_&range2._dx2*/
data op_last_&range2._dx(keep=bid_hrs_21 diag);
set op_meet_&days_bef_surg.(keep=bid_hrs_21 PDGNS_CD DGNSCD01-DGNSCD25  );
array dx PDGNS_CD DGNSCD01-DGNSCD25 ;
do over dx;
diag=dx ;
output;
end;
run;
proc sort data=op_last_&range2._dx out=op_last_&range2._dx2 nodupkey;
by bid_hrs_21 diag;
run;

/*Process medpar medicare claims to pull out dx codes
Dataset being created: mp_last_&range2._dx2*/
data mp_last_&range2._dx(keep=bid_hrs_21 diag);
set mp_meet3_&days_bef_surg.(keep=bid_hrs_21 AD_DGNS DGNS_CD01-DGNS_CD25 );
array dx AD_DGNS DGNS_CD01-DGNS_CD25 ;
do over dx;
diag=dx ;
output;
end;
run;
proc sort data=mp_last_&range2._dx out=mp_last_&range2._dx2 nodupkey;
by bid_hrs_21 diag;
run;

/*Process dme medicare claims to pull out dx codes
Dataset being created: dm_last_&range2._dx2*/
data dm_last_&range2._dx(keep=bid_hrs_21 diag);
set dm_meet_&days_bef_surg.(keep=BID_HRS_21 PDGNS_CD DGNSCD01-DGNSCD12 );
array dx PDGNS_CD DGNSCD01-DGNSCD12 ;
do over dx;
diag=dx ;
output;
end;
run;
proc sort data=dm_last_&range2._dx out=dm_last_&range2._dx2 nodupkey;
by bid_hrs_21 diag;
run;

/*Process hh medicare claims to pull out dx codes
Dataset being created: dm_last_&range2._dx2*/
data hh_last_&range2._dx(keep=bid_hrs_21 diag);
set hh_meet_&days_bef_surg.(keep=bid_hrs_21 PDGNS_CD DGNSCD01-DGNSCD25 );
array dx PDGNS_CD DGNSCD01-DGNSCD25 ;
do over dx;
diag=dx ;
output;
end;
run;
proc sort data=hh_last_&range2._dx out=hh_last_&range2._dx2 nodupkey;
by bid_hrs_21 diag;
run;

/*Process hs medicare claims to pull out dx codes
Dataset being created: dm_last_&range2._dx2*/
data hs_last_&range2._dx(keep=bid_hrs_21 diag);
set hs_meet_&days_bef_surg.(keep=bid_hrs_21 PDGNS_CD DGNSCD01-DGNSCD25 );
array dx PDGNS_CD DGNSCD01-DGNSCD25 ;
do over dx;
diag=dx ;
output;
end;
run;
proc sort data=hs_last_&range2._dx out=hs_last_&range2._dx2 nodupkey;
by bid_hrs_21 diag;
run;


/*set diag variable length = 7 chars since that's the max length from the mc claims
Need to do this because length varies across the different mc claim types*/
data hs_last_&range2._dx3;
length diag $7;
set hs_last_&range2._dx2;
run;
data hh_last_&range2._dx3;
length diag $7;
set hh_last_&range2._dx2;
run;
data mp_last_&range2._dx3;
length diag $7;
set mp_last_&range2._dx2;
run;
data dm_last_&range2._dx3;
length diag $7;
set dm_last_&range2._dx2;
run;
data op_last_&range2._dx3;
length diag $7;
set op_last_&range2._dx2;
run;
data pb_last_&range2._dx3;
length diag $7;
set pb_last_&range2._dx2;
run;


/*merge diagnoses from each claim type into single dataset*/
data dx_all_last_&range2.;
set hs_last_&range2._dx3
hh_last_&range2._dx3
mp_last_&range2._dx3
dm_last_&range2._dx3
op_last_&range2._dx3
pb_last_&range2._dx3;
run;
proc sort data=dx_all_last_&range2.(where=(diag~="")) out=sur_int.dx_&range1._&range2 nodupkey;
by bid_hrs_21 diag;
run;

%mend;


/*run the macro - 6 months pre-surgery - get sas dataset sur_int.dx_0_n6m*/
%dx_time_range(range1=0, range2=n6m, days_bef_surg=183);
/*run the macro - 12 months pre-surgery - get sas dataset sur_int.dx_0_n12m*/
%dx_time_range(range1=0, range2=n12m, days_bef_surg=365);


H="add elixhauser index"
/*Elixhauser index created in two files

sur_fin.surgery_ids_last_n6m
sur_fin.surgery_ids_last_n12m

One for 6 months pre-surgery and one for 12 months pre-surgery
Merged with index surgery, pre- and post-surgery hospitalization and 
insurance information collected in the previous sections of this
outline code

CAD defined with ICD-9 codes as defined by CMS here:
http://www.mdinteractive.com/files/uploaded/file/cms2013group/CAD_2013_CMS.pdf
*/

/*    Macro rename 
lib=library
dsn=dataset name
pre=suffix to be added to all of the variable names
*/

%macro rename(lib,dsn,pre);
options pageno=1 nodate;
proc contents data=&lib..&dsn;
title "Before Renaming All Variables";
run;

proc sql noprint;
select nvar into :num_vars
from dictionary.tables
where libname="&LIB" and
memname="&DSN";
select distinct(name) into :var1-
:var%TRIM(%LEFT(&num_vars))
from dictionary.columns
where libname="&LIB" and
memname="&DSN";
quit;
run;

proc datasets library=&LIB;
modify &DSN;
rename
%do i=1 %to &num_vars;
&&var&i=&&var&i.._&pre 
%end;
;
quit;
run;
options pageno=1 nodate;
proc contents data=&lib..&dsn;
title "After Renaming All Variables";
run;
%mend rename;





/*Elixhauser index macro
Note includes additional 2 comorbidities: Dementia and Coronary Artery Disease*/

%macro elixhauser(range1=, range2=);

data dx_31_comor_&range2;
set sur_int.dx_&range1._&range2(rename=(diag=dx_0));
dx=trim(left(dx_0));

if dx~="" then do;

comorbi_1=0;
comorbi_2=0;
comorbi_3=0;
comorbi_4=0;
comorbi_5=0;
comorbi_6=0;
comorbi_7=0;
comorbi_8=0;
comorbi_9=0;
comorbi_10=0;
comorbi_11=0;
comorbi_12=0;
comorbi_13=0;
comorbi_14=0;
comorbi_15=0;
comorbi_16=0;
comorbi_17=0;
comorbi_18=0;
comorbi_19=0;
comorbi_20=0;
comorbi_21=0;
comorbi_22=0;
comorbi_23=0;
comorbi_24=0;
comorbi_25=0;
comorbi_26=0;
comorbi_27=0;
comorbi_28=0;
comorbi_29=0;
comorbi_30=0;
*end of intialize of 30 binary variables;
*add dementia and CAD;
dementia=0;
cad=0;

*do over dx;
	*Congestive Heart Failure;
	if (substr(dx,1,5)='39891' or
		substr(dx,1,5)='40211' or
		substr(dx,1,5)='40291' or
		substr(dx,1,5)='40411' or
		substr(dx,1,5)='40413' or
		substr(dx,1,5)='40491' or
		substr(dx,1,5)='40493' or
		substr(dx,1,3)='428') 
		and comorbi_1=0 
		then comorbi_1=1;*add one binary variables here.;
	*Cardiac Arrhythmias;
	if (substr(dx,1,5)='42610' or
		substr(dx,1,5)='42611' or
		substr(dx,1,5)='42613' or
		substr(dx,1,4)='4262' or
		substr(dx,1,4)='4263' or
		substr(dx,1,4)='4264' or
		substr(dx,1,5)='42650' or
		substr(dx,1,5)='42651' or
		substr(dx,1,5)='42652' or
		substr(dx,1,5)='42653' or
		substr(dx,1,4)='4266' or
		substr(dx,1,4)='4267' or
		substr(dx,1,4)='4268' or
		substr(dx,1,4)='4270' or
		substr(dx,1,4)='4272' or
		substr(dx,1,5)='42731' or
		substr(dx,1,5)='42760' or
		substr(dx,1,4)='4279' or
		substr(dx,1,4)='7850' or
		substr(dx,1,4)='V450' or
		substr(dx,1,4)='V533')
			and comorbi_2=0 
		then comorbi_2=1;
	* Valvular Disease ;
	if (substr(dx,1,5)='09320' or
		substr(dx,1,5)='09321' or
		substr(dx,1,5)='09322' or
		substr(dx,1,5)='09323' or
		substr(dx,1,5)='09324' or
		substr(dx,1,3)='394' or
		substr(dx,1,3)='395' or
		substr(dx,1,3)='396' or
		substr(dx,1,4)='3970' or
		substr(dx,1,4)='3971' or
		substr(dx,1,4)='4240' or
		substr(dx,1,4)='4241' or
		substr(dx,1,4)='4242' or
		substr(dx,1,4)='4243' or
		substr(dx,1,4)='4244' or
		substr(dx,1,4)='4245' or
		substr(dx,1,4)='4246' or
		substr(dx,1,4)='4247' or
		substr(dx,1,4)='4248' or
		substr(dx,1,5)='42490' or
		substr(dx,1,5)='42491' or
		substr(dx,1,4)='7463' or
		substr(dx,1,4)='7464' or
		substr(dx,1,4)='7465' or
		substr(dx,1,4)='7466' or
		substr(dx,1,4)='V422' or
		substr(dx,1,5)='V433')
			and comorbi_3=0 
		then comorbi_3=1;
	*Pulmonary Circulation Disorders;
	if (substr(dx,1,3)='416' or
		substr(dx,1,4)='4179')
			and comorbi_4=0 
		then comorbi_4=1;
	*Peripheral Vascular Disorders;
	if (substr(dx,1,3)='440' or
		substr(dx,1,4)='4412' or
		substr(dx,1,4)='4414' or
		substr(dx,1,4)='4417' or
		substr(dx,1,4)='4419' or
		substr(dx,1,4)='4431' or
		substr(dx,1,4)='4432' or
		substr(dx,1,4)='4438' or
		substr(dx,1,4)='4439' or
		substr(dx,1,4)='4471' or
		substr(dx,1,4)='5571' or
		substr(dx,1,4)='5579' or
		substr(dx,1,4)='V434')
			and comorbi_5=0 
		then comorbi_5=1;
	*Hypertension;
	if ((substr(dx,1,4)='4011' or
		substr(dx,1,4)='4019')) or
	   ((substr(dx,1,5)='40210' or
		substr(dx,1,5)='40290' or
		substr(dx,1,5)='40410' or
		substr(dx,1,5)='40490' or
		substr(dx,1,5)='40511' or
		substr(dx,1,5)='40519' or
		substr(dx,1,5)='40591' or
		substr(dx,1,5)='40599')) 
			and comorbi_6=0 
		then comorbi_6=1;
	*Paralysis;	
	if (substr(dx,1,4)='3420' or
		substr(dx,1,5)='34210' or
		substr(dx,1,5)='34211' or
		substr(dx,1,5)='34212' or
		substr(dx,1,4)='3429' or
		substr(dx,1,3)='343' or
		substr(dx,1,3)='344')
			and comorbi_7=0 
		then comorbi_7=1;
	*Other Neurological Disorders;
	if (substr(dx,1,4)='3319' or
		substr(dx,1,4)='3320' or
		substr(dx,1,4)='3334' or
		substr(dx,1,4)='3335' or
		substr(dx,1,3)='334' or
		substr(dx,1,3)='335' or
		substr(dx,1,3)='340' or
		substr(dx,1,4)='3411' or
		substr(dx,1,4)='3418' or
		substr(dx,1,4)='3419' or
		substr(dx,1,5)='34500' or
		substr(dx,1,5)='34501' or
		substr(dx,1,5)='34510' or
		substr(dx,1,5)='34511' or
		substr(dx,1,4)='3454' or
		substr(dx,1,5)='34550' or
		substr(dx,1,5)='34551' or
		substr(dx,1,4)='3458' or
		substr(dx,1,5)='34590' or
		substr(dx,1,5)='34591' or
		substr(dx,1,4)='3481' or
		substr(dx,1,4)='3483' or
		substr(dx,1,4)='7803' or
		substr(dx,1,4)='7843') 
			and comorbi_8=0 
		then comorbi_8=1;	
	*Chronic Pulmonary Disease;
	if (substr(dx,1,3)='490' or
		substr(dx,1,3)='491' or
		substr(dx,1,3)='492' or
		substr(dx,1,4)='4930' or
		substr(dx,1,4)='4931' or
		substr(dx,1,4)='4932' or
		substr(dx,1,4)='4938' or
		substr(dx,1,5)='49390' or
		substr(dx,1,5)='49391' or
		substr(dx,1,3)='494' or
		substr(dx,1,3)='495' or
		substr(dx,1,3)='496' or
		substr(dx,1,3)='497' or
		substr(dx,1,3)='498' or
		substr(dx,1,3)='499' or
		substr(dx,1,3)='500' or
		substr(dx,1,3)='501' or
		substr(dx,1,3)='502' or
		substr(dx,1,3)='503' or
		substr(dx,1,3)='504' or
		substr(dx,1,3)='505' or
		substr(dx,1,4)='5064') 
			and comorbi_9=0 
		then comorbi_9=1;	
	*Diabetes, uncomplicated;
	if (substr(dx,1,4)='2500' or
		substr(dx,1,4)='2501' or
		substr(dx,1,4)='2502' or
		substr(dx,1,4)='2503') 
			and comorbi_10=0 
		then comorbi_10=1;
	*Diabetes, complicated;
	if (substr(dx,1,4)='2504' or
		substr(dx,1,4)='2505' or
		substr(dx,1,4)='2506' or
		substr(dx,1,4)='2507' or
		substr(dx,1,4)='2509') 
			and comorbi_11=0 
		then comorbi_11=1;
	*Hypothyroidism;
	if (substr(dx,1,3)='243' or
		substr(dx,1,4)='2440' or
		substr(dx,1,4)='2441' or
		substr(dx,1,4)='2442' or
		substr(dx,1,4)='2448' or
		substr(dx,1,4)='2449') 	
			and comorbi_12=0 
		then comorbi_12=1;
	*Renal Failure;
	if (substr(dx,1,5)='40311' or
		substr(dx,1,5)='40391' or
		substr(dx,1,5)='40412' or
		substr(dx,1,5)='40492' or
		substr(dx,1,3)='585' or
		substr(dx,1,3)='586' or
		substr(dx,1,4)='V420' or
		substr(dx,1,4)='V451' or
		substr(dx,1,4)='V560' or
		substr(dx,1,4)='V568') 
			and comorbi_13=0 
		then comorbi_13=1;
	*Liver Disease;
	if (substr(dx,1,5)='07032' or
		substr(dx,1,5)='07033' or
		substr(dx,1,5)='07054' or
		substr(dx,1,4)='4560' or
		substr(dx,1,4)='4561' or
		substr(dx,1,5)='45620' or
		substr(dx,1,5)='45621' or
		substr(dx,1,4)='5710' or
		substr(dx,1,4)='5712' or
		substr(dx,1,4)='5713' or
		substr(dx,1,4)='5714' or
		substr(dx,1,4)='5715' or
		substr(dx,1,4)='5716' or
		substr(dx,1,4)='5718' or
		substr(dx,1,4)='5719' or
		substr(dx,1,4)='5723' or
		substr(dx,1,4)='5728' or
		substr(dx,1,4)='V427') 
			and comorbi_14=0 
		then comorbi_14=1;
	*Peptic Ulcer Disease excluding bleeding;
	if (substr(dx,1,5)='53170' or
		substr(dx,1,5)='53190' or
		substr(dx,1,5)='53270' or
		substr(dx,1,5)='53290' or
		substr(dx,1,5)='53370' or
		substr(dx,1,5)='53390' or
		substr(dx,1,5)='53470' or
		substr(dx,1,5)='53490' or
		substr(dx,1,5)='V1271') 
			and comorbi_15=0 
		then comorbi_15=1;
	*AIDS;
	if (substr(dx,1,3)='042' or
		substr(dx,1,3)='043' or
		substr(dx,1,3)='044') 
			and comorbi_16=0 
		then comorbi_16=1;
	*Lymphoma;
	if (substr(dx,1,3)='200' or
		substr(dx,1,4)='201' or
		substr(dx,1,4)='2020' or
		substr(dx,1,4)='2021' or
		substr(dx,1,4)='2022' or
		substr(dx,1,4)='2023' or
		substr(dx,1,4)='2025' or
		substr(dx,1,4)='2026' or
		substr(dx,1,4)='2027' or
		substr(dx,1,4)='2028' or
		substr(dx,1,4)='2029' or
		substr(dx,1,4)='2030' or
		substr(dx,1,4)='2038' or
		substr(dx,1,4)='2386' or
		substr(dx,1,4)='2733' or
		substr(dx,1,4)='V1071' or
		substr(dx,1,4)='V1072' or
		substr(dx,1,4)='V1079')
			and comorbi_17=0 
		then comorbi_17=1;
	*Metastatic Cancer;
	if (substr(dx,1,3)='196' or
		substr(dx,1,3)='197' or
		substr(dx,1,3)='198' or
		substr(dx,1,4)='199') 
			and comorbi_18=0 
		then comorbi_18=1;	
	*Solid Tumor without Metastisis;
	if (substr(dx,1,2)='14' or
		substr(dx,1,2)='15' or
		substr(dx,1,2)='16' or
		substr(dx,1,3)='170' or
		substr(dx,1,3)='171' or
		substr(dx,1,3)='172' or
		substr(dx,1,3)='174' or
		substr(dx,1,3)='175' or
		substr(dx,1,3)='179' or
		substr(dx,1,2)='18' or
		substr(dx,1,3)='190' or
		substr(dx,1,3)='191' or
		substr(dx,1,3)='192' or
		substr(dx,1,3)='193' or
		substr(dx,1,3)='194' or
		substr(dx,1,3)='195' or
		substr(dx,1,3)='V10')
			and comorbi_19=0 
		then comorbi_19=1;
	*Rheumatoid Arthritis/Collagen Vascular Diseases;
	if (substr(dx,1,4)='7010' or
		substr(dx,1,3)='710' or
		substr(dx,1,3)='714' or
		substr(dx,1,3)='720' or
		substr(dx,1,3)='725') 
			and comorbi_20=0 
		then comorbi_20=1;
	*Coagulopathy;
	if (substr(dx,1,3)='286' or
		substr(dx,1,4)='2871' or
		substr(dx,1,4)='2873' or
		substr(dx,1,4)='2874' or
		substr(dx,1,4)='2875') 
			and comorbi_21=0 
		then comorbi_21=1;
	*Obesity;
	if (substr(dx,1,4)='2780')  
			and comorbi_22=0 
		then comorbi_22=1;
	*Weight Loss;
	if (substr(dx,1,3)='260' or
		substr(dx,1,3)='261' or
		substr(dx,1,3)='262' or
		substr(dx,1,3)='263') 
			and comorbi_23=0 
		then comorbi_23=1;	
	*Fluid and Electrolyte Disorders;
	if (substr(dx,1,3)='276') 
			and comorbi_24=0 
		then comorbi_24=1;
	*Blood Loss Anemia;
	if (substr(dx,1,4)='2800') 
			and comorbi_25=0 
		then comorbi_25=1;
	*Deficiency Anemias;
	if (substr(dx,1,4)='2801' or
		substr(dx,1,4)='2808' or
		substr(dx,1,4)='2809' or
		substr(dx,1,4)='2859') 
			and comorbi_26=0 
		then comorbi_26=1;
	*Alcohol Abuse;
	if (substr(dx,1,4)='2911' or
		substr(dx,1,4)='2912' or
		substr(dx,1,4)='2915' or
		substr(dx,1,4)='2918' or
		substr(dx,1,4)='2919' or
		substr(dx,1,4)='3039' or
		substr(dx,1,4)='3050' or
		substr(dx,1,4)='V113') 
			and comorbi_27=0 
		then comorbi_27=1;
	*Drug Abuse;
	if (substr(dx,1,4)='2920' or
		substr(dx,1,5)='29282' or
		substr(dx,1,5)='29283' or
		substr(dx,1,5)='29284' or
		substr(dx,1,5)='29289' or
		substr(dx,1,4)='2929' or
		substr(dx,1,3)='304' or
		substr(dx,1,4)='3052' or
		substr(dx,1,4)='3053' or
		substr(dx,1,4)='3054' or
		substr(dx,1,4)='3055' or
		substr(dx,1,4)='3056' or
		substr(dx,1,4)='3057' or
		substr(dx,1,4)='3058' or
		substr(dx,1,4)='3059')
			and comorbi_28=0 
		then comorbi_28=1;	
	*Psychoses;
	if (substr(dx,1,3)='295' or
		substr(dx,1,3)='296' or
		substr(dx,1,3)='297' or
		substr(dx,1,3)='298' or
		substr(dx,1,4)='2991') 
			and comorbi_29=0 
		then comorbi_29=1;
	*Depression;
	if (substr(dx,1,4)='3004' or
		substr(dx,1,5)='30112' or
		substr(dx,1,4)='3090' or
		substr(dx,1,4)='3091' or
		substr(dx,1,3)='311')
			and comorbi_30=0 
		then comorbi_30=1;


	*Dementia;
	if (substr(dx,1,4) in ('3310','3311','3312','2900','2901',
             '2902','2903','2912','2948','2949') or
		substr(dx,1,5) in ('29410','29411','29040','29041','29042','29043')) 
		and dementia=0 
          then dementia=1;

	*CAD coronary artery disease;
	if (substr(dx,1,4) in ('4140','4142','4143','4148','4149') or 
		substr(dx,1,3) in ('410','411','412','413') or
		substr(dx,1,5) in ('V4581','V4582'))
		and cad=0 
          then cad=1;

/* CAD list
410.00-410.92
411.0-411.89
412
413.0-413.9
414.00-414.07
414.2
414.3
414.8
414.9
V45.81
V45.82 */

end;
run;


/*check sums of each comorbidity for each ID*/
proc sql;
create table com_test1_&range2 as
select distinct bid_hrs_21,
sum(comorbi_1) as com_1,
sum(comorbi_2) as com_2,
sum(comorbi_3) as com_3,
sum(comorbi_4) as com_4,
sum(comorbi_5) as com_5,
sum(comorbi_6) as com_6,
sum(comorbi_7) as com_7,
sum(comorbi_8) as com_8,
sum(comorbi_9) as com_9,
sum(comorbi_10) as com_10,
sum(comorbi_11) as com_11,
sum(comorbi_12) as com_12,
sum(comorbi_13) as com_13,
sum(comorbi_14) as com_14,
sum(comorbi_15) as com_15,
sum(comorbi_16) as com_16,
sum(comorbi_17) as com_17,
sum(comorbi_18) as com_18,
sum(comorbi_19) as com_19,
sum(comorbi_20) as com_20,
sum(comorbi_21) as com_21,
sum(comorbi_22) as com_22,
sum(comorbi_23) as com_23,
sum(comorbi_24) as com_24,
sum(comorbi_25) as com_25,
sum(comorbi_26) as com_26,
sum(comorbi_27) as com_27,
sum(comorbi_28) as com_28,
sum(comorbi_29) as com_29,
sum(comorbi_30) as com_30,
sum(dementia) as com_31,
sum(cad) as com_32
from dx_31_comor_&range2
group by bid_hrs_21;
quit;

/*define comorbidities as binary indicators*/
data comorbidity_&range2.(keep=bid_hrs_21 comorb_1-comorb_32 comorb_all);
set com_test1_&range2;
array list_com com_1-com_30 com_31 com_32;
array list_com_bin comorb_1-comorb_30 comorb_31 comorb_32;

/*note this defines comorbidity 31 = dementia & 32 = cad*/
do over list_com;
  list_com_bin=0;

  if list_com>0 then do;
    list_com_bin=1;
   end;

end;

/*define aggregate comorbidity as sum of 30 individual indicator vars.
note: CAD not included in this aggregate score*/
comorb_all=comorb_1+comorb_2+comorb_3+comorb_4+comorb_5+comorb_6+comorb_7+
comorb_8+comorb_9+comorb_10+comorb_11+comorb_12+comorb_13+comorb_14+
comorb_15+comorb_16+comorb_17+comorb_18+comorb_19+comorb_20+comorb_21+
comorb_22+comorb_23+comorb_24+comorb_25+comorb_26+comorb_27+comorb_28+
comorb_29+comorb_30+comorb_31;
run;


proc sort data=comorbidity_&range2. nodupkey;
by bid_hrs_21;
run;

/*merges with table of most recent surgeries by id*/
proc sql;
create table ids_meet_criteria_&range2.13 as
select a.*,b.*
from sur_fin.surgery_ids_6m_pre_adm
a left join
comorbidity_&range2. b
on trim(left(a.bid_hrs_21))=trim(left(b.bid_hrs_21));
quit;

/*if comorbidity=null, set to zero*/
data sur_int.elix_&range1._&range2;
set ids_meet_criteria_&range2.13;
array list comorb_1-comorb_31 comorb_all;
do over list;
if list=. then list=0;
end;

label comorb_1 ="Congestive Heart Failure";
label comorb_2 ="Cardiac Arrhythmias";
label comorb_3 ="Valvular Disease";
label comorb_4 ="Pulmonary Circulation Disorders";
label comorb_5 ="Peripheral Vascular Disorders";
label comorb_6 ="Hypertension";
label comorb_7 ="Paralysis";
label comorb_8 ="Other Neurological Disorders";
label comorb_9 ="Chronic Pulmonary Disease";
label comorb_10 ="Diabetes, uncomplicated";
label comorb_11 ="Diabetes, complicated";
label comorb_12 ="Hypothyroidism";
label comorb_13 ="Renal Failure";
label comorb_14 ="Liver Disease";
label comorb_15 ="Peptic Ulcer Disease excluding bleeding";
label comorb_16 ="AIDS";
label comorb_17 ="Lymphoma";
label comorb_18 ="Metastatic Cancer";
label comorb_19 ="Solid Tumor without Metastisis";
label comorb_20 ="Rheumatoid Arthritis/Collagen Vascular Diseases";
label comorb_21 ="Coagulopathy";
label comorb_22 ="Obesity";
label comorb_23 ="Weight Loss";
label comorb_24 ="Fluid and Electrolyte Disorders";
label comorb_25 ="Blood Loss Anemia";
label comorb_26 ="Deficiency Anemias";
label comorb_27 ="Alcohol Abuse";
label comorb_28 ="Drug Abuse";
label comorb_29 ="Psychoses";
label comorb_30 ="Depression";
label comorb_31 ="Dementia";
label comorb_32 ="Coronary Artery Disease";
run;


data test;
set sur_int.elix_&range1._&range2;
run;

/*calls rename macro*/
%rename(WORK,TEST,&range1._&range2);

/*rename bid_hrs_&range1._&range2=bid_hrs*/
data sur_int.elix_&range1._&range2._2(rename =(bid_hrs_21_&range1._&range2=bid_hrs_21));
set test;
keep bid_hrs_21_&range1._&range2 comorb:;
run;
proc sort data=sur_int.elix_&range1._&range2._2;
by bid_hrs_21;
run;

%mend;


/*run macro to get elixhauser comorbidities 6 and 12 months pre-surgery*/
%elixhauser(range1=0, range2=n6m);
%elixhauser(range1=0, range2=n12m);


proc freq;
table comorb:;
run;
proc contents data=sur_int.elix_0_n6m_2;
run;
proc contents data=sur_int.elix_0_n12m_2;
run;


/* merge surgery information and elixhauser comorbidities 
Resulting 2 files are:
sur_fin.surgery_ids_last_n6m
sur_fin.surgery_ids_last_n12m
With elixhauser comorbidities for 6 months and 12 months pre-surgery*/ 

%macro mergeel(range2=);
proc sql;
create table sur_fin.surgery_ids_last_&range2(drop=BID_hrs2) as select a.*,
b.*
from 
sur_fin.surgery_ids_post_adm_snf2 a left join
sur_int.elix_0_&range2._2(rename=(bid_hrs_21=BID_hrs2)) b
on trim(left(a.bid_hrs_21))=trim(left(b.BID_hrs2));
quit;
%mend;

%mergeel(range2=n6m);
%mergeel(range2=n12m);

proc freq data=sur_fin.surgery_ids_last_n6m;
table comorb:;
run;

proc freq data=sur_fin.surgery_ids_last_n12m;
table comorb:;
run;


H="add chronic conditions-note, both sas & stata code"
/*begin of chronic 21 conditions.
Need to do two times, one for 6 month pre-surgery, one for 12 months pre-surgery

Note this code switches between SAS and stata.

Note this pulls from a list of icd-9 codes associated with each of the chronic
conditions. The file path may need to be updated depending on the PC the
code is run from
*/

/*export list of diagnosis codes to stata*/
proc export data=sur_int.dx_0_n6m
outfile="E:\data\surgery_hysterectomy\int_data\dx_0_n6m.dta" replace;
run;

proc export data=sur_int.dx_0_n12m
outfile="E:\data\surgery_hysterectomy\int_data\dx_0_n12m.dta" replace;
run;

/*******************************************************************/
/*put the sas data to stata in to dot format
This is STATA code*/
/*
/*******************************************************************/


clear
set more off

//process diagnosis codes 6 months pre-surgery
use "E:\data\surgery_hysterectomy\int_data\dx_0_n6m.dta",clear

// convert diagnosis codes to string variables, tostring diag,gen(icd9_c)
gen new=ltrim(diag)
icd9 check new,gen(icd9_c)
replace new="" if icd9_c>0 
// convert into dot format (ex 12.1 instead of 121)
icd9 clean new,dots 

replace diag=new
drop icd9_c new

saveold "E:\data\surgery_hysterectomy\int_data\dx_0_n6m_2.dta",replace

//process diagnosis codes 12 months pre-surgery
clear
use "E:\data\surgery_hysterectomy\int_data\dx_0_n12m.dta",clear

// convert diagnosis codes to string variables, tostring diag,gen(icd9_c)
gen new=ltrim(diag)
icd9 check new,gen(icd9_c)
replace new="" if icd9_c>0 
// convert into dot format (ex 12.1 instead of 121)
icd9 clean new,dots 

replace diag=new
drop icd9_c new

saveold "E:\data\surgery_hysterectomy\int_data\dx_0_n12m_2.dta",replace

/*******************************************************************/
/*Convert back to SAS
//This is SAS Code*/
/* to the cms 21 chronic comorbidity*/ /*******************************************************************/

/*bring in formatted Stata dataset of dx codes*/
proc import 
datafile="E:\data\surgery_hysterectomy\int_data\dx_0_n6m_2.dta" 
out=dx_0_n6m_2 replace;
run;

proc import 
datafile="E:\data\surgery_hysterectomy\int_data\dx_0_n12m_2.dta" 
out=dx_0_n12m_2 replace;
run;


/*bring in excel list of dx codes associated with each chronic condition*/
proc import /*datafile="C:\projects\Hospice_impact_on_utilization\raw_data\chronic_21_condition_icd9.xls" */
datafile='E:\data\surgery_hysterectomy\ref_data\chronic_21_condition_icd9.xls'
out=icd9_21_chronic dbms=xls replace;
run;
data icd9_21_chronic2;
set icd9_21_chronic;
/*create new variable of icd 9 code list NOT in dot format
Don't actually use this variable in the following code*/
icd9_wo_dot=compress(icd_9,".");
run;
proc contents data=icd9_21_chronic;
run;

/*creates macro variables of each of the chronic conditions listing of dx codes*/
proc sql;
select icd_9 into :chronic_desc1-:chronic_desc21 from icd9_21_chronic;
quit;
%put &chronic_desc10;
%put &chronic_desc5;

/*******************************************************************/
/*Generate chronic conditions indicator variables using dx
codes 6 months and 12 months pre-surgery */
/*******************************************************************/

/*macro to create indicator variables for 21 chronic conditions
results are two files, one with chronic conditions using dx codes 6 
months pre-surgery, one with dx codes 12 months pre-surgery
presurg = n6m or n12m */

%macro cc(presurg=);

/*initialize the chronic conditions variables*/
data list_&presurg._dx;
set dx_0_&presurg._2;
array list CC_1_AMI
CC_2_ALZH
CC_3_ALZHDMTA
CC_4_ATRIALFB
CC_5_CATARACT
CC_6_CHRNKIDN
CC_7_COPD
CC_8_CHF
CC_9_DIABETES
CC_10_GLAUCOMA
CC_11_HIPFRAC
CC_12_ISCHMCHT
CC_13_DEPRESSN
CC_14_OSTEOPRS
CC_15_RA_OA
CC_16_STRKETIA
CC_17_CNCRBRST
CC_18_CNCRCLRC
CC_19_CNCRPRST
CC_20_CNCRLUNG
CC_21_CNCREndM
;
do over list ;
list=0;
end;

diag_string=diag;

/* for dx codes that begin with numbers, process chronic cond variables*/
if anydigit(substr(trim(left(diag_string)),1,1))=1 then do;
diag=diag_string+0;

if diag in (&chronic_desc1) then CC_1_AMI=1;
if diag in (&chronic_desc2)  then CC_2_ALZH=1;
if diag in (&chronic_desc3)  then CC_3_ALZHDMTA=1;
if diag in (&chronic_desc4) then CC_4_ATRIALFB=1;
if diag in (&chronic_desc5) then CC_5_CATARACT=1;
if diag in (&chronic_desc6) then CC_6_CHRNKIDN=1;
if diag in (&chronic_desc7) then CC_7_COPD=1;
if diag in (&chronic_desc8) then CC_8_CHF=1;
if diag in (&chronic_desc9) then CC_9_DIABETES=1;
if diag in (&chronic_desc10) then CC_10_GLAUCOMA=1;
if diag in (&chronic_desc11) then CC_11_HIPFRAC=1;
if diag in (&chronic_desc12) then CC_12_ISCHMCHT=1;
if diag in (&chronic_desc13) then CC_13_DEPRESSN=1;
if diag in (&chronic_desc14) then CC_14_OSTEOPRS=1;
if diag in (&chronic_desc15) then CC_15_RA_OA=1;
if diag in (&chronic_desc16) then CC_16_STRKETIA=1;
if diag in (&chronic_desc17) then CC_17_CNCRBRST=1;
if diag in (&chronic_desc18) then CC_18_CNCRCLRC=1;
if diag in (&chronic_desc19) then CC_19_CNCRPRST=1;
if diag in (&chronic_desc20) then CC_20_CNCRLUNG=1;
if diag in (&chronic_desc21) then CC_21_CNCREndM=1;
end;

/*deal with dx codes that start with letters
Only two of them in the list we have to worry about*/
if anydigit(substr(trim(left(diag_string)),1,1))=0 then do;
if trim(left(diag_string)) in ("V431") then CC_5_CATARACT=1;
if trim(left(diag_string)) in ("V801") then CC_10_GLAUCOMA=1;
end;

run;

/*aggregate all chronic condition variables by bid*/
proc sql;
create table bid_dx_0_&presurg.(rename=(bid_hrs_21=bid)) as
select distinct bid_hrs_21,
sum(CC_1_AMI) as CC_1_AMI,
sum(CC_2_ALZH) as CC_2_ALZH,
sum(CC_3_ALZHDMTA) as CC_3_ALZHDMTA,
sum(CC_4_ATRIALFB) as CC_4_ATRIALFB,
sum(CC_5_CATARACT) as CC_5_CATARACT,
sum(CC_6_CHRNKIDN) as CC_6_CHRNKIDN,
sum(CC_7_COPD) as CC_7_COPD,
sum(CC_8_CHF) as CC_8_CHF,
sum(CC_9_DIABETES) as CC_9_DIABETES,
sum(CC_10_GLAUCOMA) as CC_10_GLAUCOMA,
sum(CC_11_HIPFRAC) as CC_11_HIPFRAC,
sum(CC_12_ISCHMCHT) as CC_12_ISCHMCHT,
sum(CC_13_DEPRESSN) as CC_13_DEPRESSN,
sum(CC_14_OSTEOPRS) as CC_14_OSTEOPRS,
sum(CC_15_RA_OA) as CC_15_RA_OA,
sum(CC_16_STRKETIA) as CC_16_STRKETIA,
sum(CC_17_CNCRBRST) as CC_17_CNCRBRST,
sum(CC_18_CNCRCLRC) as CC_18_CNCRCLRC,
sum(CC_19_CNCRPRST) as CC_19_CNCRPRST,
sum(CC_20_CNCRLUNG) as CC_20_CNCRLUNG,
sum(CC_21_CNCREndM) as CC_21_CNCREndM

from list_&presurg._dx group by bid_hrs_21;
quit;

/*merge chronic conditions into index surgery list of bid's by bid*/
 proc sql;
 create table bid_dx_0_&presurg.2(drop=bid) as select a.bid_hrs_21,b.*
 from sur_fin.surgery_ids_6m_pre_adm a
 left join
  bid_dx_0_&presurg. b 
 on trim(left(a.bid_hrs_21))=trim(left(b.bid));
 quit;

/*convert to chronic condition vars. to binary variables*/
 data bid_dx_0_&presurg.3;
 set bid_dx_0_&presurg.2;
 array list CC_1_AMI
CC_2_ALZH
CC_3_ALZHDMTA
CC_4_ATRIALFB
CC_5_CATARACT
CC_6_CHRNKIDN
CC_7_COPD
CC_8_CHF
CC_9_DIABETES
CC_10_GLAUCOMA
CC_11_HIPFRAC
CC_12_ISCHMCHT
CC_13_DEPRESSN
CC_14_OSTEOPRS
CC_15_RA_OA
CC_16_STRKETIA
CC_17_CNCRBRST
CC_18_CNCRCLRC
CC_19_CNCRPRST
CC_20_CNCRLUNG
CC_21_CNCREndM
;
do over list ;
if list>0 then list=1;
if list<=0 then list=0;
end;

/*create aggregated indicators*/
CC_AMI_isch=CC_1_AMI|CC_12_ISCHMCHT;
CC_alzheim=CC_2_ALZH|CC_3_ALZHDMTA;
CC_cncr_chronic=CC_17_CNCRBRST | CC_18_CNCRCLRC | CC_19_CNCRPRST | CC_20_CNCRLUNG | 
	CC_21_CNCREndM ;
run;


proc means;
var CC_1_AMI
CC_2_ALZH
CC_3_ALZHDMTA
CC_4_ATRIALFB
CC_5_CATARACT
CC_6_CHRNKIDN
CC_7_COPD
CC_8_CHF
CC_9_DIABETES
CC_10_GLAUCOMA
CC_11_HIPFRAC
CC_12_ISCHMCHT
CC_13_DEPRESSN
CC_14_OSTEOPRS
CC_15_RA_OA
CC_16_STRKETIA
CC_17_CNCRBRST
CC_18_CNCRCLRC
CC_19_CNCRPRST
CC_20_CNCRLUNG
CC_21_CNCREndM;
run;

%mend;

%cc(presurg=n6m);
%cc(presurg=n12m);

/*so resulting 2 datastets are bid_dx_0_n6m3 and bid_dx_0_n12m3*/

/************************************************************/
/*rename the 6 month pre-surgery chronic condition vars*/
/************************************************************/
/*creates dataset to use in the rename macro below*/
data test;
set bid_dx_0_n6m3;
run;

/*rename macro to add _n6mn0 suffix to the chronic conditions variable names
Data file is still work.test but variables renamed after running this macro*/
%rename(WORK,TEST,n6mn0);

/*Changes name of bid_hrs variable so no _n6mn0*/
data sur_int.chronic_21_n6m_n0_0;
set test;
bid_hrs_21=bid_hrs_21_n6mn0;
drop bid_hrs_21_n6mn0;
run;

proc freq data=sur_int.chronic_21_n6m_n0_0;
table cc_alzheim_n6mn0 cc_cncr_chronic_n6mn0;
run;
proc contents;
run;

/************************************************************/
/*rename the 12 month pre-surgery chronic condition vars*/
/************************************************************/

/*creates dataset to use in the rename macro below*/
data test;
set bid_dx_0_n12m3;
run;

/*rename macro to add _n12mn0 suffix to the chronic conditions variable names
Data file is still work.test but variables renamed after running this macro*/
%rename(WORK,TEST,n12mn0);

/*Changes name of bid_hrs variable so no _n12mn0*/
data sur_int.chronic_21_n12m_n0_0;
set test;
bid_hrs_21=bid_hrs_21_n12mn0;
drop bid_hrs_21_n12mn0;
run;

proc freq data=sur_int.chronic_21_n12m_n0_0;
table cc_alzheim_n12mn0 cc_cncr_chronic_n12mn0;
run;
proc contents;
run;

/***************************************************************************/
/* merging chronic conditions variables with the index surgery data file
that also contains the Elixhauser comorbidities */
/***************************************************************************/

%macro mergecc(presurg=);

proc sql;
create table sur_fin.surgery_ids_last_&presurg.3(drop=bid_hrs2)
as select * from
sur_fin.surgery_ids_last_&presurg. a
left join
sur_int.chronic_21_&presurg._n0_0(rename=(bid_hrs_21=bid_hrs2)) b 
on (a.bid_hrs_21)=(b.bid_hrs2);
quit;

data sur_fin.surgery_ids_last_comor_&presurg.;
set sur_fin.surgery_ids_last_&presurg.3;
run;

%mend;

%mergecc(presurg=n6m);
%mergecc(presurg=n12m);

/* the above file contains just people who have had surgery, surgery data,
pre and post surgery hospital and snf data,  
elixhauser and chronic conditions and insurance data 

File names are:
sur_fin.surgery_ids_last_comor_n6m
sur_fin.surgery_ids_last_comor_n12m
*/

proc contents data=sur_fin.surgery_ids_last_comor_n6m;
run;

proc contents data=sur_fin.surgery_ids_last_comor_n12m;
run;


proc freq data=sur_fin.surgery_ids_last_comor_n6m;
table cc_:;
run;

proc freq data=sur_fin.surgery_ids_last_comor_n12m;
table cc_:;
run;



H="**add complications & mortality 60 days/1yr"
/*note-this needs work

/*start of MACRO */

/*Macro for all claims files except for medpar
Creates file source_meet_after_&name._2 which has the first claim after
1 year of surgery
*/
%macro other_post(days_start=,source=,name=);

/*Identify claims within certain time from procedure date defined when run macro*/
proc sql;
create table &source._meet_after_&name. as select a.*,b.procedure_date,b.is_admit_date
from medi.&source._2000_2012 a inner join
sur_fin.surgery_ids_last b
on trim(left(a.bid_hrs_21))=trim(left(b.bid_hrs_21))
and a.admit_date-b.procedure_date<=&days_start
and a.admit_date>=is_admit_date;
quit;
run;

data &source._meet_after_&name._1a;
set &source._meet_after_&name.;
format admit_date date9. disch_date date9.;
run;

proc sort data=&source._meet_after_&name._1a;
by bid_hrs_21 admit_date;
run;

data &source._meet_after_&name._2;
set &source._meet_after_&name._1a;
by bid_hrs_21;
rename admit_date = follow_up_dt_&name._ps;
&source=1;
run;
%mend;

/*Macro for medpar claims*/
%macro mp_post(days_start=,source=,name=);
%let source0=mp;

/*Identify claims within certain time from procedure date*/
proc sql;
create table &source._meet_after_&name. as select a.*,b.procedure_date,b.is_admit_date
from medi.&source0._2000_2012 a inner join
sur_fin.surgery_ids_last b
on trim(left(a.bid_hrs_21))=trim(left(b.bid_hrs_21)) 
and a.admit_date-b.procedure_date<=&days_start
and a.admit_date>=b.is_admit_date;
quit;
run;

data &source._meet_after_&name._1a;
set &source._meet_after_&name.;
format admit_date date9. disch_date date9.;
run;

proc sort data=&source._meet_after_&name._1a;
by bid_hrs_21 admit_date;
run;

data &source._meet_after_&name._2;
set &source._meet_after_&name._1a;
by bid_hrs_21;
rename DGNS_CD01=DGNSCD01;
rename DGNS_CD02=DGNSCD02;
rename DGNS_CD03=DGNSCD03;
rename DGNS_CD04=DGNSCD04;
rename DGNS_CD05=DGNSCD05;
rename DGNS_CD06=DGNSCD06;
rename DGNS_CD07=DGNSCD07;
rename DGNS_CD08=DGNSCD08;
rename DGNS_CD09=DGNSCD09;
rename DGNS_CD10=DGNSCD10;
rename DGNS_CD11=DGNSCD11;
rename DGNS_CD12=DGNSCD12;
rename DGNS_CD13=DGNSCD13;
rename DGNS_CD14=DGNSCD14;
rename DGNS_CD15=DGNSCD15;
rename DGNS_CD16=DGNSCD16;
rename DGNS_CD17=DGNSCD17;
rename DGNS_CD18=DGNSCD18;
rename DGNS_CD19=DGNSCD19;
rename DGNS_CD20=DGNSCD20;
rename DGNS_CD21=DGNSCD21;
rename DGNS_CD22=DGNSCD22;
rename DGNS_CD23=DGNSCD23;
rename DGNS_CD24=DGNSCD24;
rename DGNS_CD25=DGNSCD25;
&source=1;

run;

%mend;
/*Run macros to identify claims that are up to 60 days from surgery date*/
%mp_post(days_start=60,source=mp,name=60d );
%other_post(days_start=60,source=hh,name=60d );
%other_post(days_start=60,source=hs,name=60d );
%other_post(days_start=60,source=dm,name=60d );
%other_post(days_start=60,source=op,name=60d );
%other_post(days_start=60,source=pb,name=60d );

/*Run macros to identify claims that are up to 365 days from surgery date*/
%mp_post(days_start=365,source=mp,name=365d );
%other_post(days_start=365,source=hh,name=365d );
%other_post(days_start=365,source=hs,name=365d );
%other_post(days_start=365,source=dm,name=365d );
%other_post(days_start=365,source=op,name=365d );
%other_post(days_start=365,source=pb,name=365d );
data all_after_60d;
set mp_meet_after_60d_2 hh_meet_after_60d_2  hs_meet_after_60d_2  dm_meet_after_60d_2 
 op_meet_after_60d_2  pb_meet_after_60d_2;
run;

data all_after_365d;
set mp_meet_after_365d_2 hh_meet_after_365d_2  hs_meet_after_365d_2  dm_meet_after_365d_2 
 op_meet_after_365d_2  pb_meet_after_365d_2;
run;

data sur_int.compl_60d;
set all_after_60d;

dx_1=trim(left(DGNSCD01));
if dx_1~="" then do;

/*initialize complications variables*/
comp_uti=0;
comp_pe=0;
comp_inf=0;
comp_rf=0;
comp_mi=0;
comp_del=0;
comp_kf=0;
comp_any=0;
comp_deh=0;
comp_int=0;
comp_pne=0;
comp_strk=0;
comp_dvt=0;
comp_hmrg=0;
end;

array dx DGNSCD01-DGNSCD25;
do over dx;
/*UTI*/
if substr(dx,1,4)='5990' and comp_uti=0 
	then comp_uti=1;

/*PE*/
if substr(dx,1,4)='4151'
	 and comp_pe=0 
	then comp_pe=1;

/*post-op hemorrhage*/
if substr(dx,1,5)='99811'
	 and comp_hmrg=0 
	then comp_hmrg=1;

/*Stroke*/
if substr(dx,1,5)='43491'
	 and comp_strk=0 
	then comp_strk=1;

/*Internal*/
if substr(dx,1,4)='9983'
	 and comp_int=0 
	then comp_int=1;

/*Dehiscence*/
if (substr(dx,1,5)='99831'
	or substr(dx,1,5)='99832')
	 and comp_deh=0 
	then comp_deh=1;

/*Infection*/
if (substr(dx,1,4)='9985'
	or substr(dx,1,5)='99851'
	or substr(dx,1,5)='99859')
	 and comp_inf=0 
	then comp_inf=1;

/*Resp Failure*/
if substr(dx,1,5)='51881' and comp_rf=0
	then comp_rf=1;

/*MI*/
if substr(dx,1,3)=410
	and comp_mi=0 
	then comp_mi=1;

/*Delirium*/
if (substr(dx,1,4)='2930'
	or substr(dx,1,4)='2931')
	 and comp_del=0 
	then comp_del=1;

/*kidney failure*/
if (substr(dx,1,4)='5845'
	or substr(dx,1,4)='5846'
	or substr(dx,1,4)='5847'
	or substr(dx,1,4)='5848'
	or substr(dx,1,4)='5849')
	 and comp_kf=0 
	then comp_kf=1;

/*Pneumonia*/
if (substr(dx,1,3)='480'
	or substr(dx,1,3)='481'
	or substr(dx,1,3)='482'
	or substr(dx,1,3)='483'
	or substr(dx,1,3)='484'
	or substr(dx,1,3)='485'
	or substr(dx,1,3)='486')
	 and comp_pne=0 
	then comp_pne=1;

if (comp_uti=1  
	or comp_pe=1
	or comp_inf=1
	or comp_rf=1
	or comp_mi=1
	or comp_del=1
	or comp_kf=1
	or comp_deh=1
	or comp_int=1
	or comp_pne=1
	or comp_strk=1
	or comp_dvt=1
	or comp_hmrg=1)
	and comp_any=0
	then comp_any=1; 

end;
run;


proc export data=sur_int.compl_60d outfile="E:\data\surgery_hysterectomy\int_2012clms\all_after_60d.dta" replace; run;
proc export data=all_after_365d outfile="E:\data\surgery_hysterectomy\int_2012clms\all_after_365d.dta" replace; run;


H="identify first claim after 1yr post surgery"
/*Survival analysis requires an end date to be coded
For observations where the core interiew is within 1 year
of the surgery date, can we use a claim date to identify that the
beneficiary is alive at 1 year? */


/*start of MACRO */

/*Macro for all claims files except for medpar
Creates file source_meet_after_1yr_2 which has the first claim after
1 year of surgery
*/
%macro other_post(days_start=,source=);

/*Identify claims within certain time from procedure date defined when run macro*/
proc sql;
create table &source._meet_after_1yr as select a.*,b.procedure_date
from medi.&source._2000_2012 a inner join
sur_fin.surgery_ids_last b
on trim(left(a.bid_hrs_21))=trim(left(b.bid_hrs_21))
and &days_start<=a.admit_date-b.procedure_date;
quit;
run;

data &source._meet_after_1yr_1a;
set &source._meet_after_1yr;
format admit_date date9. disch_date date9.;
run;

proc sort data=&source._meet_after_1yr_1a;
by bid_hrs_21 admit_date;
run;

data &source._meet_after_1yr_2;
set &source._meet_after_1yr_1a(keep=bid_hrs_21 admit_date);
by bid_hrs_21;
if first.bid_hrs_21;
rename admit_date = follow_up_dt_1yr_ps;
run;
%mend;

/*Macro for medpar claims*/
%macro mp_post(days_start=,source=);
%let source0=mp;

/*Identify claims within certain time from procedure date*/
proc sql;
create table &source._meet_after_1yr as select a.*,b.procedure_date,
from medi.&source0._2000_2012 a inner join
sur_fin.surgery_ids_last b
on trim(left(a.bid_hrs_21))=trim(left(b.bid_hrs_21)) 
and &days_start<=a.admit_date-b.procedure_date;
quit;
run;

data &source._meet_after_1yr_1a;
set &source._meet_after_1yr;
format admit_date date9. disch_date date9.;
run;

proc sort data=&source._meet_after_1yr_1a;
by bid_hrs_21 admit_date;
run;

data &source._meet_after_1yr_2;
set &source._meet_after_1yr_1a(keep=bid_hrs_21 admit_date disch_date dschrgcd dstntncd);
by bid_hrs_21;
if first.bid_hrs_21;
run;

%mend;

/*Run macros to identify claims that are after 1 year from surgery date*/
%mp_post(days_start=366,source=mp );
%other_post(days_start=366,source=hh );
%other_post(days_start=366,source=hs );
%other_post(days_start=366,source=dm );
%other_post(days_start=366,source=op );
%other_post(days_start=366,source=pb );

/*combine to get follow up date at least 1 year post surgery to use in
survival analysis */

/*for medpar claims, create indicator for cases where discharge code indicates died*/
proc freq data=mp_meet_after_1yr_2;
table dschrgcd*dstntncd /missprint;
run;

data mp_after_1yr_3(keep=bid_hrs_21 follow_up_dt_1yr_ps died_post_1yr);
set mp_meet_after_1yr_2;
if dschrgcd='B' then died_post_1yr=1;
follow_up_dt_1yr_ps = disch_date;
run;

data all_after_1yr;
set mp_after_1yr_3 hh_meet_after_1yr_2  hs_meet_after_1yr_2  dm_meet_after_1yr_2 
 op_meet_after_1yr_2  pb_meet_after_1yr_2;
run;

proc sort data=all_after_1yr;
by bid_hrs_21 follow_up_dt_1yr_ps ;
run;

data sur_int.all_after_1yr_1;
set all_after_1yr;
by bid_hrs_21 ;
if first.bid_hrs_21 ;
run;

/*none of the medpar claims where the beneficiary died
got used in the final dataset with the claim right after 1 year post surgery*/
proc freq;
table died_post_1yr /missprint;
run;

/*merge in the follow up dates to the overall dataset*/
%macro mergefu(presurg=);

proc sql;
create table sur_fin.surgery_ids_last_comor_&presurg.2(drop=bid_hrs2 died_post_1yr )
as select * from
sur_fin.surgery_ids_last_comor_&presurg. a
left join
sur_int.all_after_1yr_1(rename=(bid_hrs_21=bid_hrs2)) b 
on (a.bid_hrs_21)=(b.bid_hrs2);
quit;

%mend;

%mergefu(presurg=n6m);
%mergefu(presurg=n12m);


H="bring in HRS-n1"


/****************************************************************/
/*Add HRS xwalk ID to the claims datasets
Creates 2 datasets, one with the 6 month cc and elix 
and one with 12 month cc and elix */
/****************************************************************/

/*HRS - CMS crosswalk initial processing*/
data crosswalk_1;
set medi.cmsxref2012;
keep bid_hrs_21 hhid pn hhidpn hhidnew pnnew;
/*create id variable as concat of hhid and pn*/
length hhidpn $9 hhidnew $6 pnnew $3;
hhidnew=trim(hhid);
pnnew=trim(pn);
hhidpn=hhidnew||pnnew;
run;

data crosswalk_1a;
set crosswalk_1(keep=bid_hrs_21 hhidpn);
run;

data crosswalk_2;
set crosswalk_1a;
bid_hrs=bid_hrs_21;
id=hhidpn;
drop hhidpn;
drop bid_hrs_21;
run;

proc sort data= crosswalk_2;
by bid_hrs;
run;

/*sort surgery information claims dataset so can merge in hrs xwalk id*/
proc sort data=sur_fin.surgery_ids_last_comor_n12m;
by bid_hrs_21;
run;

proc sort data=sur_fin.surgery_ids_last_comor_n6m;
by bid_hrs_21;
run;


/*bring in xwalk data - 12 month look back*/
proc sql;
create table surg_ids_xwalk_n12m as select
a.*,b.id from
sur_fin.surgery_ids_last_comor_n12m a
left join
crosswalk_2 b
on a.bid_hrs_21=b.bid_hrs;
quit;

/*check for missing xwalk ids*/
data check1;
set surg_ids_xwalk_n12m ;
if id='';
run;

/*bring in xwalk data - 6 month look back*/
proc sql;
create table surg_ids_xwalk_n6m as select
a.*,b.id from
sur_fin.surgery_ids_last_comor_n6m2 a
left join
crosswalk_2 b
on a.bid_hrs_21=b.bid_hrs;
quit;

/*check for missing xwalk ids*/
data check1;
set surg_ids_xwalk_n6m ;
if id='';
run;

/****************************************************************/
/*get the n1 (core interview before surgery) core*/
/****************************************************************/

/*get table of all core interviews for bids with surgery
where core interview done prior to the surgery date
908 interviews*/
proc sql;
create table r_n1_core_before_surg(drop=id)
as select b.*,b.id as r_id label="respondent's id"
 from surg_ids_xwalk_n12m a inner join
hrs_cln.core_00_to_12 b
  on a.id=b.id and a.procedure_date>b.c_ivw_date;
  quit;


proc sort data=r_n1_core_before_surg ;
by r_id c_ivw_date;
run;

data sur_int.r_n1_core_before_surg_1(compress=yes);
set  r_n1_core_before_surg;
run;

/*Dataset with just the core interview prior to surgery date
231 first core interviews identified*/
data resp_core_n1;
set r_n1_core_before_surg;
by r_id c_ivw_date;
if last.r_id;
run;

proc freq;
table core_year;
run;

/*re name the n1 core variables*/

*options macrogen mprint mlogic;
%macro rename2(lib,dsn,pre,first);
options pageno=1 nodate;
proc contents data=&lib..&dsn;
title "Before Renaming All Variables";
run;
proc sql noprint;
select nvar into :num_vars
from dictionary.tables
where libname="&LIB" and
memname="&DSN";
select distinct(name) into :var1-
:var%TRIM(%LEFT(&num_vars))
from dictionary.columns
where libname="&LIB" and
memname="&DSN" ;
quit;
run;
proc datasets library=&LIB;
modify &DSN;
rename
%do i=1 %to &num_vars;

&&var&i=&first.&&var&i.&&pre.
%end;
;
quit;
run;
options pageno=1 nodate;
proc contents data=&lib..&dsn;
title "After Renaming All Variables";
run;
%mend ;


/*creates dataset work.resp_core_n1 that just contains 
_n1 core interview (pre-surgery) with variables all renamed
with _n1 suffix
231 core interviews */
%rename2(WORK,RESP_CORE_N1,_n1,);


proc sql outobs=10;
select r_id_n1,c_ivw_date_n1 from RESP_CORE_N1;
quit;

/*rename id variable so can use to merge later*/
data RESP_CORE_N1;
set RESP_CORE_N1;
id=r_id_n1;
run;


/*check dataset, need all ids in resp_core_n1 to be in surgery xwalk id list
all 231 core interviews are in the surgery xwalk list*/
proc sql;
create table test1 as select *
from RESP_CORE_N1 where id in (select id from surg_ids_xwalk_n12m);
quit;


H="bring in HRS-n2"
/*bring in n2 core interview
n1 = core interview immediately before surgery
n2 = core interview before the n1 interview
*/

/*get all core interviews that are earlier than the n1 core interview
for those bids with a n1 core interview identified
*677 interviews*/
proc sql;
create table r_n2_core_before_surg(drop=id)
as select b.*,b.id as r_id label="respondent's id"
 from RESP_CORE_N1 a inner join
hrs_cln.core_00_to_12 b
  on a.id=b.id and a.c_ivw_date_n1>b.c_ivw_date;
  quit;

proc sort data=r_n2_core_before_surg ;
by r_id c_ivw_date;
run;

data sur_int.r_n2_core_before_surg_2(compress=yes);
set  r_n2_core_before_surg;
run;

/*Dataset with just the core interview prior to the n1 interview date
214 first core interviews identified*/
data resp_core_n2;
set r_n2_core_before_surg;
by r_id c_ivw_date;
if last.r_id;
run;

proc freq;
table core_year;
run;

/*re name the n2 core variables*/

/*creates dataset work.resp_core_n2 that just contains 
_n2 core interview (pre-surgery) with variables all renamed
with _n2 suffix
*** core interviews */
%rename2(WORK,RESP_CORE_N2,_n2,);


proc sql outobs=10;
select r_id_n2,c_ivw_date_n2 from RESP_CORE_N2;
quit;

/*rename id variable so can use to merge later*/
data RESP_CORE_N2;
set RESP_CORE_N2;
id=r_id_n2;
run;


/*check dataset, need all ids in resp_core_n1 to be in surgery xwalk id list
all 214 core interviews are in the surgery xwalk list*/
proc sql;
create table testn2 as select *
from RESP_CORE_N2 where id in (select id from surg_ids_xwalk_n12m);
quit;

H="bring in HRS-p1 & p2"

/*get the positive one core (core interview after surgery*/

/*gets all core interviews post surgery
645 interviews*/
proc sql;
create table p1_core_after_surg(drop=id)
as select a.id as r_id,b.*
 from surg_ids_xwalk_n12m a inner join
hrs_cln.core_00_to_12 b
  on a.id=b.id and a.procedure_date<b.c_ivw_date;
  quit;

proc sort data=p1_core_after_surg ;
by r_id c_ivw_date;
run;

/*just keep core interview immediately after surgery date
216 interviews*/
data core_p1;
set p1_core_after_surg;
by r_id c_ivw_date;
if first.r_id;
run;

/*creates file work.core_p1 of post-surgery core interviews
216 core interviews*/
%rename2(WORK,CORE_P1,_p1,);

/*rename id variable so can use it to merge later*/
data CORE_P1;
set CORE_P1;
id=r_id_p1;
run;


data core_pp1;
set p1_core_after_surg;
by r_id c_ivw_date;
if ~first.r_id;
run;

data core_p2;
set core_pp1;
by r_id c_ivw_date;
if first.r_id;
run;

%rename2(WORK,CORE_P2,_p2,);

/*rename id variable so can use it to merge later*/
data CORE_P2;
set CORE_P2;
id=r_id_p2;
run;




H="xxxbring in HRS-p2"
this is extra from the end of get p1, I just want to hold it for a short while
/*get interview date for p2 interview also to check
for end date for survival analysis*/
/*
proc sql;
create table p2_core_after_surg
as select a.id,a.c_ivw_date_p1,b.c_ivw_date
 from CORE_P1 a inner join
hrs_cln.core_00_to_12 b
  on a.id=b.id and a.c_ivw_date_p1<b.c_ivw_date;
  quit;

proc sort data=p2_core_after_surg;
by id c_ivw_date;
run;

data core_p2(drop=c_ivw_date_p1);
set p2_core_after_surg;
by id;
if first.id;
rename c_ivw_date=c_ivw_date_p2;
run;

H="bring in HRS restricted & exit"
/*merged with the exit data and restricted data

Results in final dataset to be analyzed:

E:\data\surgery_hysterectomy\final_data\surgery_final.dta*/

/*put the exit_restricted file also have the r_id*/

/*get exit dataset with interview date added*/
data exit_1;
set hrs_cln.exit_02_to_12_dt;
run;

/*pull restricted dataset 2012 version*/
data restricted;
set hrs_cln.restricted_v2012;
run;

/*Rename restricted variables with _e suffix*/
%rename2(WORK,RESTRICTED,_E,);

data RESTRICTED;
set RESTRICTED;
id=id_e;
run;

/*just keep cleaned variables from exit interview*/
data exit;
set exit_1(keep=ID EXIT_YEAR PROXY_EXIT FEMALE MARITAL MARRIED MARITAL_SEP MARITAL_DIV MARITAL_WID MARITAL_NEV
MARITAL_SD MARITAL_MISSING MEDICARE MEDICAREB MEDICAID CHAMPUS HMO MEDIGAP CATINSUR NHRES
HOSPICE FREQRELG CHILD GCHIL ALLCHIL RESCHIL RESCHIL_D RESSPOUSE HHM LIVEALONE LOCATION LOC_HOSP
ICU VENT DIALYSIS DEC_ALL DEC_LIM DEC_WHLD DEC_COMF DEC_CAT DEXP EOLDEC CAPACITY DURATION ADAPP
ADPROB DECMAKER LWILL LW_ALL LW_LIM LW_WHLD LW_COMF LW_CAT HCP DISCUSS ADVDIR EOLPLAN
ADL_BEDBOUND ADL_DR ADL_WK ADL_BH ADL_E ADL_TX ADL_T ADL_INDEX ADL_CAT ADL_INDEPENDENT
ADL_PARTIAL ADL_SEVERE IADL_MP IADL_GR IADL_PH IADL_RX IADL_M IADL_IND IADL_CAT IADL_INDEPENDENT
IADL_PARTIAL IADL_SEVERE CANCER_HRS LUNG_HRS HEART_HRS CHF_HRS STROKE_HRS MEMORY_HRS FALLS_HRS
INCONT_HRS PAIN_HRS HTN_HRS DM_HRS PSYCH_HRS ARTH_HRS COMOR_IN_HRS COMOR_C_HRS 
nhres_2yr_exit nh_stays_exit nh_nights_exit nh_ins_exit e_ivw_day e_ivw_month e_ivw_year 
e_ivw_date e_ivw_day_imp) ;
run;

/*add _x suffix to variable names in exit dataset*/
%rename2(WORK,EXIT,_x,);
data exit;
set exit;
id=id_x;
run;



H="merge HRS survey data & claims"
/*sort the individual hrs datasets pre-merge*/
proc sort data=restricted ;
by id;
run;

proc sort data=exit ;
by id;
run;

proc sort data=resp_core_n1 ;
by id;
run;

proc sort data=resp_core_n2 ;
by id;
run;

proc sort data=core_p1 ;
by id;
run;

proc sort data=core_p2 ;
by id;
run;


/*sort surgery information w/ xwalk id datasets by id*/
proc sort data=surg_ids_xwalk_n12m;
by id;
run;

proc sort data=surg_ids_xwalk_n6m;
by id;
run;


/*use macro to merge core n1, n2, p1 and exit hrs interviews to
surgery files
run 2x to get one for 12 m and 6 m comorbidity datasets
datasets are final_0_n12m and final_0_n6m*/
%macro add_hrs(nm);
/*bring in core n1 interview to surgery data*/
proc sql;
create table mg_&nm._core_n1 as select * from
surg_ids_xwalk_&nm. a left join
resp_core_n1 b
on a.id=b.id;
quit;

/*bring in core n2 interview to surgery data*/
proc sql;
create table mg_&nm._core_n2 as select * from
mg_&nm._core_n1 a left join
resp_core_n2 b
on a.id=b.id;
quit;


/*bring in core p1 interview to surgery data*/
proc sql;
create table mg_&nm._core_p1 as select * from
mg_&nm._core_n2 a left join
core_p1 b
on a.id=b.id;
quit;

/*bring in core p2 interview dates*/
proc sql;
create table mg_&nm._core_p2 as select * from
mg_&nm._core_p1 a left join
core_p2 b
on a.id=b.id;
quit;


/*bring in exit interview to surgery data*/
proc sql;
create table mg_&nm._exit as select * from
mg_&nm._core_p2 a left join
exit b
on a.id=b.id;
quit;

proc sort data=mg_&nm._exit out=final_0_&nm. nodupkey;
by id;
run;

%mend;

%add_hrs(nm=n12m);
%add_hrs(nm=n6m);


/*replace id with character id*/
data restricted_2;
set restricted;
length id_new $9 hhid_e $6 pn_e $3;
id_new=hhid_e||pn_e;
drop id;
rename id_new=id;
run;

/*bring in restricted HRS data */
proc sort data=restricted_2 nodupkey;
by id;
run;

%macro add_res(nm);
proc sql;
create table final_&nm. as select a.*,b.*
from final_0_&nm. a left join
restricted_2 b
on a.id=b.id;
quit;
%mend;

%add_res(nm=n12m);
%add_res(nm=n6m);

/*add additional variables and save final datasets*/

%macro add_vars(nm);
data final2_&nm.;
set final_&nm.;
days_surg_n1core=procedure_date-c_ivw_date_n1;
days_surg_n2core=procedure_date-c_ivw_date_n2;
days_surg_p1core=c_ivw_date_p1-procedure_date;
days_surg_p2core=c_ivw_date_p2-procedure_date;
days_surg_x=e_ivw_date_x-procedure_date;

ind_n1core=0;
if CORE_YEAR_n1 ~=. then ind_n1core=1;
ind_n2core=0;
if CORE_YEAR_n2 ~=. then ind_n2core=1;
ind_p1core=0;
if CORE_YEAR_p1 ~=. then ind_p1core=1;
ind_p2core=0;
if c_ivw_date_p2 ~=. then ind_p2core=1;
ind_exit=0;
if EXIT_YEAR_x ~=. then ind_exit=1;

em_urgent_admit=0;
if type_adm in (1,2) then em_urgent_admit=1;
label days_surg_n1core="days between surgery date and n1 core"
days_surg_n2core="days between surgery date and n2 core"
days_surg_p1core="days between surgery date and p1 core"
days_surg_p2core="days between surgery date and p2 core"
days_surg_x="days between surgery date and exit ivw"
ind_n1core="Indicator for core n1 interview"
ind_n2core="Indicator for core n2 interview"
ind_p1core="Indicator for core p1 interview"
ind_p2core="Indicator for core p2 interview"
ind_exit="Indicator for exit interview"
em_urgent_admit="ip admit=emergency or urgent"
procedure="surgery procedure code,in icd9 procedure"
procedure_date="surgery date"
surgery_meet="Laparotomy|gastric_ulcer|gas_volvulus|intest_resection|Colostomy|
abdom_hernia"
;
run;

proc freq;
table type_adm ind_n1core ind_n2core ind_p1core ind_p2core ind_exit;
run;

proc means;
var days_surg_n1core days_surg_n2core days_surg_p1core days_surg_p2core days_surg_x;
run;

proc sql;
create table surgery1_&nm. as select a.*,b.death_all
from final2_&nm. a left join
hrs_cln.death_date_2012 b
on a.id=b.id;
quit;

/* final dataset*/
data sur_fin.surgery_&nm.;
set surgery1_&nm.;
run;
%mend;

%add_vars(nm=n12m);
%add_vars(nm=n6m);


/*save as stata datasets for analysis and summary statistics*/
proc export data=sur_fin.surgery_n12m
outfile="E:\data\surgery_hysterectomy\final_2012clms\surgery_hysterectomy_final_n12m.dta"
replace;
run;

proc export data=sur_fin.surgery_n6m
outfile="E:\data\surgery_hysterectomy\final_2012clms\surgery_hysterectomy_final_n6m.dta"
replace;
run;






H="bring in dementia (not done)"
/*******************************************************************/
/* Dementia probabilities */
/*******************************************************************/
/*merge in the HRS dementia probabilities at each core year
Use dementia year - 1 to get the core year that the probability is based on*/
proc contents data=hrs_dem.pdem_withvarnames;
run;

data dem_1;
set hrs_dem.pdem_withvarnames;
core_year_imp = prediction_year-1;
/*create id variable as concat of hhid and pn*/
length id $9 hhid $6 pn $3;
id=hhid||pn;
run;

/*dementia probablility 1998-2006 core years*/
proc freq;
table core_year_imp;
run;

proc sort data=dem_1 nodupkey;
by id core_year_imp;
run;

proc sort data=resp_core_n1 nodupkey;
by id core_year;
run;

/*n1 core interviews*/
proc sql;
create table resp_dem_core_n1
as select a.*,b.prob_dementia 
from resp_core_n1 a 
left join dem_1 b
on a.id=b.id and a.core_year=b.core_year_imp;
quit;

proc sort data=resp_core_n2 nodupkey;
by id core_year;
run;

/*n2 core interviews*/
proc sql;
create table resp_dem_core_n2
as select a.*,b.prob_dementia 
from resp_core_n2 a 
left join dem_1 b
on a.id=b.id and a.core_year=b.core_year_imp;
quit;




H="xxxxx"


H="add in those from pb"
/*Identify claims with particular procedure codes present from the
pb claims file

Final file created: sur_int.pb_last_surgery_date
List of index surgery  by beneficiary id

Keep additional information needed about this claim / surgery:
1. Complications (type of complications? can look to original surgery for it)
2. LOS
3. Discharge status (to home, SNF, etc)
4. Admission type (to track if ER admission or not)
*/
%let source0=pb;

proc sort data=medi.&source0._2000_2012 ;
by BID_HRS_21;
run;

/*Create claim id for full set of ip claims 2000-2012*/
/*sequential, unique ID for each claim in this file*/
data sur_int.&source0._2000_2012_claim_id;
set medi.&source0._2000_2012;
	clm_id=_N_;
run;

/*check no duplicates of new claim id*/
proc sort data=sur_int.&source0._2000_2012_claim_id nodupkey ;
by clm_id;
run;

proc contents order=casecollate data=sur_int.&source0._2000_2012_claim_id;
run;


proc sql;
create table &source0._meet as select BID_hrs_21,
hcpscd01, hcpscd02, hcpscd03, hcpscd04, hcpscd05, hcpscd06, hcpscd07, hcpscd08, hcpscd09, hcpscd10, hcpscd11, hcpscd12, hcpscd13,
clm_id,
admit_date,
disch_date
from sur_int.&source0._2000_2012_claim_id ;
quit;

proc contents data=sur_int.&source0._2000_2012_claim_id(keep=hcps:);
run;

proc contents data=medi.pb_2000_2012; run;
/*creates table with each procedure as a separate row*/

data proc_long(keep=BID_hrs_21 procedure claim_start_date
	 admit_date disch_date);
set pb_meet;
array list hcpscd01-hcpscd13;
do over list;
if list~="" then do;
procedure=list;
claim_start_date=mdy(substr(trim(left(from_date)),5,2),substr(trim(left(from_date)),7,2),substr(trim(left(from_date)),1,4));
output;
end;
end;
format claim_start_date date10.;
run;

/*rename admit date and discharge date to be is_ for index surgery
This way can use this index surgery information to check against
claims lists pre- and post-surgery*/
data proc_long2(rename=(admit_date=is_admit_date) rename=(disch_date=is_disch_date));
set proc_long;
format admit_date date10.;
format disch_date date10.;
run; 

/* Identify surgeries that meet the criteria
Indicator variable surgery_meet = 1 if yes, include in sample 
1700 surgeries meet the criteria*/
data surgery_meet;
set proc_long2;
if length(compress(procedure))>0 then do;

if procedure+0 in (58150 58152 58180 58200 
	58210 58240 58951 58953 58954 58956 58541 58542 
	58543 58544 58548 58550	58552 58553 58554 58570 
	58571 58572 58573 58260	58262 58263 58267 58270 
	58275 58280 58285 58290	58291 58292 58293 58294) 
	then surgery_meet=1;


end;
/*only keep observations in work.surgery_meet that meet criteria*/
if surgery_meet then output;

run;

proc freq data=surgery_meet;
table procedure;
run;

/*****************************************************************************/
/*Look at number of qualifying procedures per bid*/
/*****************************************************************************/
/*Identify the most recent surgery from the list that meet the criteria for each 
beneficiary id*/
proc sort data=surgery_meet;
by bid_hrs_21;
run;

/*get count of qualifying procedures per beneficary, regardless of surgery dates
so a beneficiary can have more than 1 surgery on the same date*/
data surg_meet_count1;
set surgery_meet;
by bid_hrs_21;
	if first.bid_hrs_21 then pro_count=1;
	else pro_count+1;
run;

data surg_meet_count2(rename=pro_count=pro_cnt_all);
set surg_meet_count1(keep=bid_hrs_21 pro_count);
by bid_hrs_21;
if last.bid_hrs_21;
label pro_count="Procedure count, all qualifying procedures";
run;

/*now get list of surgeries on seperate dates*/
proc sort data=surgery_meet out=surg_meet_count3 nodupkey;
by bid_hrs_21 claim_start_date;
run;

data surg_meet_count4;
set surg_meet_count3;
by bid_hrs_21;
	if first.bid_hrs_21 then pro_count=1;
	else pro_count+1;
run;


data surg_meet_count5(rename=pro_count=pro_cnt_date);
set surg_meet_count4(keep=bid_hrs_21 pro_count);
by bid_hrs_21;
if last.bid_hrs_21;
label pro_count="Procedure count, only count 1 per procedure date";
run;

/*finally with separate medicare claims*/
proc sort data=surgery_meet out=surg_meet_count6 nodupkey;
by bid_hrs_21;
run;

data surg_meet_count7;
set surg_meet_count6;
by bid_hrs_21;
	if first.bid_hrs_21 then pro_count=1;
	else pro_count+1;
run;

data surg_meet_count8(rename=pro_count=pro_cnt_clm);
set surg_meet_count7(keep=bid_hrs_21 pro_count);
by bid_hrs_21;
if last.bid_hrs_21;
label pro_count="Procedure count, only count 1 per claim";
run;

ods rtf body='E:\data\surgery_hysterectomy\logs\pb_Procedure_counts.rtf';

title "Count of qualifying procedures, including multiple surgeries on the same date";
proc freq data=surg_meet_count2; table pro_cnt_all; run;

title "Count of qualifying procedures with separate procedure dates";
proc freq data=surg_meet_count5; table pro_cnt_date; run;

title "Count of qualifying procedures with separate Medicare claims";
proc freq data=surg_meet_count8; table pro_cnt_clm; run;

ods rtf close;

/*final file list of index surgery by bid
314 beneficiaries have index surgery identified*/
data pb_last_surgery_date_1;
set surgery_meet ;
by bid_hrs_21 claim_start_date ;
if last.bid_hrs_21;
run;

/*now merge in procedure counts so can carry through dataset*/
data counts;
merge surg_meet_count2 surg_meet_count5 surg_meet_count8;
by bid_hrs_21;
run;

proc freq; table pro_cnt_all pro_cnt_date pro_cnt_clm; run;

proc sql;
create table sur_int.pb_last_surgery_date as select a.*,b.pro_cnt_all,b.pro_cnt_date,b.pro_cnt_clm from
pb_last_surgery_date_1 a left join
counts b
on a.bid_hrs_21=b.bid_hrs_21;
quit;




H="pb check for mc parts a&b"
/*
last_surgery_date
to have part a part b in the last 6m, and no hmo
Use mc denominator file to determine insurance status*/


/*sort denominator file, remove duplicate entries on id and year*/
proc sort data=medi.dn_2000_2012 out=dn_2000_20122  nodupkey;
by bid_hrs_21 year;
run;

/*latest surgery year variable defined*/
data r_sp;
set sur_int.pb_last_surgery_date;
r_year=year(procedure_date);
run;

/*pull medicare ab status and hmo status variables from dn file
for latest surgery year from above*/
proc sql;
create table dn_surg_y as select
a.*,b.buyin12,b.year,b.HMOIND12
from r_sp a inner join
dn_2000_20122 b
on trim(left(a.bid_hrs_21))=trim(left(b.bid_hrs_21))
and a.r_year=b.year;
quit;

/*check frequency for surgery years*/
proc freq data=dn_surg_y;
table r_year;
run;
/*243 surgeries that meet criteria with denominator data*/
proc sql;
select count(distinct bid_hrs_21) from dn_surg_y;
quit;

/* Trim buyin and hmo variables to only reflect time before the surgery */
data dn_surg_y2;
set dn_surg_y;
surg_month=month(procedure_date);
if length(trim(left(buyin12)))=12 and surg_month>0 then do;
buyin_sy=substr(trim(left(buyin12)),1,surg_month);
hmo_sy=substr(trim(left(HMOIND12)),1,surg_month);
end;
else do;
buyin_sy=trim(left(buyin12));
hmo_sy=trim(left(HMOIND12));
end;
run;
proc means n;
var  surg_month;
run;

/*Look at year prior to surgery to get records of complete 12 months prior to surgery
only have the -1 year dn file
If surgery was within 1 year or 6 months of Jan 2000, then get null for buyin_ vars*/
proc sql;
create table dn_surg_y_bef as select
a.bid_hrs_21,a.year as surg_year,b.year as surg_year_bef,b.year,b.buyin12,b.HMOIND12
from dn_surg_y a inner join
dn_2000_20122 b
on trim(left(a.bid_hrs_21))=trim(left(b.bid_hrs_21))
and 0<a.year-b.year<=1 order by bid_hrs_21,year;
quit;

proc sql;
create table all_insurance as select a.*,b.buyin12 as buyin_bef,b.HMOIND12 as hmo_bef from
dn_surg_y2 a
left join
dn_surg_y_bef b
on trim(left(a.bid_hrs_21))=trim(left(b.bid_hrs_21));
quit;

/*merge surgery year and year before surgery buy-in and hmo variables
Trim so the final variable _1y shows 12 months pre-surgery
Variable _6m is 6 months pre-surgery
Note: indicator variables for parts a and b and hmo are null if don't
have information for full 12 or 6 months pre-surgery*/
data all_insurance2;
set all_insurance;
buyin_2y=trim(left(buyin_bef))||trim(left(buyin_sy));
hmo_2y=trim(left(hmo_bef))||trim(left(hmo_sy));

/*create 12 month variables*/
buyin_2y_r=reverse(trim(buyin_2y));
hmo_2y_r=reverse(trim(hmo_2y));

if length(buyin_2y_r)>11 then buyin_1y_r=substr(trim(left(buyin_2y)),1,12);
if length(hmo_2y_r)>11 then hmo_1y_r=substr(trim(left(hmo_2y)),1,12);

if length(buyin_2y_r)<12 then buyin_1y_r="";
if length(hmo_2y_r)<12 then hmo_1y_r="";

buyin_1y=reverse(trim(buyin_1y_r));
hmo_1y=reverse(trim(hmo_1y_r));

/*create indicator variable for mc coverage 0=no, 1=yes*/
if length(buyin_1y)=12 then do;
if indexc(buyin_1y,"0","1","2","A","B") then part_ab_1y=0;
if indexc(buyin_1y,"0","1","2","A","B")=0 then part_ab_1y=1;
end;
/*create indicator variable for hmo coverage 0=no, 1=yes*/
if length(hmo_1y)=12 then do;
if index(hmo_1y,"00000000000") then hmo_d_1y=0;
if index(hmo_1y,"00000000000")=0 then hmo_d_1y=1;
end;

/*create 6 month variable*/
if length(buyin_2y_r)>5 then buyin_6m_r=substr(trim(left(buyin_2y)),1,6);
if length(hmo_2y_r)>5 then hmo_6m_r=substr(trim(left(hmo_2y)),1,6);

if length(buyin_2y_r)<6 then buyin_6m_r="";
if length(hmo_2y_r)<6 then hmo_6m_r="";

buyin_6m=reverse(trim(buyin_6m_r));
hmo_6m=reverse(trim(hmo_6m_r));

/*create indicator variable for mc coverage 6 mo. 0=no, 1=yes*/
if length(buyin_6m)=6 then do;
if indexc(buyin_6m,"0","1","2","A","B") then part_ab_6m=0;
if indexc(buyin_6m,"0","1","2","A","B")=0 then part_ab_6m=1;
end;
if length(hmo_6m)=6 then do;
if index(hmo_6m,"00000") then hmo_d_6m=0;
if index(hmo_6m,"00000")=0 then hmo_d_6m=1;
end;

run;

/*25 (9 missing=34) observations were within 6months of Jan. 2000 so don't have 6 months pre-surgery data*/
proc freq;
table part_ab_6m*hmo_d_6m;
run;

/*20 (23 missing=43) observations were within 12months of Jan. 2000 so don't have 12 months pre-surgery data*/
proc freq;
table part_ab_1y*hmo_d_1y;
run;

/*bring in gender, reason for entitlement, dob, esrd indicator
 from claims denominator file*/
proc sql;
create table all_ins_gender as select a.*,b.sex,b.CREC,b.BENE_DOB,b.esrd_ind, b.DEATH_DT from
all_insurance2 a
left join dn_2000_20122 b
on trim(left(a.bid_hrs_21))=trim(left(b.bid_hrs_21))
and a.year=b.year;
quit;

proc freq data=all_ins_gender;
table sex CREC esrd_ind CREC*esrd_ind /missprint;
run;

proc contents order=casecollate data=all_ins_gender;
run;

data surgery_ids_last_1(drop=dgnscd01-dgnscd25 ad_dgns BUYIN12 HMOIND12 
surg_month year buyin_1y_r buyin_2y buyin_2y_r r_year buyin_6m_r 
buyin_bef buyin_sy hmo_1y_r hmo_2y hmo_2y_r hmo_6m_r hmo_bef hmo_sy);
set all_ins_gender;
rename sex=claims_sex;
rename bene_dob=claims_dob;
rename esrd_ind=claims_esrd_ind;
rename DEATH_DT=claims_dod;
run;

proc freq data=surgery_ids_last_1;
table claims_dod /missprint;
run;

/*deal with claims dod missing values that are coded as "00000000"
and change format for dob and dod to dates*/
data surgery_ids_last_2;
set surgery_ids_last_1;
if claims_dod=00000000 then claims_dod=.;
claims_dob2=input(claims_dob,yymmdd8.);
claims_dod2=input(claims_dod,yymmdd8.);
run;

proc freq;
table claims_dod2 /missprint;
run;

data sur_fin.pb_surgery_ids_last;
set surgery_ids_last_2;
drop claims_dob claims_dod;
format claims_dob2 date10. claims_dod2 date10.;
label claims_dob2="Beneficiary dob from claims" claims_dod2="Beneficiary dod from claims";
run;

H="xxxadd in those from op"
/*Identify claims with particular procedure codes present from the
op claims file

Final file created: sur_int.op_last_surgery_date
List of index surgery  by beneficiary id

Keep additional information needed about this claim / surgery:
1. Complications (type of complications? can look to original surgery for it)
2. LOS
3. Discharge status (to home, SNF, etc)
4. Admission type (to track if ER admission or not)
*/
%let source0=op;

proc sort data=medi.&source0._2000_2012 ;
by BID_HRS_21;
run;

/*Create claim id for full set of ip claims 2000-2012*/
/*sequential, unique ID for each claim in this file*/
data sur_int.&source0._2000_2012_claim_id;
set medi.&source0._2000_2012;
	clm_id=_N_;
run;

/*check no duplicates of new claim id*/
proc sort data=sur_int.&source0._2000_2012_claim_id nodupkey ;
by clm_id;
run;

proc contents order=casecollate data=sur_int.&source0._2000_2012_claim_id;
run;


proc sql;
create table &source0._meet as select BID_hrs_21,
hcpscd01, hcpscd02, hcpscd03, hcpscd04, hcpscd05, hcpscd06, hcpscd07, hcpscd08, hcpscd09, hcpscd10, hcpscd11, hcpscd12, hcpscd13,
clm_id,
admit_date,
disch_date
from sur_int.&source0._2000_2012_claim_id ;
quit;

proc contents data=sur_int.&source0._2000_2012_claim_id(keep=hcps:);
run;

proc contents data=medi.op_2000_2012; run;
/*creates table with each procedure as a separate row*/

data proc_long(keep=BID_hrs_21 procedure claim_start_date
	 admit_date disch_date);
set op_meet;
array list hcpscd01-hcpscd13;
do over list;
if list~="" then do;
procedure=list;
claim_start_date=mdy(substr(trim(left(from_date)),5,2),substr(trim(left(from_date)),7,2),substr(trim(left(from_date)),1,4));
output;
end;
end;
format claim_start_date date10.;
run;

/*rename admit date and discharge date to be is_ for index surgery
This way can use this index surgery information to check against
claims lists pre- and post-surgery*/
data proc_long2(rename=(admit_date=is_admit_date) rename=(disch_date=is_disch_date));
set proc_long;
format admit_date date10.;
format disch_date date10.;
run; 

/* Identify surgeries that meet the criteria
Indicator variable surgery_meet = 1 if yes, include in sample 
1700 surgeries meet the criteria*/
data surgery_meet;
set proc_long2;
if length(compress(procedure))>0 then do;

if procedure+0 in (58150 58152 58180 58200 
	58210 58240 58951 58953 58954 58956 58541 58542 
	58543 58544 58548 58550	58552 58553 58554 58570 
	58571 58572 58573 58260	58262 58263 58267 58270 
	58275 58280 58285 58290	58291 58292 58293 58294) 
	then surgery_meet=1;


end;
/*only keep observations in work.surgery_meet that meet criteria*/
if surgery_meet then output;

run;

proc freq data=surgery_meet;
table procedure;
run;

/*****************************************************************************/
/*Look at number of qualifying procedures per bid*/
/*****************************************************************************/
/*Identify the most recent surgery from the list that meet the criteria for each 
beneficiary id*/
proc sort data=surgery_meet;
by bid_hrs_21;
run;

/*get count of qualifying procedures per beneficary, regardless of surgery dates
so a beneficiary can have more than 1 surgery on the same date*/
data surg_meet_count1;
set surgery_meet;
by bid_hrs_21;
	if first.bid_hrs_21 then pro_count=1;
	else pro_count+1;
run;

data surg_meet_count2(rename=pro_count=pro_cnt_all);
set surg_meet_count1(keep=bid_hrs_21 pro_count);
by bid_hrs_21;
if last.bid_hrs_21;
label pro_count="Procedure count, all qualifying procedures";
run;

/*now get list of surgeries on seperate dates*/
proc sort data=surgery_meet out=surg_meet_count3 nodupkey;
by bid_hrs_21 claim_start_date;
run;

data surg_meet_count4;
set surg_meet_count3;
by bid_hrs_21;
	if first.bid_hrs_21 then pro_count=1;
	else pro_count+1;
run;


data surg_meet_count5(rename=pro_count=pro_cnt_date);
set surg_meet_count4(keep=bid_hrs_21 pro_count);
by bid_hrs_21;
if last.bid_hrs_21;
label pro_count="Procedure count, only count 1 per procedure date";
run;

/*finally with separate medicare claims*/
proc sort data=surgery_meet out=surg_meet_count6 nodupkey;
by bid_hrs_21;
run;

data surg_meet_count7;
set surg_meet_count6;
by bid_hrs_21;
	if first.bid_hrs_21 then pro_count=1;
	else pro_count+1;
run;

data surg_meet_count8(rename=pro_count=pro_cnt_clm);
set surg_meet_count7(keep=bid_hrs_21 pro_count);
by bid_hrs_21;
if last.bid_hrs_21;
label pro_count="Procedure count, only count 1 per claim";
run;

ods rtf body='E:\data\surgery_hysterectomy\logs\op_Procedure_counts.rtf';

title "Count of qualifying procedures, including multiple surgeries on the same date";
proc freq data=surg_meet_count2; table pro_cnt_all; run;

title "Count of qualifying procedures with separate procedure dates";
proc freq data=surg_meet_count5; table pro_cnt_date; run;

title "Count of qualifying procedures with separate Medicare claims";
proc freq data=surg_meet_count8; table pro_cnt_clm; run;

ods rtf close;

/*final file list of index surgery by bid
314 beneficiaries have index surgery identified*/
data op_last_surgery_date_1;
set surgery_meet ;
by bid_hrs_21 claim_start_date ;
if last.bid_hrs_21;
run;

/*now merge in procedure counts so can carry through dataset*/
data counts;
merge surg_meet_count2 surg_meet_count5 surg_meet_count8;
by bid_hrs_21;
run;

proc freq; table pro_cnt_all pro_cnt_date pro_cnt_clm; run;

proc sql;
create table sur_int.op_last_surgery_date as select a.*,b.pro_cnt_all,b.pro_cnt_date,b.pro_cnt_clm from
op_last_surgery_date_1 a left join
counts b
on a.bid_hrs_21=b.bid_hrs_21;
quit;




H="get malignancy dx "

/*Pull stata for all claims for now.  */

/*proc export data=medi.mp_2000_2012 outfile="E:\data\surgery_hysterectomy\int_2012clms\mp_2000_2012.dta" replace; run;

proc export data=medi.ip_2000_2012 outfile="E:\data\surgery_hysterectomy\int_2012clms\ip_2000_2012.dta" replace; run;

proc export data=medi.pb_2000_2012 outfile="E:\data\surgery_hysterectomy\int_2012clms\pb_2000_2012.dta" replace; run;

proc export data=medi.dm_2000_2012 outfile="E:\data\surgery_hysterectomy\int_2012clms\dm_2000_2012.dta" replace; run;

proc export data=medi.hh_2000_2012 outfile="E:\data\surgery_hysterectomy\int_2012clms\hh_2000_2012.dta" replace; run;

proc export data=medi.dn_2000_2012 outfile="E:\data\surgery_hysterectomy\int_2012clms\dn_2000_2012.dta" replace; run;

proc export data=medi.hs_2000_2012 outfile="E:\data\surgery_hysterectomy\int_2012clms\hs_2000_2012.dta" replace; run;

proc export data=medi.op_2000_2012 outfile="E:\data\surgery_hysterectomy\int_2012clms\op_2000_2012.dta" replace; run;



*/




capture log close

clear all

set more off

local logpath E:\data\surgery_hysterectomy\logs
local datapath E:\data\surgery_hysterectomy\final_2012clms
local datapath2 E:\data\surgery_hysterectomy\int_2012clms


log using "`logpath'\9_retrieval_of_malignancy_dx_60days.txt", text replace

cd "`datapath2'"

use "`datapath'\surgery_hysterectomy_final_n12m.dta"

keep procedure_date bid_hrs_21 is_admit_date
gen malignancy=0
gen mal_uc=0
gen mal_oc=0
gen mal_cc=0
gen mal_ppc=0
gen dx_mal=""

local claims ip op sn hs hh  
 
local diag pdgns_cd dgnscd01 dgnscd02 dgnscd03 dgnscd04 dgnscd05 dgnscd06 dgnscd07 ///
dgnscd08 dgnscd09 dgnscd10 dgnscd11 dgnscd12 dgnscd13 dgnscd14 dgnscd15 dgnscd16 ///
dgnscd17 dgnscd18 dgnscd19 dgnscd20 dgnscd21 dgnscd22 dgnscd23 dgnscd24 dgnscd25 ///


local diag2 pdgns_cd dgnscd01 dgnscd02 dgnscd03 dgnscd04 dgnscd05 dgnscd06 dgnscd07 ///
dgnscd08 dgnscd09 dgnscd10 dgnscd11 dgnscd12 

merge 1:m bid_hrs_21 using "all_after_60d", keep(match master) keepusing(pdgns_cd dgns* follow comp*)

foreach c in uti pe inf rf mi del kf deh int pne strk dvt hmrg any {
	egen _`c'=max(comp_`c'), by(bid_hrs_21)
	replace comp_`c'=_`c'
}


	


foreach x of local diag {
	foreach n in "179" "182" "1820" "1821" "1828" {
		replace malignancy=1 if `x'=="`n'"
		replace mal_uc=1 if `x'=="`n'"
		replace dx_mal="`n'" if `x'=="`n'"
}
	foreach n in "183" "1830" "1832" "1833" "1834" "1835" "1838" "1839" {
		replace malignancy=1 if `x'=="`n'"
		replace mal_oc=1 if `x'=="`n'"
		replace dx_mal="`n'" if `x'=="`n'"
}	
		
	foreach n in "180" "1801" "1808" "1809" {
		replace malignancy=1 if `x'=="`n'"
		replace mal_cc=1 if `x'=="`n'"
		replace dx_mal="`n'" if `x'=="`n'"
}	
		
	foreach n in "158" "1580" "1588" "1589" {
		replace malignancy=1 if `x'=="`n'"
		replace mal_ppc=1 if `x'=="`n'"
		replace dx_mal="`n'" if `x'=="`n'"
}
}


egen uc=max(mal_uc), by(bid)
egen oc=max(mal_oc), by(bid)
egen cc=max(mal_cc), by(bid)
egen ppc=max(mal_ppc), by(bid)

foreach x in uc oc cc ppc {
replace mal_`x' = `x' if mal_`x'==0
replace malignancy=1 if mal_`x'==1
}
*rename admit_date mal_admit_date
keep bid_hrs_21 procedure_date mal* *admit_date comp*
duplicates drop bid_hrs_21 mal*, force


gen mal_type = 1 if mal_uc==1 
replace mal_type=2 if mal_oc==1 
replace mal_type=3 if mal_cc==1 
replace mal_type=4 if mal_ppc==1
replace mal_type=5 if mal_uc+mal_oc+mal_cc+mal_ppc>1

label define maltype 1 "Uterine Cancer" 2 "Ovarian/Admenxal Cancer" ///
3 "Cervical Cancer" 4 "Primary Peritoneal Cancer" 5 "Multiple Cancer Diagnoses"

label values mal_type maltype

duplicates tag bid_hrs_21 mal_*, gen(dup)

drop if dup!=0 & mali==0

keep bid_hrs_21 procedure_date mal* *admit_date comp*

duplicates drop bid_hrs_21 mal_uc mal_oc mal_cc mal_ppc mal_type, force

merge 1:m bid_hrs_21 using `datapath2'\all_after_365d, keepusing(mp op hh hs pb follow dm ssl pdgn dgnsc*)

gen proc_to_admit=follow-procedure_date



foreach i in 60 365 {
	by bid_hrs_21, sort: egen _hosp_adm_p`i'd=total(mp) if ssl!="N" & proc_to_admit>0 & proc_to_admit<=`i'
	by bid_hrs_21, sort: egen _snf_adm_p`i'd=total(mp) if ssl=="N" & proc_to_admit>0 & proc_to_admit<=`i' 
	by bid_hrs_21, sort: egen _hs_clms_p`i'd=total(hs) if proc_to_admit>0 & proc_to_admit<=`i'
	replace _hosp_adm_p`i'=0 if _hosp_adm_p`i'==.
	replace _snf_adm_p`i'd=0 if _snf_adm_p`i'd==.
	replace _hs_clms_p`i'd=0 if _hs_clms_p`i'd==.
	by bid_hrs_21, sort: egen hosp_adm_p`i'd=max(_hosp_adm_p`i'd) 
	by bid_hrs_21, sort: egen snf_adm_p`i'd=max(_snf_adm_p`i'd) 
	by bid_hrs_21, sort: egen hs_clms_p`i'd=max(_hs_clms_p`i'd) 

}


gen oneyr_malignancy=0
gen oneyr_mal_uc=0
gen oneyr_dx_mal=""
gen oneyr_mal_oc=0
gen oneyr_mal_cc=0
gen oneyr_mal_ppc=0

foreach x of local diag {
	foreach n in "179" "182" "1820" "1821" "1828" {
		replace oneyr_malignancy=1 if `x'=="`n'" & proc_to_admit>60
		replace oneyr_mal_uc=1 if `x'=="`n'" & proc_to_admit>60
		replace oneyr_dx_mal="`n'" if `x'=="`n'" & proc_to_admit>60
}
	foreach n in "183" "1830" "1832" "1833" "1834" "1835" "1838" "1839" {
		replace oneyr_malignancy=1 if `x'=="`n'" & proc_to_admit>60
		replace oneyr_mal_oc=1 if `x'=="`n'" & proc_to_admit>60
		replace oneyr_dx_mal="`n'" if `x'=="`n'" & proc_to_admit>60
}	
		
	foreach n in "180" "1801" "1808" "1809" {
		replace oneyr_malignancy=1 if `x'=="`n'" & proc_to_admit>60
		replace oneyr_mal_cc=1 if `x'=="`n'" & proc_to_admit>60
		replace oneyr_dx_mal="`n'" if `x'=="`n'" & proc_to_admit>60
}	
		
	foreach n in "158" "1580" "1588" "1589" {
		replace oneyr_malignancy=1 if `x'=="`n'" & proc_to_admit>60
		replace oneyr_mal_ppc=1 if `x'=="`n'" & proc_to_admit>60
		replace oneyr_dx_mal="`n'" if `x'=="`n'" & proc_to_admit>60
}
}

egen uc=max(oneyr_mal_uc), by(bid)
egen oc=max(oneyr_mal_oc), by(bid)
egen cc=max(oneyr_mal_cc), by(bid)
egen ppc=max(oneyr_mal_ppc), by(bid)

foreach x in uc oc cc ppc {
replace oneyr_mal_`x' = `x' if oneyr_mal_`x'==0
replace oneyr_malignancy=1 if oneyr_mal_`x'==1
}




drop sslssnf follow_up_dt_365d_ps mp hh hs dm op pb _merge proc_to_admit ///
_hosp_adm_p60d _snf_adm_p60d _hs_clms_p60d _hosp_adm_p365d _snf_adm_p365d ///
_hs_clms_p365d pdgn dgn* uc oc cc ppc oneyr_dx

duplicates drop


save "`datapath'\surgery_hysterectomy_malignancy_dx.dta", replace

use "`datapath'\surgery_hysterectomy_final_n12m.dta"

rename comp_* is_comp_*

merge 1:1 bid_hrs_21 using "`datapath'\surgery_hysterectomy_malignancy_dx.dta"

save "`datapath'\surgery_hysterectomy_final_n12m_dx.dta.dta", replace


/*
capture log close

clear all

set more off

local logpath E:\data\surgery_hysterectomy\logs
local datapath E:\data\surgery_hysterectomy\final_2012clms
local datapath2 E:\data\surgery_hysterectomy\int_2012clms


log using "`logpath'\9_retrieval_of_malignancy_dx_60days.txt", text replace

cd "`datapath2'"

use "`datapath'\surgery_hysterectomy_final_n12m.dta"

keep procedure_date bid_hrs_21 is_admit_date
gen malignancy=0
gen mal_uc=0
gen mal_oc=0
gen mal_cc=0
gen mal_ppc=0

local claims ip op sn hs hh  
 
local diag pdgns_cd dgnscd01 dgnscd02 dgnscd03 dgnscd04 dgnscd05 dgnscd06 dgnscd07 ///
dgnscd08 dgnscd09 dgnscd10 dgnscd11 dgnscd12 dgnscd13 dgnscd14 dgnscd15 dgnscd16 ///
dgnscd17 dgnscd18 dgnscd19 dgnscd20 dgnscd21 dgnscd22 dgnscd23 dgnscd24 dgnscd25

local diag2 pdgns_cd dgnscd01 dgnscd02 dgnscd03 dgnscd04 dgnscd05 dgnscd06 dgnscd07 ///
dgnscd08 dgnscd09 dgnscd10 dgnscd11 dgnscd12 

foreach c of local claims {
merge 1:m bid_hrs_21 using "`c'_2000_2012.dta", keep(match master) keepusing(pdgns_cd dgnscd* admit_date)

duplicates tag bid_hrs_21, gen(dup)
format admit_date %td

if admit_date<=procedure_date+60 & admit_date>=is_admit_date {
	foreach x of local diag {
		foreach n in "179" "182" "1820" "1821" "1828" {
			replace malignancy=1 if `x'=="`n'"
			replace mal_uc=1 if `x'=="`n'"
}
		foreach n in "183" "1830" "1832" "1833" "1834" "1835" "1838" "1839" {
			replace malignancy=1 if `x'=="`n'"
			replace mal_oc=1 if `x'=="`n'"
}	
		
		foreach n in "180" "1801" "1808" "1809" {
			replace malignancy=1 if `x'=="`n'"
			replace mal_cc=1 if `x'=="`n'"
}	
		
		foreach n in "158" "1580" "1588" "1589" {
			replace malignancy=1 if `x'=="`n'"
			replace mal_ppc=1 if `x'=="`n'"
}
}
}

egen uc=max(mal_uc), by(bid)
egen oc=max(mal_oc), by(bid)
egen cc=max(mal_cc), by(bid)
egen ppc=max(mal_ppc), by(bid)

foreach x in uc oc cc ppc {
replace mal_`x' = `x' if mal_`x'==0
replace malignancy=1 if mal_`x'==1
}
rename admit_date `c'_admit_date
keep bid_hrs_21 is_admit_date procedure_date mal* *admit_date
duplicates drop bid_hrs_21 mal*, force

}

foreach c in pb dm {
merge 1:m bid_hrs_21 using "`c'_2000_2012.dta", keep(match master) keepusing(pdgns_cd dgnscd* admit_date)

format admit_date %td

if admit_date<=procedure_date+60 & admit_date>=is_admit_date {
	foreach x of local diag2 {
		foreach n in "179" "182" "1820" "1821" "1828" {
			replace malignancy=1 if `x'=="`n'"
			replace mal_uc=1 if `x'=="`n'"
}
		foreach n in "183" "1830" "1832" "1833" "1834" "1835" "1838" "1839" {
			replace malignancy=1 if `x'=="`n'"
			replace mal_oc=1 if `x'=="`n'"
}	
		
		foreach n in "180" "1801" "1808" "1809" {
			replace malignancy=1 if `x'=="`n'"
			replace mal_cc=1 if `x'=="`n'"
}	
		
		foreach n in "158" "1580" "1588" "1589" {
			replace malignancy=1 if `x'=="`n'"
			replace mal_ppc=1 if `x'=="`n'"
}
}
}

egen uc=max(mal_uc), by(bid)
egen oc=max(mal_oc), by(bid)
egen cc=max(mal_cc), by(bid)
egen ppc=max(mal_ppc), by(bid)

foreach x in uc oc cc ppc {
replace mal_`x' = `x' if mal_`x'==0
replace malignancy=1 if mal_`x'==1
}

rename admit_date `c'_admit_date
keep bid_hrs_21 is_admit_date procedure_date mal* *admit_date
duplicates drop bid_hrs_21 mal*, force
}

gen mal_type = 1 if mal_uc==1 
replace mal_type=2 if mal_oc==1 
replace mal_type=3 if mal_cc==1 
replace mal_type=4 if mal_ppc==1
replace mal_type=5 if mal_uc+mal_oc+mal_cc+mal_ppc>1

label define maltype 1 "Uterine Cancer" 2 "Ovarian/Admenxal Cancer" ///
3 "Cervical Cancer" 4 "Primary Peritoneal Cancer" 5 "Multiple Cancer Diagnoses"

label values mal_type maltype

duplicates tag bid_hrs_21 mal_*, gen(dup)

drop if dup!=0 & mali==0

keep bid_hrs_21 is_admit_date procedure_date mal* *admit_date

duplicates drop bid_hrs_21 mal*, force


save "`datapath'\surgery_hysterectomy_malignancy_dx.dta", replace

use "`datapath'\surgery_hysterectomy_final_n12m.dta"

merge 1:1 bid_hrs_21 using "`datapath'\surgery_hysterectomy_malignancy_dx.dta"

save "`datapath'\surgery_hysterectomy_final_n12m_dx.dta.dta", replace


H="get complication"


H="stata-define sample"
/*surgery project summary statistics

Drops observations based on sample criteria:
Start with 2000-2012 claims, 1998-2010 core interviews, 2002-2012 exit interviews
1. Age at surgery >=65
2. Parts a+b Medicare FFS coverage for 6 months prior to surgery
3. Hysterectomy, per ICD-9 procedure code

Creates cleaned variables and new variables needed
for analysis
*/

capture log close

clear all

set more off

local logpath E:\data\surgery_hysterectomy\logs
local datapath E:\data\surgery_hysterectomy\final_2012clms
local datapath2 E:\data\surgery_hysterectomy\int_2012clms

log using "`logpath'\7_Surgery_hysterectomy_code_sum_stats_2012_claims.txt", text replace

cd "`datapath'"

//2 datasets, one with 12 month pre surgery comorbidities, one with 6 month
//pre surg comorbidities
use surgery_hysterectomy_final_n12m_dx.dta.dta
//use surgery_final_n6m.dta

drop _m
merge 1:1 bid_hrs_21 using "E:\data\surgery_hysterectomy\int_2012clms\ip_hyst.dta", keepusing(procedure_a) keep(match master)

describe

gen surg_year = year(procedure_date)

la var surg_year "Surgery year"
tab core_year_n1 surg_year, missing

**********************************************************
**********************************************************
//create age at surgery variables
**********************************************************
**********************************************************

//check dob from restricted files vs dob from claims
/*restricted file has quite a few instances of missing dob
but claims does not so maybe use claims dob*/

format birth_date_e %td
//2 observations have missing birth date from restricted file
tab birth_date_e,missing

//rename dob variable from claims
rename claims_dob2 claims_dob

//check to see if there's a difference between claims dob and rest dob
//there is so don't just replace restricted dob with claims dob
gen dob_clm_rest = claims_dob - birth_date_e
tab dob_clm_rest, missing

//check claims dob for cases where restricted birth date is missing
//seem to check out, one was imputed, year is same for both
tab claims_dob if birth_date_e==.,missing
tab birthmo_e dob_imp if birth_date_e==.,missing
tab birthyr_e dob_imp if birth_date_e==.,missing
tab birthday_e  dob_imp  if birth_date_e==.,missing

//for 2 obs with missing dob, use claims dob
replace birth_date_e=claims_dob if birth_date_e==.

//create age at surgery variable
gen age_at_surg=.
replace age_at_surg  = (procedure_date-birth_date_e) / 365.25
la var age_at_surg "Age at time of index surgery"
sum age_at_surg, detail

//create category indicator age variables
gen age_at_surg_lt65=.
replace age_at_surg_lt65=1 if (age_at_surg<65 & age_at_surg~=.)
replace age_at_surg_lt65=0 if (age_at_surg>=65 & age_at_surg~=.)
la var age_at_surg_lt65 "Age at time of index surgery less than 65"

gen age_at_surg_65_74=.
replace age_at_surg_65_74=1 if (age_at_surg>=65 & age_at_surg<75)
replace age_at_surg_65_74=0 if (age_at_surg<65 | age_at_surg>=75)
la var age_at_surg_65_74 "Age at time of index surgery 65-74"

gen age_at_surg_75_79=.
replace age_at_surg_75_79=1 if (age_at_surg>=75 & age_at_surg<80)
replace age_at_surg_75_79=0 if (age_at_surg<75 | age_at_surg>=80)
la var age_at_surg_75_79 "Age at time of index surgery 75-79"

gen age_at_surg_80_84=.
replace age_at_surg_80_84=1 if (age_at_surg>=80 & age_at_surg<85)
replace age_at_surg_80_84=0 if (age_at_surg<80 | age_at_surg>=85)
la var age_at_surg_80_84 "Age at time of index surgery 80-84"

gen age_at_surg_gt84=.
replace age_at_surg_gt84=1 if (age_at_surg>=85 & age_at_surg~=.)
replace age_at_surg_gt84=0 if (age_at_surg<85 & age_at_surg~=.)
la var age_at_surg_gt84 "Age at time of index surgery 85+"

tab age_at_surg_lt65,missing
tab age_at_surg_65_74,missing
tab age_at_surg_75_79,missing
tab age_at_surg_80_84,missing
tab age_at_surg_gt84,missing

//create categorical age variable
//category 1 65-74 includes those that were less than 65 at surgery
//drop them from analysis later
gen age_cat=.
replace age_cat=1 if age_at_surg_65_74==1 | age_at_surg_lt==1
replace age_cat=2 if age_at_surg_75_79==1
replace age_cat=3 if age_at_surg_80_84==1
replace age_cat=4 if age_at_surg_gt84==1
la var age_cat "Age at Surgery"
la def age 1 "65-74" 2 "75-79" 3 "80-84" 4 "85+"
la val age_cat age
tab age_cat, missing

//check current reason for entitlement for those age<65
destring crec, replace
la var crec "current reason for mc entitlement"
la def crec 0 "age 65 and older" 1 "disability insurance benefits" ///
	2 "ESRD" 3 "DIB and ESRD"
la values crec crec	
tab crec if age_at_surg_lt65==1, missing

// percent of surgeries that were emergent/urgent
tab em_urgent_admit, missing

//quick table to get sample size
mat sample=J(4,1,.)
sum age_cat //number of surgeries
mat sample[1,1]=r(N)
sum age_cat if age_at_surg_lt==0 //age > 65
mat sample[2,1]=r(N)
sum age_cat if (age_at_surg_lt==0 & part_ab_6m==1 & hmo_d_6m ==0) //mc status
mat sample[3,1]=r(N)
sum age_cat if (age_at_surg_lt==0 & part_ab_6m==1 & hmo_d_6m ==0 & ind_n1core==1) //core ivw
mat sample[4,1]=r(N)



mat rownames sample="N Surgeries" "Age > 65" "With MC A+B FFS 6mos" ///
 "With pre-surg core ivw" 

mat list sample

frmttable, statmat(sample) title("Hysterectomies in Sample") sdec(0)
outreg using "`logpath'\Hysterectomy_Sample_Size.rtf", replace replay(sample) 

// drop observations to get to final sample
drop if age_at_surg_lt65==1 //drop if age less than 65
drop if part_ab_6m==. //surgery within 6 months of Jan. 2000
drop if part_ab_6m==0 //no mc a+b coverage 6 months prior to surgery
drop if hmo_d_6m==1 //HMO coverage 6 months prior to surgery


tab surg_year, missing

gen procedure_type=.
foreach x in "684" "6849" "683" "6839" "685" "686" "6869" "689" {
	replace procedure_type=1 if procedure=="`x'"
}

foreach x in "6841" "6831" "6851" "6861" "6871" {
		replace procedure_type=2 if procedure=="`x'"
}

foreach x in "685" "6859" "687" "6879" {
		replace procedure_type=3 if procedure=="`x'"
}

label define ptype 1 "Abdominal Hysterectomy" 2 "Laparoscopic Hysterectomy" ///
3 "Vaginal Hysterectomy" 
label values procedure_type ptype
label var procedure_a "Robotic Hysterectomy"

mat type=J(5,1,.)

sum age_cat 
mat type[1,1]=r(N)
sum age_cat if procedure_type==1
mat type[2,1]=r(N)
sum age_cat if procedure_type==2
mat type[3,1]=r(N)
sum age_cat if procedure_type==3
mat type[4,1]=r(N)
sum age_cat if procedure_a==1742
mat type[5,1]=r(N)

mat rownames type="N Surgeries" "Abdominal" "Laparscopic" "Vaginal" ///
"Robotic"
frmttable, statmat(type) sdec(0)
outreg using "`logpath'\Hysterectomy_Sample_Size.rtf", addtable ///
title("Hysterectomies by type") replay(type)

mat time=J(6,4,.)
local r=1
foreach x in n1 n2 p1 p2 x {
sum days_surg_`x', d
mat time[`r',1]=r(N)
mat time[`r',2]=r(p50)
mat time[`r',3]=r(mean)
mat time[`r',4]=r(sd)
local r=`r'+1
}

gen core_to_dod_n1=death_date_e-c_ivw_date_n1

sum core_to_dod_n1 if core_to_dod_n1<731 & c_ivw_date_p1==.
mat time[`r',1]=r(N)

mat rownames time="Days n1 to Procedure" "Days n2 to Procedure" ///
"Days Procedure to p1" "Days Procedure to p2" "Days Procedure to Exit" ///
"Died within two years n1, no p1"

frmttable, statmat(time) sdec(0,2,2,2)
outreg using "`logpath'\Hysterectomy_Sample_Size.rtf", replay(time) addtable ///
title("Time Between Interview & Procedure") ///
ctitle("" "N" "Median" "Mean" "SD")

/**************************************************************/
/**************************************************************/
// Now have final sample of 408 beneficiaries with urgent
// or emergent surgery, age 65 and over at surgery and
// fee for service medicare in the 6 months prior to surgery
/**************************************************************/
/**************************************************************/


save surgery_hysterectomy_final_n12m_sample1.dta, replace

log close


H="clean, create new vars"
/*starts with sample defined
Creates clean variables, saves dataset for tables and analysis*/

capture log close

clear all

set more off

local logpath E:\data\surgery_hysterectomy\logs
local datapath E:\data\surgery_hysterectomy\final_2012clms

log using "`logpath'\8_Surgery_code_var_cleaning_2012_claims.txt", text replace

cd "`datapath'"

//Use sample from 12 month before surgery comorbidities
use surgery_hysterectomy_final_n12m_sample1.dta

// list of surgeries
tab procedure, missing

***************************************************************************
 ***************************************************************************
//Clean demo variables
***************************************************************************
***************************************************************************

//age at time of surgery
sum age_at_surg, detail
tab age_cat, missing

//gender - from HRS
gen byte female = .
replace female=1 if (female_n1==1 | female_p1==1 | female_x==1)
replace female=0 if (female_n1==0 | female_p1==0 | female_x==0)
tab female, missing

//gender - from claims
tab claims_sex, missing
gen byte female_claims = .
replace female_claims = 1 if (claims_sex=="2")
replace female_claims = 0 if (claims_sex=="1")

// compare HRS and claims gender values
tab female female_claims, missing
//no conflicts and the 4 missing observations in HRS have gender
//assigned in the claims so use the claims gender variable

replace female=female_claims
la def fem 0 "Male" 1 "Female"
la values female fem
tab female, missing

//race & ethnicity
tab white_e, missing
tab black_e, missing
tab hisp_eth_e, missing
tab native_amer_e, missing
tab asian_pi_e, missing
tab other_race_e, missing
tab other_na_api_race_e, missing

//create race and ethnicity categorical variable
gen re_cat = .
replace re_cat = 1 if black_e==1
replace re_cat = 3 if white_e==1
replace re_cat = 2 if hisp_eth_e==1
replace re_cat = 4 if native_amer_e==1 | asian_pi_e==1 | other_race_e==1
la var re_cat "race & ethnicity"
la def re_cat 1 "African American" 3 "White" 2 "Hispanic" 4 "Other"
la val re_cat re_cat
tab re_cat, missing

***************************************************************************
***************************************************************************
//Clean health status variables
***************************************************************************
***************************************************************************

//nursing home resident - using n1 core interview, add labels
la def nhres_n1 1 "Yes" 0 "No"
la val nhres_n1 nhres_n1
tab nhres_n1, missing

****************************************************
// Self reported health status
****************************************************
//create collapsed self reported health, pre-surgery core categorical variable
//one obs is missing n1 srh but has n2 srh so use n2 srh for categorical variable
la var srh_n2 "SRH Core n2"
tab srh_n1 srh_n2, missing

gen byte srh_n1_imp_n2=0
replace srh_n1_imp_n2=1 if (srh_n1==. & srh_n2!=.)
tab srh_n1_imp_n2, missing

gen srh_cat_core=.
replace srh_cat_core=1 if  srh_ve_n1==1 //very good and excellent
replace srh_cat_core=2 if  srh_g_n1==1 //good
replace srh_cat_core=3 if  srh_pf_n1==1 //fair and poor

//for the obs where n1 core is missing but n2 core reported, use n2 core value
replace srh_cat_core=1 if (srh_ve_n2==1 & srh_n1==.) //very good and excellent
replace srh_cat_core=2 if (srh_g_n2==1 & srh_n1==.) //good
replace srh_cat_core=3 if (srh_pf_n2==1 & srh_n1==.) //fair and poor

la var srh_cat_core "Self reported health"
la def srh_cat_core 1 "Very Good / Excellent" 2 "Good" 3 "Fair / Poor"
la val srh_cat_core srh_cat_core
tab srh_cat_core,missing

//indicator variables for srh categories
gen byte srh_ve_ncore=0
replace srh_ve_ncore=1 if srh_cat_core==1
gen byte srh_g_ncore=0
replace srh_g_ncore=1 if srh_cat_core==2
gen byte srh_fp_ncore=0
replace srh_fp_ncore=1 if srh_cat_core==3
la var srh_ve_ncore "SRH Excel / VG pre-surgery core"
la var srh_g_ncore "SRH Good pre-surgery core"
la var srh_fp_ncore "SRH Fair / Poor pre-surgery core"
tab srh_ve_ncore,missing
tab srh_g_ncore,missing
tab srh_fp_ncore,missing

****************************************************
// ADL Difficulty Status
****************************************************
//adl categories - add labels, use n2 core adl for obs where n1 is missing
label define adl_cat_core_n1 0 "Independent" 1 "Partial Dependence" 2 "Severe Dependence", modify
label values adl_cat_core_n1 adl_cat_core_n1 
label var adl_cat_core_n2 "ADL Categ n2 core"
tab adl_cat_core_n1 adl_cat_core_n2, missing

gen byte adl_cat_n1_imp_n2=0
replace adl_cat_n1_imp_n2=1 if (adl_cat_core_n1==. & adl_cat_core_n2 !=.)
tab adl_cat_n1_imp_n2, missing

gen adl_cat_core=adl_cat_core_n1
replace adl_cat_core=adl_cat_core_n2 if (adl_cat_core_n1==. & adl_cat_core_n2 !=.)
la var adl_cat_core "ADL categorical from pre-surg core int"
la val adl_cat_core adl_cat_core_n2 adl_cat_core_n1
tab adl_cat_core, missing

//indicator variables for adl categories
gen byte adl_ind_ncore=0
replace adl_ind_ncore=1 if adl_cat_core==0
gen byte adl_pd_ncore=0
replace adl_pd_ncore=1 if adl_cat_core==1
gen byte adl_sd_ncore=0
replace adl_sd_ncore=1 if adl_cat_core==2
la var adl_ind_ncore "ADL Independent pre-surgery core"
la var adl_pd_ncore "ADL Partial Depend. pre-surgery core"
la var adl_sd_ncore "ADL Severe Depend. pre-surgery core"
tab adl_ind_ncore,missing
tab adl_pd_ncore,missing
tab adl_sd_ncore,missing

****************************************************
// Elixhauser comorbidities
****************************************************

//create diabetes variable to cover both comorb variables
gen el_diab=.
replace el_diab=1 if comorb_10_0_n12m==1 | comorb_11_0_n12m==1 //diabetes, uncompl.+compl.
replace el_diab=0 if comorb_10_0_n12m==0 & comorb_11_0_n12m==0
tab el_diab, missing
la var el_diab "Diabetes"

//create cancer variable to cover different el comorb variables
gen el_cancer=.
replace el_cancer=1 if comorb_17_0_n12m==1 | comorb_18_0_n12m==1 | comorb_19_0_n12m==1
replace el_cancer=0 if comorb_17_0_n12m==0 & comorb_18_0_n12m==0 & comorb_19_0_n12m==0
la var el_cancer "Cancer"
tab el_cancer, missing 

local comorb el_cancer comorb_1_0_n12m comorb_32_0_n12m comorb_31_0_n12m comorb_13_0_n12m el_diab
la def el_ind  0 "No" 1 "Yes"
lab val `comorb' el_ind  

****************************************************
// TICS score
****************************************************
//tics score n1 - categorical
gen tics_cat_n1 = .
replace tics_cat_n1 = 1 if (tics_tot_n1 > 8 & tics_tot_n1~=.)
replace tics_cat_n1 = 2 if (tics_tot_n1 >= 5 & tics_tot_n1 <= 8)
replace tics_cat_n1 = 3 if (tics_tot_n1 <= 4 & tics_tot_n1~=.)
la var tics_cat_n1 "TICS - categorical"
la def tics_cat_n1 1 "9-35 Normal" 2 "5-8 MCI" 3 "0-4 Demented"
la val tics_cat_n1 tics_cat
tab tics_cat_n1, missing


//tics score n2 - categorical
gen tics_cat_n2 = .
replace tics_cat_n2 = 1 if (tics_tot_n2 > 8 & tics_tot_n2~=.)
replace tics_cat_n2 = 2 if (tics_tot_n2 >= 5 & tics_tot_n2 <= 8)
replace tics_cat_n2 = 3 if (tics_tot_n2 <= 4 & tics_tot_n2~=.)
la var tics_cat_n2 "TICS - categorical n2 int"
la def tics_cat_n2 1 "9-35 Normal" 2 "5-8 MCI" 3 "0-4 Demented"
la val tics_cat_n2 tics_cat_n2
tab tics_cat_n2, missing

tab tics_cat_n2 comorb_31_0_n12m, missing


gen tics_cat_p1 = .
replace tics_cat_p1 = 1 if (tics_tot_p1 > 8 & tics_tot_p1~=.)
replace tics_cat_p1 = 2 if (tics_tot_p1 >= 5 & tics_tot_p1 <= 8)
replace tics_cat_p1 = 3 if (tics_tot_p1 <= 4 & tics_tot_p1~=.)
la var tics_cat_p1 "TICS - categorical p1 int"
la def tics_cat_p1 1 "9-35 Normal" 2 "5-8 MCI" 3 "0-4 Demented"
la val tics_cat_p1 tics_cat_p1
tab tics_cat_p1, missing

//There are 7 obs where n1 tics is missing but n2 tics is not
//Create indicator for ticsn2 used and recode tics_cat_n1 variable
//to use n2 tics so we can keep those obs in the cohort
gen byte tics_n1_imp_n2=0
replace tics_n1_imp_n2=1 if tics_cat_n1==. & tics_cat_n2!=.
tab tics_n1_imp_n2, missing

replace tics_cat_n1 = 1 if (tics_tot_n2 > 8 & tics_tot_n2~=. & tics_tot_n1==.)
replace tics_cat_n1 = 2 if (tics_tot_n2 >= 5 & tics_tot_n2 <= 8 & tics_tot_n1==.)
replace tics_cat_n1 = 3 if (tics_tot_n2 <= 4 & tics_tot_n2~=. & tics_tot_n1==.)

//look at why tics is missing for 33 observations
//age at n1 core interview
//create age at surgery variable
gen age_at_n1=.
replace age_at_n1  = ( c_ivw_date_n1-birth_date_e) / 365.25
la var age_at_n1 "Age at time of core n1 interview"
sum age_at_n1, detail

gen age_at_p1=.
replace age_at_p1= (c_ivw_date_p1-birth_date_e) / 365.25

//they are either <65 at the n1 core interview or the n1 core was by proxy
tab age_at_n1  proxy_core_n1 if tics_cat_n1==.

//create tics category variable, including missing
gen tics_cat_miss = tics_cat_n1
replace tics_cat_miss = 4 if tics_cat_n1==.
la var tics_cat_miss "TICS categorical"
la def tics_cat_miss 1 "Normal >8" 2 "MCI 5-8" 3"Demented 0-4" 4"Unknown"
la val tics_cat_miss tics_cat_miss
tab tics_cat_miss

//create tics indicator variables for the 4 categories
gen byte tics_ind_normal=0
replace tics_ind_normal=1 if tics_cat_miss==1
gen byte tics_ind_mci=0
replace tics_ind_mci=1 if tics_cat_miss==2
gen byte tics_ind_dem=0
replace tics_ind_dem=1 if tics_cat_miss==3
gen byte tics_ind_unk=0
replace tics_ind_unk=1 if tics_cat_miss==4
tab tics_ind_normal, missing
tab tics_ind_mci, missing
tab tics_ind_dem, missing
tab tics_ind_unk, missing

***************************************************************************
***************************************************************************
//Clean surgery episode / MC use variables
***************************************************************************
***************************************************************************
tab index_los,missing

local compl comp_any comp_uti comp_pe comp_inf comp_rf comp_mi comp_del
la var comp_any "Any complication"
la var comp_uti "UTI"
la var comp_pe "PE"
la var comp_inf "Surgical site infection"
la var comp_rf "Respiratory failure"
la var comp_mi "MI"
la var comp_del "Delirium"
la def comp_ind 0 "No" 1 "Yes"
la val `compl' comp_ind

la var admit_ind_6m_pre "Indicator for Hospital admission 6 months pre-surgery"
la def admit_ind_6m_pre 0 "No" 1 "Yes"
la val  admit_ind_6m_pre admit_ind_6m_pre
tab admit_ind_6m_pre, missing

*************************************************************************
*************************************************************************
//Death date variable cleaning
*************************************************************************
*************************************************************************
//compare death date from restricted hrs dataset vs claims
//claims dod comes from the denominator file
//especially interested in dates for discharge dstn code = expired
format death_date_e %d
sum death_date_e, detail
sum claims_dod2, detail

//7 obs have death date from claims but not in restricted dataset
//use their death date...
tab claims_dod2 if death_date_e==.

sum claims_dod2 if(stay_dstn_cd=="20"), detail
gen dod_dif = death_date_e - claims_dod2
tab dod_dif, missing
//of 66 claims with dstn code = expired, 51 have matching dod from claims and restr file
//so 15 have conflicts
//4 are ~1 year different, 9 are within 1 month
//2 have either missing dod in restricted file or missing in claims
tab dod_dif if(stay_dstn_cd=="20"), missing
tab dod_dif stay_dstn_cd, missing
tab death_date_e claims_dod2 if stay_dstn_cd=="20" & dod_dif!=0, m
tab death_date_e claims_dod2 if(stay_dstn_cd=="20" & dod_dif==.), missing

//need to deal with the 15 with conflicts
// 1 observation - has restricted death date, no date from claims
// procedure date = 03Aug2010, disch date = 12Aug2010, disch code = expired
// death date = 15Nov2011
// has additional ip claims after discharge date, so expired code is incorrect
// recode discharge code for this observation as "99" for unknown
// indicator for discharge code is modified created
gen disch_cd_mod = 0
tab stay_dstn_cd if(stay_dstn_cd=="20" & dod_dif==. & death_date_e!=.), missing
replace disch_cd_mod = 1 if(stay_dstn_cd=="20" & dod_dif==. & death_date_e!=.)
replace stay_dstn_cd="99" if(stay_dstn_cd=="20" & dod_dif==. & death_date_e!=.)
la var disch_cd_mod "Discharge code modified indicator"
tab disch_cd_mod, missing

// 1 observation with death date in claims, no date in restricted file
// has no post surgery ip stays or snf days recorded
// claims death date = discharge date which supports disch code = expired
// so use the claims death date
gen death_date_from_clms = 0
replace death_date_from_clms = 1  if(stay_dstn_cd=="20" & dod_dif==. & claims_dod2!=.)
replace death_date_e=claims_dod2  if(stay_dstn_cd=="20" & dod_dif==. & claims_dod2!=.)
la var death_date_from_clms "Death date from claims (not restricted hrs)"
tab death_date_from_clms, missing

//look at 4 with difference of ~1 year
tab stay_end death_date_e if(dod_dif>100 &dod_dif!=.& stay_dstn_cd=="20"), missing
tab location_x claims_dod2 if(dod_dif>100 &dod_dif!=.& stay_dstn_cd=="20"), missing
//all report died in hospital from exit interview but have no ip claims post-surgery
//hospital stay which supports disch code = 30
//so replace death date with claims death date
replace death_date_from_clms = 1 if(dod_dif>100 &dod_dif!=.& stay_dstn_cd=="20" & location_x==1)
replace death_date_e=claims_dod2 if(dod_dif>100 &dod_dif!=.& stay_dstn_cd=="20" & location_x==1)
tab death_date_from_clms, missing

gen dod_dif_2 = death_date_e - claims_dod2
tab dod_dif_2, missing
tab dod_dif_2 if stay_dstn_cd=="20" , missing


*************************************************************************
*************************************************************************
//look at surgery to death date timeline
gen surg_to_death_dt = death_date_e - procedure_date
tab surg_to_death_dt, missing

//8 observations have dod <= procedure date
//need to address these so don't lose them in the Cox analysis
gen byte death_date_mod = 0
replace death_date_mod = 1 if (surg_to_death_dt<1)
tab index_los stay_dstn_cd if (surg_to_death_dt<1)
//6 obs indicate died during hospital stay, so reset dod to discharge date
tab is_disch_date death_date_e if (surg_to_death_dt<1 & stay_dstn_cd=="20")
tab is_disch_date procedure_date if (surg_to_death_dt<1 & stay_dstn_cd=="20")
replace death_date_e = is_disch_date if (surg_to_death_dt<1 & stay_dstn_cd=="20")
//4 of these obs procedure date=discharge date, to keep them in analysis, need to add
//a day to death date
replace death_date_e = is_disch_date +1 if (procedure_date==is_disch_date & stay_dstn_cd=="20")
//for remaining 2, disch to home and disch to snf
//check claims dod vs restricted dod
//no claims dod
tab death_date_e claims_dod2 if (surg_to_death_dt<1 & stay_dstn_cd!="20"), missing
tab id if (surg_to_death_dt<1 & stay_dstn_cd!="20"), missing
//check interview timeline dates - no p1 core
tab death_date_e c_ivw_date_p1 if (surg_to_death_dt<1 & stay_dstn_cd!="20"), missing
tab death_date_e e_ivw_date_x if (surg_to_death_dt<1 & stay_dstn_cd!="20"), missing
tab death_date_e admit_12m_post if (surg_to_death_dt<1 & stay_dstn_cd!="20"), missing
tab death_date_e snf_days_post_12m if (surg_to_death_dt<1 & stay_dstn_cd!="20"), missing
//2 observations, still need to figure out what to do with them!!
//one has an ip admit after surgery stay, other has a snf stay post-surgery stay
//so cannot just say they died... drop them from the analysis

//replace surgery to death date variable with updated death dates
replace surg_to_death_dt = death_date_e - procedure_date
la var surg_to_death_dt "Days from surgery to death"
tab surg_to_death_dt, missing

****************************************************
// Discharge Destination code
****************************************************
//discharge location code from surgery hospital stay
gen stay_dstn_cd_n=real(stay_dstn_cd)
la def stay_dstn_cd_n 1 "Home" 2 "Short term general hosp for inpatient care" 3 "SNF" ///
  4 "Intermediate care facility" 5 "Another type of inst" 6"Home care hhs org." ///
  20"Expired" 30"Still patient" 50"Hospice - home" 51"Hospice - medical facility" ///
  61"Within same inst to hospital based swing bed" 62"Inpatient rehab facility" ///
  63"Long term care hosp" 99 "Missing"
la val  stay_dstn_cd_n stay_dstn_cd_n 
tab stay_dstn_cd_n, missing

//discharge location coded into groups
gen stay_dstn_cat=.
replace stay_dstn_cat=1 if inlist(stay_dstn_cd_n,1,6) //home
replace stay_dstn_cat=2 if inlist(stay_dstn_cd_n,3,4,63) //long term care
replace stay_dstn_cat=3 if inlist(stay_dstn_cd_n,62) //rehab
replace stay_dstn_cat=4 if inlist(stay_dstn_cd_n,50,51) //hospice
replace stay_dstn_cat=5 if inlist(stay_dstn_cd_n,2,5,61,99,30) //other (includes still patient and unknown)
replace stay_dstn_cat=6 if inlist(stay_dstn_cd_n,20) //expired
la var stay_dstn_cat "Discharge location categorical"
la def stay_dstn_cat 1 "Home incl hha" 2"long term care incl snf" 3"IP rehab" ///
	4"Hospice" 5"Other location or missing" 6"Expired"
la var stay_dstn_cat stay_dstn_cat
tab stay_dstn_cat stay_dstn_cd, missing

gen dis_home=.
replace dis_home=0 if inlist(stay_dstn_cat,2,3,4,5,6)
replace dis_home=1 if stay_dstn_cat==1
gen dis_ltc=.
replace dis_ltc=0 if inlist(stay_dstn_cat,1,3,4,5,6)
replace dis_ltc=1 if stay_dstn_cat==2
gen dis_rehab=.
replace dis_rehab=0 if inlist(stay_dstn_cat,1,2,4,5,6)
replace dis_rehab=1 if stay_dstn_cat==3
gen dis_hs=.
replace dis_hs=0 if inlist(stay_dstn_cat,1,2,3,5,6)
replace dis_hs=1 if stay_dstn_cat==4
gen dis_oth=.
replace dis_oth=0 if inlist(stay_dstn_cat,1,2,3,4,6)
replace dis_oth=1 if stay_dstn_cat==5
gen dis_died=.
replace dis_died=0 if inlist(stay_dstn_cat,1,2,3,4,5)
replace dis_died=1 if stay_dstn_cat==6
la var dis_home "Discharged to home"
la var dis_ltc "Discharged to long term care facility"
la var dis_rehab "Discharged to rehab facility"
la var dis_hs "Discharged to hospice"
la var dis_oth "Other / Unknown Discharged Location"
la var dis_died "Expired"


*************************************************************************
*************************************************************************
//Mortality timeline indicator variables
*************************************************************************
*************************************************************************
//inclusive mortality window variables (so 180 days includes those that
//died in first 30 days
//0 = died outside of window or did not die at all within the study time period

//create variables for died at 30 days, 180 days, 1 year
gen byte died_ind=.
replace died_ind=1 if death_date_e~=.
replace died_ind=0 if death_date_e==.
la var died_ind "indicator for death date present in HRS"

//died within 30 days of surgery (null if did not die)
gen byte died_30d = .
replace died_30d = 1 if (surg_to_death_dt<31)
replace died_30d = 0 if (surg_to_death_dt>30 & surg_to_death_dt~=.) | death_date_e==.
la var died_30d "died within 30 days post surgery"

//died within 180 days of surgery (null if did not die)
gen byte died_180d = .
replace died_180d = 1 if (surg_to_death_dt<181)
replace died_180d = 0 if (surg_to_death_dt>180 & surg_to_death_dt~=.) | death_date_e==.
la var died_180d "died within 180 days post surgery"

//died within 365 days of surgery (null if did not die)
gen byte died_365d = .
replace died_365d = 1 if (surg_to_death_dt<366)
replace died_365d = 0 if (surg_to_death_dt>365 & surg_to_death_dt~=.) | death_date_e==.
la var died_365d "died within 1 year post surgery"

//indicator for alive at 365 days
gen byte alive_365d_full =0
replace alive_365d_full = 1 if died_365d!=1
la var alive_365d_full "Did not die within 1 year post surgery"

la var died_365d "Died within 1 year"
la def ny 0 "No" 1 "Yes", modify
la val died_365d ny

tab died_ind, missing
tab died_30d, missing
tab died_180d, missing
tab died_365d, missing
tab died_365d alive_365d_full, missing

tab dis_died stay_dstn_cd_n, missing
tab died_30d if (stay_dstn_cd_n==20)
tab died_30d if (dis_died==1)
tab died_180d if (stay_dstn_cd_n==20)
tab died_180d if (dis_died==1)
tab died_180d if stay_dstn_cat==6

//create categorical variable for mortality timeline
gen mort_cat=.
replace mort_cat=3 if died_365d==1
replace mort_cat=2 if died_180d==1
replace mort_cat=1 if died_30d==1
replace mort_cat=4 if died_365d==0
la var mort_cat "Mortality - 30 day, 180 day and 1 year"
la def mort_cat 1 "30 day mortality" 2 "180 day mortality" 3 "365 day mortality" ///
	4 "Subject alive at 365 days", modify
la val mort_cat mort_cat
tab mort_cat, missing

//mutually exclusive indicator variables
//0-30 days, 31-180 days and 181-365 days
gen byte died_30d_me1=died_30d //no change for this variable
gen byte died_180d_me1=died_180d
replace died_180d_me1 = 0 if died_30d==1 //exclude those who died 30 days
gen byte died_365d_me1=died_365d
replace died_365d_me1 = 0 if died_180d==1 //exclude those who died 180 days
tab died_30d_me1, missing
tab died_180d_me1, missing
tab died_365d_me1, missing

gen died_me1_cat = 4
replace died_me1_cat = 1 if died_30d_me1==1
replace  died_me1_cat = 2 if died_180d_me1==1
replace died_me1_cat =3 if died_365d_me1==1
la var died_me1_cat "Mortality time categorical variable, mutually exclusive cats"
la def mort1 1 "0-30 days" 2 "31-180 days" 3 "181-365 days" 4 "Alive at 1 year"
la val died_me1_cat mort1
tab died_me1_cat , missing 

//Another set combining the 180 and 365 categories mortality windows
gen byte died_0_30=died_30d_me1
gen byte died_31_180=died_180d_me1
gen byte died_31_365 = 0
replace died_31_365 = 1 if died_180d_me1==1 | died_365d_me1==1
la var died_0_30 "Died 0-30 days post-surgery"
la var died_31_180 "Died 31-180 days post-surgery"
la var died_31_365 "Died 31-365 days post-surgery"
tab died_0_30, missing
tab died_31_180, missing
tab died_31_365, missing

tab died_0_30 died_me1_cat , missing
tab died_31_180 died_me1_cat , missing
tab died_31_365 died_me1_cat , missing


*************************************************************************
*************************************************************************
//Interview timeline variables
*************************************************************************
*************************************************************************
//Indicaors for n1 and p1 core interviews
tab ind_n1core, missing
tab ind_p1core, missing

//Exit interview
la var days_surg_x "Days from surgery to exit int"
sum days_surg_x
tab ind_exit,missing

tab core_year_n1 exit_year_x, missing

//completed follow up core interview within 1 year
gen byte core_1yr_ps=.
replace core_1yr_ps=1 if  (days_surg_p1core<366 & ind_p1core==1)
replace core_1yr_ps=0 if (days_surg_p1core>365 | ind_p1core==0)
la var core_1yr_ps "core interview within 1 year after surgery"

//look at outcomes at 1 year version 1, for timeline frequency table
//5 paths 
// 1. died and exit interview w/i 1 year
// 2. died w/i 1 year but exit interview later than 1 yr
// 3. died but no recorded exit interview (1 observation)
// 3. core / survived
// 4. no core / survived
gen outcome_1yr=.
//died 1 year and exit int 1 yr
replace outcome_1yr=1 if died_365d==1 & ( e_ivw_date_x - procedure_date <=365 )
//died 1 year and exit int later than 1 yr
replace outcome_1yr=2 if died_365d==1 & ( (e_ivw_date_x - procedure_date > 365) & ind_exit==1)
//died 1 year, no exit int
replace outcome_1yr=3 if died_365d==1 & ( (e_ivw_date_x - procedure_date > 365) & ind_exit==0)
//survived and core
replace outcome_1yr=4 if core_1yr_ps==1 & (died_365d==0|died_365d==.)
//survived and no core
replace outcome_1yr=5 if core_1yr_ps==0 & (died_365d==0|died_365d==.)
la var outcome_1yr "Outcome category 1 yr post surgery"
la def outcome_1yr 1 "Died and exit interview" 2 "Died, exit later than 1 yr" ///
	3 "Died and no exit" 4 "Survived, completed core interview" ///
	5 "Survived, no core interview", replace
la val outcome_1yr outcome_1yr
tab outcome_1yr died_365d, missing

//look at outcomes at 1 year, version 2
//8 paths 
// 1. Core w/i 1 year, no exit
// 2. Core after 1 year, no exit
// 3. Exit w/i 1 year, no core
// 4. Exit after 1 year, no core
// 5. Core and exit w/i 1 year (no observations)
// 6. Core w/i 1 year, exit after 1 year
// 7. Core and exit after 1 year
// 8. No post surgery interview

gen days_x_int_ps = .
replace days_x_int_ps = ( e_ivw_date_x - procedure_date )
tab days_x_int_ps died_ind, missing

gen exit_1yr_ps=0
replace exit_1yr_ps=1 if (days_x_int_ps<=365 & days_x_int_ps!=.)
tab exit_1yr_ps

gen exit_2yr_ps=0
replace exit_2yr_ps=1 if (days_x_int_ps<=(2*365) & days_x_int_ps!=.)
tab exit_2yr_ps

tab core_1yr_ps	died_365d, missing 
tab exit_1yr_ps died_365d, missing 
tab exit_2yr_ps died_365d, missing 

gen outcome_12m_v2=.
replace outcome_12m_v2=1 if (core_1yr_ps==1 & ind_exit==0) //core w/i 1 year, no exit
replace outcome_12m_v2=2 if (core_1yr_ps==0 & ind_p1core==1 & ind_exit==0) //core after 1 yr, no exit
replace outcome_12m_v2=3 if (exit_1yr_ps==1 & ind_p1core==0 ) //exit w/i 1 year, no core
replace outcome_12m_v2=4 if (exit_1yr_ps==0 & ind_exit==1 & ind_p1core==0 ) // exit after 1 yr, no core
replace outcome_12m_v2=5 if (core_1yr_ps==1 & exit_1yr_ps==1) //core and exit w/i 12 m
replace outcome_12m_v2=6 if (core_1yr_ps==1 & ind_p1core==1 & exit_1yr_ps==0 & ind_exit==1) //core w/i 12 m, exit after 12m
replace outcome_12m_v2=7 if (core_1yr_ps==0 & ind_p1core==1 & exit_1yr_ps==0 & ind_exit==1) //core and exit after 12m
replace outcome_12m_v2=8 if (ind_p1core==0 & ind_exit==0) // no core or exit interview
la def outcome_12m_v2 1 "Core interview within 1 year, no exit int."  ///
	2 "Core after 1 year, no exit int." 3 "Exit interview within 1 year, no core" ///
	4 "Exit interview after 1 year, no core" ///
	6 "Core within 1 year, exit after 1 year" ///
	7 "Core and exit after 1 year" 8 "No post surgery interview", modify
la val outcome_12m_v2 outcome_12m_v2
la var outcome_12m_v2 "Interview timeline categories"

tab outcome_12m_v2 mort_cat, missing

//Variable for no post surgery interview
gen byte post_surg_ivw=1
replace post_surg_ivw=0 if outcome_12m_v2==8
la var post_surg_ivw "Post surgery interview, exit or core"

*************************************************************************
*************************************************************************
//Look at p1 variables for obs who had a post surgery core interview
*************************************************************************
*************************************************************************
//independent functional status using adls
tab adl_independent_core_p1 if(core_1yr_ps==1), missing
//nursing home residence
tab nhres_p1 if(core_1yr_ps==1), missing
//surgery discharge destination codes - create new indicator variable
//62, 63, 3 code up to discharge to snf
tab stay_dstn_cd

//experienced functional decline post surgery
gen fx_diff_1 =  adl_index_core_p1 -  adl_index_core_n1
tab fx_diff_1 if(core_1yr_ps==1), missing

gen byte fx_decline=.
replace fx_decline=1 if fx_diff_1>0 & fx_diff_1~=.
replace fx_decline=0 if fx_diff_1<=0 & fx_diff_1~=.
tab fx_decline if(core_1yr_ps==1), missing

tab re_cat, gen(re_cat_)
rename re_cat_1 re_black
rename re_cat_2 re_hisp
rename re_cat_3 re_white
rename re_cat_4 re_other

gen tics_norm_n1=tics_tot_n1>8 if tics_tot_n1!=.
gen tics_norm_p1=tics_tot_p1>8 if tics_tot_p1!=.

gen incont_yy_n1p1=incont_hrs_n1==1 & incont_hrs_p1==1
gen incont_yn_n1p1=incont_hrs_n1==1 & incont_hrs_p1==0
gen incont_ny_n1p1=incont_hrs_n1==0 & incont_hrs_p1==1
gen incont_nn_n1p1=incont_hrs_n1==0 & incont_hrs_p1==0

gen indep_yy_n1p1=adl_independent_core_n1==1 & adl_independent_core_p1==1
gen indep_yn_n1p1=adl_independent_core_n1==1 & adl_independent_core_p1==0
gen indep_ny_n1p1=adl_independent_core_n1==0 & adl_independent_core_p1==1
gen indep_nn_n1p1=adl_independent_core_n1==0 & adl_independent_core_p1==0

gen srh_pf_yy_n1p1=srh_pf_n1==1 & srh_pf_p1==1
gen srh_pf_yn_n1p1=srh_pf_n1==1 & srh_pf_p1==0
gen srh_pf_ny_n1p1=srh_pf_n1==0 & srh_pf_p1==1
gen srh_pf_nn_n1p1=srh_pf_n1==0 & srh_pf_p1==0

gen nhres_yy_n1p1=nhres_n1==1 & nhres_p1==1
gen nhres_yn_n1p1=nhres_n1==1 & nhres_p1==0
gen nhres_ny_n1p1=nhres_n1==0 & nhres_p1==1
gen nhres_nn_n1p1=nhres_n1==0 & nhres_p1==0

gen proc_to_death=death_all-procedure_date
gen proc_to_dod_365d=(proc_to_death<366)
gen proc_to_dod_60d=(proc_to_death<61)
gen dod_ind=death_all!=.

foreach i in 60 365 {
	foreach x in hosp_adm_p`i' snf_adm_p`i' hs_clms_p`i' {
		replace `x'=0 if `x'==.
}
}

save surgery_hysterectomy_final_n12m_sample_clean.dta, replace

log close


H=" create prelim tables"
/*surgery project summary statistics
For tables from Zara Cooper requested 10/11/2013

Note, this does not drop observatons that are dropped from the following
survival analysis, run version in 'Stata - run tables with final sample' heading section
for final versions of unadjusted results, means tables
*/

capture log close

clear all
set more off

local texpath E:\data\surgery_hysterectomy\logs\tex\
local logpath E:\data\surgery_hysterectomy\logs\
local datapath E:\data\surgery_hysterectomy\final_2012clms\


log using `logpath'9_surgery_hysterectomy_code_tables.txt, text replace

cd "`datapath'"

use surgery_hysterectomy_final_n12m_sample_clean.dta

***************************************************
***************************************************
// Table 1 - Cohort characteristics
***************************************************
***************************************************
local comorb el_cancer comorb_1_0_n12m comorb_32_0_n12m comorb_31_0_n12m comorb_13_0_n12m el_diab
local compl comp_any comp_uti comp_pe comp_inf comp_rf comp_mi comp_del comp_kf ///
comp_deh comp_int comp_pne comp_strk comp_dvt comp_hmrg

local race re_white re_black re_hisp re_other 
local ind_demo adl_independent_core_ incont_hrs_ falls_hrs_ tics_norm_ ///
srh_ve_ srh_g_ srh_pf_ nhres_
local other admit_ind_6m
//First part - Patient Factors
mat tab_1=J(14,6,.)

sum age_at_n1
mat tab_1[1,1]=r(mean)
mat tab_1[1,3]=r(N)
sum age_at_p1
mat tab_1[1,4]=r(mean)
mat tab_1[1,6]=r(N)

local j=2
foreach v of local race {
	sum `v'
	mat tab_1[`j',1]=r(mean)*100
	mat tab_1[`j',2]=r(N)*r(mean)
	mat tab_1[`j',3]=r(N)
	local j=`j'+1
}

foreach v of local ind_demo {
	sum `v'n1
	mat tab_1[`j',1]=r(mean)*100
	mat tab_1[`j',2]=r(N)*r(mean)
	mat tab_1[`j',3]=r(N)
	sum `v'p1
	mat tab_1[`j',4]=r(mean)*100
	mat tab_1[`j',5]=r(N)*r(mean)
	mat tab_1[`j',6]=r(N)

	local j=`j'+1
}

sum admit_ind_6m
mat tab_1[`j',1]=r(mean)*100
mat tab_1[`j',2]=r(N)*r(mean)
mat tab_1[`j',3]=r(N)

mat list tab_1

mat rownames tab_1="Age" "RE White" "RE Black" "RE Hispanic" "RE Other" ///
"Independent ADLs" "Incontinence" "Falls" "TICS Normal" "SRH VG/E" ///
"SRH Good" "SRH P/F" "Nursing Home Resident" ///
"Hospital Admit Prev 6m, claims"

frmttable using "`logpath'\surgery_hysterectomy_cohort.rtf", replace ///
statmat(tab_1) ctitles("" "Mean/Percent n1" "N Yes" "N" ///
"Mean/Percent p1" "N Yes" "N") sdec(2,0,0,2,0,0) title("Cohort Characteristics")






//Second part - hospital episode
local is_compl is_comp_any is_comp_uti is_comp_pe is_comp_inf is_comp_rf ///
is_comp_mi is_comp_del is_comp_kf ///
is_comp_deh is_comp_int is_comp_pne is_comp_strk is_comp_dvt is_comp_hmrg
local disch dis_home dis_ltc dis_rehab dis_hs dis_oth dis_died

//Table 1b Hospital Episode:
local rn : word count `is_compl' `disch' los

mat tab_1b=J(`=`rn'',2,.)
sum index_los, detail
mat tab_1b[1,1]=r(mean)
mat tab_1b[1,2]=r(p50)
mat list tab_1b

local j=2
foreach v in `is_compl' {
	tab `v' , missing  matcell(m_`v')
	sca s_`v'_n=r(N)
	mat m_`v'_p=m_`v'/s_`v'_n
	mat tab_1b[`j',2] = m_`v'[2,1]
	mat tab_1b[`j',1] = m_`v'_p[2,1]*100 //in percent
	local j=`j'+1
}




foreach v in `disch' {
	tab `v' , missing  matcell(m_`v')
	sca s_`v'_n=r(N)
	mat m_`v'_p=m_`v'/s_`v'_n
	mat tab_1b[`j',2] = m_`v'[2,1]
	mat tab_1b[`j',1] = m_`v'_p[2,1]*100 //in percent
	local j=`j'+1
}


local mal malignancy mal_uc mal_oc mal_cc mal_ppc
local rownum : word count `compl' `mal' one two
local j=1

mat tab_1c=J(`=`rownum'',2,.)

foreach v in `compl' {
	tab `v' , missing  matcell(m_`v')
	sca s_`v'_n=r(N)
	mat m_`v'_p=m_`v'/s_`v'_n
	mat tab_1c[`j',2] = m_`v'[2,1]
	mat tab_1c[`j',1] = m_`v'_p[2,1]*100 //in percent
	local j=`j'+1
}


foreach x of local mal {
	sum `x'
	mat tab_1c[`j',2]=r(mean)*r(N)
	mat tab_1c[`j',1]=r(mean)*100
	local j=`j'+1
}

sum procedure_date if mal_type==5
mat tab_1c[`j',2]=r(N)
mat tab_1c[`j',1]=r(N)/_N
mat list tab_1c 



frmttable using "`logpath'\surgery_hysterectomy_cohort.rtf" , statmat(tab_1b) ///
	title("Hospital Episode") ///
	ctitle("","%", "N") ///
	rtitle("LOS - mean, median" \ "Any complication"\"UTI" \ "PE" \ "Surgical site infection" ///
		\ "Respiratory failure" \ "MI" \ "Delirium" \ "Kidney Failure" \ ///
		"Dehiscence" \ "Internal" \ "Pneumonia" \ "Stroke" \ "DVT" \ ///
		"Hemorrhage" \"Home"\"Long term care facility"\"Rehab"\ ///
		"Hospice"\"Other or Unknown"\"Expired") ///
	sdec(1,0 \ 2,0) addtable
	
frmttable using "`logpath'\surgery_hysterectomy_cohort.rtf" , statmat(tab_1c) ///
	title("Within 60 Days") ///
	ctitle("","%", "N") ///
	rtitle("Any complication within 60 Days"\"UTI" \ "PE" \ "Surgical site infection" ///
		\ "Respiratory failure" \ "MI" \ "Delirium" \ "Kidney Failure" \ ///
		"Dehiscence" \ "Internal" \ "Pneumonia" \ "Stroke" \ "DVT" \ ///
		"Hemorrhage" \ "Any Gyn Malignancy within 60 Days" ///
		\"Uterine Cancer" \ "Ovarian/Adnexal Cancer"\"Cervical Cancer" ///
		\"Primary Peritoneal Cancer"\"Mulitple Cancer Diagnoses") ///
	sdec(1,0 \ 2,0) addtable


*******************************************************
*******************************************************
//Table 1c - timeline by 1 year outcome
*******************************************************
*******************************************************
/*
//create matrix for output
mat tab_1c=J(21,4,.)
local timevars days_surg_n1core days_surg_p1core surg_to_death_dt days_surg_x

//N for each category of outcome at 1 year
tab outcome_1yr, missing matcell(samples)
mat list samples
sca sample_n4 = samples[4,1]
sca sample_n5 = samples[5,1]
sca sample_n1 = samples[1,1]
sca sample_n2 = (samples[2,1]+samples[3,1]) //died and either exit after 1 year or no exit
//sca sample_n3 = samples[3,1]

mat tab_1c[1,1] =  sample_n4
mat tab_1c[6,1] =  sample_n5
mat tab_1c[11,1] =  sample_n1
mat tab_1c[16,1] =  sample_n2

local j=2	
foreach v in `timevars' {
	sum `v' if outcome_1yr==4, detail //alive and completed core w/i 1 year
	mat tab_1c[`j',1]=r(N)
	mat tab_1c[`j',2]=sample_n4 - r(N)
	mat tab_1c[`j',3]=r(p50) //median
	mat tab_1c[`j',4]=r(sd) //standard deviation
	local j=`j'+1
}
mat list tab_1c
local j=7	
foreach v in `timevars' {
	sum `v' if outcome_1yr==5, detail //alive but no core w/i 1 year
	mat tab_1c[`j',1]=r(N)
	mat tab_1c[`j',2]=sample_n5 - r(N)
	mat tab_1c[`j',3]=r(p50) //median
	mat tab_1c[`j',4]=r(sd) //standard deviation
	local j=`j'+1
}
mat list tab_1c
local j=12	
foreach v in `timevars' {
	sum `v' if outcome_1yr==1, detail //died, exit w/i 1 year
	mat tab_1c[`j',1]=r(N)
	mat tab_1c[`j',2]=sample_n1 - r(N)
	mat tab_1c[`j',3]=r(p50) //median
	mat tab_1c[`j',4]=r(sd) //standard deviation
	local j=`j'+1
}
mat list tab_1c
local j=17	
foreach v in `timevars' {
	sum `v' if (outcome_1yr==2 | outcome_1yr==3) , detail //died, exit after 1 year or no exit
	mat tab_1c[`j',1]=r(N)
	mat tab_1c[`j',2]=sample_n2 - r(N)
	mat tab_1c[`j',3]=r(p50) //median
	mat tab_1c[`j',4]=r(sd) //standard deviation
	local j=`j'+1
}
mat list tab_1c

local 1clabel "Days from Baseline interview to surgery" \ "Days from Surgery to next core interview" \ ///
	"Days from Surgery to death" \ "Days from Surgery to exit interview"

frmttable using `logpath'table1b , statmat(tab_1c) ///
	title("Table 1c - Interview/Procedure Timeline") ///
	ctitle("Status at 1 year post surgery","N","N - missing", "Median", "SD") ///
	rtitle("Alive & completed next core" \ "Days from Baseline interview to surgery" \ ///
	"Days from Surgery to next core interview" \ "Days from Surgery to death" \ ///
	"Days from Surgery to exit interview" \ ///
	"Alive, no next core" \ "Days from Baseline interview to surgery" \ ///
	"Days from Surgery to next core interview" \ "Days from Surgery to death" \ ///
	"Days from Surgery to exit interview" \ ///
	"Died, exit complete" \ "Days from Baseline interview to surgery" \ ///
	"Days from Surgery to next core interview" \ "Days from Surgery to death" \ ///
	"Days from Surgery to exit interview" \ ///
	"Died, no exit" \ "Days from Baseline interview to surgery" \ ///
	"Days from Surgery to next core interview" \ "Days from Surgery to death" \ ///
	"Days from Surgery to exit interview") ///
	sdec(0,0,1,1) addtable

*******************************************************
*******************************************************
//Frequency table for possible outcomes 12 mos
*******************************************************
*******************************************************	



//output to txt file
tabout outcome_12m_v2 mort_cat using `logpath'table1c_2.txt, ///
/*c(freq col freq col )*/ replace ///
style(tab) ptotal(none) format(0c)
//Note: this uses tabout, paste tab delimited file from text file into
//an excel spreadsheet for easy importing into a table
//Totals across mortality columns need to be manually added since
//mortality variable used is mutually exclusive
//should fix this eventually!

*******************************************************
*******************************************************
//Table 1e - Sensitivity analysis, obs with no post
//surgery interview
*******************************************************
*******************************************************

local sensvars age_at_surg_65_74 age_at_surg_75_79 age_at_surg_80_84 ///
age_at_surg_gt84 female black_e hisp_eth_e white_e other_na_api_race_e ///
tics_ind_normal tics_ind_mci tics_ind_dem tics_ind_unk ///
el_cancer comorb_1_0_n12m comorb_32_0_n12m comorb_31_0_n12m ///
comorb_13_0_n12m el_diab srh_ve_ncore srh_g_ncore srh_fp_ncore ///
adl_ind_ncore adl_pd_ncore adl_sd_ncore nhres_n1 admit_ind_6m_pre

mat tab_1e=J(28,3,.)

//first row - just N's of the two groups
tab post_surg_ivw, matcell(row1)
mat tab_1e[1,1]=row1[1,1]
mat tab_1e[1,2]=row1[2,1]

local i=2
foreach var in `sensvars'{
	sum `var' if post_surg_ivw==0
	mat tab_1e[`i',1]=r(mean)
	sum `var' if post_surg_ivw==1
	mat tab_1e[`i',2]=r(mean)	
	tabulate `var' post_surg_ivw, exact
	mat tab_1e[`i',3]=r(p_exact)
	local i = `i'+1
}

mat list tab_1e

frmttable using `logpath'table1b , statmat(tab_1e) ///
	title("Table 1e - Sensitivity analysis, obs with no post-surgery interview" \ ///
	"P-values calculated from Fisher's exact test" ) ///
	ctitle("","Mean obs no interview","Mean obs with interview","p-value") ///
	rtitle("N" \ "Age: 65-74" \ "75-79" \ "80-84" \ "85+" \ ///
	"Female" \ "AA" \ "Hispanic" \ "White" \"Other" \ ///
	"TICS >8 Normal" \"5-8 MCI" \"<5 Demented"\ "TICS Unknown" \"Cancer" \"CHF" \ ///
	"CAD"\"Dementia"\"ESRD"\"Diabetes"\"Self reported health: Exc / VG" \ ///
	"Good" \ "Fair/Poor" \ "Baseline ADL: Independent" \ "Partial" \ "Severe" \  ///
	"Nursing home resident - Yes"  \ "Hospital admit in prior 6 mos: Yes" ) ///
	sdec(3,3,3) addtable

	
*******************************************************
*******************************************************
//Table 2 - unadjusted mortality rates - 
//Have to manually input 100% mortality rates for
//those with discharge code = expired
//Categories for mortality - 0-30d, 31-181d, 31-365d

*******************************************************
*******************************************************
//create new vars that are missing if in the 0-30 day window for table 2
gen died_31_180_t2 = died_31_180
replace died_31_180_t2=. if died_0_30==1
gen died_31_365_t2 = died_31_365
replace died_31_365_t2=. if died_0_30==1

mat tab_2=J(39,11,.)
//first column = N
//then percent, n and p value for each of 30 day mort, 180 mort and 365 mort

//first column - n for each subgroup
//first row is overall sample
sum died_0_30 //overall sample
mat tab_2[1,1]=r(N)
sum died_0_30 if age_cat==1 //age 65-74
mat tab_2[2,1]=r(N)
sum died_0_30 if age_cat==2 //age 75-79
mat tab_2[3,1]=r(N)
sum died_0_30 if age_cat==3 //age 80-84
mat tab_2[4,1]=r(N)
sum died_0_30 if age_cat==4 //age 85+
mat tab_2[5,1]=r(N)
sum died_0_30 if female==1 //female
mat tab_2[6,1]=r(N)
sum died_0_30 if female==0 //male
mat tab_2[7,1]=r(N)
sum died_0_30 if re_cat==1 //aa
mat tab_2[8,1]=r(N)
sum died_0_30 if re_cat==2 //hispanic
mat tab_2[9,1]=r(N)
sum died_0_30 if re_cat==3 //white
mat tab_2[10,1]=r(N)
sum died_0_30 if re_cat==4 //other
mat tab_2[11,1]=r(N)
sum died_0_30 if tics_cat_miss==1 //tics normal
mat tab_2[12,1]=r(N)
sum died_0_30 if tics_cat_miss==2 //tics mci
mat tab_2[13,1]=r(N)
sum died_0_30 if tics_cat_miss==3 //tics demented
mat tab_2[14,1]=r(N)
sum died_0_30 if tics_cat_miss==4 //tics missing
mat tab_2[15,1]=r(N)	
local k=16
	foreach w in `comorb' {  //comorbidities: cancer, chf, cad, dementia, esrd, dm
		sum died_0_30 if `w'==1
		mat tab_2[`k',1]=r(N)
		local k = `k' + 1  //populates rows 16 through 21
	}
sum died_0_30 if srh_cat_core==1 //srhs excel/vg
mat tab_2[22,1]=r(N)
sum died_0_30 if srh_cat_core==2 //srhs g
mat tab_2[23,1]=r(N)
sum died_0_30 if srh_cat_core==3 //srhs f/p
mat tab_2[24,1]=r(N)
sum died_0_30 if adl_cat_core==0 //adl ind
mat tab_2[25,1]=r(N)
sum died_0_30 if adl_cat_core==1 //adl partial dep
mat tab_2[26,1]=r(N)
sum died_0_30 if adl_cat_core==2 //adl severe dep
mat tab_2[27,1]=r(N)
sum died_0_30 if nhres_n1==1 //nh resident - yes
mat tab_2[28,1]=r(N)
sum died_0_30 if nhres_n1==0 //nh resident - no
mat tab_2[29,1]=r(N)
sum died_0_30 if admit_ind_6m_pre==1 //pre surg admit - yes
mat tab_2[30,1]=r(N)
sum died_0_30 if admit_ind_6m_pre==0 //pre surg admit - no
mat tab_2[31,1]=r(N)
	local k=32
	forvalues i=1/6 {					//discharge locations:
		sum died_0_30 if stay_dstn_cat==`i'	//home, ltc, rehab
			//hospice, other, expired
		mat tab_2[`k',1]=r(N)
		local k = `k'+1 //rows 32-37
	}
sum died_0_30 if comp_any==1 // any complication - yes
mat tab_2[38,1]=r(N)
sum died_0_30 if comp_any==0 // any complication - no
mat tab_2[39,1]=r(N)


//column 2 - N for each subgroup excluding those that died in first 30 days
sum died_31_180_t2 //overall sample
mat tab_2[1,2]=r(N)
sum died_31_180_t2 if age_cat==1 //age 65-74
mat tab_2[2,2]=r(N)
sum died_31_180_t2 if age_cat==2 //age 75-79
mat tab_2[3,2]=r(N)
sum died_31_180_t2 if age_cat==3 //age 80-84
mat tab_2[4,2]=r(N)
sum died_31_180_t2 if age_cat==4 //age 85+
mat tab_2[5,2]=r(N)
sum died_31_180_t2 if female==1 //female
mat tab_2[6,2]=r(N)
sum died_31_180_t2 if female==0 //male
mat tab_2[7,2]=r(N)
sum died_31_180_t2 if re_cat==1 //aa
mat tab_2[8,2]=r(N)
sum died_31_180_t2 if re_cat==2 //hispanic
mat tab_2[9,2]=r(N)
sum died_31_180_t2 if re_cat==3 //white
mat tab_2[10,2]=r(N)
sum died_31_180_t2 if re_cat==4  //other
mat tab_2[11,2]=r(N)
sum died_31_180_t2 if tics_cat_miss==1  //tics normal
mat tab_2[12,2]=r(N)
sum died_31_180_t2 if tics_cat_miss==2  //tics mci
mat tab_2[13,2]=r(N)
sum died_31_180_t2 if tics_cat_miss==3  //tics demented
mat tab_2[14,2]=r(N)
sum died_31_180_t2 if tics_cat_miss==4  //tics missing
mat tab_2[15,2]=r(N)	
local k=16
	foreach w in `comorb' {  //comorbidities: cancer, chf, cad, dementia, esrd, dm
		sum died_31_180_t2 if `w'==1 
		mat tab_2[`k',2]=r(N)
		local k = `k' + 1  //populates rows 16 through 21
	}
sum died_31_180_t2 if srh_cat_core==1 //srhs excel/vg
mat tab_2[22,2]=r(N)
sum died_31_180_t2 if srh_cat_core==2  //srhs g
mat tab_2[23,2]=r(N)
sum died_31_180_t2 if srh_cat_core==3  //srhs f/p
mat tab_2[24,2]=r(N)
sum died_31_180_t2 if adl_cat_core==0  //adl ind
mat tab_2[25,2]=r(N)
sum died_31_180_t2 if adl_cat_core==1  //adl partial dep
mat tab_2[26,2]=r(N)
sum died_31_180_t2 if adl_cat_core==2  //adl severe dep
mat tab_2[27,2]=r(N)
sum died_31_180_t2 if nhres_n1==1  //nh resident - yes
mat tab_2[28,2]=r(N)
sum died_31_180_t2 if nhres_n1==0  //nh resident - no
mat tab_2[29,2]=r(N)
sum died_31_180_t2 if admit_ind_6m_pre==1 //pre surg admit - yes
mat tab_2[30,2]=r(N)
sum died_31_180_t2 if admit_ind_6m_pre==0 //pre surg admit - no
mat tab_2[31,2]=r(N)
	local k=32
	forvalues i=1/6 {					//discharge locations:
		sum died_31_180_t2 if stay_dstn_cat==`i' //home, ltc, rehab
			//hospice, other, expired
		mat tab_2[`k',2]=r(N)
		local k = `k'+1 //rows 32-37
	}
sum died_31_180_t2 if comp_any==1 // any complication - yes
mat tab_2[38,2]=r(N)
sum died_31_180_t2 if comp_any==0 // any complication - no
mat tab_2[39,2]=r(N)

tab died_0_30 if re_cat==4
tab died_0_30 if tics_cat_n1==2
tab died_31_180 if tics_cat_n1==2
tab died_0_30 if stay_dstn_cat==2
tab died_31_180 if stay_dstn_cat==6
tab index_los if stay_dstn_cat==6 & died_30d==0

//next columns (keeps p columns blank)
local j=3
foreach v in died_0_30 died_31_180_t2 died_31_365_t2 {
tab `v', matcell(`v'_`j') //overall sample
mat tab_2[1,`j']=`v'_`j'[2,1]/r(N)*100 //percent
mat tab_2[1,`j'+1]=`v'_`j'[2,1] //n
tab `v' if age_cat==1, matcell(`v'_`j') //age 65-74
mat tab_2[2,`j']=`v'_`j'[2,1]/r(N)*100 //percent
mat tab_2[2,`j'+1]=`v'_`j'[2,1] //n
tab `v' if age_cat==2, matcell(`v'_`j') //age 75-79
mat tab_2[3,`j']=`v'_`j'[2,1]/r(N)*100
mat tab_2[3,`j'+1]=`v'_`j'[2,1]
tab `v' if age_cat==3, matcell(`v'_`j') //age 80-84
mat tab_2[4,`j']=`v'_`j'[2,1]/r(N)*100
mat tab_2[4,`j'+1]=`v'_`j'[2,1]
tab `v' if age_cat==4, matcell(`v'_`j') //age 85+
mat tab_2[5,`j']=`v'_`j'[2,1]/r(N)*100
mat tab_2[5,`j'+1]=`v'_`j'[2,1]
tab `v' if female==1, matcell(`v'_`j') //female
mat tab_2[6,`j']=`v'_`j'[2,1]/r(N)*100
mat tab_2[6,`j'+1]=`v'_`j'[2,1]
tab `v' if female==0, matcell(`v'_`j') //male
mat tab_2[7,`j']=`v'_`j'[2,1]/r(N)*100
mat tab_2[7,`j'+1]=`v'_`j'[2,1]
tab `v' if re_cat==1, matcell(`v'_`j') //aa
mat tab_2[8,`j']=`v'_`j'[2,1]/r(N)*100
mat tab_2[8,`j'+1]=`v'_`j'[2,1]
tab `v' if re_cat==2, matcell(`v'_`j') //hispanic
mat tab_2[9,`j']=`v'_`j'[2,1]/r(N)*100
mat tab_2[9,`j'+1]=`v'_`j'[2,1]
tab `v' if re_cat==3, matcell(`v'_`j') //white
mat tab_2[10,`j']=`v'_`j'[2,1]/r(N)*100
mat tab_2[10,`j'+1]=`v'_`j'[2,1]
tab `v' if re_cat==4, matcell(`v'_`j') //other
mat tab_2[11,`j']=`v'_`j'[2,1]/r(N)*100
mat tab_2[11,`j'+1]=`v'_`j'[2,1]
tab `v' if tics_cat_miss==1, matcell(`v'_`j') //tics normal
mat tab_2[12,`j']=`v'_`j'[2,1]/r(N)*100
mat tab_2[12,`j'+1]=`v'_`j'[2,1]
tab `v' if tics_cat_miss==2, matcell(`v'_`j') //tics mci
mat tab_2[13,`j']=`v'_`j'[2,1]/r(N)*100
mat tab_2[13,`j'+1]=`v'_`j'[2,1]
tab `v' if tics_cat_miss==3, matcell(`v'_`j') //tics demented
mat tab_2[14,`j']=`v'_`j'[2,1]/r(N)*100
mat tab_2[14,`j'+1]=`v'_`j'[2,1]
tab `v' if tics_cat_miss==4, matcell(`v'_`j') //tics missing
mat tab_2[15,`j']=`v'_`j'[2,1]/r(N)*100
mat tab_2[15,`j'+1]=`v'_`j'[2,1]	
local k=16
	foreach w in `comorb' {  //comorbidities: cancer, chf, cad, dementia, esrd, dm
		tab `v' if `w'==1, matcell(`v'_`j')
		mat tab_2[`k',`j']=`v'_`j'[2,1]/r(N)*100
		mat tab_2[`k',`j'+1]=`v'_`j'[2,1]
		local k = `k' + 1  //populates rows 16 through 21
	}
tab `v' if srh_cat_core==1, matcell(`v'_`j') //srhs excel/vg
mat tab_2[22,`j']=`v'_`j'[2,1]/r(N)*100
mat tab_2[22,`j'+1]=`v'_`j'[2,1]
tab `v' if srh_cat_core==2, matcell(`v'_`j') //srhs g
mat tab_2[23,`j']=`v'_`j'[2,1]/r(N)*100
mat tab_2[23,`j'+1]=`v'_`j'[2,1]
tab `v' if srh_cat_core==3, matcell(`v'_`j') //srhs f/p
mat tab_2[24,`j']=`v'_`j'[2,1]/r(N)*100
mat tab_2[24,`j'+1]=`v'_`j'[2,1]
tab `v' if adl_cat_core==0, matcell(`v'_`j') //adl ind
mat tab_2[25,`j']=`v'_`j'[2,1]/r(N)*100
mat tab_2[25,`j'+1]=`v'_`j'[2,1]
tab `v' if adl_cat_core==1, matcell(`v'_`j') //adl partial dep
mat tab_2[26,`j']=`v'_`j'[2,1]/r(N)*100
mat tab_2[26,`j'+1]=`v'_`j'[2,1]
tab `v' if adl_cat_core==2, matcell(`v'_`j') //adl severe dep
mat tab_2[27,`j']=`v'_`j'[2,1]/r(N)*100
mat tab_2[27,`j'+1]=`v'_`j'[2,1]
tab `v' if nhres_n1==1, matcell(`v'_`j') //nh resident - yes
mat tab_2[28,`j']=`v'_`j'[2,1]/r(N)*100
mat tab_2[28,`j'+1]=`v'_`j'[2,1]
tab `v' if nhres_n1==0, matcell(`v'_`j') //nh resident - no
mat tab_2[29,`j']=`v'_`j'[2,1]/r(N)*100
mat tab_2[29,`j'+1]=`v'_`j'[2,1]
tab `v' if admit_ind_6m_pre==1, matcell(`v'_`j') //pre surg admit - yes
mat tab_2[30,`j']=`v'_`j'[2,1]/r(N)*100
mat tab_2[30,`j'+1]=`v'_`j'[2,1]
tab `v' if admit_ind_6m_pre==0, matcell(`v'_`j') //pre surg admit - no
mat tab_2[31,`j']=`v'_`j'[2,1]/r(N)*100
mat tab_2[31,`j'+1]=`v'_`j'[2,1]
	local k=32
	forvalues i=1/6 {					//discharge locations:
		tab `v' if stay_dstn_cat==`i', matcell(`v'_`j')	//home, ltc, rehab
		mat tab_2[`k',`j']=`v'_`j'[2,1]/r(N)*100			//hospice, other, expired
		mat tab_2[`k',`j'+1]=`v'_`j'[2,1]
		local k = `k'+1
	}
tab `v' if comp_any==1, matcell(`v'_`j') // any complication - yes
mat tab_2[38,`j']=`v'_`j'[2,1]/r(N)*100
mat tab_2[38,`j'+1]=`v'_`j'[2,1]
tab `v' if comp_any==0, matcell(`v'_`j') // any complication - no
mat tab_2[39,`j']=`v'_`j'[2,1]/r(N)*100
mat tab_2[39,`j'+1]=`v'_`j'[2,1]
local j = `j' + 3
}
mat list tab_2

//p value columns - using Fisher's exact test

local j=5
foreach v in died_0_30 died_31_180_t2 died_31_365_t2 {
tab age_cat `v', exact  //age
mat tab_2[2,`j']=r(p_exact) //pvalue
tab female  `v', exact  //gender
mat tab_2[6,`j']=r(p_exact) 
tab re_cat  `v', exact  //race
mat tab_2[8,`j']=r(p_exact) 
tab tics_cat_miss  `v', exact  //tics
mat tab_2[12,`j']=r(p_exact) 
	local k=16
	foreach w in `comorb' {  //comorbidities: cancer, chf, cad, dementia, esrd, dm
		tab `w' `v', exact
		mat tab_2[`k',`j']=r(p_exact)
		local k = `k' + 1  //populates rows 15 through 20
	}
tab srh_cat_core  `v', exact  //self reported health
mat tab_2[22,`j']=r(p_exact) 
tab adl_cat_core  `v', exact  //adl
mat tab_2[25,`j']=r(p_exact) 
tab nhres_n1  `v', exact  //nursing home res
mat tab_2[28,`j']=r(p_exact) 
tab admit_ind_6m_pre  `v', exact  //admit 6 mos
mat tab_2[30,`j']=r(p_exact) 
tab stay_dstn_cat  `v', exact  //discharge loc
mat tab_2[32,`j']=r(p_exact) 
tab comp_any  `v', exact  //any complication
mat tab_2[38,`j']=r(p_exact) 
local j = `j' + 3
}

frmttable using `logpath'table1b , statmat(tab_2) ///
	title("Table 2 - Unadjusted 30-, 180- and 365-Day Mortality" \ ///
	"Not mutually exclusive mortality categories") ///
	ctitle("","N all","N excl 0-30d","0-30-Day %","n","p-val","31-180-Day %","n","p-val", "31-365-Day %","n","p-val") ///
	rtitle("Overall sample" \ "Age: 65-74" \ "75-79" \ "80-84" \ "85+" \ ///
	"Female" \ "Male"\ "AA" \ "Hispanic" \ "White" \"Other" \ ///
	"TICS >8 Normal" \"5-8 MCI" \"<5 Demented"\ "TICS Unknown" \"Cancer" \"CHF" \ ///
	"CAD"\"Dementia"\"ESRD"\"Diabetes"\"Self reported health: Exc / VG" \ ///
	"Good" \ "Fair/Poor" \ "Baseline ADL: Independent" \ "Partial" \ "Severe" \  ///
	"Nursing home resident - Yes" \ "No" \ "Hospital admit in prior 6 mos: Yes" \ "No" \ ///
	"Discharge location: Home" \ "Long term care" \ "Inpatient rehab" \"Hospice" \  ///
	"Other or Unknown" \ "Expired" \ "Any complication: Yes" \ "No") ///
	note("P-values are calculating using Fisher's exact test.") ///
	sdec(0,0,2,0,3,2,0,3,2,0,3) addtable

*/
******************************************************************
******************************************************************
// Tables to compare comorbidity / chronic conditions measures
******************************************************************
******************************************************************
local hcc cc_1_ami_n12mn0 cc_2_alzh_n12mn0 cc_3_alzhdmta_n12mn0 ///
cc_4_atrialfb_n12mn0 cc_5_cataract_n12mn0 cc_6_chrnkidn_n12mn0 ///
cc_7_copd_n12mn0 cc_8_chf_n12mn0 cc_9_diabetes_n12mn0 cc_10_glaucoma_n12mn0 ///
cc_11_hipfrac_n12mn0 cc_12_ischmcht_n12mn0 cc_13_depressn_n12mn0 ///
cc_14_osteoprs_n12mn0 cc_15_ra_oa_n12mn0 cc_16_strketia_n12mn0 ///
cc_17_cncrbrst_n12mn0 cc_18_cncrclrc_n12mn0 cc_19_cncrprst_n12mn0 ///
cc_20_cncrlung_n12mn0 cc_21_cncrendm_n12mn0 cc_ami_isch_n12mn0 ///
cc_alzheim_n12mn0 cc_cncr_chronic_n12mn0


local elix comorb_1_0_n12m comorb_2_0_n12m comorb_3_0_n12m comorb_4_0_n12m ///
comorb_5_0_n12m comorb_6_0_n12m comorb_7_0_n12m comorb_8_0_n12m ///
comorb_9_0_n12m comorb_10_0_n12m comorb_11_0_n12m comorb_12_0_n12m ///
comorb_13_0_n12m comorb_14_0_n12m comorb_15_0_n12m comorb_16_0_n12m ///
comorb_17_0_n12m comorb_18_0_n12m comorb_19_0_n12m comorb_20_0_n12m ///
comorb_21_0_n12m comorb_22_0_n12m comorb_23_0_n12m comorb_24_0_n12m ///
comorb_25_0_n12m comorb_26_0_n12m comorb_27_0_n12m comorb_28_0_n12m ///
comorb_29_0_n12m comorb_30_0_n12m

mat hcc_mean=J(24,2,.)
local i=1
foreach v in `hcc'{
sum `v'
mat hcc_mean[`i',1]=r(mean)
mat hcc_mean[`i',2]=r(N)*r(mean)
local i=`i'+1
}

mat rownames hcc_mean ="AMI" "Alzheimer's" "Alzheimer's or Dementia" "Atrial Fibrillation" ///
"Cataract" "Chronic Kidney Disease" ///
"COPD" "CHF" "Diabetes" "Glaucoma" "Hip fracture" "Ischemic Heart Disease" "Depression" ///
"Osteoporosis" "Rheumatoid Arthritis" "Stroke" "Cancer - Breast" "Cancer - Colorectal" "Cancer - Prostate" ///
"Cancer - Lung" "Cancer - Endometrial" "AMI+ISCH" "Alzh + Dementia" "Cancer - any"


mat el_mean=J(30,2,.)
local i=1
foreach v in `elix'{
sum `v'
mat el_mean[`i',1]=r(mean)
mat el_mean[`i',2]=r(N)
local i=`i'+1
}

mat rownames el_mean = "Congestive Heart Failure" "Cariac Arrhythmias" "Valvular Disease" ///
"Pulmonary Circulation Disorders" "Peripheral Vascular Disorders" "Hypertension" ///
 "Paralysis" "Other Neurological Disorders" "Chronic Pulmonary Disease" "Diabetes, uncomplicated" ///
 "Diabetes, complicated" "Hypothyroidism" "Renal Failure" "Liver Disease" ///
 "Peptic Ulcer Disease" "AIDS" "Lymphoma" "Metastatic Cancer" ///
 "Solid Tumor without Metastisis" "Rheumatoid Arthritis" ///
 "Coagulopathy" "Obesity" "Weight Loss" "Fluid and Electrolyte Disorders" ///
 "Blood Loss Anemia" "Deficiency Anemias" "Alcohol Abuse" "Drug Abuse" "Psychoses" "Depression"

mat list hcc_mean
mat list el_mean

	
frmttable using "`logpath'\surgery_hysterectomy_cohort.rtf", statmat(hcc_mean) ///
title("Chronic conditions") ctitle("","%","N") ///
sdec(2,0) addtable

frmttable using `logpath'cc_elix, statmat(hcc_mean) ///
title("Chronic conditions") ctitle("","%","N") ///
sdec(2,0) replace

frmttable using `logpath'cc_elix, statmat(hcc_mean) ///
title("Elixhauser comorbidities") ctitle("","%","N") ///
sdec(2,0) addtable 
 
tab claims_esrd_ind comorb_13_0_n12m, missing

log close
/*
//looking at date of death

//11 obs have exit interview but missing date of death
 tab died_ind ind_exit, missing
 
 gen dod_to_exit = (  e_ivw_date_x - death_date_e)
 tab dod_to_exit if(died_ind==1), missing //all exit interviews are at least after date of death
 //there are a few though with exit interviews more than 1000 days after death


H="tables changes n1-p1"
capture log close

clear all
set more off

local texpath E:\data\surgery_hysterectomy\logs\tex\
local logpath E:\data\surgery_hysterectomy\logs\
local datapath E:\data\surgery_hysterectomy\final_2012clms\


log using `logpath'9_surgery_hysterectomy_code_tables.txt, text replace

cd "`datapath'"

use surgery_hysterectomy_final_n12m_sample_clean.dta

preserve
drop if c_ivw_date_p1==.

local changes incont srh_pf indep nhres 
mat change=J(4,8,.)
local r=1
local c=1
foreach x of local changes {
	foreach ch in yy yn ny nn {
		sum `x'_`ch'_n1p1
		mat change[`r',`c']=r(mean)*100
		mat change[`r',`c'+1]=r(mean)*r(N)
		local c=`c'+2
}
	local r=`r'+1
	local c=1
}

mat rownames change="Incontinence" "SRH P/F" "Independent ADLs" "NH Residency"

frmttable using "E:\data\surgery_hysterectomy\logs\changes_n1_p1.rtf", ///
statmat(change) title("Changes, n1 to p1") ctitles("" "% Y both" "n" ///
"% Y n1 only" "n" "% Y p1 only" "n" "% N both" "n") sdec(2,0,2,0,2,0,2,0) replace
restore

mat twom1yr=J(8,9,.)
local r=1
local c=2

foreach x in hosp_adm_p snf_adm_p hs_clms_p proc_to_dod_ {
	foreach i in 60 365 {
		forvalues j=0/7 {
			tab `x'`i' if `x'`i'==`j'
			mat twom1yr[`r',1]=`i'
			mat twom1yr[`r',`c']=r(N)
			local c=`c'+1
}
		local r=`r'+1
		local c=2
}
	local c=2
}

mat rownames twom1yr="Hospital Admissions" "" "SNF Admissions" "" "Hospice Claims" ///
"" "Death" ""
 
frmttable using "E:\data\surgery_hysterectomy\logs\changes_n1_p1.rtf", ///
statmat(twom1yr) title("Utilization and Mortality") ///
ctitles("" "Days post surgery" "0" "1" "2" "3" "4" "5" "6" "7") sdec(0) addtable


H="xxstata code to retrieve surgeriesxx"
clear all 
set more off
capture log close

use "E:\data\surgery_hysterectomy\int_2012clms\ip_meet.dta", clear
*rename prcdrdt* proc_date*
forvalues i=1/9 {

rename prcdrdt0`i' prcdrdt`i'
rename prcdrcd0`i' prcdrcd`i'
}

local proc prcdrcd1 prcdrcd2 prcdrcd3 prcdrcd4 prcdrcd5 prcdrcd6 prcdrcd7 prcdrcd8 prcdrcd9 prcdrcd10 prcdrcd11 prcdrcd12 prcdrcd13 prcdrcd14 prcdrcd15 prcdrcd16 prcdrcd17 prcdrcd18 prcdrcd19 prcdrcd20 prcdrcd21 prcdrcd22 prcdrcd23 prcdrcd24 prcdrcd25 
destring prcdrcd* prcdrdt*, replace
gen hysterectomy=.
gen procedure=.
gen procedure_date=.
gen procedure2=.
gen procedure3=.
gen p_date2=.
gen p_date3=.
gen procedure_a=.


foreach v of local proc {
	foreach n in 684 683 685 686 687 689 6849 6839 6869 ///
			6841 6831 6851 6861 6871 6859 6879 {
		replace hysterectomy=1 if `v'==`n'
}
}

keep if hyst==1

foreach v of local proc {
	foreach n in 684 683 685 686 687 689 6849 6839 6869 ///
			6841 6831 6851 6861 6871 6859 6879 {
		replace procedure=`n' if procedure==. & `v'==`n'
		replace procedure2=`n' if `v'==`n' & procedure!=`n' & procedure2==.
		replace procedure3=`n' if `v'==`n' & procedure!=`n' & procedure2!=`n' ///
			& procedure3==.
		forvalues i=01/25 {
			replace procedure_date=prcdrdt`i' if `v'==prcdrcd`i' & ///
				procedure_date==. & `v'==`n'
			replace p_date2=prcdrdt`i' if `v'==prcdrcd`i' & ///
				p_date2==. & `v'==`n' & procedure_date!=prcdrdt`i'
			replace p_date3=prcdrdt`i' if `v'==prcdrcd`i' & ///
				p_date3==. & `v'==`n' & p_date2!=prcdrdt`i' & ///
					procedure_date!=prcdrdt`i'
}
}
	foreach n in 174 1741 1742 1743 1744 1745 1749 {
		replace procedure_a=`n' if `v'==`n'
}
}

gen source="ip"
*keep procedure procedure_date procedure_a admit_date disch_date source bid_hrs
save "E:\data\surgery_hysterectomy\int_2012clms\ip_hyst.dta", replace

use "E:\data\surgery_hysterectomy\int_2012clms\pb_2000_2012.dta", clear
gen hysterectomy=.
gen procedure=""
gen procedure2=""
gen procedure3=""

local cpt hcpscd01 hcpscd02 hcpscd03 hcpscd04 hcpscd05 hcpscd06 hcpscd07 hcpscd08 hcpscd09 hcpscd10 hcpscd11 hcpscd12 hcpscd13

foreach x of local cpt {
	foreach n in "58150" "58152" "58180" "58200" ///
		"58210" "58240" "58951" "58953" ///
		"58954" "58956" "58541" "58542" ///
		"58543" "58544" "58548" "58550" ///
		"58552" "58553" "58554" "58570" ///
		"58571" "58572" "58573" "58260"  ///
		"58262" "58263" "58267" "58270" ///
		"58275" "58280" "58285" "58290" ///
		"58291" "58292" "58293" "58294" {
replace hysterectomy=1 if `x'=="`n'"
}
}

keep if hysterectomy==1

foreach x of local cpt {
	foreach n in "58150" "58152" "58180" "58200" ///
		"58210" "58240" "58951" "58953" ///
		"58954" "58956" "58541" "58542" ///
		"58543" "58544" "58548" "58550" ///
		"58552" "58553" "58554" "58570" ///
		"58571" "58572" "58573" "58260"  ///
		"58262" "58263" "58267" "58270" ///
		"58275" "58280" "58285" "58290" ///
		"58291" "58292" "58293" "58294" {
			replace procedure="`n'" if procedure=="" & `x'=="`n'"
			*replace procedure2="`n'" if `x'=="`n'" & procedure!=`n' & procedure2==""
			*replace procedure3="`n'" if `x'=="`n'" & procedure!=`n' & procedure2!=`n' ///
			*	& procedure3==""
			
}
}

gen source="pb"

*keep procedure admit_date disch_date source bid_hrs
destring procedure*, replace
save "E:\data\surgery_hysterectomy\int_2012clms\pb_hyst.dta", replace

use "E:\data\surgery_hysterectomy\int_2012clms\op_2000_2012.dta", clear

gen hysterectomy=.
gen procedure=""
gen procedure2=""
gen procedure3=""
gen procedure_a=.
gen procedure_date=.

forvalues i=1/9 {

rename prcdrdt0`i' prcdrdt`i'
rename prcdrcd0`i' prcdrcd`i'
}

local cpt hcpscd01 hcpscd02 hcpscd03 hcpscd04 hcpscd05 hcpscd06 hcpscd07 hcpscd08 hcpscd09 hcpscd10 hcpscd11 hcpscd12 hcpscd13
local proc prcdrcd1 prcdrcd2 prcdrcd3 prcdrcd4 prcdrcd5 prcdrcd6 

foreach v of local proc {
	foreach n in "684" "683" "685" "686" "687" "689" "6849" "6839" "6869" ///
			"6841" "6831" "6851" "6861" "6871" "6859" "6879" {
		replace hysterectomy=1 if `v'=="`n'"
}
}

foreach x of local cpt {
	foreach n in "58150" "58152" "58180" "58200" ///
		"58210" "58240" "58951" "58953" ///
		"58954" "58956" "58541" "58542" ///
		"58543" "58544" "58548" "58550" ///
		"58552" "58553" "58554" "58570" ///
		"58571" "58572" "58573" "58260"  ///
		"58262" "58263" "58267" "58270" ///
		"58275" "58280" "58285" "58290" ///
		"58291" "58292" "58293" "58294" {
replace hysterectomy=1 if `x'=="`n'"
}
}

keep if hyst==1

foreach x of local cpt {
	foreach n in "58150" "58152" "58180" "58200" ///
		"58210" "58240" "58951" "58953" ///
		"58954" "58956" "58541" "58542" ///
		"58543" "58544" "58548" "58550" ///
		"58552" "58553" "58554" "58570" ///
		"58571" "58572" "58573" "58260"  ///
		"58262" "58263" "58267" "58270" ///
		"58275" "58280" "58285" "58290" ///
		"58291" "58292" "58293" "58294" {
			replace procedure="`n'" if `x'=="`n'"
			replace procedure2="`n'" if `x'=="`n'" & procedure!="`n'" & procedure2==""
			replace procedure3="`n'" if `x'=="`n'" & procedure!="`n'" & procedure2!="`n'" ///
				& procedure3==""
			
}
}

gen source="op"
destring procedure*, replace
destring prcdrcd* prcdrdt*, replace


foreach v of local proc {
	foreach n in 684 683 685 686 687 689 6849 6839 6869 ///
			6841 6831 6851 6861 6871 6859 6879 {
		replace procedure=`n' if procedure==. & `v'==`n'
		replace procedure2=`n' if `v'==`n' & procedure!=`n' & procedure2==.
		replace procedure3=`n' if `v'==`n' & procedure!=`n' & procedure2!=`n' ///
			& procedure3==.
		forvalues i=01/25 {
			replace procedure_date=prcdrdt`i' if `v'==prcdrcd`i' & ///
				procedure_date==. & `v'==`n'

}
}
	foreach n in 174 1741 1742 1743 1744 1745 1749 {
		replace procedure_a=`n' if `v'==`n'
}
}

save "E:\data\surgery_hysterectomy\int_2012clms\op_hyst.dta", replace


H="xxstata code to check sample"
use  "E:\data\surgery_hysterectomy\int_2012clms\ip_hyst.dta", clear
rename procedure ip_procedure
tostring procedure_d, replace
gen year=substr(procedure_d,1,4)
destring year procedure_d, replace
append using "E:\data\surgery_hysterectomy\int_2012clms\pb_hyst.dta"
append using "E:\data\surgery_hysterectomy\int_2012clms\op_hyst.dta"
drop procedure
merge m:m bid_hrs_21 using "E:\data\surgery_hysterectomy\int_2012clms\pb_hyst.dta", keepusing(procedure)
rename procedure pb_procedure
rename _m merge1
merge m:1 bid_hrs_21 using "E:\data\surgery_hysterectomy\int_2012clms\op_hyst.dta"
rename procedure op_procedure
rename _m merge2
replace year=admit_year if year==.
merge m:1 bid_hrs_21 year using "E:\data\surgery_hysterectomy\int_2012clms\dn_2000_20122.dta", keep(match master)
rename _mer merge3
sort source
tab source
duplicates drop bid_hrs, force
tab source
merge 1:m bid_hrs_21 using "E:\data\surgery_hysterectomy\int_2012clms\cmsxref2012.dta", keep(match master) keepusing(hhidpn)
rename hhidpn id
rename _m merge4
merge 1:m id using "E:\data\surgery_hysterectomy\int_2012clms\core_2000_2012.dta", keep(match master)

drop if age<65
keep if hmo_mo==0
keep if a_mo==12
keep if b_mo==12

gen surg_year = year(procedure_date)

la var surg_year "Surgery year"

format admit_date %td
keep if c_ivw_date<=admit_date
by bid_hrs_21, sort: egen lastcore=max(c_ivw_dat)
keep if c_ivw_dat==lastcore


gen ip_procedure_type=.
replace ip_procedure_type=1 if ip_procedure==684 | ip_procedure==6849 | ip_procedure==683 | ///
	ip_procedure==6839 | ip_procedure==685 | ip_procedure==686 | ip_procedure==6869 | ip_procedure==689
replace ip_procedure_type=2 if ip_procedure==6841 |ip_procedure==6831 |ip_procedure==6851 | ///
	ip_procedure==6861 |ip_procedure==6871 
replace ip_procedure_type=3 if ip_procedure==685 |ip_procedure==6859 |ip_procedure==687 | ///
	ip_procedure==6879 

label define ptype 1 "Abdominal Hysterectomy" 2 "Laparoscopic Hysterectomy" 3 ///
	"Vaginal Hysterectomy"
label values ip_procedure_type ptype

rename procedure_a robotic_hysterectomy
replace robotic=1 if robotic!=.

mat sample=J(5,1,.)
sum ip_procedure //number of surgeries
mat sample[1,1]=r(N)
sum ip_procedure if ip_procedure_t==1 //abdom
mat sample[2,1]=r(N)
sum ip_procedure if ip_procedure_t==2 //laparascopic
mat sample[3,1]=r(N)
sum ip_procedure if ip_procedure_t==3 //vaginal
mat sample[4,1]=r(N)
sum ip_procedure if robotic==1 //robotic
mat sample[5,1]=r(N)


mat rownames sample="N Surgeries" "Abdominal" "Laparoscopic" ///
 "Vaginal" "Robotic"

mat list sample


gen adv_procedure=""

foreach x of local cpt {
	foreach n in "58240" "58952" "58953" "58954" "49203" "49204" "49205" "58957" "58958" ///
"58200" "58210" "58943" "58951" "58954" "58958" "58960" "58548" "57531" ///
"57109" "38562" "38564" "38571" "38570" "38572" "38589" "38770" "38780" ///
"58958" "58240" "44120" "44121" "44125" "44126" "44127" "44128" "44130" ///
"44202" "44203" "44141" "44143" "44144" "44150" "44151" "44155" "44156" ///
"44157" "44158" "44160" "44204" "44205" "44206" "44210" "44211" "44212" ///
"44152" "44153" "44145" "44146" "44147" "44207" "44208" "45110" "45111" ///
"45112" "45113" "45114" "45116" "45119" "45120" "45121" "45126" "45130" ///
"45135" "47100" "47120" "47122" "47125" "47130" "51550" "51555" "51570" ///
"51575" "51580" "51585" "51590" "51595" "51596" "51597" "39560" "39561" {
		replace adv_procedure="`n'" if `x'=="`n'"
		
}
}